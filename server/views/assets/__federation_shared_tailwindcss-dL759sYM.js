import { g as lf, c as Yi, a as Yn, b as uf } from "./_commonjs-dynamic-modules-D9Q0Knnx.js";
var Va = { exports: {} }, cf = {};
const lg = {}, ug = Object.freeze(Object.defineProperty({ __proto__: null, default: lg }, Symbol.toStringTag, { value: "Module" })), gt = lf(ug);
class cg {
  constructor(s = {}) {
    if (!(s.maxSize && s.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
    if (typeof s.maxAge == "number" && s.maxAge === 0) throw new TypeError("`maxAge` must be a number greater than 0");
    this.maxSize = s.maxSize, this.maxAge = s.maxAge || 1 / 0, this.onEviction = s.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  _emitEvictions(s) {
    if (typeof this.onEviction == "function") for (const [o, b] of s) this.onEviction(o, b.value);
  }
  _deleteIfExpired(s, o) {
    return typeof o.expiry == "number" && o.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(s, o.value), this.delete(s)) : false;
  }
  _getOrDeleteIfExpired(s, o) {
    if (this._deleteIfExpired(s, o) === false) return o.value;
  }
  _getItemValue(s, o) {
    return o.expiry ? this._getOrDeleteIfExpired(s, o) : o.value;
  }
  _peek(s, o) {
    const b = o.get(s);
    return this._getItemValue(s, b);
  }
  _set(s, o) {
    this.cache.set(s, o), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
  _moveToRecent(s, o) {
    this.oldCache.delete(s), this._set(s, o);
  }
  *_entriesAscending() {
    for (const s of this.oldCache) {
      const [o, b] = s;
      this.cache.has(o) || this._deleteIfExpired(o, b) === false && (yield s);
    }
    for (const s of this.cache) {
      const [o, b] = s;
      this._deleteIfExpired(o, b) === false && (yield s);
    }
  }
  get(s) {
    if (this.cache.has(s)) {
      const o = this.cache.get(s);
      return this._getItemValue(s, o);
    }
    if (this.oldCache.has(s)) {
      const o = this.oldCache.get(s);
      if (this._deleteIfExpired(s, o) === false) return this._moveToRecent(s, o), o.value;
    }
  }
  set(s, o, { maxAge: b = this.maxAge === 1 / 0 ? void 0 : Date.now() + this.maxAge } = {}) {
    this.cache.has(s) ? this.cache.set(s, { value: o, maxAge: b }) : this._set(s, { value: o, expiry: b });
  }
  has(s) {
    return this.cache.has(s) ? !this._deleteIfExpired(s, this.cache.get(s)) : this.oldCache.has(s) ? !this._deleteIfExpired(s, this.oldCache.get(s)) : false;
  }
  peek(s) {
    if (this.cache.has(s)) return this._peek(s, this.cache);
    if (this.oldCache.has(s)) return this._peek(s, this.oldCache);
  }
  delete(s) {
    const o = this.cache.delete(s);
    return o && this._size--, this.oldCache.delete(s) || o;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  resize(s) {
    if (!(s && s > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
    const o = [...this._entriesAscending()], b = o.length - s;
    b < 0 ? (this.cache = new Map(o), this.oldCache = /* @__PURE__ */ new Map(), this._size = o.length) : (b > 0 && this._emitEvictions(o.slice(0, b)), this.oldCache = new Map(o.slice(b)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = s;
  }
  *keys() {
    for (const [s] of this) yield s;
  }
  *values() {
    for (const [, s] of this) yield s;
  }
  *[Symbol.iterator]() {
    for (const s of this.cache) {
      const [o, b] = s;
      this._deleteIfExpired(o, b) === false && (yield [o, b.value]);
    }
    for (const s of this.oldCache) {
      const [o, b] = s;
      this.cache.has(o) || this._deleteIfExpired(o, b) === false && (yield [o, b.value]);
    }
  }
  *entriesDescending() {
    let s = [...this.cache];
    for (let o = s.length - 1; o >= 0; --o) {
      const b = s[o], [A, R] = b;
      this._deleteIfExpired(A, R) === false && (yield [A, R.value]);
    }
    s = [...this.oldCache];
    for (let o = s.length - 1; o >= 0; --o) {
      const b = s[o], [A, R] = b;
      this.cache.has(A) || this._deleteIfExpired(A, R) === false && (yield [A, R.value]);
    }
  }
  *entriesAscending() {
    for (const [s, o] of this._entriesAscending()) yield [s, o.value];
  }
  get size() {
    if (!this._size) return this.oldCache.size;
    let s = 0;
    for (const o of this.oldCache.keys()) this.cache.has(o) || s++;
    return Math.min(this._size + s, this.maxSize);
  }
}
var pf = cg, df = {}, ff = { exports: {} };
(function(a3, s) {
  (function(o) {
    a3.exports = o();
  })(function() {
    return function o(b, A, R) {
      function P(n, u) {
        if (!A[n]) {
          if (!b[n]) {
            var c = typeof Yi == "function" && Yi;
            if (!u && c) return c(n, true);
            if (t) return t(n, true);
            throw new Error("Cannot find module '" + n + "'");
          }
          u = A[n] = { exports: {} }, b[n][0].call(u.exports, function(e) {
            var r = b[n][1][e];
            return P(r || e);
          }, u, u.exports, o, b, A, R);
        }
        return A[n].exports;
      }
      for (var t = typeof Yi == "function" && Yi, l = 0; l < R.length; l++) P(R[l]);
      return P;
    }({ 1: [function(o, b, A) {
      (function(R, P, t, l, n, u, c, e, r) {
        var f = o("crypto");
        function y(E, _) {
          _ = d(E, _);
          var C;
          return (C = _.algorithm !== "passthrough" ? f.createHash(_.algorithm) : new m()).write === void 0 && (C.write = C.update, C.end = C.update), h(_, C).dispatch(E), C.update || C.end(""), C.digest ? C.digest(_.encoding === "buffer" ? void 0 : _.encoding) : (E = C.read(), _.encoding !== "buffer" ? E.toString(_.encoding) : E);
        }
        (A = b.exports = y).sha1 = function(E) {
          return y(E);
        }, A.keys = function(E) {
          return y(E, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
        }, A.MD5 = function(E) {
          return y(E, { algorithm: "md5", encoding: "hex" });
        }, A.keysMD5 = function(E) {
          return y(E, { algorithm: "md5", encoding: "hex", excludeValues: true });
        };
        var S = f.getHashes ? f.getHashes().slice() : ["sha1", "md5"], T = (S.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
        function d(E, _) {
          var C = {};
          if (C.algorithm = (_ = _ || {}).algorithm || "sha1", C.encoding = _.encoding || "hex", C.excludeValues = !!_.excludeValues, C.algorithm = C.algorithm.toLowerCase(), C.encoding = C.encoding.toLowerCase(), C.ignoreUnknown = _.ignoreUnknown === true, C.respectType = _.respectType !== false, C.respectFunctionNames = _.respectFunctionNames !== false, C.respectFunctionProperties = _.respectFunctionProperties !== false, C.unorderedArrays = _.unorderedArrays === true, C.unorderedSets = _.unorderedSets !== false, C.unorderedObjects = _.unorderedObjects !== false, C.replacer = _.replacer || void 0, C.excludeKeys = _.excludeKeys || void 0, E === void 0) throw new Error("Object argument required.");
          for (var w = 0; w < S.length; ++w) S[w].toLowerCase() === C.algorithm.toLowerCase() && (C.algorithm = S[w]);
          if (S.indexOf(C.algorithm) === -1) throw new Error('Algorithm "' + C.algorithm + '"  not supported. supported values: ' + S.join(", "));
          if (T.indexOf(C.encoding) === -1 && C.algorithm !== "passthrough") throw new Error('Encoding "' + C.encoding + '"  not supported. supported values: ' + T.join(", "));
          return C;
        }
        function p(E) {
          if (typeof E == "function") return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(E)) != null;
        }
        function h(E, _, C) {
          C = C || [];
          function w(I) {
            return _.update ? _.update(I, "utf8") : _.write(I, "utf8");
          }
          return { dispatch: function(I) {
            return this["_" + ((I = E.replacer ? E.replacer(I) : I) === null ? "null" : typeof I)](I);
          }, _object: function(I) {
            var D, j = Object.prototype.toString.call(I), L = /\[object (.*)\]/i.exec(j);
            if (L = (L = L ? L[1] : "unknown:[" + j + "]").toLowerCase(), 0 <= (j = C.indexOf(I))) return this.dispatch("[CIRCULAR:" + j + "]");
            if (C.push(I), t !== void 0 && t.isBuffer && t.isBuffer(I)) return w("buffer:"), w(I);
            if (L === "object" || L === "function" || L === "asyncfunction") return j = Object.keys(I), E.unorderedObjects && (j = j.sort()), E.respectType === false || p(I) || j.splice(0, 0, "prototype", "__proto__", "constructor"), E.excludeKeys && (j = j.filter(function(k) {
              return !E.excludeKeys(k);
            })), w("object:" + j.length + ":"), D = this, j.forEach(function(k) {
              D.dispatch(k), w(":"), E.excludeValues || D.dispatch(I[k]), w(",");
            });
            if (!this["_" + L]) {
              if (E.ignoreUnknown) return w("[" + L + "]");
              throw new Error('Unknown object type "' + L + '"');
            }
            this["_" + L](I);
          }, _array: function(I, k) {
            k = k !== void 0 ? k : E.unorderedArrays !== false;
            var j = this;
            if (w("array:" + I.length + ":"), !k || I.length <= 1) return I.forEach(function(N) {
              return j.dispatch(N);
            });
            var L = [], k = I.map(function(N) {
              var F = new m(), W = C.slice();
              return h(E, F, W).dispatch(N), L = L.concat(W.slice(C.length)), F.read().toString();
            });
            return C = C.concat(L), k.sort(), this._array(k, false);
          }, _date: function(I) {
            return w("date:" + I.toJSON());
          }, _symbol: function(I) {
            return w("symbol:" + I.toString());
          }, _error: function(I) {
            return w("error:" + I.toString());
          }, _boolean: function(I) {
            return w("bool:" + I.toString());
          }, _string: function(I) {
            w("string:" + I.length + ":"), w(I.toString());
          }, _function: function(I) {
            w("fn:"), p(I) ? this.dispatch("[native]") : this.dispatch(I.toString()), E.respectFunctionNames !== false && this.dispatch("function-name:" + String(I.name)), E.respectFunctionProperties && this._object(I);
          }, _number: function(I) {
            return w("number:" + I.toString());
          }, _xml: function(I) {
            return w("xml:" + I.toString());
          }, _null: function() {
            return w("Null");
          }, _undefined: function() {
            return w("Undefined");
          }, _regexp: function(I) {
            return w("regex:" + I.toString());
          }, _uint8array: function(I) {
            return w("uint8array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _uint8clampedarray: function(I) {
            return w("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(I));
          }, _int8array: function(I) {
            return w("int8array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _uint16array: function(I) {
            return w("uint16array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _int16array: function(I) {
            return w("int16array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _uint32array: function(I) {
            return w("uint32array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _int32array: function(I) {
            return w("int32array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _float32array: function(I) {
            return w("float32array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _float64array: function(I) {
            return w("float64array:"), this.dispatch(Array.prototype.slice.call(I));
          }, _arraybuffer: function(I) {
            return w("arraybuffer:"), this.dispatch(new Uint8Array(I));
          }, _url: function(I) {
            return w("url:" + I.toString());
          }, _map: function(I) {
            return w("map:"), I = Array.from(I), this._array(I, E.unorderedSets !== false);
          }, _set: function(I) {
            return w("set:"), I = Array.from(I), this._array(I, E.unorderedSets !== false);
          }, _file: function(I) {
            return w("file:"), this.dispatch([I.name, I.size, I.type, I.lastModfied]);
          }, _blob: function() {
            if (E.ignoreUnknown) return w("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return w("domwindow");
          }, _bigint: function(I) {
            return w("bigint:" + I.toString());
          }, _process: function() {
            return w("process");
          }, _timer: function() {
            return w("timer");
          }, _pipe: function() {
            return w("pipe");
          }, _tcp: function() {
            return w("tcp");
          }, _udp: function() {
            return w("udp");
          }, _tty: function() {
            return w("tty");
          }, _statwatcher: function() {
            return w("statwatcher");
          }, _securecontext: function() {
            return w("securecontext");
          }, _connection: function() {
            return w("connection");
          }, _zlib: function() {
            return w("zlib");
          }, _context: function() {
            return w("context");
          }, _nodescript: function() {
            return w("nodescript");
          }, _httpparser: function() {
            return w("httpparser");
          }, _dataview: function() {
            return w("dataview");
          }, _signal: function() {
            return w("signal");
          }, _fsevent: function() {
            return w("fsevent");
          }, _tlswrap: function() {
            return w("tlswrap");
          } };
        }
        function m() {
          return { buf: "", write: function(E) {
            this.buf += E;
          }, end: function(E) {
            this.buf += E;
          }, read: function() {
            return this.buf;
          } };
        }
        A.writeToStream = function(E, _, C) {
          return C === void 0 && (C = _, _ = {}), h(_ = d(E, _), C).dispatch(E);
        };
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(o, b, A) {
      (function(R, P, t, l, n, u, c, e, r) {
        (function(f) {
          var y = typeof Uint8Array < "u" ? Uint8Array : Array, S = 43, T = 47, d = 48, p = 97, h = 65, m = 45, E = 95;
          function _(C) {
            return C = C.charCodeAt(0), C === S || C === m ? 62 : C === T || C === E ? 63 : C < d ? -1 : C < d + 10 ? C - d + 26 + 26 : C < h + 26 ? C - h : C < p + 26 ? C - p + 26 : void 0;
          }
          f.toByteArray = function(C) {
            var w, I;
            if (0 < C.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
            var D = C.length, D = C.charAt(D - 2) === "=" ? 2 : C.charAt(D - 1) === "=" ? 1 : 0, j = new y(3 * C.length / 4 - D), L = 0 < D ? C.length - 4 : C.length, k = 0;
            function N(F) {
              j[k++] = F;
            }
            for (w = 0; w < L; w += 4, 0) N((16711680 & (I = _(C.charAt(w)) << 18 | _(C.charAt(w + 1)) << 12 | _(C.charAt(w + 2)) << 6 | _(C.charAt(w + 3)))) >> 16), N((65280 & I) >> 8), N(255 & I);
            return D == 2 ? N(255 & (I = _(C.charAt(w)) << 2 | _(C.charAt(w + 1)) >> 4)) : D == 1 && (N((I = _(C.charAt(w)) << 10 | _(C.charAt(w + 1)) << 4 | _(C.charAt(w + 2)) >> 2) >> 8 & 255), N(255 & I)), j;
          }, f.fromByteArray = function(C) {
            var w, I, D, j, L = C.length % 3, k = "";
            function N(F) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(F);
            }
            for (w = 0, D = C.length - L; w < D; w += 3) I = (C[w] << 16) + (C[w + 1] << 8) + C[w + 2], k += N((j = I) >> 18 & 63) + N(j >> 12 & 63) + N(j >> 6 & 63) + N(63 & j);
            switch (L) {
              case 1:
                k = (k += N((I = C[C.length - 1]) >> 2)) + N(I << 4 & 63) + "==";
                break;
              case 2:
                k = (k = (k += N((I = (C[C.length - 2] << 8) + C[C.length - 1]) >> 10)) + N(I >> 4 & 63)) + N(I << 2 & 63) + "=";
            }
            return k;
          };
        })(A === void 0 ? this.base64js = {} : A);
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 11 }], 3: [function(o, b, A) {
      (function(R, P, S, l, n, u, c, e, r) {
        var f = o("base64-js"), y = o("ieee754");
        function S(M, K, Q) {
          if (!(this instanceof S)) return new S(M, K, Q);
          var ie, ue, ge, Te, le = typeof M;
          if (K === "base64" && le == "string") for (M = (Te = M).trim ? Te.trim() : Te.replace(/^\s+|\s+$/g, ""); M.length % 4 != 0; ) M += "=";
          if (le == "number") ie = X(M);
          else if (le == "string") ie = S.byteLength(M, K);
          else {
            if (le != "object") throw new Error("First argument needs to be a number, array or string.");
            ie = X(M.length);
          }
          if (S._useTypedArrays ? ue = S._augment(new Uint8Array(ie)) : ((ue = this).length = ie, ue._isBuffer = true), S._useTypedArrays && typeof M.byteLength == "number") ue._set(M);
          else if (H(Te = M) || S.isBuffer(Te) || Te && typeof Te == "object" && typeof Te.length == "number") for (ge = 0; ge < ie; ge++) S.isBuffer(M) ? ue[ge] = M.readUInt8(ge) : ue[ge] = M[ge];
          else if (le == "string") ue.write(M, 0, K);
          else if (le == "number" && !S._useTypedArrays && !Q) for (ge = 0; ge < ie; ge++) ue[ge] = 0;
          return ue;
        }
        function T(M, K, Q, ie) {
          return S._charsWritten = re(function(ue) {
            for (var ge = [], Te = 0; Te < ue.length; Te++) ge.push(255 & ue.charCodeAt(Te));
            return ge;
          }(K), M, Q, ie);
        }
        function d(M, K, Q, ie) {
          return S._charsWritten = re(function(ue) {
            for (var ge, Te, le = [], fe = 0; fe < ue.length; fe++) Te = ue.charCodeAt(fe), ge = Te >> 8, Te = Te % 256, le.push(Te), le.push(ge);
            return le;
          }(K), M, Q, ie);
        }
        function p(M, K, Q) {
          var ie = "";
          Q = Math.min(M.length, Q);
          for (var ue = K; ue < Q; ue++) ie += String.fromCharCode(M[ue]);
          return ie;
        }
        function h(M, K, Q, ge) {
          ge || (z(typeof Q == "boolean", "missing or invalid endian"), z(K != null, "missing offset"), z(K + 1 < M.length, "Trying to read beyond buffer length"));
          var ue, ge = M.length;
          if (!(ge <= K)) return Q ? (ue = M[K], K + 1 < ge && (ue |= M[K + 1] << 8)) : (ue = M[K] << 8, K + 1 < ge && (ue |= M[K + 1])), ue;
        }
        function m(M, K, Q, ge) {
          ge || (z(typeof Q == "boolean", "missing or invalid endian"), z(K != null, "missing offset"), z(K + 3 < M.length, "Trying to read beyond buffer length"));
          var ue, ge = M.length;
          if (!(ge <= K)) return Q ? (K + 2 < ge && (ue = M[K + 2] << 16), K + 1 < ge && (ue |= M[K + 1] << 8), ue |= M[K], K + 3 < ge && (ue += M[K + 3] << 24 >>> 0)) : (K + 1 < ge && (ue = M[K + 1] << 16), K + 2 < ge && (ue |= M[K + 2] << 8), K + 3 < ge && (ue |= M[K + 3]), ue += M[K] << 24 >>> 0), ue;
        }
        function E(M, K, Q, ie) {
          if (ie || (z(typeof Q == "boolean", "missing or invalid endian"), z(K != null, "missing offset"), z(K + 1 < M.length, "Trying to read beyond buffer length")), !(M.length <= K)) return ie = h(M, K, Q, true), 32768 & ie ? -1 * (65535 - ie + 1) : ie;
        }
        function _(M, K, Q, ie) {
          if (ie || (z(typeof Q == "boolean", "missing or invalid endian"), z(K != null, "missing offset"), z(K + 3 < M.length, "Trying to read beyond buffer length")), !(M.length <= K)) return ie = m(M, K, Q, true), 2147483648 & ie ? -1 * (4294967295 - ie + 1) : ie;
        }
        function C(M, K, Q, ie) {
          return ie || (z(typeof Q == "boolean", "missing or invalid endian"), z(K + 3 < M.length, "Trying to read beyond buffer length")), y.read(M, K, Q, 23, 4);
        }
        function w(M, K, Q, ie) {
          return ie || (z(typeof Q == "boolean", "missing or invalid endian"), z(K + 7 < M.length, "Trying to read beyond buffer length")), y.read(M, K, Q, 52, 8);
        }
        function I(M, K, Q, ie, ue) {
          if (ue || (z(K != null, "missing value"), z(typeof ie == "boolean", "missing or invalid endian"), z(Q != null, "missing offset"), z(Q + 1 < M.length, "trying to write beyond buffer length"), Z(K, 65535)), ue = M.length, !(ue <= Q)) for (var ge = 0, Te = Math.min(ue - Q, 2); ge < Te; ge++) M[Q + ge] = (K & 255 << 8 * (ie ? ge : 1 - ge)) >>> 8 * (ie ? ge : 1 - ge);
        }
        function D(M, K, Q, ie, ue) {
          if (ue || (z(K != null, "missing value"), z(typeof ie == "boolean", "missing or invalid endian"), z(Q != null, "missing offset"), z(Q + 3 < M.length, "trying to write beyond buffer length"), Z(K, 4294967295)), ue = M.length, !(ue <= Q)) for (var ge = 0, Te = Math.min(ue - Q, 4); ge < Te; ge++) M[Q + ge] = K >>> 8 * (ie ? ge : 3 - ge) & 255;
        }
        function j(M, K, Q, ie, ue) {
          ue || (z(K != null, "missing value"), z(typeof ie == "boolean", "missing or invalid endian"), z(Q != null, "missing offset"), z(Q + 1 < M.length, "Trying to write beyond buffer length"), G(K, 32767, -32768)), M.length <= Q || I(M, 0 <= K ? K : 65535 + K + 1, Q, ie, ue);
        }
        function L(M, K, Q, ie, ue) {
          ue || (z(K != null, "missing value"), z(typeof ie == "boolean", "missing or invalid endian"), z(Q != null, "missing offset"), z(Q + 3 < M.length, "Trying to write beyond buffer length"), G(K, 2147483647, -2147483648)), M.length <= Q || D(M, 0 <= K ? K : 4294967295 + K + 1, Q, ie, ue);
        }
        function k(M, K, Q, ie, ue) {
          ue || (z(K != null, "missing value"), z(typeof ie == "boolean", "missing or invalid endian"), z(Q != null, "missing offset"), z(Q + 3 < M.length, "Trying to write beyond buffer length"), B(K, 34028234663852886e22, -34028234663852886e22)), M.length <= Q || y.write(M, K, Q, ie, 23, 4);
        }
        function N(M, K, Q, ie, ue) {
          ue || (z(K != null, "missing value"), z(typeof ie == "boolean", "missing or invalid endian"), z(Q != null, "missing offset"), z(Q + 7 < M.length, "Trying to write beyond buffer length"), B(K, 17976931348623157e292, -17976931348623157e292)), M.length <= Q || y.write(M, K, Q, ie, 52, 8);
        }
        A.Buffer = S, A.SlowBuffer = S, A.INSPECT_MAX_BYTES = 50, S.poolSize = 8192, S._useTypedArrays = function() {
          try {
            var M = new ArrayBuffer(0), K = new Uint8Array(M);
            return K.foo = function() {
              return 42;
            }, K.foo() === 42 && typeof K.subarray == "function";
          } catch {
            return false;
          }
        }(), S.isEncoding = function(M) {
          switch (String(M).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, S.isBuffer = function(M) {
          return !(M == null || !M._isBuffer);
        }, S.byteLength = function(M, K) {
          var Q;
          switch (M += "", K || "utf8") {
            case "hex":
              Q = M.length / 2;
              break;
            case "utf8":
            case "utf-8":
              Q = q(M).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              Q = M.length;
              break;
            case "base64":
              Q = ee(M).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              Q = 2 * M.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return Q;
        }, S.concat = function(M, K) {
          if (z(H(M), `Usage: Buffer.concat(list, [totalLength])
list should be an Array.`), M.length === 0) return new S(0);
          if (M.length === 1) return M[0];
          if (typeof K != "number") for (ue = K = 0; ue < M.length; ue++) K += M[ue].length;
          for (var Q = new S(K), ie = 0, ue = 0; ue < M.length; ue++) {
            var ge = M[ue];
            ge.copy(Q, ie), ie += ge.length;
          }
          return Q;
        }, S.prototype.write = function(M, K, Q, ie) {
          isFinite(K) ? isFinite(Q) || (ie = Q, Q = void 0) : (fe = ie, ie = K, K = Q, Q = fe), K = Number(K) || 0;
          var ue, ge, Te, le, fe = this.length - K;
          switch ((!Q || fe < (Q = Number(Q))) && (Q = fe), ie = String(ie || "utf8").toLowerCase()) {
            case "hex":
              ue = function(Pe, xe, we, me) {
                we = Number(we) || 0;
                var ye = Pe.length - we;
                (!me || ye < (me = Number(me))) && (me = ye), z((ye = xe.length) % 2 == 0, "Invalid hex string"), ye / 2 < me && (me = ye / 2);
                for (var pe = 0; pe < me; pe++) {
                  var J = parseInt(xe.substr(2 * pe, 2), 16);
                  z(!isNaN(J), "Invalid hex string"), Pe[we + pe] = J;
                }
                return S._charsWritten = 2 * pe, pe;
              }(this, M, K, Q);
              break;
            case "utf8":
            case "utf-8":
              ge = this, Te = K, le = Q, ue = S._charsWritten = re(q(M), ge, Te, le);
              break;
            case "ascii":
            case "binary":
              ue = T(this, M, K, Q);
              break;
            case "base64":
              ge = this, Te = K, le = Q, ue = S._charsWritten = re(ee(M), ge, Te, le);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              ue = d(this, M, K, Q);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return ue;
        }, S.prototype.toString = function(M, K, Q) {
          var ie, ue, ge, Te, le = this;
          if (M = String(M || "utf8").toLowerCase(), K = Number(K) || 0, (Q = Q !== void 0 ? Number(Q) : le.length) === K) return "";
          switch (M) {
            case "hex":
              ie = function(fe, Pe, xe) {
                var we = fe.length;
                (!Pe || Pe < 0) && (Pe = 0), (!xe || xe < 0 || we < xe) && (xe = we);
                for (var me = "", ye = Pe; ye < xe; ye++) me += U(fe[ye]);
                return me;
              }(le, K, Q);
              break;
            case "utf8":
            case "utf-8":
              ie = function(fe, Pe, xe) {
                var we = "", me = "";
                xe = Math.min(fe.length, xe);
                for (var ye = Pe; ye < xe; ye++) fe[ye] <= 127 ? (we += Y(me) + String.fromCharCode(fe[ye]), me = "") : me += "%" + fe[ye].toString(16);
                return we + Y(me);
              }(le, K, Q);
              break;
            case "ascii":
            case "binary":
              ie = p(le, K, Q);
              break;
            case "base64":
              ue = le, Te = Q, ie = (ge = K) === 0 && Te === ue.length ? f.fromByteArray(ue) : f.fromByteArray(ue.slice(ge, Te));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              ie = function(fe, Pe, xe) {
                for (var we = fe.slice(Pe, xe), me = "", ye = 0; ye < we.length; ye += 2) me += String.fromCharCode(we[ye] + 256 * we[ye + 1]);
                return me;
              }(le, K, Q);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return ie;
        }, S.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, S.prototype.copy = function(M, K, Q, ie) {
          if (K = K || 0, (ie = ie || ie === 0 ? ie : this.length) !== (Q = Q || 0) && M.length !== 0 && this.length !== 0) {
            z(Q <= ie, "sourceEnd < sourceStart"), z(0 <= K && K < M.length, "targetStart out of bounds"), z(0 <= Q && Q < this.length, "sourceStart out of bounds"), z(0 <= ie && ie <= this.length, "sourceEnd out of bounds"), ie > this.length && (ie = this.length);
            var ue = (ie = M.length - K < ie - Q ? M.length - K + Q : ie) - Q;
            if (ue < 100 || !S._useTypedArrays) for (var ge = 0; ge < ue; ge++) M[ge + K] = this[ge + Q];
            else M._set(this.subarray(Q, Q + ue), K);
          }
        }, S.prototype.slice = function(M, K) {
          var Q = this.length;
          if (M = W(M, Q, 0), K = W(K, Q, Q), S._useTypedArrays) return S._augment(this.subarray(M, K));
          for (var ie = K - M, ue = new S(ie, void 0, true), ge = 0; ge < ie; ge++) ue[ge] = this[ge + M];
          return ue;
        }, S.prototype.get = function(M) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(M);
        }, S.prototype.set = function(M, K) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(M, K);
        }, S.prototype.readUInt8 = function(M, K) {
          if (K || (z(M != null, "missing offset"), z(M < this.length, "Trying to read beyond buffer length")), !(M >= this.length)) return this[M];
        }, S.prototype.readUInt16LE = function(M, K) {
          return h(this, M, true, K);
        }, S.prototype.readUInt16BE = function(M, K) {
          return h(this, M, false, K);
        }, S.prototype.readUInt32LE = function(M, K) {
          return m(this, M, true, K);
        }, S.prototype.readUInt32BE = function(M, K) {
          return m(this, M, false, K);
        }, S.prototype.readInt8 = function(M, K) {
          if (K || (z(M != null, "missing offset"), z(M < this.length, "Trying to read beyond buffer length")), !(M >= this.length)) return 128 & this[M] ? -1 * (255 - this[M] + 1) : this[M];
        }, S.prototype.readInt16LE = function(M, K) {
          return E(this, M, true, K);
        }, S.prototype.readInt16BE = function(M, K) {
          return E(this, M, false, K);
        }, S.prototype.readInt32LE = function(M, K) {
          return _(this, M, true, K);
        }, S.prototype.readInt32BE = function(M, K) {
          return _(this, M, false, K);
        }, S.prototype.readFloatLE = function(M, K) {
          return C(this, M, true, K);
        }, S.prototype.readFloatBE = function(M, K) {
          return C(this, M, false, K);
        }, S.prototype.readDoubleLE = function(M, K) {
          return w(this, M, true, K);
        }, S.prototype.readDoubleBE = function(M, K) {
          return w(this, M, false, K);
        }, S.prototype.writeUInt8 = function(M, K, Q) {
          Q || (z(M != null, "missing value"), z(K != null, "missing offset"), z(K < this.length, "trying to write beyond buffer length"), Z(M, 255)), K >= this.length || (this[K] = M);
        }, S.prototype.writeUInt16LE = function(M, K, Q) {
          I(this, M, K, true, Q);
        }, S.prototype.writeUInt16BE = function(M, K, Q) {
          I(this, M, K, false, Q);
        }, S.prototype.writeUInt32LE = function(M, K, Q) {
          D(this, M, K, true, Q);
        }, S.prototype.writeUInt32BE = function(M, K, Q) {
          D(this, M, K, false, Q);
        }, S.prototype.writeInt8 = function(M, K, Q) {
          Q || (z(M != null, "missing value"), z(K != null, "missing offset"), z(K < this.length, "Trying to write beyond buffer length"), G(M, 127, -128)), K >= this.length || (0 <= M ? this.writeUInt8(M, K, Q) : this.writeUInt8(255 + M + 1, K, Q));
        }, S.prototype.writeInt16LE = function(M, K, Q) {
          j(this, M, K, true, Q);
        }, S.prototype.writeInt16BE = function(M, K, Q) {
          j(this, M, K, false, Q);
        }, S.prototype.writeInt32LE = function(M, K, Q) {
          L(this, M, K, true, Q);
        }, S.prototype.writeInt32BE = function(M, K, Q) {
          L(this, M, K, false, Q);
        }, S.prototype.writeFloatLE = function(M, K, Q) {
          k(this, M, K, true, Q);
        }, S.prototype.writeFloatBE = function(M, K, Q) {
          k(this, M, K, false, Q);
        }, S.prototype.writeDoubleLE = function(M, K, Q) {
          N(this, M, K, true, Q);
        }, S.prototype.writeDoubleBE = function(M, K, Q) {
          N(this, M, K, false, Q);
        }, S.prototype.fill = function(M, K, Q) {
          if (K = K || 0, Q = Q || this.length, z(typeof (M = typeof (M = M || 0) == "string" ? M.charCodeAt(0) : M) == "number" && !isNaN(M), "value is not a number"), z(K <= Q, "end < start"), Q !== K && this.length !== 0) {
            z(0 <= K && K < this.length, "start out of bounds"), z(0 <= Q && Q <= this.length, "end out of bounds");
            for (var ie = K; ie < Q; ie++) this[ie] = M;
          }
        }, S.prototype.inspect = function() {
          for (var M = [], K = this.length, Q = 0; Q < K; Q++) if (M[Q] = U(this[Q]), Q === A.INSPECT_MAX_BYTES) {
            M[Q + 1] = "...";
            break;
          }
          return "<Buffer " + M.join(" ") + ">";
        }, S.prototype.toArrayBuffer = function() {
          if (typeof Uint8Array > "u") throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (S._useTypedArrays) return new S(this).buffer;
          for (var M = new Uint8Array(this.length), K = 0, Q = M.length; K < Q; K += 1) M[K] = this[K];
          return M.buffer;
        };
        var F = S.prototype;
        function W(M, K, Q) {
          return typeof M != "number" ? Q : K <= (M = ~~M) ? K : 0 <= M || 0 <= (M += K) ? M : 0;
        }
        function X(M) {
          return (M = ~~Math.ceil(+M)) < 0 ? 0 : M;
        }
        function H(M) {
          return (Array.isArray || function(K) {
            return Object.prototype.toString.call(K) === "[object Array]";
          })(M);
        }
        function U(M) {
          return M < 16 ? "0" + M.toString(16) : M.toString(16);
        }
        function q(M) {
          for (var K = [], Q = 0; Q < M.length; Q++) {
            var ie = M.charCodeAt(Q);
            if (ie <= 127) K.push(M.charCodeAt(Q));
            else for (var ue = Q, ge = (55296 <= ie && ie <= 57343 && Q++, encodeURIComponent(M.slice(ue, Q + 1)).substr(1).split("%")), Te = 0; Te < ge.length; Te++) K.push(parseInt(ge[Te], 16));
          }
          return K;
        }
        function ee(M) {
          return f.toByteArray(M);
        }
        function re(M, K, Q, ie) {
          for (var ue = 0; ue < ie && !(ue + Q >= K.length || ue >= M.length); ue++) K[ue + Q] = M[ue];
          return ue;
        }
        function Y(M) {
          try {
            return decodeURIComponent(M);
          } catch {
            return "\uFFFD";
          }
        }
        function Z(M, K) {
          z(typeof M == "number", "cannot write a non-number as a number"), z(0 <= M, "specified a negative value for writing an unsigned value"), z(M <= K, "value is larger than maximum value for type"), z(Math.floor(M) === M, "value has a fractional component");
        }
        function G(M, K, Q) {
          z(typeof M == "number", "cannot write a non-number as a number"), z(M <= K, "value larger than maximum allowed value"), z(Q <= M, "value smaller than minimum allowed value"), z(Math.floor(M) === M, "value has a fractional component");
        }
        function B(M, K, Q) {
          z(typeof M == "number", "cannot write a non-number as a number"), z(M <= K, "value larger than maximum allowed value"), z(Q <= M, "value smaller than minimum allowed value");
        }
        function z(M, K) {
          if (!M) throw new Error(K || "Failed assertion");
        }
        S._augment = function(M) {
          return M._isBuffer = true, M._get = M.get, M._set = M.set, M.get = F.get, M.set = F.set, M.write = F.write, M.toString = F.toString, M.toLocaleString = F.toString, M.toJSON = F.toJSON, M.copy = F.copy, M.slice = F.slice, M.readUInt8 = F.readUInt8, M.readUInt16LE = F.readUInt16LE, M.readUInt16BE = F.readUInt16BE, M.readUInt32LE = F.readUInt32LE, M.readUInt32BE = F.readUInt32BE, M.readInt8 = F.readInt8, M.readInt16LE = F.readInt16LE, M.readInt16BE = F.readInt16BE, M.readInt32LE = F.readInt32LE, M.readInt32BE = F.readInt32BE, M.readFloatLE = F.readFloatLE, M.readFloatBE = F.readFloatBE, M.readDoubleLE = F.readDoubleLE, M.readDoubleBE = F.readDoubleBE, M.writeUInt8 = F.writeUInt8, M.writeUInt16LE = F.writeUInt16LE, M.writeUInt16BE = F.writeUInt16BE, M.writeUInt32LE = F.writeUInt32LE, M.writeUInt32BE = F.writeUInt32BE, M.writeInt8 = F.writeInt8, M.writeInt16LE = F.writeInt16LE, M.writeInt16BE = F.writeInt16BE, M.writeInt32LE = F.writeInt32LE, M.writeInt32BE = F.writeInt32BE, M.writeFloatLE = F.writeFloatLE, M.writeFloatBE = F.writeFloatBE, M.writeDoubleLE = F.writeDoubleLE, M.writeDoubleBE = F.writeDoubleBE, M.fill = F.fill, M.inspect = F.inspect, M.toArrayBuffer = F.toArrayBuffer, M;
        };
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(o, b, A) {
      (function(R, P, f, l, n, u, c, e, r) {
        var f = o("buffer").Buffer, y = 4, S = new f(y);
        S.fill(0), b.exports = { hash: function(T, d, p, h) {
          for (var m = d(function(I, D) {
            I.length % y != 0 && (j = I.length + (y - I.length % y), I = f.concat([I, S], j));
            for (var j, L = [], k = D ? I.readInt32BE : I.readInt32LE, N = 0; N < I.length; N += y) L.push(k.call(I, N));
            return L;
          }(T = f.isBuffer(T) ? T : new f(T), h), 8 * T.length), d = h, E = new f(p), _ = d ? E.writeInt32BE : E.writeInt32LE, C = 0; C < m.length; C++) _.call(E, m[C], 4 * C, true);
          return E;
        } };
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 5: [function(o, b, A) {
      (function(R, P, f, l, n, u, c, e, r) {
        var f = o("buffer").Buffer, y = o("./sha"), S = o("./sha256"), T = o("./rng"), d = { sha1: y, sha256: S, md5: o("./md5") }, p = 64, h = new f(p);
        function m(I, D) {
          var j = d[I = I || "sha1"], L = [];
          return j || E("algorithm:", I, "is not yet supported"), { update: function(k) {
            return f.isBuffer(k) || (k = new f(k)), L.push(k), k.length, this;
          }, digest: function(k) {
            var N = f.concat(L), N = D ? function(F, W, X) {
              f.isBuffer(W) || (W = new f(W)), f.isBuffer(X) || (X = new f(X)), W.length > p ? W = F(W) : W.length < p && (W = f.concat([W, h], p));
              for (var H = new f(p), U = new f(p), q = 0; q < p; q++) H[q] = 54 ^ W[q], U[q] = 92 ^ W[q];
              return X = F(f.concat([H, X])), F(f.concat([U, X]));
            }(j, D, N) : j(N);
            return L = null, k ? N.toString(k) : N;
          } };
        }
        function E() {
          var I = [].slice.call(arguments).join(" ");
          throw new Error([I, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
`));
        }
        h.fill(0), A.createHash = function(I) {
          return m(I);
        }, A.createHmac = m, A.randomBytes = function(I, D) {
          if (!D || !D.call) return new f(T(I));
          try {
            D.call(this, void 0, new f(T(I)));
          } catch (j) {
            D(j);
          }
        };
        var _, C = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], w = function(I) {
          A[I] = function() {
            E("sorry,", I, "is not implemented yet");
          };
        };
        for (_ in C) w(C[_]);
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(o, b, A) {
      (function(R, P, t, l, n, u, c, e, r) {
        var f = o("./helpers");
        function y(E, _) {
          E[_ >> 5] |= 128 << _ % 32, E[14 + (_ + 64 >>> 9 << 4)] = _;
          for (var C = 1732584193, w = -271733879, I = -1732584194, D = 271733878, j = 0; j < E.length; j += 16) {
            var L = C, k = w, N = I, F = D, C = T(C, w, I, D, E[j + 0], 7, -680876936), D = T(D, C, w, I, E[j + 1], 12, -389564586), I = T(I, D, C, w, E[j + 2], 17, 606105819), w = T(w, I, D, C, E[j + 3], 22, -1044525330);
            C = T(C, w, I, D, E[j + 4], 7, -176418897), D = T(D, C, w, I, E[j + 5], 12, 1200080426), I = T(I, D, C, w, E[j + 6], 17, -1473231341), w = T(w, I, D, C, E[j + 7], 22, -45705983), C = T(C, w, I, D, E[j + 8], 7, 1770035416), D = T(D, C, w, I, E[j + 9], 12, -1958414417), I = T(I, D, C, w, E[j + 10], 17, -42063), w = T(w, I, D, C, E[j + 11], 22, -1990404162), C = T(C, w, I, D, E[j + 12], 7, 1804603682), D = T(D, C, w, I, E[j + 13], 12, -40341101), I = T(I, D, C, w, E[j + 14], 17, -1502002290), C = d(C, w = T(w, I, D, C, E[j + 15], 22, 1236535329), I, D, E[j + 1], 5, -165796510), D = d(D, C, w, I, E[j + 6], 9, -1069501632), I = d(I, D, C, w, E[j + 11], 14, 643717713), w = d(w, I, D, C, E[j + 0], 20, -373897302), C = d(C, w, I, D, E[j + 5], 5, -701558691), D = d(D, C, w, I, E[j + 10], 9, 38016083), I = d(I, D, C, w, E[j + 15], 14, -660478335), w = d(w, I, D, C, E[j + 4], 20, -405537848), C = d(C, w, I, D, E[j + 9], 5, 568446438), D = d(D, C, w, I, E[j + 14], 9, -1019803690), I = d(I, D, C, w, E[j + 3], 14, -187363961), w = d(w, I, D, C, E[j + 8], 20, 1163531501), C = d(C, w, I, D, E[j + 13], 5, -1444681467), D = d(D, C, w, I, E[j + 2], 9, -51403784), I = d(I, D, C, w, E[j + 7], 14, 1735328473), C = p(C, w = d(w, I, D, C, E[j + 12], 20, -1926607734), I, D, E[j + 5], 4, -378558), D = p(D, C, w, I, E[j + 8], 11, -2022574463), I = p(I, D, C, w, E[j + 11], 16, 1839030562), w = p(w, I, D, C, E[j + 14], 23, -35309556), C = p(C, w, I, D, E[j + 1], 4, -1530992060), D = p(D, C, w, I, E[j + 4], 11, 1272893353), I = p(I, D, C, w, E[j + 7], 16, -155497632), w = p(w, I, D, C, E[j + 10], 23, -1094730640), C = p(C, w, I, D, E[j + 13], 4, 681279174), D = p(D, C, w, I, E[j + 0], 11, -358537222), I = p(I, D, C, w, E[j + 3], 16, -722521979), w = p(w, I, D, C, E[j + 6], 23, 76029189), C = p(C, w, I, D, E[j + 9], 4, -640364487), D = p(D, C, w, I, E[j + 12], 11, -421815835), I = p(I, D, C, w, E[j + 15], 16, 530742520), C = h(C, w = p(w, I, D, C, E[j + 2], 23, -995338651), I, D, E[j + 0], 6, -198630844), D = h(D, C, w, I, E[j + 7], 10, 1126891415), I = h(I, D, C, w, E[j + 14], 15, -1416354905), w = h(w, I, D, C, E[j + 5], 21, -57434055), C = h(C, w, I, D, E[j + 12], 6, 1700485571), D = h(D, C, w, I, E[j + 3], 10, -1894986606), I = h(I, D, C, w, E[j + 10], 15, -1051523), w = h(w, I, D, C, E[j + 1], 21, -2054922799), C = h(C, w, I, D, E[j + 8], 6, 1873313359), D = h(D, C, w, I, E[j + 15], 10, -30611744), I = h(I, D, C, w, E[j + 6], 15, -1560198380), w = h(w, I, D, C, E[j + 13], 21, 1309151649), C = h(C, w, I, D, E[j + 4], 6, -145523070), D = h(D, C, w, I, E[j + 11], 10, -1120210379), I = h(I, D, C, w, E[j + 2], 15, 718787259), w = h(w, I, D, C, E[j + 9], 21, -343485551), C = m(C, L), w = m(w, k), I = m(I, N), D = m(D, F);
          }
          return Array(C, w, I, D);
        }
        function S(E, _, C, w, I, D) {
          return m((_ = m(m(_, E), m(w, D))) << I | _ >>> 32 - I, C);
        }
        function T(E, _, C, w, I, D, j) {
          return S(_ & C | ~_ & w, E, _, I, D, j);
        }
        function d(E, _, C, w, I, D, j) {
          return S(_ & w | C & ~w, E, _, I, D, j);
        }
        function p(E, _, C, w, I, D, j) {
          return S(_ ^ C ^ w, E, _, I, D, j);
        }
        function h(E, _, C, w, I, D, j) {
          return S(C ^ (_ | ~w), E, _, I, D, j);
        }
        function m(E, _) {
          var C = (65535 & E) + (65535 & _);
          return (E >> 16) + (_ >> 16) + (C >> 16) << 16 | 65535 & C;
        }
        b.exports = function(E) {
          return f.hash(E, y, 16);
        };
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(o, b, A) {
      (function(R, P, t, l, n, u, c, e, r) {
        b.exports = function(f) {
          for (var y, S = new Array(f), T = 0; T < f; T++) !(3 & T) && (y = 4294967296 * Math.random()), S[T] = y >>> ((3 & T) << 3) & 255;
          return S;
        };
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 8: [function(o, b, A) {
      (function(R, P, t, l, n, u, c, e, r) {
        var f = o("./helpers");
        function y(d, p) {
          d[p >> 5] |= 128 << 24 - p % 32, d[15 + (p + 64 >> 9 << 4)] = p;
          for (var h, m, E, _ = Array(80), C = 1732584193, w = -271733879, I = -1732584194, D = 271733878, j = -1009589776, L = 0; L < d.length; L += 16) {
            for (var k = C, N = w, F = I, W = D, X = j, H = 0; H < 80; H++) {
              _[H] = H < 16 ? d[L + H] : T(_[H - 3] ^ _[H - 8] ^ _[H - 14] ^ _[H - 16], 1);
              var U = S(S(T(C, 5), (U = w, m = I, E = D, (h = H) < 20 ? U & m | ~U & E : !(h < 40) && h < 60 ? U & m | U & E | m & E : U ^ m ^ E)), S(S(j, _[H]), (h = H) < 20 ? 1518500249 : h < 40 ? 1859775393 : h < 60 ? -1894007588 : -899497514)), j = D, D = I, I = T(w, 30), w = C, C = U;
            }
            C = S(C, k), w = S(w, N), I = S(I, F), D = S(D, W), j = S(j, X);
          }
          return Array(C, w, I, D, j);
        }
        function S(d, p) {
          var h = (65535 & d) + (65535 & p);
          return (d >> 16) + (p >> 16) + (h >> 16) << 16 | 65535 & h;
        }
        function T(d, p) {
          return d << p | d >>> 32 - p;
        }
        b.exports = function(d) {
          return f.hash(d, y, 20, true);
        };
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(o, b, A) {
      (function(R, P, t, l, n, u, c, e, r) {
        function f(p, h) {
          var m = (65535 & p) + (65535 & h);
          return (p >> 16) + (h >> 16) + (m >> 16) << 16 | 65535 & m;
        }
        function y(p, h) {
          var m, E = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), _ = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), C = new Array(64);
          p[h >> 5] |= 128 << 24 - h % 32, p[15 + (h + 64 >> 9 << 4)] = h;
          for (var w, I, D = 0; D < p.length; D += 16) {
            for (var j = _[0], L = _[1], k = _[2], N = _[3], F = _[4], W = _[5], X = _[6], H = _[7], U = 0; U < 64; U++) C[U] = U < 16 ? p[U + D] : f(f(f((I = C[U - 2], T(I, 17) ^ T(I, 19) ^ d(I, 10)), C[U - 7]), (I = C[U - 15], T(I, 7) ^ T(I, 18) ^ d(I, 3))), C[U - 16]), m = f(f(f(f(H, T(I = F, 6) ^ T(I, 11) ^ T(I, 25)), F & W ^ ~F & X), E[U]), C[U]), w = f(T(w = j, 2) ^ T(w, 13) ^ T(w, 22), j & L ^ j & k ^ L & k), H = X, X = W, W = F, F = f(N, m), N = k, k = L, L = j, j = f(m, w);
            _[0] = f(j, _[0]), _[1] = f(L, _[1]), _[2] = f(k, _[2]), _[3] = f(N, _[3]), _[4] = f(F, _[4]), _[5] = f(W, _[5]), _[6] = f(X, _[6]), _[7] = f(H, _[7]);
          }
          return _;
        }
        var S = o("./helpers"), T = function(p, h) {
          return p >>> h | p << 32 - h;
        }, d = function(p, h) {
          return p >>> h;
        };
        b.exports = function(p) {
          return S.hash(p, y, 32, true);
        };
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(o, b, A) {
      (function(R, P, t, l, n, u, c, e, r) {
        A.read = function(f, y, S, T, D) {
          var p, h, m = 8 * D - T - 1, E = (1 << m) - 1, _ = E >> 1, C = -7, w = S ? D - 1 : 0, I = S ? -1 : 1, D = f[y + w];
          for (w += I, p = D & (1 << -C) - 1, D >>= -C, C += m; 0 < C; p = 256 * p + f[y + w], w += I, C -= 8) ;
          for (h = p & (1 << -C) - 1, p >>= -C, C += T; 0 < C; h = 256 * h + f[y + w], w += I, C -= 8) ;
          if (p === 0) p = 1 - _;
          else {
            if (p === E) return h ? NaN : 1 / 0 * (D ? -1 : 1);
            h += Math.pow(2, T), p -= _;
          }
          return (D ? -1 : 1) * h * Math.pow(2, p - T);
        }, A.write = function(f, y, S, T, d, j) {
          var h, m, E = 8 * j - d - 1, _ = (1 << E) - 1, C = _ >> 1, w = d === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, I = T ? 0 : j - 1, D = T ? 1 : -1, j = y < 0 || y === 0 && 1 / y < 0 ? 1 : 0;
          for (y = Math.abs(y), isNaN(y) || y === 1 / 0 ? (m = isNaN(y) ? 1 : 0, h = _) : (h = Math.floor(Math.log(y) / Math.LN2), y * (T = Math.pow(2, -h)) < 1 && (h--, T *= 2), 2 <= (y += 1 <= h + C ? w / T : w * Math.pow(2, 1 - C)) * T && (h++, T /= 2), _ <= h + C ? (m = 0, h = _) : 1 <= h + C ? (m = (y * T - 1) * Math.pow(2, d), h += C) : (m = y * Math.pow(2, C - 1) * Math.pow(2, d), h = 0)); 8 <= d; f[S + I] = 255 & m, I += D, m /= 256, d -= 8) ;
          for (h = h << d | m, E += d; 0 < E; f[S + I] = 255 & h, I += D, h /= 256, E -= 8) ;
          f[S + I - D] |= 128 * j;
        };
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 11 }], 11: [function(o, b, A) {
      (function(R, P, t, l, n, u, c, e, r) {
        var f, y, S;
        function T() {
        }
        (R = b.exports = {}).nextTick = (y = typeof window < "u" && window.setImmediate, S = typeof window < "u" && window.postMessage && window.addEventListener, y ? function(d) {
          return window.setImmediate(d);
        } : S ? (f = [], window.addEventListener("message", function(d) {
          var p = d.source;
          p !== window && p !== null || d.data !== "process-tick" || (d.stopPropagation(), 0 < f.length && f.shift()());
        }, true), function(d) {
          f.push(d), window.postMessage("process-tick", "*");
        }) : function(d) {
          setTimeout(d, 0);
        }), R.title = "browser", R.browser = true, R.env = {}, R.argv = [], R.on = T, R.addListener = T, R.once = T, R.off = T, R.removeListener = T, R.removeAllListeners = T, R.emit = T, R.binding = function(d) {
          throw new Error("process.binding is not supported");
        }, R.cwd = function() {
          return "/";
        }, R.chdir = function(d) {
          throw new Error("process.chdir is not supported");
        };
      }).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
  });
})(ff);
var pg = ff.exports;
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return b;
  } });
  const s = o(pg);
  function o(A) {
    return A && A.__esModule ? A : { default: A };
  }
  function b(A) {
    return (0, s.default)(A, { ignoreUnknown: true });
  }
})(df);
var hf = {}, mf = {}, Wa = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  function s(o) {
    if (o = `${o}`, o === "0") return "0";
    if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(o)) return o.replace(/^[+-]?/, (A) => A === "-" ? "" : "-");
    let b = ["var", "calc", "min", "max", "clamp"];
    for (const A of b) if (o.includes(`${A}(`)) return `calc(${o} * -1)`;
  }
})(Wa);
var yf = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  const s = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "size", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "textWrap", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "contain", "content", "forcedColorAdjust"];
})(yf);
var bf = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  function s(o, b) {
    return o === void 0 ? b : Array.isArray(o) ? o : [...new Set(b.filter((R) => o !== false && o[R] !== false).concat(Object.keys(o).filter((R) => o[R] !== false)))];
  }
})(bf);
var gf = {}, xr = {}, Su = { exports: {} }, Yt = String, vf = function() {
  return { isColorSupported: false, reset: Yt, bold: Yt, dim: Yt, italic: Yt, underline: Yt, inverse: Yt, hidden: Yt, strikethrough: Yt, black: Yt, red: Yt, green: Yt, yellow: Yt, blue: Yt, magenta: Yt, cyan: Yt, white: Yt, gray: Yt, bgBlack: Yt, bgRed: Yt, bgGreen: Yt, bgYellow: Yt, bgBlue: Yt, bgMagenta: Yt, bgCyan: Yt, bgWhite: Yt, blackBright: Yt, redBright: Yt, greenBright: Yt, yellowBright: Yt, blueBright: Yt, magentaBright: Yt, cyanBright: Yt, whiteBright: Yt, bgBlackBright: Yt, bgRedBright: Yt, bgGreenBright: Yt, bgYellowBright: Yt, bgBlueBright: Yt, bgMagentaBright: Yt, bgCyanBright: Yt, bgWhiteBright: Yt };
};
Su.exports = vf();
Su.exports.createColors = vf;
var _u = Su.exports;
(function(a3) {
  var s = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  function o(n, u) {
    for (var c in u) Object.defineProperty(n, c, { enumerable: true, get: u[c] });
  }
  o(a3, { dim: function() {
    return t;
  }, default: function() {
    return l;
  } });
  const b = A(_u);
  function A(n) {
    return n && n.__esModule ? n : { default: n };
  }
  let R = /* @__PURE__ */ new Set();
  function P(n, u, c) {
    typeof process < "u" && s.JEST_WORKER_ID || c && R.has(c) || (c && R.add(c), console.warn(""), u.forEach((e) => console.warn(n, "-", e)));
  }
  function t(n) {
    return b.default.dim(n);
  }
  const l = { info(n, u) {
    P(b.default.bold(b.default.cyan("info")), ...Array.isArray(n) ? [n] : [u, n]);
  }, warn(n, u) {
    P(b.default.bold(b.default.yellow("warn")), ...Array.isArray(n) ? [n] : [u, n]);
  }, risk(n, u) {
    P(b.default.bold(b.default.magenta("risk")), ...Array.isArray(n) ? [n] : [u, n]);
  } };
})(xr);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return A;
  } });
  const s = o(xr);
  function o(R) {
    return R && R.__esModule ? R : { default: R };
  }
  function b({ version: R, from: P, to: t }) {
    s.default.warn(`${P}-color-renamed`, [`As of Tailwind CSS ${R}, \`${P}\` has been renamed to \`${t}\`.`, "Update your configuration file to silence this warning."]);
  }
  const A = { inherit: "inherit", current: "currentColor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a", 950: "#020617" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827", 950: "#030712" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b", 950: "#09090b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717", 950: "#0a0a0a" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917", 950: "#0c0a09" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d", 950: "#450a0a" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12", 950: "#431407" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f", 950: "#451a03" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12", 950: "#422006" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314", 950: "#1a2e05" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d", 950: "#052e16" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b", 950: "#022c22" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a", 950: "#042f2e" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63", 950: "#083344" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e", 950: "#082f49" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a", 950: "#172554" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81", 950: "#1e1b4b" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95", 950: "#2e1065" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87", 950: "#3b0764" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75", 950: "#4a044e" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843", 950: "#500724" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337", 950: "#4c0519" }, get lightBlue() {
    return b({ version: "v2.2", from: "lightBlue", to: "sky" }), this.sky;
  }, get warmGray() {
    return b({ version: "v3.0", from: "warmGray", to: "stone" }), this.stone;
  }, get trueGray() {
    return b({ version: "v3.0", from: "trueGray", to: "neutral" }), this.neutral;
  }, get coolGray() {
    return b({ version: "v3.0", from: "coolGray", to: "gray" }), this.gray;
  }, get blueGray() {
    return b({ version: "v3.0", from: "blueGray", to: "slate" }), this.slate;
  } };
})(gf);
var Ef = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "defaults", { enumerable: true, get: function() {
    return s;
  } });
  function s(o, ...b) {
    for (let P of b) {
      for (let t in P) {
        var A;
        !(o == null || (A = o.hasOwnProperty) === null || A === void 0) && A.call(o, t) || (o[t] = P[t]);
      }
      for (let t of Object.getOwnPropertySymbols(P)) {
        var R;
        !(o == null || (R = o.hasOwnProperty) === null || R === void 0) && R.call(o, t) || (o[t] = P[t]);
      }
    }
    return o;
  }
})(Ef);
var Ha = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "toPath", { enumerable: true, get: function() {
    return s;
  } });
  function s(o) {
    if (Array.isArray(o)) return o;
    let b = o.split("[").length - 1, A = o.split("]").length - 1;
    if (b !== A) throw new Error(`Path is invalid. Has unbalanced brackets: ${o}`);
    return o.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
  }
})(Ha);
var Sf = {}, is = {};
(function(a3) {
  var s = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  function o(e, r) {
    for (var f in r) Object.defineProperty(e, f, { enumerable: true, get: r[f] });
  }
  o(a3, { flagEnabled: function() {
    return l;
  }, issueFlagNotices: function() {
    return u;
  }, default: function() {
    return c;
  } });
  const b = R(_u), A = R(xr);
  function R(e) {
    return e && e.__esModule ? e : { default: e };
  }
  let P = { optimizeUniversalDefaults: false, generalizedModifiers: true, disableColorOpacityUtilitiesByDefault: false, relativeContentPathsByDefault: false }, t = { future: ["hoverOnlyWhenSupported", "respectDefaultRingColorOpacity", "disableColorOpacityUtilitiesByDefault", "relativeContentPathsByDefault"], experimental: ["optimizeUniversalDefaults", "generalizedModifiers"] };
  function l(e, r) {
    if (t.future.includes(r)) {
      var f, y, S;
      return e.future === "all" || ((S = (y = e == null || (f = e.future) === null || f === void 0 ? void 0 : f[r]) !== null && y !== void 0 ? y : P[r]) !== null && S !== void 0 ? S : false);
    }
    if (t.experimental.includes(r)) {
      var T, d, p;
      return e.experimental === "all" || ((p = (d = e == null || (T = e.experimental) === null || T === void 0 ? void 0 : T[r]) !== null && d !== void 0 ? d : P[r]) !== null && p !== void 0 ? p : false);
    }
    return false;
  }
  function n(e) {
    if (e.experimental === "all") return t.experimental;
    var r;
    return Object.keys((r = e == null ? void 0 : e.experimental) !== null && r !== void 0 ? r : {}).filter((f) => t.experimental.includes(f) && e.experimental[f]);
  }
  function u(e) {
    if (s.JEST_WORKER_ID === void 0 && n(e).length > 0) {
      let r = n(e).map((f) => b.default.yellow(f)).join(", ");
      A.default.warn("experimental-flags-enabled", [`You have enabled experimental features: ${r}`, "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."]);
    }
  }
  const c = t;
})(is);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "normalizeConfig", { enumerable: true, get: function() {
    return R;
  } });
  const s = is, o = A(xr);
  function b(P) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
    return (b = function(n) {
      return n ? l : t;
    })(P);
  }
  function A(P, t) {
    if (P && P.__esModule) return P;
    if (P === null || typeof P != "object" && typeof P != "function") return { default: P };
    var l = b(t);
    if (l && l.has(P)) return l.get(P);
    var n = {}, u = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var c in P) if (c !== "default" && Object.prototype.hasOwnProperty.call(P, c)) {
      var e = u ? Object.getOwnPropertyDescriptor(P, c) : null;
      e && (e.get || e.set) ? Object.defineProperty(n, c, e) : n[c] = P[c];
    }
    return n.default = P, l && l.set(P, n), n;
  }
  function R(P) {
    if ((() => {
      if (P.purge || !P.content || !Array.isArray(P.content) && !(typeof P.content == "object" && P.content !== null)) return false;
      if (Array.isArray(P.content)) return P.content.every((n) => typeof n == "string" ? true : !(typeof (n == null ? void 0 : n.raw) != "string" || (n == null ? void 0 : n.extension) && typeof (n == null ? void 0 : n.extension) != "string"));
      if (typeof P.content == "object" && P.content !== null) {
        if (Object.keys(P.content).some((n) => !["files", "relative", "extract", "transform"].includes(n))) return false;
        if (Array.isArray(P.content.files)) {
          if (!P.content.files.every((n) => typeof n == "string" ? true : !(typeof (n == null ? void 0 : n.raw) != "string" || (n == null ? void 0 : n.extension) && typeof (n == null ? void 0 : n.extension) != "string"))) return false;
          if (typeof P.content.extract == "object") {
            for (let n of Object.values(P.content.extract)) if (typeof n != "function") return false;
          } else if (!(P.content.extract === void 0 || typeof P.content.extract == "function")) return false;
          if (typeof P.content.transform == "object") {
            for (let n of Object.values(P.content.transform)) if (typeof n != "function") return false;
          } else if (!(P.content.transform === void 0 || typeof P.content.transform == "function")) return false;
          if (typeof P.content.relative != "boolean" && typeof P.content.relative < "u") return false;
        }
        return true;
      }
      return false;
    })() || o.default.warn("purge-deprecation", ["The `purge`/`content` options have changed in Tailwind CSS v3.0.", "Update your configuration file to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"]), P.safelist = (() => {
      var n;
      let { content: u, purge: c, safelist: e } = P;
      return Array.isArray(e) ? e : Array.isArray(u == null ? void 0 : u.safelist) ? u.safelist : Array.isArray(c == null ? void 0 : c.safelist) ? c.safelist : Array.isArray(c == null || (n = c.options) === null || n === void 0 ? void 0 : n.safelist) ? c.options.safelist : [];
    })(), P.blocklist = (() => {
      let { blocklist: n } = P;
      if (Array.isArray(n)) {
        if (n.every((u) => typeof u == "string")) return n;
        o.default.warn("blocklist-invalid", ["The `blocklist` option must be an array of strings.", "https://tailwindcss.com/docs/content-configuration#discarding-classes"]);
      }
      return [];
    })(), typeof P.prefix == "function") o.default.warn("prefix-function", ["As of Tailwind CSS v3.0, `prefix` cannot be a function.", "Update `prefix` in your configuration to be a string to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"]), P.prefix = "";
    else {
      var l;
      P.prefix = (l = P.prefix) !== null && l !== void 0 ? l : "";
    }
    P.content = { relative: (() => {
      let { content: n } = P;
      return (n == null ? void 0 : n.relative) ? n.relative : (0, s.flagEnabled)(P, "relativeContentPathsByDefault");
    })(), files: (() => {
      let { content: n, purge: u } = P;
      return Array.isArray(u) ? u : Array.isArray(u == null ? void 0 : u.content) ? u.content : Array.isArray(n) ? n : Array.isArray(n == null ? void 0 : n.content) ? n.content : Array.isArray(n == null ? void 0 : n.files) ? n.files : [];
    })(), extract: (() => {
      let n = (() => {
        var e, r, f, y, S, T, d, p, h, m;
        return !((e = P.purge) === null || e === void 0) && e.extract ? P.purge.extract : !((r = P.content) === null || r === void 0) && r.extract ? P.content.extract : !((f = P.purge) === null || f === void 0 || (y = f.extract) === null || y === void 0) && y.DEFAULT ? P.purge.extract.DEFAULT : !((S = P.content) === null || S === void 0 || (T = S.extract) === null || T === void 0) && T.DEFAULT ? P.content.extract.DEFAULT : !((d = P.purge) === null || d === void 0 || (p = d.options) === null || p === void 0) && p.extractors ? P.purge.options.extractors : !((h = P.content) === null || h === void 0 || (m = h.options) === null || m === void 0) && m.extractors ? P.content.options.extractors : {};
      })(), u = {}, c = (() => {
        var e, r, f, y;
        if (!((e = P.purge) === null || e === void 0 || (r = e.options) === null || r === void 0) && r.defaultExtractor) return P.purge.options.defaultExtractor;
        if (!((f = P.content) === null || f === void 0 || (y = f.options) === null || y === void 0) && y.defaultExtractor) return P.content.options.defaultExtractor;
      })();
      if (c !== void 0 && (u.DEFAULT = c), typeof n == "function") u.DEFAULT = n;
      else if (Array.isArray(n)) for (let { extensions: e, extractor: r } of n ?? []) for (let f of e) u[f] = r;
      else typeof n == "object" && n !== null && Object.assign(u, n);
      return u;
    })(), transform: (() => {
      let n = (() => {
        var c, e, r, f, y, S;
        return !((c = P.purge) === null || c === void 0) && c.transform ? P.purge.transform : !((e = P.content) === null || e === void 0) && e.transform ? P.content.transform : !((r = P.purge) === null || r === void 0 || (f = r.transform) === null || f === void 0) && f.DEFAULT ? P.purge.transform.DEFAULT : !((y = P.content) === null || y === void 0 || (S = y.transform) === null || S === void 0) && S.DEFAULT ? P.content.transform.DEFAULT : {};
      })(), u = {};
      return typeof n == "function" ? u.DEFAULT = n : typeof n == "object" && n !== null && Object.assign(u, n), u;
    })() };
    for (let n of P.content.files) if (typeof n == "string" && /{([^,]*?)}/g.test(n)) {
      o.default.warn("invalid-glob-braces", [`The glob pattern ${(0, o.dim)(n)} in your Tailwind CSS configuration is invalid.`, `Update it to ${(0, o.dim)(n.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`]);
      break;
    }
    return P;
  }
})(Sf);
var Xs = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  function s(o) {
    if (Object.prototype.toString.call(o) !== "[object Object]") return false;
    const b = Object.getPrototypeOf(o);
    return b === null || Object.getPrototypeOf(b) === null;
  }
})(Xs);
var _f = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "cloneDeep", { enumerable: true, get: function() {
    return s;
  } });
  function s(o) {
    return Array.isArray(o) ? o.map((b) => s(b)) : typeof o == "object" && o !== null ? Object.fromEntries(Object.entries(o).map(([b, A]) => [b, s(A)])) : o;
  }
})(_f);
var Pi = {}, Ga = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  function s(o) {
    return o.replace(/\\,/g, "\\2c ");
  }
})(Ga);
var xi = {}, Tu = {}, Tf = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  const s = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
})(Tf);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(f, y) {
    for (var S in y) Object.defineProperty(f, S, { enumerable: true, get: y[S] });
  }
  s(a3, { parseColor: function() {
    return e;
  }, formatColor: function() {
    return r;
  } });
  const o = b(Tf);
  function b(f) {
    return f && f.__esModule ? f : { default: f };
  }
  let A = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, R = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, P = /(?:\d+|\d*\.\d+)%?/, t = /(?:\s*,\s*|\s+)/, l = /\s*[,/]\s*/, n = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/, u = new RegExp(`^(rgba?)\\(\\s*(${P.source}|${n.source})(?:${t.source}(${P.source}|${n.source}))?(?:${t.source}(${P.source}|${n.source}))?(?:${l.source}(${P.source}|${n.source}))?\\s*\\)$`), c = new RegExp(`^(hsla?)\\(\\s*((?:${P.source})(?:deg|rad|grad|turn)?|${n.source})(?:${t.source}(${P.source}|${n.source}))?(?:${t.source}(${P.source}|${n.source}))?(?:${l.source}(${P.source}|${n.source}))?\\s*\\)$`);
  function e(f, { loose: y = false } = {}) {
    var S, T;
    if (typeof f != "string") return null;
    if (f = f.trim(), f === "transparent") return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
    if (f in o.default) return { mode: "rgb", color: o.default[f].map((E) => E.toString()) };
    let d = f.replace(R, (E, _, C, w, I) => ["#", _, _, C, C, w, w, I ? I + I : ""].join("")).match(A);
    if (d !== null) return { mode: "rgb", color: [parseInt(d[1], 16), parseInt(d[2], 16), parseInt(d[3], 16)].map((E) => E.toString()), alpha: d[4] ? (parseInt(d[4], 16) / 255).toString() : void 0 };
    var p;
    let h = (p = f.match(u)) !== null && p !== void 0 ? p : f.match(c);
    if (h === null) return null;
    let m = [h[2], h[3], h[4]].filter(Boolean).map((E) => E.toString());
    return m.length === 2 && m[0].startsWith("var(") ? { mode: h[1], color: [m[0]], alpha: m[1] } : !y && m.length !== 3 || m.length < 3 && !m.some((E) => /^var\(.*?\)$/.test(E)) ? null : { mode: h[1], color: m, alpha: (S = h[5]) === null || S === void 0 || (T = S.toString) === null || T === void 0 ? void 0 : T.call(S) };
  }
  function r({ mode: f, color: y, alpha: S }) {
    let T = S !== void 0;
    return f === "rgba" || f === "hsla" ? `${f}(${y.join(", ")}${T ? `, ${S}` : ""})` : `${f}(${y.join(" ")}${T ? ` / ${S}` : ""})`;
  }
})(Tu);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(R, P) {
    for (var t in P) Object.defineProperty(R, t, { enumerable: true, get: P[t] });
  }
  s(a3, { withAlphaValue: function() {
    return b;
  }, default: function() {
    return A;
  } });
  const o = Tu;
  function b(R, P, t) {
    if (typeof R == "function") return R({ opacityValue: P });
    let l = (0, o.parseColor)(R, { loose: true });
    return l === null ? t : (0, o.formatColor)({ ...l, alpha: P });
  }
  function A({ color: R, property: P, variable: t }) {
    let l = [].concat(P);
    if (typeof R == "function") return { [t]: "1", ...Object.fromEntries(l.map((u) => [u, R({ opacityVariable: t, opacityValue: `var(${t}, 1)` })])) };
    const n = (0, o.parseColor)(R);
    return n === null ? Object.fromEntries(l.map((u) => [u, R])) : n.alpha !== void 0 ? Object.fromEntries(l.map((u) => [u, R])) : { [t]: "1", ...Object.fromEntries(l.map((u) => [u, (0, o.formatColor)({ ...n, alpha: `var(${t}, 1)` })])) };
  }
})(xi);
var Ai = {}, wu = {}, Is = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "splitAtTopLevelOnly", { enumerable: true, get: function() {
    return s;
  } });
  function s(o, b) {
    let A = [], R = [], P = 0, t = false;
    for (let l = 0; l < o.length; l++) {
      let n = o[l];
      A.length === 0 && n === b[0] && !t && (b.length === 1 || o.slice(l, l + b.length) === b) && (R.push(o.slice(P, l)), P = l + b.length), t = t ? false : n === "\\", n === "(" || n === "[" || n === "{" ? A.push(n) : (n === ")" && A[A.length - 1] === "(" || n === "]" && A[A.length - 1] === "[" || n === "}" && A[A.length - 1] === "{") && A.pop();
    }
    return R.push(o.slice(P)), R;
  }
})(Is);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(l, n) {
    for (var u in n) Object.defineProperty(l, u, { enumerable: true, get: n[u] });
  }
  s(a3, { parseBoxShadowValue: function() {
    return P;
  }, formatBoxShadowValue: function() {
    return t;
  } });
  const o = Is;
  let b = /* @__PURE__ */ new Set(["inset", "inherit", "initial", "revert", "unset"]), A = /\ +(?![^(]*\))/g, R = /^-?(\d+|\.\d+)(.*?)$/g;
  function P(l) {
    return (0, o.splitAtTopLevelOnly)(l, ",").map((u) => {
      let c = u.trim(), e = { raw: c }, r = c.split(A), f = /* @__PURE__ */ new Set();
      for (let y of r) R.lastIndex = 0, !f.has("KEYWORD") && b.has(y) ? (e.keyword = y, f.add("KEYWORD")) : R.test(y) ? f.has("X") ? f.has("Y") ? f.has("BLUR") ? f.has("SPREAD") || (e.spread = y, f.add("SPREAD")) : (e.blur = y, f.add("BLUR")) : (e.y = y, f.add("Y")) : (e.x = y, f.add("X")) : e.color ? (e.unknown || (e.unknown = []), e.unknown.push(y)) : e.color = y;
      return e.valid = e.x !== void 0 && e.y !== void 0, e;
    });
  }
  function t(l) {
    return l.map((n) => n.valid ? [n.keyword, n.x, n.y, n.blur, n.spread, n.color].filter(Boolean).join(" ") : n.raw).join(", ");
  }
})(wu);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(W, X) {
    for (var H in X) Object.defineProperty(W, H, { enumerable: true, get: X[H] });
  }
  s(a3, { normalize: function() {
    return l;
  }, normalizeAttributeSelectors: function() {
    return n;
  }, url: function() {
    return c;
  }, number: function() {
    return e;
  }, percentage: function() {
    return r;
  }, length: function() {
    return S;
  }, lineWidth: function() {
    return d;
  }, shadow: function() {
    return p;
  }, color: function() {
    return h;
  }, image: function() {
    return m;
  }, gradient: function() {
    return _;
  }, position: function() {
    return w;
  }, familyName: function() {
    return I;
  }, genericName: function() {
    return j;
  }, absoluteSize: function() {
    return k;
  }, relativeSize: function() {
    return F;
  } });
  const o = Tu, b = wu, A = Is;
  let R = ["min", "max", "clamp", "calc"];
  function P(W) {
    return R.some((X) => new RegExp(`^${X}\\(.*\\)`).test(W));
  }
  const t = /* @__PURE__ */ new Set(["scroll-timeline-name", "timeline-scope", "view-timeline-name", "font-palette", "anchor-name", "anchor-scope", "position-anchor", "position-try-options", "scroll-timeline", "animation-timeline", "view-timeline", "position-try"]);
  function l(W, X = null, H = true) {
    let U = X && t.has(X.property);
    return W.startsWith("--") && !U ? `var(${W})` : W.includes("url(") ? W.split(/(url\(.*?\))/g).filter(Boolean).map((q) => /^url\(.*?\)$/.test(q) ? q : l(q, X, false)).join("") : (W = W.replace(/([^\\])_+/g, (q, ee) => ee + " ".repeat(q.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), H && (W = W.trim()), W = u(W), W);
  }
  function n(W) {
    return W.includes("=") && (W = W.replace(/(=.*)/g, (X, H) => {
      if (H[1] === "'" || H[1] === '"') return H;
      if (H.length > 2) {
        let U = H[H.length - 1];
        if (H[H.length - 2] === " " && (U === "i" || U === "I" || U === "s" || U === "S")) return `="${H.slice(1, -2)}" ${H[H.length - 1]}`;
      }
      return `="${H.slice(1)}"`;
    })), W;
  }
  function u(W) {
    let X = ["theme"], H = ["min-content", "max-content", "fit-content", "safe-area-inset-top", "safe-area-inset-right", "safe-area-inset-bottom", "safe-area-inset-left", "titlebar-area-x", "titlebar-area-y", "titlebar-area-width", "titlebar-area-height", "keyboard-inset-top", "keyboard-inset-right", "keyboard-inset-bottom", "keyboard-inset-left", "keyboard-inset-width", "keyboard-inset-height", "radial-gradient", "linear-gradient", "conic-gradient", "repeating-radial-gradient", "repeating-linear-gradient", "repeating-conic-gradient", "anchor-size"];
    return W.replace(/(calc|min|max|clamp)\(.+\)/g, (U) => {
      let q = "";
      function ee() {
        let re = q.trimEnd();
        return re[re.length - 1];
      }
      for (let re = 0; re < U.length; re++) {
        let Y = function(B) {
          return B.split("").every((z, M) => U[re + M] === z);
        }, Z = function(B) {
          let z = 1 / 0;
          for (let K of B) {
            let Q = U.indexOf(K, re);
            Q !== -1 && Q < z && (z = Q);
          }
          let M = U.slice(re, z);
          return re += M.length - 1, M;
        }, G = U[re];
        if (Y("var")) q += Z([")", ","]);
        else if (H.some((B) => Y(B))) {
          let B = H.find((z) => Y(z));
          q += B, re += B.length - 1;
        } else X.some((B) => Y(B)) ? q += Z([")"]) : Y("[") ? q += Z(["]"]) : ["+", "-", "*", "/"].includes(G) && !["(", "+", "-", "*", "/", ","].includes(ee()) ? q += ` ${G} ` : q += G;
      }
      return q.replace(/\s+/g, " ");
    });
  }
  function c(W) {
    return W.startsWith("url(");
  }
  function e(W) {
    return !isNaN(Number(W)) || P(W);
  }
  function r(W) {
    return W.endsWith("%") && e(W.slice(0, -1)) || P(W);
  }
  let y = `(?:${["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"].join("|")})`;
  function S(W) {
    return W === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${y}$`).test(W) || P(W);
  }
  let T = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
  function d(W) {
    return T.has(W);
  }
  function p(W) {
    let X = (0, b.parseBoxShadowValue)(l(W));
    for (let H of X) if (!H.valid) return false;
    return true;
  }
  function h(W) {
    let X = 0;
    return (0, A.splitAtTopLevelOnly)(W, "_").every((U) => (U = l(U), U.startsWith("var(") ? true : (0, o.parseColor)(U, { loose: true }) !== null ? (X++, true) : false)) ? X > 0 : false;
  }
  function m(W) {
    let X = 0;
    return (0, A.splitAtTopLevelOnly)(W, ",").every((U) => (U = l(U), U.startsWith("var(") ? true : c(U) || _(U) || ["element(", "image(", "cross-fade(", "image-set("].some((q) => U.startsWith(q)) ? (X++, true) : false)) ? X > 0 : false;
  }
  let E = /* @__PURE__ */ new Set(["conic-gradient", "linear-gradient", "radial-gradient", "repeating-conic-gradient", "repeating-linear-gradient", "repeating-radial-gradient"]);
  function _(W) {
    W = l(W);
    for (let X of E) if (W.startsWith(`${X}(`)) return true;
    return false;
  }
  let C = /* @__PURE__ */ new Set(["center", "top", "right", "bottom", "left"]);
  function w(W) {
    let X = 0;
    return (0, A.splitAtTopLevelOnly)(W, "_").every((U) => (U = l(U), U.startsWith("var(") ? true : C.has(U) || S(U) || r(U) ? (X++, true) : false)) ? X > 0 : false;
  }
  function I(W) {
    let X = 0;
    return (0, A.splitAtTopLevelOnly)(W, ",").every((U) => (U = l(U), U.startsWith("var(") ? true : U.includes(" ") && !/(['"])([^"']+)\1/g.test(U) || /^\d/g.test(U) ? false : (X++, true))) ? X > 0 : false;
  }
  let D = /* @__PURE__ */ new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);
  function j(W) {
    return D.has(W);
  }
  let L = /* @__PURE__ */ new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"]);
  function k(W) {
    return L.has(W);
  }
  let N = /* @__PURE__ */ new Set(["larger", "smaller"]);
  function F(W) {
    return N.has(W);
  }
})(Ai);
var wf = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "backgroundSize", { enumerable: true, get: function() {
    return b;
  } });
  const s = Ai, o = Is;
  function b(A) {
    let R = ["cover", "contain"];
    return (0, o.splitAtTopLevelOnly)(A, ",").every((P) => {
      let t = (0, o.splitAtTopLevelOnly)(P, "_").filter(Boolean);
      return t.length === 1 && R.includes(t[0]) ? true : t.length !== 1 && t.length !== 2 ? false : t.every((l) => (0, s.length)(l) || (0, s.percentage)(l) || l === "auto");
    });
  }
})(wf);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(w, I) {
    for (var D in I) Object.defineProperty(w, D, { enumerable: true, get: I[D] });
  }
  s(a3, { updateAllClasses: function() {
    return n;
  }, asValue: function() {
    return e;
  }, parseColorFormat: function() {
    return y;
  }, asColor: function() {
    return T;
  }, asLookupValue: function() {
    return d;
  }, typeMap: function() {
    return h;
  }, coerceValue: function() {
    return _;
  }, getMatchingTypes: function() {
    return C;
  } });
  const o = l(Ga), b = xi, A = Ai, R = l(Wa), P = wf, t = is;
  function l(w) {
    return w && w.__esModule ? w : { default: w };
  }
  function n(w, I) {
    w.walkClasses((D) => {
      D.value = I(D.value), D.raws && D.raws.value && (D.raws.value = (0, o.default)(D.raws.value));
    });
  }
  function u(w, I) {
    if (!r(w)) return;
    let D = w.slice(1, -1);
    if (I(D)) return (0, A.normalize)(D);
  }
  function c(w, I = {}, D) {
    let j = I[w];
    if (j !== void 0) return (0, R.default)(j);
    if (r(w)) {
      let L = u(w, D);
      return L === void 0 ? void 0 : (0, R.default)(L);
    }
  }
  function e(w, I = {}, { validate: D = () => true } = {}) {
    var j;
    let L = (j = I.values) === null || j === void 0 ? void 0 : j[w];
    return L !== void 0 ? L : I.supportsNegativeValues && w.startsWith("-") ? c(w.slice(1), I.values, D) : u(w, D);
  }
  function r(w) {
    return w.startsWith("[") && w.endsWith("]");
  }
  function f(w) {
    let I = w.lastIndexOf("/"), D = w.lastIndexOf("[", I), j = w.indexOf("]", I);
    return w[I - 1] === "]" || w[I + 1] === "[" || D !== -1 && j !== -1 && D < I && I < j && (I = w.lastIndexOf("/", D)), I === -1 || I === w.length - 1 ? [w, void 0] : r(w) && !w.includes("]/[") ? [w, void 0] : [w.slice(0, I), w.slice(I + 1)];
  }
  function y(w) {
    if (typeof w == "string" && w.includes("<alpha-value>")) {
      let I = w;
      return ({ opacityValue: D = 1 }) => I.replace(/<alpha-value>/g, D);
    }
    return w;
  }
  function S(w) {
    return (0, A.normalize)(w.slice(1, -1));
  }
  function T(w, I = {}, { tailwindConfig: D = {} } = {}) {
    var j;
    if (((j = I.values) === null || j === void 0 ? void 0 : j[w]) !== void 0) {
      var L;
      return y((L = I.values) === null || L === void 0 ? void 0 : L[w]);
    }
    let [k, N] = f(w);
    if (N !== void 0) {
      var F, W, X, H;
      let U = (H = (F = I.values) === null || F === void 0 ? void 0 : F[k]) !== null && H !== void 0 ? H : r(k) ? k.slice(1, -1) : void 0;
      return U === void 0 ? void 0 : (U = y(U), r(N) ? (0, b.withAlphaValue)(U, S(N)) : ((W = D.theme) === null || W === void 0 || (X = W.opacity) === null || X === void 0 ? void 0 : X[N]) === void 0 ? void 0 : (0, b.withAlphaValue)(U, D.theme.opacity[N]));
    }
    return e(w, I, { validate: A.color });
  }
  function d(w, I = {}) {
    var D;
    return (D = I.values) === null || D === void 0 ? void 0 : D[w];
  }
  function p(w) {
    return (I, D) => e(I, D, { validate: w });
  }
  let h = { any: e, color: T, url: p(A.url), image: p(A.image), length: p(A.length), percentage: p(A.percentage), position: p(A.position), lookup: d, "generic-name": p(A.genericName), "family-name": p(A.familyName), number: p(A.number), "line-width": p(A.lineWidth), "absolute-size": p(A.absoluteSize), "relative-size": p(A.relativeSize), shadow: p(A.shadow), size: p(P.backgroundSize) }, m = Object.keys(h);
  function E(w, I) {
    let D = w.indexOf(I);
    return D === -1 ? [void 0, w] : [w.slice(0, D), w.slice(D + 1)];
  }
  function _(w, I, D, j) {
    if (D.values && I in D.values) for (let { type: k } of w ?? []) {
      let N = h[k](I, D, { tailwindConfig: j });
      if (N !== void 0) return [N, k, null];
    }
    if (r(I)) {
      let k = I.slice(1, -1), [N, F] = E(k, ":");
      if (!/^[\w-_]+$/g.test(N)) F = k;
      else if (N !== void 0 && !m.includes(N)) return [];
      if (F.length > 0 && m.includes(N)) return [e(`[${F}]`, D), N, null];
    }
    let L = C(w, I, D, j);
    for (let k of L) return k;
    return [];
  }
  function* C(w, I, D, j) {
    let L = (0, t.flagEnabled)(j, "generalizedModifiers"), [k, N] = f(I);
    if (L && D.modifiers != null && (D.modifiers === "any" || typeof D.modifiers == "object" && (N && r(N) || N in D.modifiers)) || (k = I, N = void 0), N !== void 0 && k === "" && (k = "DEFAULT"), N !== void 0 && typeof D.modifiers == "object") {
      var W, X;
      let H = (X = (W = D.modifiers) === null || W === void 0 ? void 0 : W[N]) !== null && X !== void 0 ? X : null;
      H !== null ? N = H : r(N) && (N = S(N));
    }
    for (let { type: H } of w ?? []) {
      let U = h[H](k, D, { tailwindConfig: j });
      U !== void 0 && (yield [U, H, N ?? null]);
    }
  }
})(Pi);
var Pu = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  function s(o) {
    return typeof o == "function" ? o({}) : o;
  }
})(Pu);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return D;
  } });
  const s = r(Wa), o = r(yf), b = r(bf), A = r(gf), R = Ef, P = Ha, t = Sf, l = r(Xs), n = _f, u = Pi, c = xi, e = r(Pu);
  function r(j) {
    return j && j.__esModule ? j : { default: j };
  }
  function f(j) {
    return typeof j == "function";
  }
  function y(j, ...L) {
    let k = L.pop();
    for (let N of L) for (let F in N) {
      let W = k(j[F], N[F]);
      W === void 0 ? (0, l.default)(j[F]) && (0, l.default)(N[F]) ? j[F] = y({}, j[F], N[F], k) : j[F] = N[F] : j[F] = W;
    }
    return j;
  }
  const S = { colors: A.default, negative(j) {
    return Object.keys(j).filter((L) => j[L] !== "0").reduce((L, k) => {
      let N = (0, s.default)(j[k]);
      return N !== void 0 && (L[`-${k}`] = N), L;
    }, {});
  }, breakpoints(j) {
    return Object.keys(j).filter((L) => typeof j[L] == "string").reduce((L, k) => ({ ...L, [`screen-${k}`]: j[k] }), {});
  } };
  function T(j, ...L) {
    return f(j) ? j(...L) : j;
  }
  function d(j) {
    return j.reduce((L, { extend: k }) => y(L, k, (N, F) => N === void 0 ? [F] : Array.isArray(N) ? [F, ...N] : [F, N]), {});
  }
  function p(j) {
    return { ...j.reduce((L, k) => (0, R.defaults)(L, k), {}), extend: d(j) };
  }
  function h(j, L) {
    if (Array.isArray(j) && (0, l.default)(j[0])) return j.concat(L);
    if (Array.isArray(L) && (0, l.default)(L[0]) && (0, l.default)(j)) return [j, ...L];
    if (Array.isArray(L)) return L;
  }
  function m({ extend: j, ...L }) {
    return y(L, j, (k, N) => !f(k) && !N.some(f) ? y({}, k, ...N, h) : (F, W) => y({}, ...[k, ...N].map((X) => T(X, F, W)), h));
  }
  function* E(j) {
    let L = (0, P.toPath)(j);
    if (L.length === 0 || (yield L, Array.isArray(j))) return;
    let k = /^(.*?)\s*\/\s*([^/]+)$/, N = j.match(k);
    if (N !== null) {
      let [, F, W] = N, X = (0, P.toPath)(F);
      X.alpha = W, yield X;
    }
  }
  function _(j) {
    const L = (k, N) => {
      for (const F of E(k)) {
        let W = 0, X = j;
        for (; X != null && W < F.length; ) X = X[F[W++]], X = f(X) && (F.alpha === void 0 || W <= F.length - 1) ? X(L, S) : X;
        if (X !== void 0) {
          if (F.alpha !== void 0) {
            let H = (0, u.parseColorFormat)(X);
            return (0, c.withAlphaValue)(H, F.alpha, (0, e.default)(H));
          }
          return (0, l.default)(X) ? (0, n.cloneDeep)(X) : X;
        }
      }
      return N;
    };
    return Object.assign(L, { theme: L, ...S }), Object.keys(j).reduce((k, N) => (k[N] = f(j[N]) ? j[N](L, S) : j[N], k), {});
  }
  function C(j) {
    let L = [];
    return j.forEach((k) => {
      L = [...L, k];
      var N;
      const F = (N = k == null ? void 0 : k.plugins) !== null && N !== void 0 ? N : [];
      F.length !== 0 && F.forEach((W) => {
        W.__isOptionsFunction && (W = W());
        var X;
        L = [...L, ...C([(X = W == null ? void 0 : W.config) !== null && X !== void 0 ? X : {}])];
      });
    }), L;
  }
  function w(j) {
    return [...j].reduceRight((k, N) => f(N) ? N({ corePlugins: k }) : (0, b.default)(N, k), o.default);
  }
  function I(j) {
    return [...j].reduceRight((k, N) => [...k, ...N], []);
  }
  function D(j) {
    let L = [...C(j), { prefix: "", important: false, separator: ":" }];
    var k, N;
    return (0, t.normalizeConfig)((0, R.defaults)({ theme: _(m(p(L.map((F) => (k = F == null ? void 0 : F.theme) !== null && k !== void 0 ? k : {})))), corePlugins: w(L.map((F) => F.corePlugins)), plugins: I(j.map((F) => (N = F == null ? void 0 : F.plugins) !== null && N !== void 0 ? N : [])) }, ...L));
  }
})(mf);
var Pf = {}, dg = { content: [], presets: [], darkMode: "media", theme: { accentColor: ({ theme: a3 }) => ({ ...a3("colors"), auto: "auto" }), animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite", pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", bounce: "bounce 1s infinite" }, aria: { busy: 'busy="true"', checked: 'checked="true"', disabled: 'disabled="true"', expanded: 'expanded="true"', hidden: 'hidden="true"', pressed: 'pressed="true"', readonly: 'readonly="true"', required: 'required="true"', selected: 'selected="true"' }, aspectRatio: { auto: "auto", square: "1 / 1", video: "16 / 9" }, backdropBlur: ({ theme: a3 }) => a3("blur"), backdropBrightness: ({ theme: a3 }) => a3("brightness"), backdropContrast: ({ theme: a3 }) => a3("contrast"), backdropGrayscale: ({ theme: a3 }) => a3("grayscale"), backdropHueRotate: ({ theme: a3 }) => a3("hueRotate"), backdropInvert: ({ theme: a3 }) => a3("invert"), backdropOpacity: ({ theme: a3 }) => a3("opacity"), backdropSaturate: ({ theme: a3 }) => a3("saturate"), backdropSepia: ({ theme: a3 }) => a3("sepia"), backgroundColor: ({ theme: a3 }) => a3("colors"), backgroundImage: { none: "none", "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))", "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))", "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))", "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))", "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))", "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))", "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))", "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))" }, backgroundOpacity: ({ theme: a3 }) => a3("opacity"), backgroundPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { 0: "0", none: "", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, borderColor: ({ theme: a3 }) => ({ ...a3("colors"), DEFAULT: a3("colors.gray.200", "currentColor") }), borderOpacity: ({ theme: a3 }) => a3("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", full: "9999px" }, borderSpacing: ({ theme: a3 }) => ({ ...a3("spacing") }), borderWidth: { DEFAULT: "1px", 0: "0px", 2: "2px", 4: "4px", 8: "8px" }, boxShadow: { sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)", DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)", md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)", lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)", xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)", "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)", inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)", none: "none" }, boxShadowColor: ({ theme: a3 }) => a3("colors"), brightness: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", 200: "2" }, caretColor: ({ theme: a3 }) => a3("colors"), colors: ({ colors: a3 }) => ({ inherit: a3.inherit, current: a3.current, transparent: a3.transparent, black: a3.black, white: a3.white, slate: a3.slate, gray: a3.gray, zinc: a3.zinc, neutral: a3.neutral, stone: a3.stone, red: a3.red, orange: a3.orange, amber: a3.amber, yellow: a3.yellow, lime: a3.lime, green: a3.green, emerald: a3.emerald, teal: a3.teal, cyan: a3.cyan, sky: a3.sky, blue: a3.blue, indigo: a3.indigo, violet: a3.violet, purple: a3.purple, fuchsia: a3.fuchsia, pink: a3.pink, rose: a3.rose }), columns: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, container: {}, content: { none: "none" }, contrast: { 0: "0", 50: ".5", 75: ".75", 100: "1", 125: "1.25", 150: "1.5", 200: "2" }, cursor: { auto: "auto", default: "default", pointer: "pointer", wait: "wait", text: "text", move: "move", help: "help", "not-allowed": "not-allowed", none: "none", "context-menu": "context-menu", progress: "progress", cell: "cell", crosshair: "crosshair", "vertical-text": "vertical-text", alias: "alias", copy: "copy", "no-drop": "no-drop", grab: "grab", grabbing: "grabbing", "all-scroll": "all-scroll", "col-resize": "col-resize", "row-resize": "row-resize", "n-resize": "n-resize", "e-resize": "e-resize", "s-resize": "s-resize", "w-resize": "w-resize", "ne-resize": "ne-resize", "nw-resize": "nw-resize", "se-resize": "se-resize", "sw-resize": "sw-resize", "ew-resize": "ew-resize", "ns-resize": "ns-resize", "nesw-resize": "nesw-resize", "nwse-resize": "nwse-resize", "zoom-in": "zoom-in", "zoom-out": "zoom-out" }, divideColor: ({ theme: a3 }) => a3("borderColor"), divideOpacity: ({ theme: a3 }) => a3("borderOpacity"), divideWidth: ({ theme: a3 }) => a3("borderWidth"), dropShadow: { sm: "0 1px 1px rgb(0 0 0 / 0.05)", DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"], md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"], lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"], xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"], "2xl": "0 25px 25px rgb(0 0 0 / 0.15)", none: "0 0 #0000" }, fill: ({ theme: a3 }) => ({ none: "none", ...a3("colors") }), flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: a3 }) => ({ auto: "auto", ...a3("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%" }), flexGrow: { 0: "0", DEFAULT: "1" }, flexShrink: { 0: "0", DEFAULT: "1" }, fontFamily: { sans: ["ui-sans-serif", "system-ui", "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'], serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"], mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"] }, fontSize: { xs: ["0.75rem", { lineHeight: "1rem" }], sm: ["0.875rem", { lineHeight: "1.25rem" }], base: ["1rem", { lineHeight: "1.5rem" }], lg: ["1.125rem", { lineHeight: "1.75rem" }], xl: ["1.25rem", { lineHeight: "1.75rem" }], "2xl": ["1.5rem", { lineHeight: "2rem" }], "3xl": ["1.875rem", { lineHeight: "2.25rem" }], "4xl": ["2.25rem", { lineHeight: "2.5rem" }], "5xl": ["3rem", { lineHeight: "1" }], "6xl": ["3.75rem", { lineHeight: "1" }], "7xl": ["4.5rem", { lineHeight: "1" }], "8xl": ["6rem", { lineHeight: "1" }], "9xl": ["8rem", { lineHeight: "1" }] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: ({ theme: a3 }) => a3("spacing"), gradientColorStops: ({ theme: a3 }) => a3("colors"), gradientColorStopPositions: { "0%": "0%", "5%": "5%", "10%": "10%", "15%": "15%", "20%": "20%", "25%": "25%", "30%": "30%", "35%": "35%", "40%": "40%", "45%": "45%", "50%": "50%", "55%": "55%", "60%": "60%", "65%": "65%", "70%": "70%", "75%": "75%", "80%": "80%", "85%": "85%", "90%": "90%", "95%": "95%", "100%": "100%" }, grayscale: { 0: "0", DEFAULT: "100%" }, gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridColumn: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridColumnEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridColumnStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridRow: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridRowEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridRowStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridTemplateColumns: { none: "none", subgrid: "subgrid", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))" }, gridTemplateRows: { none: "none", subgrid: "subgrid", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))" }, height: ({ theme: a3 }) => ({ auto: "auto", ...a3("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", full: "100%", screen: "100vh", svh: "100svh", lvh: "100lvh", dvh: "100dvh", min: "min-content", max: "max-content", fit: "fit-content" }), hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, inset: ({ theme: a3 }) => ({ auto: "auto", ...a3("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), invert: { 0: "0", DEFAULT: "100%" }, keyframes: { spin: { to: { transform: "rotate(360deg)" } }, ping: { "75%, 100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2", 3: ".75rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem" }, listStyleType: { none: "none", disc: "disc", decimal: "decimal" }, listStyleImage: { none: "none" }, margin: ({ theme: a3 }) => ({ auto: "auto", ...a3("spacing") }), lineClamp: { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6" }, maxHeight: ({ theme: a3 }) => ({ ...a3("spacing"), none: "none", full: "100%", screen: "100vh", svh: "100svh", lvh: "100lvh", dvh: "100dvh", min: "min-content", max: "max-content", fit: "fit-content" }), maxWidth: ({ theme: a3, breakpoints: s }) => ({ ...a3("spacing"), none: "none", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch", ...s(a3("screens")) }), minHeight: ({ theme: a3 }) => ({ ...a3("spacing"), full: "100%", screen: "100vh", svh: "100svh", lvh: "100lvh", dvh: "100dvh", min: "min-content", max: "max-content", fit: "fit-content" }), minWidth: ({ theme: a3 }) => ({ ...a3("spacing"), full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }), objectPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, opacity: { 0: "0", 5: "0.05", 10: "0.1", 15: "0.15", 20: "0.2", 25: "0.25", 30: "0.3", 35: "0.35", 40: "0.4", 45: "0.45", 50: "0.5", 55: "0.55", 60: "0.6", 65: "0.65", 70: "0.7", 75: "0.75", 80: "0.8", 85: "0.85", 90: "0.9", 95: "0.95", 100: "1" }, order: { first: "-9999", last: "9999", none: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12" }, outlineColor: ({ theme: a3 }) => a3("colors"), outlineOffset: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, outlineWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, padding: ({ theme: a3 }) => a3("spacing"), placeholderColor: ({ theme: a3 }) => a3("colors"), placeholderOpacity: ({ theme: a3 }) => a3("opacity"), ringColor: ({ theme: a3 }) => ({ DEFAULT: a3("colors.blue.500", "#3b82f6"), ...a3("colors") }), ringOffsetColor: ({ theme: a3 }) => a3("colors"), ringOffsetWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringOpacity: ({ theme: a3 }) => ({ DEFAULT: "0.5", ...a3("opacity") }), ringWidth: { DEFAULT: "3px", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, rotate: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", 45: "45deg", 90: "90deg", 180: "180deg" }, saturate: { 0: "0", 50: ".5", 100: "1", 150: "1.5", 200: "2" }, scale: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5" }, screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, scrollMargin: ({ theme: a3 }) => ({ ...a3("spacing") }), scrollPadding: ({ theme: a3 }) => a3("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg" }, space: ({ theme: a3 }) => ({ ...a3("spacing") }), spacing: { px: "1px", 0: "0px", 0.5: "0.125rem", 1: "0.25rem", 1.5: "0.375rem", 2: "0.5rem", 2.5: "0.625rem", 3: "0.75rem", 3.5: "0.875rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem", 11: "2.75rem", 12: "3rem", 14: "3.5rem", 16: "4rem", 20: "5rem", 24: "6rem", 28: "7rem", 32: "8rem", 36: "9rem", 40: "10rem", 44: "11rem", 48: "12rem", 52: "13rem", 56: "14rem", 60: "15rem", 64: "16rem", 72: "18rem", 80: "20rem", 96: "24rem" }, stroke: ({ theme: a3 }) => ({ none: "none", ...a3("colors") }), strokeWidth: { 0: "0", 1: "1", 2: "2" }, supports: {}, data: {}, textColor: ({ theme: a3 }) => a3("colors"), textDecorationColor: ({ theme: a3 }) => a3("colors"), textDecorationThickness: { auto: "auto", "from-font": "from-font", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textIndent: ({ theme: a3 }) => ({ ...a3("spacing") }), textOpacity: ({ theme: a3 }) => a3("opacity"), textUnderlineOffset: { auto: "auto", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, transformOrigin: { center: "center", top: "top", "top-right": "top right", right: "right", "bottom-right": "bottom right", bottom: "bottom", "bottom-left": "bottom left", left: "left", "top-left": "top left" }, transitionDelay: { 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionDuration: { DEFAULT: "150ms", 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionProperty: { none: "none", all: "all", DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter", colors: "color, background-color, border-color, text-decoration-color, fill, stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)", linear: "linear", in: "cubic-bezier(0.4, 0, 1, 1)", out: "cubic-bezier(0, 0, 0.2, 1)", "in-out": "cubic-bezier(0.4, 0, 0.2, 1)" }, translate: ({ theme: a3 }) => ({ ...a3("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), size: ({ theme: a3 }) => ({ auto: "auto", ...a3("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }), width: ({ theme: a3 }) => ({ auto: "auto", ...a3("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", screen: "100vw", svw: "100svw", lvw: "100lvw", dvw: "100dvw", min: "min-content", max: "max-content", fit: "fit-content" }), willChange: { auto: "auto", scroll: "scroll-position", contents: "contents", transform: "transform" }, zIndex: { auto: "auto", 0: "0", 10: "10", 20: "20", 30: "30", 40: "40", 50: "50" } }, plugins: [] };
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return A;
  } });
  const s = b(dg), o = is;
  function b(R) {
    return R && R.__esModule ? R : { default: R };
  }
  function A(R) {
    var P;
    const t = ((P = R == null ? void 0 : R.presets) !== null && P !== void 0 ? P : [s.default]).slice().reverse().flatMap((u) => A(u instanceof Function ? u() : u)), l = { respectDefaultRingColorOpacity: { theme: { ringColor: ({ theme: u }) => ({ DEFAULT: "#3b82f67f", ...u("colors") }) } }, disableColorOpacityUtilitiesByDefault: { corePlugins: { backgroundOpacity: false, borderOpacity: false, divideOpacity: false, placeholderOpacity: false, ringOpacity: false, textOpacity: false } } }, n = Object.keys(l).filter((u) => (0, o.flagEnabled)(R, u)).map((u) => l[u]);
    return [R, ...n, ...t];
  }
})(Pf);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return A;
  } });
  const s = b(mf), o = b(Pf);
  function b(R) {
    return R && R.__esModule ? R : { default: R };
  }
  function A(...R) {
    let [, ...P] = (0, o.default)(R[0]);
    return (0, s.default)([...R, ...P]);
  }
})(hf);
var xf = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(c, e) {
    for (var r in e) Object.defineProperty(c, r, { enumerable: true, get: e[r] });
  }
  s(a3, { default: function() {
    return n;
  }, resolveDefaultConfigPath: function() {
    return u;
  } });
  const o = A(gt), b = A(gt);
  function A(c) {
    return c && c.__esModule ? c : { default: c };
  }
  const R = ["./tailwind.config.js", "./tailwind.config.cjs", "./tailwind.config.mjs", "./tailwind.config.ts", "./tailwind.config.cts", "./tailwind.config.mts"];
  function P(c) {
    return typeof c == "object" && c !== null;
  }
  function t(c) {
    return Object.keys(c).length === 0;
  }
  function l(c) {
    return typeof c == "string" || c instanceof String;
  }
  function n(c) {
    return P(c) && c.config === void 0 && !t(c) ? null : P(c) && c.config !== void 0 && l(c.config) ? b.default.resolve(c.config) : P(c) && c.config !== void 0 && P(c.config) ? null : l(c) ? b.default.resolve(c) : u();
  }
  function u() {
    for (const c of R) try {
      const e = b.default.resolve(c);
      return o.default.accessSync(e), e;
    } catch {
    }
    return null;
  }
})(xf);
var Io = {};
let Cp = _u, Ip = gt, pl = class Af extends Error {
  constructor(s, o, b, A, R, P) {
    super(s), this.name = "CssSyntaxError", this.reason = s, R && (this.file = R), A && (this.source = A), P && (this.plugin = P), typeof o < "u" && typeof b < "u" && (typeof o == "number" ? (this.line = o, this.column = b) : (this.line = o.line, this.column = o.column, this.endLine = b.line, this.endColumn = b.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, Af);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(s) {
    if (!this.source) return "";
    let o = this.source;
    s == null && (s = Cp.isColorSupported);
    let b = (u) => u, A = (u) => u, R = (u) => u;
    if (s) {
      let { bold: u, gray: c, red: e } = Cp.createColors(true);
      A = (r) => u(e(r)), b = (r) => c(r), Ip && (R = (r) => Ip(r));
    }
    let P = o.split(/\r?\n/), t = Math.max(this.line - 3, 0), l = Math.min(this.line + 2, P.length), n = String(l).length;
    return P.slice(t, l).map((u, c) => {
      let e = t + 1 + c, r = " " + (" " + e).slice(-n) + " | ";
      if (e === this.line) {
        if (u.length > 160) {
          let y = 20, S = Math.max(0, this.column - y), T = Math.max(this.column + y, this.endColumn + y), d = u.slice(S, T), p = b(r.replace(/\d/g, " ")) + u.slice(0, Math.min(this.column - 1, y - 1)).replace(/[^\t]/g, " ");
          return A(">") + b(r) + R(d) + `
 ` + p + A("^");
        }
        let f = b(r.replace(/\d/g, " ")) + u.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return A(">") + b(r) + R(u) + `
 ` + f + A("^");
      }
      return " " + b(r) + R(u);
    }).join(`
`);
  }
  toString() {
    let s = this.showSourceCode();
    return s && (s = `

` + s + `
`), this.name + ": " + this.message + s;
  }
};
var xu = pl;
pl.default = pl;
const kp = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
function fg(a3) {
  return a3[0].toUpperCase() + a3.slice(1);
}
let dl = class {
  constructor(s) {
    this.builder = s;
  }
  atrule(s, o) {
    let b = "@" + s.name, A = s.params ? this.rawValue(s, "params") : "";
    if (typeof s.raws.afterName < "u" ? b += s.raws.afterName : A && (b += " "), s.nodes) this.block(s, b + A);
    else {
      let R = (s.raws.between || "") + (o ? ";" : "");
      this.builder(b + A + R, s);
    }
  }
  beforeAfter(s, o) {
    let b;
    s.type === "decl" ? b = this.raw(s, null, "beforeDecl") : s.type === "comment" ? b = this.raw(s, null, "beforeComment") : o === "before" ? b = this.raw(s, null, "beforeRule") : b = this.raw(s, null, "beforeClose");
    let A = s.parent, R = 0;
    for (; A && A.type !== "root"; ) R += 1, A = A.parent;
    if (b.includes(`
`)) {
      let P = this.raw(s, null, "indent");
      if (P.length) for (let t = 0; t < R; t++) b += P;
    }
    return b;
  }
  block(s, o) {
    let b = this.raw(s, "between", "beforeOpen");
    this.builder(o + b + "{", s, "start");
    let A;
    s.nodes && s.nodes.length ? (this.body(s), A = this.raw(s, "after")) : A = this.raw(s, "after", "emptyBody"), A && this.builder(A), this.builder("}", s, "end");
  }
  body(s) {
    let o = s.nodes.length - 1;
    for (; o > 0 && s.nodes[o].type === "comment"; ) o -= 1;
    let b = this.raw(s, "semicolon");
    for (let A = 0; A < s.nodes.length; A++) {
      let R = s.nodes[A], P = this.raw(R, "before");
      P && this.builder(P), this.stringify(R, o !== A || b);
    }
  }
  comment(s) {
    let o = this.raw(s, "left", "commentLeft"), b = this.raw(s, "right", "commentRight");
    this.builder("/*" + o + s.text + b + "*/", s);
  }
  decl(s, o) {
    let b = this.raw(s, "between", "colon"), A = s.prop + b + this.rawValue(s, "value");
    s.important && (A += s.raws.important || " !important"), o && (A += ";"), this.builder(A, s);
  }
  document(s) {
    this.body(s);
  }
  raw(s, o, b) {
    let A;
    if (b || (b = o), o && (A = s.raws[o], typeof A < "u")) return A;
    let R = s.parent;
    if (b === "before" && (!R || R.type === "root" && R.first === s || R && R.type === "document")) return "";
    if (!R) return kp[b];
    let P = s.root();
    if (P.rawCache || (P.rawCache = {}), typeof P.rawCache[b] < "u") return P.rawCache[b];
    if (b === "before" || b === "after") return this.beforeAfter(s, b);
    {
      let t = "raw" + fg(b);
      this[t] ? A = this[t](P, s) : P.walk((l) => {
        if (A = l.raws[o], typeof A < "u") return false;
      });
    }
    return typeof A > "u" && (A = kp[b]), P.rawCache[b] = A, A;
  }
  rawBeforeClose(s) {
    let o;
    return s.walk((b) => {
      if (b.nodes && b.nodes.length > 0 && typeof b.raws.after < "u") return o = b.raws.after, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), false;
    }), o && (o = o.replace(/\S/g, "")), o;
  }
  rawBeforeComment(s, o) {
    let b;
    return s.walkComments((A) => {
      if (typeof A.raws.before < "u") return b = A.raws.before, b.includes(`
`) && (b = b.replace(/[^\n]+$/, "")), false;
    }), typeof b > "u" ? b = this.raw(o, null, "beforeDecl") : b && (b = b.replace(/\S/g, "")), b;
  }
  rawBeforeDecl(s, o) {
    let b;
    return s.walkDecls((A) => {
      if (typeof A.raws.before < "u") return b = A.raws.before, b.includes(`
`) && (b = b.replace(/[^\n]+$/, "")), false;
    }), typeof b > "u" ? b = this.raw(o, null, "beforeRule") : b && (b = b.replace(/\S/g, "")), b;
  }
  rawBeforeOpen(s) {
    let o;
    return s.walk((b) => {
      if (b.type !== "decl" && (o = b.raws.between, typeof o < "u")) return false;
    }), o;
  }
  rawBeforeRule(s) {
    let o;
    return s.walk((b) => {
      if (b.nodes && (b.parent !== s || s.first !== b) && typeof b.raws.before < "u") return o = b.raws.before, o.includes(`
`) && (o = o.replace(/[^\n]+$/, "")), false;
    }), o && (o = o.replace(/\S/g, "")), o;
  }
  rawColon(s) {
    let o;
    return s.walkDecls((b) => {
      if (typeof b.raws.between < "u") return o = b.raws.between.replace(/[^\s:]/g, ""), false;
    }), o;
  }
  rawEmptyBody(s) {
    let o;
    return s.walk((b) => {
      if (b.nodes && b.nodes.length === 0 && (o = b.raws.after, typeof o < "u")) return false;
    }), o;
  }
  rawIndent(s) {
    if (s.raws.indent) return s.raws.indent;
    let o;
    return s.walk((b) => {
      let A = b.parent;
      if (A && A !== s && A.parent && A.parent === s && typeof b.raws.before < "u") {
        let R = b.raws.before.split(`
`);
        return o = R[R.length - 1], o = o.replace(/\S/g, ""), false;
      }
    }), o;
  }
  rawSemicolon(s) {
    let o;
    return s.walk((b) => {
      if (b.nodes && b.nodes.length && b.last.type === "decl" && (o = b.raws.semicolon, typeof o < "u")) return false;
    }), o;
  }
  rawValue(s, o) {
    let b = s[o], A = s.raws[o];
    return A && A.value === b ? A.raw : b;
  }
  root(s) {
    this.body(s), s.raws.after && this.builder(s.raws.after);
  }
  rule(s) {
    this.block(s, this.rawValue(s, "selector")), s.raws.ownSemicolon && this.builder(s.raws.ownSemicolon, s, "end");
  }
  stringify(s, o) {
    if (!this[s.type]) throw new Error("Unknown AST node type " + s.type + ". Maybe you need to change PostCSS stringifier.");
    this[s.type](s, o);
  }
};
var Cf = dl;
dl.default = dl;
let hg = Cf;
function fl(a3, s) {
  new hg(s).stringify(a3);
}
var za = fl;
fl.default = fl;
var Ci = {};
Ci.isClean = Symbol("isClean");
Ci.my = Symbol("my");
let mg = xu, yg = Cf, bg = za, { isClean: ri, my: gg } = Ci;
function hl(a3, s) {
  let o = new a3.constructor();
  for (let b in a3) {
    if (!Object.prototype.hasOwnProperty.call(a3, b) || b === "proxyCache") continue;
    let A = a3[b], R = typeof A;
    b === "parent" && R === "object" ? s && (o[b] = s) : b === "source" ? o[b] = A : Array.isArray(A) ? o[b] = A.map((P) => hl(P, o)) : (R === "object" && A !== null && (A = hl(A)), o[b] = A);
  }
  return o;
}
function ts(a3, s) {
  if (s && typeof s.offset < "u") return s.offset;
  let o = 1, b = 1, A = 0;
  for (let R = 0; R < a3.length; R++) {
    if (b === s.line && o === s.column) {
      A = R;
      break;
    }
    a3[R] === `
` ? (o = 1, b += 1) : o += 1;
  }
  return A;
}
let ml = class {
  get proxyOf() {
    return this;
  }
  constructor(s = {}) {
    this.raws = {}, this[ri] = false, this[gg] = true;
    for (let o in s) if (o === "nodes") {
      this.nodes = [];
      for (let b of s[o]) typeof b.clone == "function" ? this.append(b.clone()) : this.append(b);
    } else this[o] = s[o];
  }
  addToError(s) {
    if (s.postcssNode = this, s.stack && this.source && /\n\s{4}at /.test(s.stack)) {
      let o = this.source;
      s.stack = s.stack.replace(/\n\s{4}at /, `$&${o.input.from}:${o.start.line}:${o.start.column}$&`);
    }
    return s;
  }
  after(s) {
    return this.parent.insertAfter(this, s), this;
  }
  assign(s = {}) {
    for (let o in s) this[o] = s[o];
    return this;
  }
  before(s) {
    return this.parent.insertBefore(this, s), this;
  }
  cleanRaws(s) {
    delete this.raws.before, delete this.raws.after, s || delete this.raws.between;
  }
  clone(s = {}) {
    let o = hl(this);
    for (let b in s) o[b] = s[b];
    return o;
  }
  cloneAfter(s = {}) {
    let o = this.clone(s);
    return this.parent.insertAfter(this, o), o;
  }
  cloneBefore(s = {}) {
    let o = this.clone(s);
    return this.parent.insertBefore(this, o), o;
  }
  error(s, o = {}) {
    if (this.source) {
      let { end: b, start: A } = this.rangeBy(o);
      return this.source.input.error(s, { column: A.column, line: A.line }, { column: b.column, line: b.line }, o);
    }
    return new mg(s);
  }
  getProxyProcessor() {
    return { get(s, o) {
      return o === "proxyOf" ? s : o === "root" ? () => s.root().toProxy() : s[o];
    }, set(s, o, b) {
      return s[o] === b || (s[o] = b, (o === "prop" || o === "value" || o === "name" || o === "params" || o === "important" || o === "text") && s.markDirty()), true;
    } };
  }
  markClean() {
    this[ri] = true;
  }
  markDirty() {
    if (this[ri]) {
      this[ri] = false;
      let s = this;
      for (; s = s.parent; ) s[ri] = false;
    }
  }
  next() {
    if (!this.parent) return;
    let s = this.parent.index(this);
    return this.parent.nodes[s + 1];
  }
  positionBy(s = {}) {
    let o = this.source.start;
    if (s.index) o = this.positionInside(s.index);
    else if (s.word) {
      let b = "document" in this.source.input ? this.source.input.document : this.source.input.css, R = b.slice(ts(b, this.source.start), ts(b, this.source.end)).indexOf(s.word);
      R !== -1 && (o = this.positionInside(R));
    }
    return o;
  }
  positionInside(s) {
    let o = this.source.start.column, b = this.source.start.line, A = "document" in this.source.input ? this.source.input.document : this.source.input.css, R = ts(A, this.source.start), P = R + s;
    for (let t = R; t < P; t++) A[t] === `
` ? (o = 1, b += 1) : o += 1;
    return { column: o, line: b, offset: P };
  }
  prev() {
    if (!this.parent) return;
    let s = this.parent.index(this);
    return this.parent.nodes[s - 1];
  }
  rangeBy(s = {}) {
    let o = "document" in this.source.input ? this.source.input.document : this.source.input.css, b = { column: this.source.start.column, line: this.source.start.line, offset: ts(o, this.source.start) }, A = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line, offset: typeof this.source.end.offset == "number" ? this.source.end.offset : ts(o, this.source.end) + 1 } : { column: b.column + 1, line: b.line, offset: b.offset + 1 };
    if (s.word) {
      let P = o.slice(ts(o, this.source.start), ts(o, this.source.end)).indexOf(s.word);
      P !== -1 && (b = this.positionInside(P), A = this.positionInside(P + s.word.length));
    } else s.start ? b = { column: s.start.column, line: s.start.line, offset: ts(o, s.start) } : s.index && (b = this.positionInside(s.index)), s.end ? A = { column: s.end.column, line: s.end.line, offset: ts(o, s.end) } : typeof s.endIndex == "number" ? A = this.positionInside(s.endIndex) : s.index && (A = this.positionInside(s.index + 1));
    return (A.line < b.line || A.line === b.line && A.column <= b.column) && (A = { column: b.column + 1, line: b.line, offset: b.offset + 1 }), { end: A, start: b };
  }
  raw(s, o) {
    return new yg().raw(this, s, o);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  replaceWith(...s) {
    if (this.parent) {
      let o = this, b = false;
      for (let A of s) A === this ? b = true : b ? (this.parent.insertAfter(o, A), o = A) : this.parent.insertBefore(o, A);
      b || this.remove();
    }
    return this;
  }
  root() {
    let s = this;
    for (; s.parent && s.parent.type !== "document"; ) s = s.parent;
    return s;
  }
  toJSON(s, o) {
    let b = {}, A = o == null;
    o = o || /* @__PURE__ */ new Map();
    let R = 0;
    for (let P in this) {
      if (!Object.prototype.hasOwnProperty.call(this, P) || P === "parent" || P === "proxyCache") continue;
      let t = this[P];
      if (Array.isArray(t)) b[P] = t.map((l) => typeof l == "object" && l.toJSON ? l.toJSON(null, o) : l);
      else if (typeof t == "object" && t.toJSON) b[P] = t.toJSON(null, o);
      else if (P === "source") {
        if (t == null) continue;
        let l = o.get(t.input);
        l == null && (l = R, o.set(t.input, R), R++), b[P] = { end: t.end, inputId: l, start: t.start };
      } else b[P] = t;
    }
    return A && (b.inputs = [...o.keys()].map((P) => P.toJSON())), b;
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  toString(s = bg) {
    s.stringify && (s = s.stringify);
    let o = "";
    return s(this, (b) => {
      o += b;
    }), o;
  }
  warn(s, o, b = {}) {
    let A = { node: this };
    for (let R in b) A[R] = b[R];
    return s.warn(o, A);
  }
};
var Ka = ml;
ml.default = ml;
let vg = Ka, yl = class extends vg {
  constructor(s) {
    super(s), this.type = "comment";
  }
};
var qa = yl;
yl.default = yl;
let Eg = Ka, bl = class extends Eg {
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
  constructor(s) {
    s && typeof s.value < "u" && typeof s.value != "string" && (s = { ...s, value: String(s.value) }), super(s), this.type = "decl";
  }
};
var Ya = bl;
bl.default = bl;
let If = qa, kf = Ya, Sg = Ka, { isClean: Of, my: Df } = Ci, Au, Nf, Rf, Cu;
function jf(a3) {
  return a3.map((s) => (s.nodes && (s.nodes = jf(s.nodes)), delete s.source, s));
}
function Lf(a3) {
  if (a3[Of] = false, a3.proxyOf.nodes) for (let s of a3.proxyOf.nodes) Lf(s);
}
let rs = class Ff extends Sg {
  get first() {
    if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
  append(...s) {
    for (let o of s) {
      let b = this.normalize(o, this.last);
      for (let A of b) this.proxyOf.nodes.push(A);
    }
    return this.markDirty(), this;
  }
  cleanRaws(s) {
    if (super.cleanRaws(s), this.nodes) for (let o of this.nodes) o.cleanRaws(s);
  }
  each(s) {
    if (!this.proxyOf.nodes) return;
    let o = this.getIterator(), b, A;
    for (; this.indexes[o] < this.proxyOf.nodes.length && (b = this.indexes[o], A = s(this.proxyOf.nodes[b], b), A !== false); ) this.indexes[o] += 1;
    return delete this.indexes[o], A;
  }
  every(s) {
    return this.nodes.every(s);
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let s = this.lastEach;
    return this.indexes[s] = 0, s;
  }
  getProxyProcessor() {
    return { get(s, o) {
      return o === "proxyOf" ? s : s[o] ? o === "each" || typeof o == "string" && o.startsWith("walk") ? (...b) => s[o](...b.map((A) => typeof A == "function" ? (R, P) => A(R.toProxy(), P) : A)) : o === "every" || o === "some" ? (b) => s[o]((A, ...R) => b(A.toProxy(), ...R)) : o === "root" ? () => s.root().toProxy() : o === "nodes" ? s.nodes.map((b) => b.toProxy()) : o === "first" || o === "last" ? s[o].toProxy() : s[o] : s[o];
    }, set(s, o, b) {
      return s[o] === b || (s[o] = b, (o === "name" || o === "params" || o === "selector") && s.markDirty()), true;
    } };
  }
  index(s) {
    return typeof s == "number" ? s : (s.proxyOf && (s = s.proxyOf), this.proxyOf.nodes.indexOf(s));
  }
  insertAfter(s, o) {
    let b = this.index(s), A = this.normalize(o, this.proxyOf.nodes[b]).reverse();
    b = this.index(s);
    for (let P of A) this.proxyOf.nodes.splice(b + 1, 0, P);
    let R;
    for (let P in this.indexes) R = this.indexes[P], b < R && (this.indexes[P] = R + A.length);
    return this.markDirty(), this;
  }
  insertBefore(s, o) {
    let b = this.index(s), A = b === 0 ? "prepend" : false, R = this.normalize(o, this.proxyOf.nodes[b], A).reverse();
    b = this.index(s);
    for (let t of R) this.proxyOf.nodes.splice(b, 0, t);
    let P;
    for (let t in this.indexes) P = this.indexes[t], b <= P && (this.indexes[t] = P + R.length);
    return this.markDirty(), this;
  }
  normalize(s, o) {
    if (typeof s == "string") s = jf(Nf(s).nodes);
    else if (typeof s > "u") s = [];
    else if (Array.isArray(s)) {
      s = s.slice(0);
      for (let A of s) A.parent && A.parent.removeChild(A, "ignore");
    } else if (s.type === "root" && this.type !== "document") {
      s = s.nodes.slice(0);
      for (let A of s) A.parent && A.parent.removeChild(A, "ignore");
    } else if (s.type) s = [s];
    else if (s.prop) {
      if (typeof s.value > "u") throw new Error("Value field is missed in node creation");
      typeof s.value != "string" && (s.value = String(s.value)), s = [new kf(s)];
    } else if (s.selector || s.selectors) s = [new Cu(s)];
    else if (s.name) s = [new Au(s)];
    else if (s.text) s = [new If(s)];
    else throw new Error("Unknown node type in node creation");
    return s.map((A) => (A[Df] || Ff.rebuild(A), A = A.proxyOf, A.parent && A.parent.removeChild(A), A[Of] && Lf(A), A.raws || (A.raws = {}), typeof A.raws.before > "u" && o && typeof o.raws.before < "u" && (A.raws.before = o.raws.before.replace(/\S/g, "")), A.parent = this.proxyOf, A));
  }
  prepend(...s) {
    s = s.reverse();
    for (let o of s) {
      let b = this.normalize(o, this.first, "prepend").reverse();
      for (let A of b) this.proxyOf.nodes.unshift(A);
      for (let A in this.indexes) this.indexes[A] = this.indexes[A] + b.length;
    }
    return this.markDirty(), this;
  }
  push(s) {
    return s.parent = this, this.proxyOf.nodes.push(s), this;
  }
  removeAll() {
    for (let s of this.proxyOf.nodes) s.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  removeChild(s) {
    s = this.index(s), this.proxyOf.nodes[s].parent = void 0, this.proxyOf.nodes.splice(s, 1);
    let o;
    for (let b in this.indexes) o = this.indexes[b], o >= s && (this.indexes[b] = o - 1);
    return this.markDirty(), this;
  }
  replaceValues(s, o, b) {
    return b || (b = o, o = {}), this.walkDecls((A) => {
      o.props && !o.props.includes(A.prop) || o.fast && !A.value.includes(o.fast) || (A.value = A.value.replace(s, b));
    }), this.markDirty(), this;
  }
  some(s) {
    return this.nodes.some(s);
  }
  walk(s) {
    return this.each((o, b) => {
      let A;
      try {
        A = s(o, b);
      } catch (R) {
        throw o.addToError(R);
      }
      return A !== false && o.walk && (A = o.walk(s)), A;
    });
  }
  walkAtRules(s, o) {
    return o ? s instanceof RegExp ? this.walk((b, A) => {
      if (b.type === "atrule" && s.test(b.name)) return o(b, A);
    }) : this.walk((b, A) => {
      if (b.type === "atrule" && b.name === s) return o(b, A);
    }) : (o = s, this.walk((b, A) => {
      if (b.type === "atrule") return o(b, A);
    }));
  }
  walkComments(s) {
    return this.walk((o, b) => {
      if (o.type === "comment") return s(o, b);
    });
  }
  walkDecls(s, o) {
    return o ? s instanceof RegExp ? this.walk((b, A) => {
      if (b.type === "decl" && s.test(b.prop)) return o(b, A);
    }) : this.walk((b, A) => {
      if (b.type === "decl" && b.prop === s) return o(b, A);
    }) : (o = s, this.walk((b, A) => {
      if (b.type === "decl") return o(b, A);
    }));
  }
  walkRules(s, o) {
    return o ? s instanceof RegExp ? this.walk((b, A) => {
      if (b.type === "rule" && s.test(b.selector)) return o(b, A);
    }) : this.walk((b, A) => {
      if (b.type === "rule" && b.selector === s) return o(b, A);
    }) : (o = s, this.walk((b, A) => {
      if (b.type === "rule") return o(b, A);
    }));
  }
};
rs.registerParse = (a3) => {
  Nf = a3;
};
rs.registerRule = (a3) => {
  Cu = a3;
};
rs.registerAtRule = (a3) => {
  Au = a3;
};
rs.registerRoot = (a3) => {
  Rf = a3;
};
var ks = rs;
rs.default = rs;
rs.rebuild = (a3) => {
  a3.type === "atrule" ? Object.setPrototypeOf(a3, Au.prototype) : a3.type === "rule" ? Object.setPrototypeOf(a3, Cu.prototype) : a3.type === "decl" ? Object.setPrototypeOf(a3, kf.prototype) : a3.type === "comment" ? Object.setPrototypeOf(a3, If.prototype) : a3.type === "root" && Object.setPrototypeOf(a3, Rf.prototype), a3[Df] = true, a3.nodes && a3.nodes.forEach((s) => {
    rs.rebuild(s);
  });
};
let Mf = ks, Ta = class extends Mf {
  constructor(s) {
    super(s), this.type = "atrule";
  }
  append(...s) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...s);
  }
  prepend(...s) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...s);
  }
};
var Iu = Ta;
Ta.default = Ta;
Mf.registerAtRule(Ta);
let _g = ks, Bf, $f, hi = class extends _g {
  constructor(s) {
    super({ type: "document", ...s }), this.nodes || (this.nodes = []);
  }
  toResult(s = {}) {
    return new Bf(new $f(), this, s).stringify();
  }
};
hi.registerLazyResult = (a3) => {
  Bf = a3;
};
hi.registerProcessor = (a3) => {
  $f = a3;
};
var ku = hi;
hi.default = hi;
let Tg = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", wg = (a3 = 21) => {
  let s = "", o = a3 | 0;
  for (; o--; ) s += Tg[Math.random() * 64 | 0];
  return s;
};
var Pg = { nanoid: wg };
let { existsSync: xg, readFileSync: Ag } = gt, { dirname: ko, join: Cg } = gt, { SourceMapConsumer: Op, SourceMapGenerator: Dp } = gt;
function Ig(a3) {
  return Buffer ? Buffer.from(a3, "base64").toString() : window.atob(a3);
}
let gl = class {
  constructor(s, o) {
    if (o.map === false) return;
    this.loadAnnotation(s), this.inline = this.startWith(this.annotation, "data:");
    let b = o.map ? o.map.prev : void 0, A = this.loadMap(o.from, b);
    !this.mapFile && o.from && (this.mapFile = o.from), this.mapFile && (this.root = ko(this.mapFile)), A && (this.text = A);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new Op(this.text)), this.consumerCache;
  }
  decodeInline(s) {
    let o = /^data:application\/json;charset=utf-?8;base64,/, b = /^data:application\/json;base64,/, A = /^data:application\/json;charset=utf-?8,/, R = /^data:application\/json,/, P = s.match(A) || s.match(R);
    if (P) return decodeURIComponent(s.substr(P[0].length));
    let t = s.match(o) || s.match(b);
    if (t) return Ig(s.substr(t[0].length));
    let l = s.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + l);
  }
  getAnnotationURL(s) {
    return s.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  isMap(s) {
    return typeof s != "object" ? false : typeof s.mappings == "string" || typeof s._mappings == "string" || Array.isArray(s.sections);
  }
  loadAnnotation(s) {
    let o = s.match(/\/\*\s*# sourceMappingURL=/g);
    if (!o) return;
    let b = s.lastIndexOf(o.pop()), A = s.indexOf("*/", b);
    b > -1 && A > -1 && (this.annotation = this.getAnnotationURL(s.substring(b, A)));
  }
  loadFile(s) {
    if (this.root = ko(s), xg(s)) return this.mapFile = s, Ag(s, "utf-8").toString().trim();
  }
  loadMap(s, o) {
    if (o === false) return false;
    if (o) {
      if (typeof o == "string") return o;
      if (typeof o == "function") {
        let b = o(s);
        if (b) {
          let A = this.loadFile(b);
          if (!A) throw new Error("Unable to load previous source map: " + b.toString());
          return A;
        }
      } else {
        if (o instanceof Op) return Dp.fromSourceMap(o).toString();
        if (o instanceof Dp) return o.toString();
        if (this.isMap(o)) return JSON.stringify(o);
        throw new Error("Unsupported previous source map format: " + o.toString());
      }
    } else {
      if (this.inline) return this.decodeInline(this.annotation);
      if (this.annotation) {
        let b = this.annotation;
        return s && (b = Cg(ko(s), b)), this.loadFile(b);
      }
    }
  }
  startWith(s, o) {
    return s ? s.substr(0, o.length) === o : false;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
};
var Uf = gl;
gl.default = gl;
let { nanoid: kg } = Pg, { isAbsolute: vl, resolve: El } = gt, { SourceMapConsumer: Og, SourceMapGenerator: Dg } = gt, { fileURLToPath: Np, pathToFileURL: Xi } = gt, Rp = xu, Ng = Uf, Oo = gt, Do = Symbol("lineToIndexCache"), Rg = !!(Og && Dg), jp = !!(El && vl);
function Lp(a3) {
  if (a3[Do]) return a3[Do];
  let s = a3.css.split(`
`), o = new Array(s.length), b = 0;
  for (let A = 0, R = s.length; A < R; A++) o[A] = b, b += s[A].length + 1;
  return a3[Do] = o, o;
}
let wa = class {
  get from() {
    return this.file || this.id;
  }
  constructor(s, o = {}) {
    if (s === null || typeof s > "u" || typeof s == "object" && !s.toString) throw new Error(`PostCSS received ${s} instead of CSS string`);
    if (this.css = s.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, this.document = this.css, o.document && (this.document = o.document.toString()), o.from && (!jp || /^\w+:\/\//.test(o.from) || vl(o.from) ? this.file = o.from : this.file = El(o.from)), jp && Rg) {
      let b = new Ng(this.css, o);
      if (b.text) {
        this.map = b;
        let A = b.consumer().file;
        !this.file && A && (this.file = this.mapResolve(A));
      }
    }
    this.file || (this.id = "<input css " + kg(6) + ">"), this.map && (this.map.file = this.from);
  }
  error(s, o, b, A = {}) {
    let R, P, t, l, n;
    if (o && typeof o == "object") {
      let c = o, e = b;
      if (typeof c.offset == "number") {
        l = c.offset;
        let r = this.fromOffset(l);
        o = r.line, b = r.col;
      } else o = c.line, b = c.column, l = this.fromLineAndColumn(o, b);
      if (typeof e.offset == "number") {
        t = e.offset;
        let r = this.fromOffset(t);
        P = r.line, R = r.col;
      } else P = e.line, R = e.column, t = this.fromLineAndColumn(e.line, e.column);
    } else if (b) l = this.fromLineAndColumn(o, b);
    else {
      l = o;
      let c = this.fromOffset(l);
      o = c.line, b = c.col;
    }
    let u = this.origin(o, b, P, R);
    return u ? n = new Rp(s, u.endLine === void 0 ? u.line : { column: u.column, line: u.line }, u.endLine === void 0 ? u.column : { column: u.endColumn, line: u.endLine }, u.source, u.file, A.plugin) : n = new Rp(s, P === void 0 ? o : { column: b, line: o }, P === void 0 ? b : { column: R, line: P }, this.css, this.file, A.plugin), n.input = { column: b, endColumn: R, endLine: P, endOffset: t, line: o, offset: l, source: this.css }, this.file && (Xi && (n.input.url = Xi(this.file).toString()), n.input.file = this.file), n;
  }
  fromLineAndColumn(s, o) {
    return Lp(this)[s - 1] + o - 1;
  }
  fromOffset(s) {
    let o = Lp(this), b = o[o.length - 1], A = 0;
    if (s >= b) A = o.length - 1;
    else {
      let R = o.length - 2, P;
      for (; A < R; ) if (P = A + (R - A >> 1), s < o[P]) R = P - 1;
      else if (s >= o[P + 1]) A = P + 1;
      else {
        A = P;
        break;
      }
    }
    return { col: s - o[A] + 1, line: A + 1 };
  }
  mapResolve(s) {
    return /^\w+:\/\//.test(s) ? s : El(this.map.consumer().sourceRoot || this.map.root || ".", s);
  }
  origin(s, o, b, A) {
    if (!this.map) return false;
    let R = this.map.consumer(), P = R.originalPositionFor({ column: o, line: s });
    if (!P.source) return false;
    let t;
    typeof b == "number" && (t = R.originalPositionFor({ column: A, line: b }));
    let l;
    vl(P.source) ? l = Xi(P.source) : l = new URL(P.source, this.map.consumer().sourceRoot || Xi(this.map.mapFile));
    let n = { column: P.column, endColumn: t && t.column, endLine: t && t.line, line: P.line, url: l.toString() };
    if (l.protocol === "file:") if (Np) n.file = Np(l);
    else throw new Error("file: protocol is not available in this PostCSS build");
    let u = R.sourceContentFor(P.source);
    return u && (n.source = u), n;
  }
  toJSON() {
    let s = {};
    for (let o of ["hasBOM", "css", "file", "id"]) this[o] != null && (s[o] = this[o]);
    return this.map && (s.map = { ...this.map }, s.map.consumerCache && (s.map.consumerCache = void 0)), s;
  }
};
var Xa = wa;
wa.default = wa;
Oo && Oo.registerInput && Oo.registerInput(wa);
let Vf = ks, Wf, Hf, Hs = class extends Vf {
  constructor(s) {
    super(s), this.type = "root", this.nodes || (this.nodes = []);
  }
  normalize(s, o, b) {
    let A = super.normalize(s);
    if (o) {
      if (b === "prepend") this.nodes.length > 1 ? o.raws.before = this.nodes[1].raws.before : delete o.raws.before;
      else if (this.first !== o) for (let R of A) R.raws.before = o.raws.before;
    }
    return A;
  }
  removeChild(s, o) {
    let b = this.index(s);
    return !o && b === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[b].raws.before), super.removeChild(s);
  }
  toResult(s = {}) {
    return new Wf(new Hf(), this, s).stringify();
  }
};
Hs.registerLazyResult = (a3) => {
  Wf = a3;
};
Hs.registerProcessor = (a3) => {
  Hf = a3;
};
var Ii = Hs;
Hs.default = Hs;
Vf.registerRoot(Hs);
let mi = { comma(a3) {
  return mi.split(a3, [","], true);
}, space(a3) {
  let s = [" ", `
`, "	"];
  return mi.split(a3, s);
}, split(a3, s, o) {
  let b = [], A = "", R = false, P = 0, t = false, l = "", n = false;
  for (let u of a3) n ? n = false : u === "\\" ? n = true : t ? u === l && (t = false) : u === '"' || u === "'" ? (t = true, l = u) : u === "(" ? P += 1 : u === ")" ? P > 0 && (P -= 1) : P === 0 && s.includes(u) && (R = true), R ? (A !== "" && b.push(A.trim()), A = "", R = false) : A += u;
  return (o || A !== "") && b.push(A.trim()), b;
} };
var Gf = mi;
mi.default = mi;
let zf = ks, jg = Gf, Pa = class extends zf {
  get selectors() {
    return jg.comma(this.selector);
  }
  set selectors(s) {
    let o = this.selector ? this.selector.match(/,\s*/) : null, b = o ? o[0] : "," + this.raw("between", "beforeOpen");
    this.selector = s.join(b);
  }
  constructor(s) {
    super(s), this.type = "rule", this.nodes || (this.nodes = []);
  }
};
var Ou = Pa;
Pa.default = Pa;
zf.registerRule(Pa);
let Lg = Iu, Fg = qa, Mg = Ya, Bg = Xa, $g = Uf, Ug = Ii, Vg = Ou;
function yi(a3, s) {
  if (Array.isArray(a3)) return a3.map((A) => yi(A));
  let { inputs: o, ...b } = a3;
  if (o) {
    s = [];
    for (let A of o) {
      let R = { ...A, __proto__: Bg.prototype };
      R.map && (R.map = { ...R.map, __proto__: $g.prototype }), s.push(R);
    }
  }
  if (b.nodes && (b.nodes = a3.nodes.map((A) => yi(A, s))), b.source) {
    let { inputId: A, ...R } = b.source;
    b.source = R, A != null && (b.source.input = s[A]);
  }
  if (b.type === "root") return new Ug(b);
  if (b.type === "decl") return new Mg(b);
  if (b.type === "rule") return new Vg(b);
  if (b.type === "comment") return new Fg(b);
  if (b.type === "atrule") return new Lg(b);
  throw new Error("Unknown node type: " + a3.type);
}
var Wg = yi;
yi.default = yi;
let { dirname: ma, relative: Kf, resolve: qf, sep: Yf } = gt, { SourceMapConsumer: Xf, SourceMapGenerator: ya } = gt, { pathToFileURL: Fp } = gt, Hg = Xa, Gg = !!(Xf && ya), zg = !!(ma && qf && Kf && Yf), Kg = class {
  constructor(s, o, b, A) {
    this.stringify = s, this.mapOpts = b.map || {}, this.root = o, this.opts = b, this.css = A, this.originalCSS = A, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
  }
  addAnnotation() {
    let s;
    this.isInline() ? s = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? s = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? s = this.mapOpts.annotation(this.opts.to, this.root) : s = this.outputFile() + ".map";
    let o = `
`;
    this.css.includes(`\r
`) && (o = `\r
`), this.css += o + "/*# sourceMappingURL=" + s + " */";
  }
  applyPrevMaps() {
    for (let s of this.previous()) {
      let o = this.toUrl(this.path(s.file)), b = s.root || ma(s.file), A;
      this.mapOpts.sourcesContent === false ? (A = new Xf(s.text), A.sourcesContent && (A.sourcesContent = null)) : A = s.consumer(), this.map.applySourceMap(A, o, this.toUrl(this.path(b)));
    }
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== false) if (this.root) {
      let s;
      for (let o = this.root.nodes.length - 1; o >= 0; o--) s = this.root.nodes[o], s.type === "comment" && s.text.startsWith("# sourceMappingURL=") && this.root.removeChild(o);
    } else this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  generate() {
    if (this.clearAnnotation(), zg && Gg && this.isMap()) return this.generateMap();
    {
      let s = "";
      return this.stringify(this.root, (o) => {
        s += o;
      }), [s];
    }
  }
  generateMap() {
    if (this.root) this.generateString();
    else if (this.previous().length === 1) {
      let s = this.previous()[0].consumer();
      s.file = this.outputFile(), this.map = ya.fromSourceMap(s, { ignoreInvalidMapping: true });
    } else this.map = new ya({ file: this.outputFile(), ignoreInvalidMapping: true }), this.map.addMapping({ generated: { column: 0, line: 1 }, original: { column: 0, line: 1 }, source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>" });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  generateString() {
    this.css = "", this.map = new ya({ file: this.outputFile(), ignoreInvalidMapping: true });
    let s = 1, o = 1, b = "<no source>", A = { generated: { column: 0, line: 0 }, original: { column: 0, line: 0 }, source: "" }, R, P;
    this.stringify(this.root, (t, l, n) => {
      if (this.css += t, l && n !== "end" && (A.generated.line = s, A.generated.column = o - 1, l.source && l.source.start ? (A.source = this.sourcePath(l), A.original.line = l.source.start.line, A.original.column = l.source.start.column - 1, this.map.addMapping(A)) : (A.source = b, A.original.line = 1, A.original.column = 0, this.map.addMapping(A))), P = t.match(/\n/g), P ? (s += P.length, R = t.lastIndexOf(`
`), o = t.length - R) : o += t.length, l && n !== "start") {
        let u = l.parent || { raws: {} };
        (!(l.type === "decl" || l.type === "atrule" && !l.nodes) || l !== u.last || u.raws.semicolon) && (l.source && l.source.end ? (A.source = this.sourcePath(l), A.original.line = l.source.end.line, A.original.column = l.source.end.column - 1, A.generated.line = s, A.generated.column = o - 2, this.map.addMapping(A)) : (A.source = b, A.original.line = 1, A.original.column = 0, A.generated.line = s, A.generated.column = o - 1, this.map.addMapping(A)));
      }
    });
  }
  isAnnotation() {
    return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((s) => s.annotation) : true;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u") return this.mapOpts.inline;
    let s = this.mapOpts.annotation;
    return typeof s < "u" && s !== true ? false : this.previous().length ? this.previous().some((o) => o.inline) : true;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((s) => s.withContent()) : true;
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  path(s) {
    if (this.mapOpts.absolute || s.charCodeAt(0) === 60 || /^\w+:\/\//.test(s)) return s;
    let o = this.memoizedPaths.get(s);
    if (o) return o;
    let b = this.opts.to ? ma(this.opts.to) : ".";
    typeof this.mapOpts.annotation == "string" && (b = ma(qf(b, this.mapOpts.annotation)));
    let A = Kf(b, s);
    return this.memoizedPaths.set(s, A), A;
  }
  previous() {
    if (!this.previousMaps) if (this.previousMaps = [], this.root) this.root.walk((s) => {
      if (s.source && s.source.input.map) {
        let o = s.source.input.map;
        this.previousMaps.includes(o) || this.previousMaps.push(o);
      }
    });
    else {
      let s = new Hg(this.originalCSS, this.opts);
      s.map && this.previousMaps.push(s.map);
    }
    return this.previousMaps;
  }
  setSourcesContent() {
    let s = {};
    if (this.root) this.root.walk((o) => {
      if (o.source) {
        let b = o.source.input.from;
        if (b && !s[b]) {
          s[b] = true;
          let A = this.usesFileUrls ? this.toFileUrl(b) : this.toUrl(this.path(b));
          this.map.setSourceContent(A, o.source.input.css);
        }
      }
    });
    else if (this.css) {
      let o = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(o, this.css);
    }
  }
  sourcePath(s) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(s.source.input.from) : this.toUrl(this.path(s.source.input.from));
  }
  toBase64(s) {
    return Buffer ? Buffer.from(s).toString("base64") : window.btoa(unescape(encodeURIComponent(s)));
  }
  toFileUrl(s) {
    let o = this.memoizedFileURLs.get(s);
    if (o) return o;
    if (Fp) {
      let b = Fp(s).toString();
      return this.memoizedFileURLs.set(s, b), b;
    } else throw new Error("`map.absolute` option is not available in this PostCSS build");
  }
  toUrl(s) {
    let o = this.memoizedURLs.get(s);
    if (o) return o;
    Yf === "\\" && (s = s.replace(/\\/g, "/"));
    let b = encodeURI(s).replace(/[#?]/g, encodeURIComponent);
    return this.memoizedURLs.set(s, b), b;
  }
};
var Jf = Kg;
const No = 39, Mp = 34, Ji = 92, Bp = 47, Qi = 10, si = 32, Zi = 12, ea = 9, ta = 13, qg = 91, Yg = 93, Xg = 40, Jg = 41, Qg = 123, Zg = 125, e1 = 59, t1 = 42, n1 = 58, r1 = 64, na = /[\t\n\f\r "#'()/;[\\\]{}]/g, ra = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, s1 = /.[\r\n"'(/\\]/, $p = /[\da-f]/i;
var i1 = function(s, o = {}) {
  let b = s.css.valueOf(), A = o.ignoreErrors, R, P, t, l, n, u, c, e, r, f, y = b.length, S = 0, T = [], d = [];
  function p() {
    return S;
  }
  function h(C) {
    throw s.error("Unclosed " + C, S);
  }
  function m() {
    return d.length === 0 && S >= y;
  }
  function E(C) {
    if (d.length) return d.pop();
    if (S >= y) return;
    let w = C ? C.ignoreUnclosed : false;
    switch (R = b.charCodeAt(S), R) {
      case Qi:
      case si:
      case ea:
      case ta:
      case Zi: {
        l = S;
        do
          l += 1, R = b.charCodeAt(l);
        while (R === si || R === Qi || R === ea || R === ta || R === Zi);
        u = ["space", b.slice(S, l)], S = l - 1;
        break;
      }
      case qg:
      case Yg:
      case Qg:
      case Zg:
      case n1:
      case e1:
      case Jg: {
        let I = String.fromCharCode(R);
        u = [I, I, S];
        break;
      }
      case Xg: {
        if (f = T.length ? T.pop()[1] : "", r = b.charCodeAt(S + 1), f === "url" && r !== No && r !== Mp && r !== si && r !== Qi && r !== ea && r !== Zi && r !== ta) {
          l = S;
          do {
            if (c = false, l = b.indexOf(")", l + 1), l === -1) if (A || w) {
              l = S;
              break;
            } else h("bracket");
            for (e = l; b.charCodeAt(e - 1) === Ji; ) e -= 1, c = !c;
          } while (c);
          u = ["brackets", b.slice(S, l + 1), S, l], S = l;
        } else l = b.indexOf(")", S + 1), P = b.slice(S, l + 1), l === -1 || s1.test(P) ? u = ["(", "(", S] : (u = ["brackets", P, S, l], S = l);
        break;
      }
      case No:
      case Mp: {
        n = R === No ? "'" : '"', l = S;
        do {
          if (c = false, l = b.indexOf(n, l + 1), l === -1) if (A || w) {
            l = S + 1;
            break;
          } else h("string");
          for (e = l; b.charCodeAt(e - 1) === Ji; ) e -= 1, c = !c;
        } while (c);
        u = ["string", b.slice(S, l + 1), S, l], S = l;
        break;
      }
      case r1: {
        na.lastIndex = S + 1, na.test(b), na.lastIndex === 0 ? l = b.length - 1 : l = na.lastIndex - 2, u = ["at-word", b.slice(S, l + 1), S, l], S = l;
        break;
      }
      case Ji: {
        for (l = S, t = true; b.charCodeAt(l + 1) === Ji; ) l += 1, t = !t;
        if (R = b.charCodeAt(l + 1), t && R !== Bp && R !== si && R !== Qi && R !== ea && R !== ta && R !== Zi && (l += 1, $p.test(b.charAt(l)))) {
          for (; $p.test(b.charAt(l + 1)); ) l += 1;
          b.charCodeAt(l + 1) === si && (l += 1);
        }
        u = ["word", b.slice(S, l + 1), S, l], S = l;
        break;
      }
      default: {
        R === Bp && b.charCodeAt(S + 1) === t1 ? (l = b.indexOf("*/", S + 2) + 1, l === 0 && (A || w ? l = b.length : h("comment")), u = ["comment", b.slice(S, l + 1), S, l], S = l) : (ra.lastIndex = S + 1, ra.test(b), ra.lastIndex === 0 ? l = b.length - 1 : l = ra.lastIndex - 2, u = ["word", b.slice(S, l + 1), S, l], T.push(u), S = l);
        break;
      }
    }
    return S++, u;
  }
  function _(C) {
    d.push(C);
  }
  return { back: _, endOfFile: m, nextToken: E, position: p };
};
let a1 = Iu, o1 = qa, l1 = Ya, u1 = Ii, Up = Ou, c1 = i1;
const Vp = { empty: true, space: true };
function p1(a3) {
  for (let s = a3.length - 1; s >= 0; s--) {
    let o = a3[s], b = o[3] || o[2];
    if (b) return b;
  }
}
let d1 = class {
  constructor(s) {
    this.input = s, this.root = new u1(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: s, start: { column: 1, line: 1, offset: 0 } };
  }
  atrule(s) {
    let o = new a1();
    o.name = s[1].slice(1), o.name === "" && this.unnamedAtrule(o, s), this.init(o, s[2]);
    let b, A, R, P = false, t = false, l = [], n = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (s = this.tokenizer.nextToken(), b = s[0], b === "(" || b === "[" ? n.push(b === "(" ? ")" : "]") : b === "{" && n.length > 0 ? n.push("}") : b === n[n.length - 1] && n.pop(), n.length === 0) if (b === ";") {
        o.source.end = this.getPosition(s[2]), o.source.end.offset++, this.semicolon = true;
        break;
      } else if (b === "{") {
        t = true;
        break;
      } else if (b === "}") {
        if (l.length > 0) {
          for (R = l.length - 1, A = l[R]; A && A[0] === "space"; ) A = l[--R];
          A && (o.source.end = this.getPosition(A[3] || A[2]), o.source.end.offset++);
        }
        this.end(s);
        break;
      } else l.push(s);
      else l.push(s);
      if (this.tokenizer.endOfFile()) {
        P = true;
        break;
      }
    }
    o.raws.between = this.spacesAndCommentsFromEnd(l), l.length ? (o.raws.afterName = this.spacesAndCommentsFromStart(l), this.raw(o, "params", l), P && (s = l[l.length - 1], o.source.end = this.getPosition(s[3] || s[2]), o.source.end.offset++, this.spaces = o.raws.between, o.raws.between = "")) : (o.raws.afterName = "", o.params = ""), t && (o.nodes = [], this.current = o);
  }
  checkMissedSemicolon(s) {
    let o = this.colon(s);
    if (o === false) return;
    let b = 0, A;
    for (let R = o - 1; R >= 0 && (A = s[R], !(A[0] !== "space" && (b += 1, b === 2))); R--) ;
    throw this.input.error("Missed semicolon", A[0] === "word" ? A[3] + 1 : A[2]);
  }
  colon(s) {
    let o = 0, b, A, R;
    for (let [P, t] of s.entries()) {
      if (A = t, R = A[0], R === "(" && (o += 1), R === ")" && (o -= 1), o === 0 && R === ":") if (!b) this.doubleColon(A);
      else {
        if (b[0] === "word" && b[1] === "progid") continue;
        return P;
      }
      b = A;
    }
    return false;
  }
  comment(s) {
    let o = new o1();
    this.init(o, s[2]), o.source.end = this.getPosition(s[3] || s[2]), o.source.end.offset++;
    let b = s[1].slice(2, -2);
    if (/^\s*$/.test(b)) o.text = "", o.raws.left = b, o.raws.right = "";
    else {
      let A = b.match(/^(\s*)([^]*\S)(\s*)$/);
      o.text = A[2], o.raws.left = A[1], o.raws.right = A[3];
    }
  }
  createTokenizer() {
    this.tokenizer = c1(this.input);
  }
  decl(s, o) {
    let b = new l1();
    this.init(b, s[0][2]);
    let A = s[s.length - 1];
    for (A[0] === ";" && (this.semicolon = true, s.pop()), b.source.end = this.getPosition(A[3] || A[2] || p1(s)), b.source.end.offset++; s[0][0] !== "word"; ) s.length === 1 && this.unknownWord(s), b.raws.before += s.shift()[1];
    for (b.source.start = this.getPosition(s[0][2]), b.prop = ""; s.length; ) {
      let n = s[0][0];
      if (n === ":" || n === "space" || n === "comment") break;
      b.prop += s.shift()[1];
    }
    b.raws.between = "";
    let R;
    for (; s.length; ) if (R = s.shift(), R[0] === ":") {
      b.raws.between += R[1];
      break;
    } else R[0] === "word" && /\w/.test(R[1]) && this.unknownWord([R]), b.raws.between += R[1];
    (b.prop[0] === "_" || b.prop[0] === "*") && (b.raws.before += b.prop[0], b.prop = b.prop.slice(1));
    let P = [], t;
    for (; s.length && (t = s[0][0], !(t !== "space" && t !== "comment")); ) P.push(s.shift());
    this.precheckMissedSemicolon(s);
    for (let n = s.length - 1; n >= 0; n--) {
      if (R = s[n], R[1].toLowerCase() === "!important") {
        b.important = true;
        let u = this.stringFrom(s, n);
        u = this.spacesFromEnd(s) + u, u !== " !important" && (b.raws.important = u);
        break;
      } else if (R[1].toLowerCase() === "important") {
        let u = s.slice(0), c = "";
        for (let e = n; e > 0; e--) {
          let r = u[e][0];
          if (c.trim().startsWith("!") && r !== "space") break;
          c = u.pop()[1] + c;
        }
        c.trim().startsWith("!") && (b.important = true, b.raws.important = c, s = u);
      }
      if (R[0] !== "space" && R[0] !== "comment") break;
    }
    s.some((n) => n[0] !== "space" && n[0] !== "comment") && (b.raws.between += P.map((n) => n[1]).join(""), P = []), this.raw(b, "value", P.concat(s), o), b.value.includes(":") && !o && this.checkMissedSemicolon(s);
  }
  doubleColon(s) {
    throw this.input.error("Double colon", { offset: s[2] }, { offset: s[2] + s[1].length });
  }
  emptyRule(s) {
    let o = new Up();
    this.init(o, s[2]), o.selector = "", o.raws.between = "", this.current = o;
  }
  end(s) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(s[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(s);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
  }
  freeSemicolon(s) {
    if (this.spaces += s[1], this.current.nodes) {
      let o = this.current.nodes[this.current.nodes.length - 1];
      o && o.type === "rule" && !o.raws.ownSemicolon && (o.raws.ownSemicolon = this.spaces, this.spaces = "", o.source.end = this.getPosition(s[2]), o.source.end.offset += o.raws.ownSemicolon.length);
    }
  }
  getPosition(s) {
    let o = this.input.fromOffset(s);
    return { column: o.col, line: o.line, offset: s };
  }
  init(s, o) {
    this.current.push(s), s.source = { input: this.input, start: this.getPosition(o) }, s.raws.before = this.spaces, this.spaces = "", s.type !== "comment" && (this.semicolon = false);
  }
  other(s) {
    let o = false, b = null, A = false, R = null, P = [], t = s[1].startsWith("--"), l = [], n = s;
    for (; n; ) {
      if (b = n[0], l.push(n), b === "(" || b === "[") R || (R = n), P.push(b === "(" ? ")" : "]");
      else if (t && A && b === "{") R || (R = n), P.push("}");
      else if (P.length === 0) if (b === ";") if (A) {
        this.decl(l, t);
        return;
      } else break;
      else if (b === "{") {
        this.rule(l);
        return;
      } else if (b === "}") {
        this.tokenizer.back(l.pop()), o = true;
        break;
      } else b === ":" && (A = true);
      else b === P[P.length - 1] && (P.pop(), P.length === 0 && (R = null));
      n = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (o = true), P.length > 0 && this.unclosedBracket(R), o && A) {
      if (!t) for (; l.length && (n = l[l.length - 1][0], !(n !== "space" && n !== "comment")); ) this.tokenizer.back(l.pop());
      this.decl(l, t);
    } else this.unknownWord(l);
  }
  parse() {
    let s;
    for (; !this.tokenizer.endOfFile(); ) switch (s = this.tokenizer.nextToken(), s[0]) {
      case "space":
        this.spaces += s[1];
        break;
      case ";":
        this.freeSemicolon(s);
        break;
      case "}":
        this.end(s);
        break;
      case "comment":
        this.comment(s);
        break;
      case "at-word":
        this.atrule(s);
        break;
      case "{":
        this.emptyRule(s);
        break;
      default:
        this.other(s);
        break;
    }
    this.endFile();
  }
  precheckMissedSemicolon() {
  }
  raw(s, o, b, A) {
    let R, P, t = b.length, l = "", n = true, u, c;
    for (let e = 0; e < t; e += 1) R = b[e], P = R[0], P === "space" && e === t - 1 && !A ? n = false : P === "comment" ? (c = b[e - 1] ? b[e - 1][0] : "empty", u = b[e + 1] ? b[e + 1][0] : "empty", !Vp[c] && !Vp[u] ? l.slice(-1) === "," ? n = false : l += R[1] : n = false) : l += R[1];
    if (!n) {
      let e = b.reduce((r, f) => r + f[1], "");
      s.raws[o] = { raw: e, value: l };
    }
    s[o] = l;
  }
  rule(s) {
    s.pop();
    let o = new Up();
    this.init(o, s[0][2]), o.raws.between = this.spacesAndCommentsFromEnd(s), this.raw(o, "selector", s), this.current = o;
  }
  spacesAndCommentsFromEnd(s) {
    let o, b = "";
    for (; s.length && (o = s[s.length - 1][0], !(o !== "space" && o !== "comment")); ) b = s.pop()[1] + b;
    return b;
  }
  spacesAndCommentsFromStart(s) {
    let o, b = "";
    for (; s.length && (o = s[0][0], !(o !== "space" && o !== "comment")); ) b += s.shift()[1];
    return b;
  }
  spacesFromEnd(s) {
    let o, b = "";
    for (; s.length && (o = s[s.length - 1][0], o === "space"); ) b = s.pop()[1] + b;
    return b;
  }
  stringFrom(s, o) {
    let b = "";
    for (let A = o; A < s.length; A++) b += s[A][1];
    return s.splice(o, s.length - o), b;
  }
  unclosedBlock() {
    let s = this.current.source.start;
    throw this.input.error("Unclosed block", s.line, s.column);
  }
  unclosedBracket(s) {
    throw this.input.error("Unclosed bracket", { offset: s[2] }, { offset: s[2] + 1 });
  }
  unexpectedClose(s) {
    throw this.input.error("Unexpected }", { offset: s[2] }, { offset: s[2] + 1 });
  }
  unknownWord(s) {
    throw this.input.error("Unknown word " + s[0][1], { offset: s[0][2] }, { offset: s[0][2] + s[0][1].length });
  }
  unnamedAtrule(s, o) {
    throw this.input.error("At-rule without name", { offset: o[2] }, { offset: o[2] + o[1].length });
  }
};
var f1 = d1;
let h1 = ks, m1 = Xa, y1 = f1;
function xa(a3, s) {
  let o = new m1(a3, s), b = new y1(o);
  try {
    b.parse();
  } catch (A) {
    throw A;
  }
  return b.root;
}
var Du = xa;
xa.default = xa;
h1.registerParse(xa);
let Sl = class {
  constructor(s, o = {}) {
    if (this.type = "warning", this.text = s, o.node && o.node.source) {
      let b = o.node.rangeBy(o);
      this.line = b.start.line, this.column = b.start.column, this.endLine = b.end.line, this.endColumn = b.end.column;
    }
    for (let b in o) this[b] = o[b];
  }
  toString() {
    return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
};
var Qf = Sl;
Sl.default = Sl;
let b1 = Qf, _l = class {
  get content() {
    return this.css;
  }
  constructor(s, o, b) {
    this.processor = s, this.messages = [], this.root = o, this.opts = b, this.css = "", this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(s, o = {}) {
    o.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (o.plugin = this.lastPlugin.postcssPlugin);
    let b = new b1(s, o);
    return this.messages.push(b), b;
  }
  warnings() {
    return this.messages.filter((s) => s.type === "warning");
  }
};
var Nu = _l;
_l.default = _l;
let g1 = ks, v1 = ku, E1 = Jf, S1 = Du, Wp = Nu, _1 = Ii, T1 = za, { isClean: Vr, my: w1 } = Ci;
const P1 = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, x1 = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, A1 = { Once: true, postcssPlugin: true, prepare: true }, Gs = 0;
function ii(a3) {
  return typeof a3 == "object" && typeof a3.then == "function";
}
function Zf(a3) {
  let s = false, o = P1[a3.type];
  return a3.type === "decl" ? s = a3.prop.toLowerCase() : a3.type === "atrule" && (s = a3.name.toLowerCase()), s && a3.append ? [o, o + "-" + s, Gs, o + "Exit", o + "Exit-" + s] : s ? [o, o + "-" + s, o + "Exit", o + "Exit-" + s] : a3.append ? [o, Gs, o + "Exit"] : [o, o + "Exit"];
}
function Hp(a3) {
  let s;
  return a3.type === "document" ? s = ["Document", Gs, "DocumentExit"] : a3.type === "root" ? s = ["Root", Gs, "RootExit"] : s = Zf(a3), { eventIndex: 0, events: s, iterator: 0, node: a3, visitorIndex: 0, visitors: [] };
}
function Tl(a3) {
  return a3[Vr] = false, a3.nodes && a3.nodes.forEach((s) => Tl(s)), a3;
}
let wl = {}, zs = class eh {
  get content() {
    return this.stringify().content;
  }
  get css() {
    return this.stringify().css;
  }
  get map() {
    return this.stringify().map;
  }
  get messages() {
    return this.sync().messages;
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    return this.sync().root;
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
  constructor(s, o, b) {
    this.stringified = false, this.processed = false;
    let A;
    if (typeof o == "object" && o !== null && (o.type === "root" || o.type === "document")) A = Tl(o);
    else if (o instanceof eh || o instanceof Wp) A = Tl(o.root), o.map && (typeof b.map > "u" && (b.map = {}), b.map.inline || (b.map.inline = false), b.map.prev = o.map);
    else {
      let R = S1;
      b.syntax && (R = b.syntax.parse), b.parser && (R = b.parser), R.parse && (R = R.parse);
      try {
        A = R(o, b);
      } catch (P) {
        this.processed = true, this.error = P;
      }
      A && !A[w1] && g1.rebuild(A);
    }
    this.result = new Wp(s, A, b), this.helpers = { ...wl, postcss: wl, result: this.result }, this.plugins = this.processor.plugins.map((R) => typeof R == "object" && R.prepare ? { ...R, ...R.prepare(this.result) } : R);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  catch(s) {
    return this.async().catch(s);
  }
  finally(s) {
    return this.async().then(s, s);
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(s, o) {
    let b = this.result.lastPlugin;
    try {
      o && o.addToError(s), this.error = s, s.name === "CssSyntaxError" && !s.plugin ? (s.plugin = b.postcssPlugin, s.setMessage()) : b.postcssVersion;
    } catch (A) {
      console && console.error && console.error(A);
    }
    return s;
  }
  prepareVisitors() {
    this.listeners = {};
    let s = (o, b, A) => {
      this.listeners[b] || (this.listeners[b] = []), this.listeners[b].push([o, A]);
    };
    for (let o of this.plugins) if (typeof o == "object") for (let b in o) {
      if (!x1[b] && /^[A-Z]/.test(b)) throw new Error(`Unknown event ${b} in ${o.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
      if (!A1[b]) if (typeof o[b] == "object") for (let A in o[b]) A === "*" ? s(o, b, o[b][A]) : s(o, b + "-" + A.toLowerCase(), o[b][A]);
      else typeof o[b] == "function" && s(o, b, o[b]);
    }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  async runAsync() {
    this.plugin = 0;
    for (let s = 0; s < this.plugins.length; s++) {
      let o = this.plugins[s], b = this.runOnRoot(o);
      if (ii(b)) try {
        await b;
      } catch (A) {
        throw this.handleError(A);
      }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let s = this.result.root;
      for (; !s[Vr]; ) {
        s[Vr] = true;
        let o = [Hp(s)];
        for (; o.length > 0; ) {
          let b = this.visitTick(o);
          if (ii(b)) try {
            await b;
          } catch (A) {
            let R = o[o.length - 1].node;
            throw this.handleError(A, R);
          }
        }
      }
      if (this.listeners.OnceExit) for (let [o, b] of this.listeners.OnceExit) {
        this.result.lastPlugin = o;
        try {
          if (s.type === "document") {
            let A = s.nodes.map((R) => b(R, this.helpers));
            await Promise.all(A);
          } else await b(s, this.helpers);
        } catch (A) {
          throw this.handleError(A);
        }
      }
    }
    return this.processed = true, this.stringify();
  }
  runOnRoot(s) {
    this.result.lastPlugin = s;
    try {
      if (typeof s == "object" && s.Once) {
        if (this.result.root.type === "document") {
          let o = this.result.root.nodes.map((b) => s.Once(b, this.helpers));
          return ii(o[0]) ? Promise.all(o) : o;
        }
        return s.Once(this.result.root, this.helpers);
      } else if (typeof s == "function") return s(this.result.root, this.result);
    } catch (o) {
      throw this.handleError(o);
    }
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = true, this.sync();
    let s = this.result.opts, o = T1;
    s.syntax && (o = s.syntax.stringify), s.stringifier && (o = s.stringifier), o.stringify && (o = o.stringify);
    let A = new E1(o, this.result.root, this.result.opts).generate();
    return this.result.css = A[0], this.result.map = A[1], this.result;
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = true, this.processing) throw this.getAsyncError();
    for (let s of this.plugins) {
      let o = this.runOnRoot(s);
      if (ii(o)) throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let s = this.result.root;
      for (; !s[Vr]; ) s[Vr] = true, this.walkSync(s);
      if (this.listeners.OnceExit) if (s.type === "document") for (let o of s.nodes) this.visitSync(this.listeners.OnceExit, o);
      else this.visitSync(this.listeners.OnceExit, s);
    }
    return this.result;
  }
  then(s, o) {
    return this.async().then(s, o);
  }
  toString() {
    return this.css;
  }
  visitSync(s, o) {
    for (let [b, A] of s) {
      this.result.lastPlugin = b;
      let R;
      try {
        R = A(o, this.helpers);
      } catch (P) {
        throw this.handleError(P, o.proxyOf);
      }
      if (o.type !== "root" && o.type !== "document" && !o.parent) return true;
      if (ii(R)) throw this.getAsyncError();
    }
  }
  visitTick(s) {
    let o = s[s.length - 1], { node: b, visitors: A } = o;
    if (b.type !== "root" && b.type !== "document" && !b.parent) {
      s.pop();
      return;
    }
    if (A.length > 0 && o.visitorIndex < A.length) {
      let [P, t] = A[o.visitorIndex];
      o.visitorIndex += 1, o.visitorIndex === A.length && (o.visitors = [], o.visitorIndex = 0), this.result.lastPlugin = P;
      try {
        return t(b.toProxy(), this.helpers);
      } catch (l) {
        throw this.handleError(l, b);
      }
    }
    if (o.iterator !== 0) {
      let P = o.iterator, t;
      for (; t = b.nodes[b.indexes[P]]; ) if (b.indexes[P] += 1, !t[Vr]) {
        t[Vr] = true, s.push(Hp(t));
        return;
      }
      o.iterator = 0, delete b.indexes[P];
    }
    let R = o.events;
    for (; o.eventIndex < R.length; ) {
      let P = R[o.eventIndex];
      if (o.eventIndex += 1, P === Gs) {
        b.nodes && b.nodes.length && (b[Vr] = true, o.iterator = b.getIterator());
        return;
      } else if (this.listeners[P]) {
        o.visitors = this.listeners[P];
        return;
      }
    }
    s.pop();
  }
  walkSync(s) {
    s[Vr] = true;
    let o = Zf(s);
    for (let b of o) if (b === Gs) s.nodes && s.each((A) => {
      A[Vr] || this.walkSync(A);
    });
    else {
      let A = this.listeners[b];
      if (A && this.visitSync(A, s.toProxy())) return;
    }
  }
  warnings() {
    return this.sync().warnings();
  }
};
zs.registerPostcss = (a3) => {
  wl = a3;
};
var th = zs;
zs.default = zs;
_1.registerLazyResult(zs);
v1.registerLazyResult(zs);
let C1 = Jf, I1 = Du;
const k1 = Nu;
let O1 = za, Pl = class {
  get content() {
    return this.result.css;
  }
  get css() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get messages() {
    return [];
  }
  get opts() {
    return this.result.opts;
  }
  get processor() {
    return this.result.processor;
  }
  get root() {
    if (this._root) return this._root;
    let s, o = I1;
    try {
      s = o(this._css, this._opts);
    } catch (b) {
      this.error = b;
    }
    if (this.error) throw this.error;
    return this._root = s, s;
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
  constructor(s, o, b) {
    o = o.toString(), this.stringified = false, this._processor = s, this._css = o, this._opts = b, this._map = void 0;
    let A, R = O1;
    this.result = new k1(this._processor, A, this._opts), this.result.css = o;
    let P = this;
    Object.defineProperty(this.result, "root", { get() {
      return P.root;
    } });
    let t = new C1(R, A, this._opts, o);
    if (t.isMap()) {
      let [l, n] = t.generate();
      l && (this.result.css = l), n && (this.result.map = n);
    } else t.clearAnnotation(), this.result.css = t.css;
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  catch(s) {
    return this.async().catch(s);
  }
  finally(s) {
    return this.async().then(s, s);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
  then(s, o) {
    return this.async().then(s, o);
  }
  toString() {
    return this._css;
  }
  warnings() {
    return [];
  }
};
var D1 = Pl;
Pl.default = Pl;
let N1 = ku, R1 = th, j1 = D1, L1 = Ii, bi = class {
  constructor(s = []) {
    this.version = "8.5.4", this.plugins = this.normalize(s);
  }
  normalize(s) {
    let o = [];
    for (let b of s) if (b.postcss === true ? b = b() : b.postcss && (b = b.postcss), typeof b == "object" && Array.isArray(b.plugins)) o = o.concat(b.plugins);
    else if (typeof b == "object" && b.postcssPlugin) o.push(b);
    else if (typeof b == "function") o.push(b);
    else if (!(typeof b == "object" && (b.parse || b.stringify))) throw new Error(b + " is not a PostCSS plugin");
    return o;
  }
  process(s, o = {}) {
    return !this.plugins.length && !o.parser && !o.stringifier && !o.syntax ? new j1(this, s, o) : new R1(this, s, o);
  }
  use(s) {
    return this.plugins = this.plugins.concat(this.normalize([s])), this;
  }
};
var F1 = bi;
bi.default = bi;
L1.registerProcessor(bi);
N1.registerProcessor(bi);
var Gp = {};
let nh = Iu, rh = qa, M1 = ks, B1 = xu, sh = Ya, ih = ku, $1 = Wg, U1 = Xa, V1 = th, W1 = Gf, H1 = Ka, G1 = Du, Ru = F1, z1 = Nu, ah = Ii, oh = Ou, K1 = za, q1 = Qf;
function yn(...a3) {
  return a3.length === 1 && Array.isArray(a3[0]) && (a3 = a3[0]), new Ru(a3);
}
yn.plugin = function(s, o) {
  let b = false;
  function A(...P) {
    console && console.warn && !b && (b = true, console.warn(s + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), Gp.LANG && Gp.LANG.startsWith("cn") && console.warn(s + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
https://www.w3ctech.com/topic/2226`));
    let t = o(...P);
    return t.postcssPlugin = s, t.postcssVersion = new Ru().version, t;
  }
  let R;
  return Object.defineProperty(A, "postcss", { get() {
    return R || (R = A()), R;
  } }), A.process = function(P, t, l) {
    return yn([A(l)]).process(P, t);
  }, A;
};
yn.stringify = K1;
yn.parse = G1;
yn.fromJSON = $1;
yn.list = W1;
yn.comment = (a3) => new rh(a3);
yn.atRule = (a3) => new nh(a3);
yn.decl = (a3) => new sh(a3);
yn.rule = (a3) => new oh(a3);
yn.root = (a3) => new ah(a3);
yn.document = (a3) => new ih(a3);
yn.CssSyntaxError = B1;
yn.Declaration = sh;
yn.Container = M1;
yn.Processor = Ru;
yn.Document = ih;
yn.Comment = rh;
yn.Warning = q1;
yn.AtRule = nh;
yn.Result = z1;
yn.Input = U1;
yn.Rule = oh;
yn.Root = ah;
yn.Node = H1;
V1.registerPostcss(yn);
var Lr = yn;
yn.default = yn;
var lh = { exports: {} };
(function(a3, s) {
  (function(o, b) {
    a3.exports = function(A, R, P, t, l) {
      for (R = R.split ? R.split(".") : R, t = 0; t < R.length; t++) A = A ? A[R[t]] : l;
      return A === l ? P : A;
    };
  })();
})(lh);
var uh = lh.exports, xl = { exports: {} }, Al = { exports: {} }, Cl = { exports: {} }, Il = { exports: {} }, kl = { exports: {} }, Ol = { exports: {} }, hr = {}, Dl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = A;
  function o(R) {
    for (var P = R.toLowerCase(), t = "", l = false, n = 0; n < 6 && P[n] !== void 0; n++) {
      var u = P.charCodeAt(n), c = u >= 97 && u <= 102 || u >= 48 && u <= 57;
      if (l = u === 32, !c) break;
      t += P[n];
    }
    if (t.length !== 0) {
      var e = parseInt(t, 16), r = e >= 55296 && e <= 57343;
      return r || e === 0 || e > 1114111 ? ["\uFFFD", t.length + (l ? 1 : 0)] : [String.fromCodePoint(e), t.length + (l ? 1 : 0)];
    }
  }
  var b = /\\/;
  function A(R) {
    var P = b.test(R);
    if (!P) return R;
    for (var t = "", l = 0; l < R.length; l++) {
      if (R[l] === "\\") {
        var n = o(R.slice(l + 1, l + 7));
        if (n !== void 0) {
          t += n[0], l += n[1];
          continue;
        }
        if (R[l + 1] === "\\") {
          t += "\\", l++;
          continue;
        }
        R.length === l + 1 && (t += R[l]);
        continue;
      }
      t += R[l];
    }
    return t;
  }
  a3.exports = s.default;
})(Dl, Dl.exports);
var ju = Dl.exports, Nl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = o;
  function o(b) {
    for (var A = arguments.length, R = new Array(A > 1 ? A - 1 : 0), P = 1; P < A; P++) R[P - 1] = arguments[P];
    for (; R.length > 0; ) {
      var t = R.shift();
      if (!b[t]) return;
      b = b[t];
    }
    return b;
  }
  a3.exports = s.default;
})(Nl, Nl.exports);
var Y1 = Nl.exports, Rl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = o;
  function o(b) {
    for (var A = arguments.length, R = new Array(A > 1 ? A - 1 : 0), P = 1; P < A; P++) R[P - 1] = arguments[P];
    for (; R.length > 0; ) {
      var t = R.shift();
      b[t] || (b[t] = {}), b = b[t];
    }
  }
  a3.exports = s.default;
})(Rl, Rl.exports);
var X1 = Rl.exports, jl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = o;
  function o(b) {
    for (var A = "", R = b.indexOf("/*"), P = 0; R >= 0; ) {
      A = A + b.slice(P, R);
      var t = b.indexOf("*/", R + 2);
      if (t < 0) return A;
      P = t + 2, R = b.indexOf("/*", P);
    }
    return A = A + b.slice(P), A;
  }
  a3.exports = s.default;
})(jl, jl.exports);
var J1 = jl.exports;
hr.__esModule = true;
hr.unesc = hr.stripComments = hr.getProp = hr.ensureObject = void 0;
var Q1 = Ja(ju);
hr.unesc = Q1.default;
var Z1 = Ja(Y1);
hr.getProp = Z1.default;
var e0 = Ja(X1);
hr.ensureObject = e0.default;
var t0 = Ja(J1);
hr.stripComments = t0.default;
function Ja(a3) {
  return a3 && a3.__esModule ? a3 : { default: a3 };
}
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = hr;
  function b(t, l) {
    for (var n = 0; n < l.length; n++) {
      var u = l[n];
      u.enumerable = u.enumerable || false, u.configurable = true, "value" in u && (u.writable = true), Object.defineProperty(t, u.key, u);
    }
  }
  function A(t, l, n) {
    return l && b(t.prototype, l), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  var R = function t(l, n) {
    if (typeof l != "object" || l === null) return l;
    var u = new l.constructor();
    for (var c in l) if (l.hasOwnProperty(c)) {
      var e = l[c], r = typeof e;
      c === "parent" && r === "object" ? n && (u[c] = n) : e instanceof Array ? u[c] = e.map(function(f) {
        return t(f, u);
      }) : u[c] = t(e, u);
    }
    return u;
  }, P = function() {
    function t(n) {
      n === void 0 && (n = {}), Object.assign(this, n), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var l = t.prototype;
    return l.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, l.replaceWith = function() {
      if (this.parent) {
        for (var u in arguments) this.parent.insertBefore(this, arguments[u]);
        this.remove();
      }
      return this;
    }, l.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, l.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, l.clone = function(u) {
      u === void 0 && (u = {});
      var c = R(this);
      for (var e in u) c[e] = u[e];
      return c;
    }, l.appendToPropertyAndEscape = function(u, c, e) {
      this.raws || (this.raws = {});
      var r = this[u], f = this.raws[u];
      this[u] = r + c, f || e !== c ? this.raws[u] = (f || r) + e : delete this.raws[u];
    }, l.setPropertyAndEscape = function(u, c, e) {
      this.raws || (this.raws = {}), this[u] = c, this.raws[u] = e;
    }, l.setPropertyWithoutEscape = function(u, c) {
      this[u] = c, this.raws && delete this.raws[u];
    }, l.isAtPosition = function(u, c) {
      if (this.source && this.source.start && this.source.end) return !(this.source.start.line > u || this.source.end.line < u || this.source.start.line === u && this.source.start.column > c || this.source.end.line === u && this.source.end.column < c);
    }, l.stringifyProperty = function(u) {
      return this.raws && this.raws[u] || this[u];
    }, l.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, l.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, A(t, [{ key: "rawSpaceBefore", get: function() {
      var u = this.raws && this.raws.spaces && this.raws.spaces.before;
      return u === void 0 && (u = this.spaces && this.spaces.before), u || "";
    }, set: function(u) {
      (0, o.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = u;
    } }, { key: "rawSpaceAfter", get: function() {
      var u = this.raws && this.raws.spaces && this.raws.spaces.after;
      return u === void 0 && (u = this.spaces.after), u || "";
    }, set: function(u) {
      (0, o.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = u;
    } }]), t;
  }();
  s.default = P, a3.exports = s.default;
})(Ol, Ol.exports);
var gs = Ol.exports, Xt = {};
Xt.__esModule = true;
Xt.UNIVERSAL = Xt.TAG = Xt.STRING = Xt.SELECTOR = Xt.ROOT = Xt.PSEUDO = Xt.NESTING = Xt.ID = Xt.COMMENT = Xt.COMBINATOR = Xt.CLASS = Xt.ATTRIBUTE = void 0;
var n0 = "tag";
Xt.TAG = n0;
var r0 = "string";
Xt.STRING = r0;
var s0 = "selector";
Xt.SELECTOR = s0;
var i0 = "root";
Xt.ROOT = i0;
var a0 = "pseudo";
Xt.PSEUDO = a0;
var o0 = "nesting";
Xt.NESTING = o0;
var l0 = "id";
Xt.ID = l0;
var u0 = "comment";
Xt.COMMENT = u0;
var c0 = "combinator";
Xt.COMBINATOR = c0;
var p0 = "class";
Xt.CLASS = p0;
var d0 = "attribute";
Xt.ATTRIBUTE = d0;
var f0 = "universal";
Xt.UNIVERSAL = f0;
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = P(gs), b = R(Xt);
  function A(y) {
    if (typeof WeakMap != "function") return null;
    var S = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap();
    return (A = function(p) {
      return p ? T : S;
    })(y);
  }
  function R(y, S) {
    if (y && y.__esModule) return y;
    if (y === null || typeof y != "object" && typeof y != "function") return { default: y };
    var T = A(S);
    if (T && T.has(y)) return T.get(y);
    var d = {}, p = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var h in y) if (h !== "default" && Object.prototype.hasOwnProperty.call(y, h)) {
      var m = p ? Object.getOwnPropertyDescriptor(y, h) : null;
      m && (m.get || m.set) ? Object.defineProperty(d, h, m) : d[h] = y[h];
    }
    return d.default = y, T && T.set(y, d), d;
  }
  function P(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function t(y, S) {
    var T = typeof Symbol < "u" && y[Symbol.iterator] || y["@@iterator"];
    if (T) return (T = T.call(y)).next.bind(T);
    if (Array.isArray(y) || (T = l(y)) || S) {
      T && (y = T);
      var d = 0;
      return function() {
        return d >= y.length ? { done: true } : { done: false, value: y[d++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function l(y, S) {
    if (y) {
      if (typeof y == "string") return n(y, S);
      var T = Object.prototype.toString.call(y).slice(8, -1);
      if (T === "Object" && y.constructor && (T = y.constructor.name), T === "Map" || T === "Set") return Array.from(y);
      if (T === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(T)) return n(y, S);
    }
  }
  function n(y, S) {
    (S == null || S > y.length) && (S = y.length);
    for (var T = 0, d = new Array(S); T < S; T++) d[T] = y[T];
    return d;
  }
  function u(y, S) {
    for (var T = 0; T < S.length; T++) {
      var d = S[T];
      d.enumerable = d.enumerable || false, d.configurable = true, "value" in d && (d.writable = true), Object.defineProperty(y, d.key, d);
    }
  }
  function c(y, S, T) {
    return S && u(y.prototype, S), Object.defineProperty(y, "prototype", { writable: false }), y;
  }
  function e(y, S) {
    y.prototype = Object.create(S.prototype), y.prototype.constructor = y, r(y, S);
  }
  function r(y, S) {
    return r = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, p) {
      return d.__proto__ = p, d;
    }, r(y, S);
  }
  var f = function(y) {
    e(S, y);
    function S(d) {
      var p;
      return p = y.call(this, d) || this, p.nodes || (p.nodes = []), p;
    }
    var T = S.prototype;
    return T.append = function(p) {
      return p.parent = this, this.nodes.push(p), this;
    }, T.prepend = function(p) {
      return p.parent = this, this.nodes.unshift(p), this;
    }, T.at = function(p) {
      return this.nodes[p];
    }, T.index = function(p) {
      return typeof p == "number" ? p : this.nodes.indexOf(p);
    }, T.removeChild = function(p) {
      p = this.index(p), this.at(p).parent = void 0, this.nodes.splice(p, 1);
      var h;
      for (var m in this.indexes) h = this.indexes[m], h >= p && (this.indexes[m] = h - 1);
      return this;
    }, T.removeAll = function() {
      for (var p = t(this.nodes), h; !(h = p()).done; ) {
        var m = h.value;
        m.parent = void 0;
      }
      return this.nodes = [], this;
    }, T.empty = function() {
      return this.removeAll();
    }, T.insertAfter = function(p, h) {
      h.parent = this;
      var m = this.index(p);
      this.nodes.splice(m + 1, 0, h), h.parent = this;
      var E;
      for (var _ in this.indexes) E = this.indexes[_], m <= E && (this.indexes[_] = E + 1);
      return this;
    }, T.insertBefore = function(p, h) {
      h.parent = this;
      var m = this.index(p);
      this.nodes.splice(m, 0, h), h.parent = this;
      var E;
      for (var _ in this.indexes) E = this.indexes[_], E <= m && (this.indexes[_] = E + 1);
      return this;
    }, T._findChildAtPosition = function(p, h) {
      var m = void 0;
      return this.each(function(E) {
        if (E.atPosition) {
          var _ = E.atPosition(p, h);
          if (_) return m = _, false;
        } else if (E.isAtPosition(p, h)) return m = E, false;
      }), m;
    }, T.atPosition = function(p, h) {
      if (this.isAtPosition(p, h)) return this._findChildAtPosition(p, h) || this;
    }, T._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, T.each = function(p) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var h = this.lastEach;
      if (this.indexes[h] = 0, !!this.length) {
        for (var m, E; this.indexes[h] < this.length && (m = this.indexes[h], E = p(this.at(m), m), E !== false); ) this.indexes[h] += 1;
        if (delete this.indexes[h], E === false) return false;
      }
    }, T.walk = function(p) {
      return this.each(function(h, m) {
        var E = p(h, m);
        if (E !== false && h.length && (E = h.walk(p)), E === false) return false;
      });
    }, T.walkAttributes = function(p) {
      var h = this;
      return this.walk(function(m) {
        if (m.type === b.ATTRIBUTE) return p.call(h, m);
      });
    }, T.walkClasses = function(p) {
      var h = this;
      return this.walk(function(m) {
        if (m.type === b.CLASS) return p.call(h, m);
      });
    }, T.walkCombinators = function(p) {
      var h = this;
      return this.walk(function(m) {
        if (m.type === b.COMBINATOR) return p.call(h, m);
      });
    }, T.walkComments = function(p) {
      var h = this;
      return this.walk(function(m) {
        if (m.type === b.COMMENT) return p.call(h, m);
      });
    }, T.walkIds = function(p) {
      var h = this;
      return this.walk(function(m) {
        if (m.type === b.ID) return p.call(h, m);
      });
    }, T.walkNesting = function(p) {
      var h = this;
      return this.walk(function(m) {
        if (m.type === b.NESTING) return p.call(h, m);
      });
    }, T.walkPseudos = function(p) {
      var h = this;
      return this.walk(function(m) {
        if (m.type === b.PSEUDO) return p.call(h, m);
      });
    }, T.walkTags = function(p) {
      var h = this;
      return this.walk(function(m) {
        if (m.type === b.TAG) return p.call(h, m);
      });
    }, T.walkUniversals = function(p) {
      var h = this;
      return this.walk(function(m) {
        if (m.type === b.UNIVERSAL) return p.call(h, m);
      });
    }, T.split = function(p) {
      var h = this, m = [];
      return this.reduce(function(E, _, C) {
        var w = p.call(h, _);
        return m.push(_), w ? (E.push(m), m = []) : C === h.length - 1 && E.push(m), E;
      }, []);
    }, T.map = function(p) {
      return this.nodes.map(p);
    }, T.reduce = function(p, h) {
      return this.nodes.reduce(p, h);
    }, T.every = function(p) {
      return this.nodes.every(p);
    }, T.some = function(p) {
      return this.nodes.some(p);
    }, T.filter = function(p) {
      return this.nodes.filter(p);
    }, T.sort = function(p) {
      return this.nodes.sort(p);
    }, T.toString = function() {
      return this.map(String).join("");
    }, c(S, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), S;
  }(o.default);
  s.default = f, a3.exports = s.default;
})(kl, kl.exports);
var Lu = kl.exports;
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = A(Lu), b = Xt;
  function A(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function R(u, c) {
    for (var e = 0; e < c.length; e++) {
      var r = c[e];
      r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(u, r.key, r);
    }
  }
  function P(u, c, e) {
    return c && R(u.prototype, c), Object.defineProperty(u, "prototype", { writable: false }), u;
  }
  function t(u, c) {
    u.prototype = Object.create(c.prototype), u.prototype.constructor = u, l(u, c);
  }
  function l(u, c) {
    return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, f) {
      return r.__proto__ = f, r;
    }, l(u, c);
  }
  var n = function(u) {
    t(c, u);
    function c(r) {
      var f;
      return f = u.call(this, r) || this, f.type = b.ROOT, f;
    }
    var e = c.prototype;
    return e.toString = function() {
      var f = this.reduce(function(y, S) {
        return y.push(String(S)), y;
      }, []).join(",");
      return this.trailingComma ? f + "," : f;
    }, e.error = function(f, y) {
      return this._error ? this._error(f, y) : new Error(f);
    }, P(c, [{ key: "errorGenerator", set: function(f) {
      this._error = f;
    } }]), c;
  }(o.default);
  s.default = n, a3.exports = s.default;
})(Il, Il.exports);
var ch = Il.exports, Ll = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = A(Lu), b = Xt;
  function A(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function R(l, n) {
    l.prototype = Object.create(n.prototype), l.prototype.constructor = l, P(l, n);
  }
  function P(l, n) {
    return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, e) {
      return c.__proto__ = e, c;
    }, P(l, n);
  }
  var t = function(l) {
    R(n, l);
    function n(u) {
      var c;
      return c = l.call(this, u) || this, c.type = b.SELECTOR, c;
    }
    return n;
  }(o.default);
  s.default = t, a3.exports = s.default;
})(Ll, Ll.exports);
var ph = Ll.exports, Fl = { exports: {} };
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var h0 = {}, m0 = h0.hasOwnProperty, y0 = function(s, o) {
  if (!s) return o;
  var b = {};
  for (var A in o) b[A] = m0.call(s, A) ? s[A] : o[A];
  return b;
}, b0 = /[ -,\.\/:-@\[-\^`\{-~]/, g0 = /[ -,\.\/:-@\[\]\^`\{-~]/, v0 = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, Fu = function a(s, o) {
  o = y0(o, a.options), o.quotes != "single" && o.quotes != "double" && (o.quotes = "single");
  for (var b = o.quotes == "double" ? '"' : "'", A = o.isIdentifier, R = s.charAt(0), P = "", t = 0, l = s.length; t < l; ) {
    var n = s.charAt(t++), u = n.charCodeAt(), c = void 0;
    if (u < 32 || u > 126) {
      if (u >= 55296 && u <= 56319 && t < l) {
        var e = s.charCodeAt(t++);
        (e & 64512) == 56320 ? u = ((u & 1023) << 10) + (e & 1023) + 65536 : t--;
      }
      c = "\\" + u.toString(16).toUpperCase() + " ";
    } else o.escapeEverything ? b0.test(n) ? c = "\\" + n : c = "\\" + u.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(n) ? c = "\\" + u.toString(16).toUpperCase() + " " : n == "\\" || !A && (n == '"' && b == n || n == "'" && b == n) || A && g0.test(n) ? c = "\\" + n : c = n;
    P += c;
  }
  return A && (/^-[-\d]/.test(P) ? P = "\\-" + P.slice(1) : /\d/.test(R) && (P = "\\3" + R + " " + P.slice(1))), P = P.replace(v0, function(r, f, y) {
    return f && f.length % 2 ? r : (f || "") + y;
  }), !A && o.wrap ? b + P + b : P;
};
Fu.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false };
Fu.version = "3.0.0";
var Mu = Fu;
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = P(Mu), b = hr, A = P(gs), R = Xt;
  function P(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function t(e, r) {
    for (var f = 0; f < r.length; f++) {
      var y = r[f];
      y.enumerable = y.enumerable || false, y.configurable = true, "value" in y && (y.writable = true), Object.defineProperty(e, y.key, y);
    }
  }
  function l(e, r, f) {
    return r && t(e.prototype, r), Object.defineProperty(e, "prototype", { writable: false }), e;
  }
  function n(e, r) {
    e.prototype = Object.create(r.prototype), e.prototype.constructor = e, u(e, r);
  }
  function u(e, r) {
    return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(y, S) {
      return y.__proto__ = S, y;
    }, u(e, r);
  }
  var c = function(e) {
    n(r, e);
    function r(y) {
      var S;
      return S = e.call(this, y) || this, S.type = R.CLASS, S._constructed = true, S;
    }
    var f = r.prototype;
    return f.valueToString = function() {
      return "." + e.prototype.valueToString.call(this);
    }, l(r, [{ key: "value", get: function() {
      return this._value;
    }, set: function(S) {
      if (this._constructed) {
        var T = (0, o.default)(S, { isIdentifier: true });
        T !== S ? ((0, b.ensureObject)(this, "raws"), this.raws.value = T) : this.raws && delete this.raws.value;
      }
      this._value = S;
    } }]), r;
  }(A.default);
  s.default = c, a3.exports = s.default;
})(Fl, Fl.exports);
var dh = Fl.exports, Ml = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = A(gs), b = Xt;
  function A(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function R(l, n) {
    l.prototype = Object.create(n.prototype), l.prototype.constructor = l, P(l, n);
  }
  function P(l, n) {
    return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, e) {
      return c.__proto__ = e, c;
    }, P(l, n);
  }
  var t = function(l) {
    R(n, l);
    function n(u) {
      var c;
      return c = l.call(this, u) || this, c.type = b.COMMENT, c;
    }
    return n;
  }(o.default);
  s.default = t, a3.exports = s.default;
})(Ml, Ml.exports);
var fh = Ml.exports, Bl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = A(gs), b = Xt;
  function A(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function R(l, n) {
    l.prototype = Object.create(n.prototype), l.prototype.constructor = l, P(l, n);
  }
  function P(l, n) {
    return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, e) {
      return c.__proto__ = e, c;
    }, P(l, n);
  }
  var t = function(l) {
    R(n, l);
    function n(c) {
      var e;
      return e = l.call(this, c) || this, e.type = b.ID, e;
    }
    var u = n.prototype;
    return u.valueToString = function() {
      return "#" + l.prototype.valueToString.call(this);
    }, n;
  }(o.default);
  s.default = t, a3.exports = s.default;
})(Bl, Bl.exports);
var hh = Bl.exports, $l = { exports: {} }, Ul = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = R(Mu), b = hr, A = R(gs);
  function R(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function P(c, e) {
    for (var r = 0; r < e.length; r++) {
      var f = e[r];
      f.enumerable = f.enumerable || false, f.configurable = true, "value" in f && (f.writable = true), Object.defineProperty(c, f.key, f);
    }
  }
  function t(c, e, r) {
    return e && P(c.prototype, e), Object.defineProperty(c, "prototype", { writable: false }), c;
  }
  function l(c, e) {
    c.prototype = Object.create(e.prototype), c.prototype.constructor = c, n(c, e);
  }
  function n(c, e) {
    return n = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, y) {
      return f.__proto__ = y, f;
    }, n(c, e);
  }
  var u = function(c) {
    l(e, c);
    function e() {
      return c.apply(this, arguments) || this;
    }
    var r = e.prototype;
    return r.qualifiedName = function(y) {
      return this.namespace ? this.namespaceString + "|" + y : y;
    }, r.valueToString = function() {
      return this.qualifiedName(c.prototype.valueToString.call(this));
    }, t(e, [{ key: "namespace", get: function() {
      return this._namespace;
    }, set: function(y) {
      if (y === true || y === "*" || y === "&") {
        this._namespace = y, this.raws && delete this.raws.namespace;
        return;
      }
      var S = (0, o.default)(y, { isIdentifier: true });
      this._namespace = y, S !== y ? ((0, b.ensureObject)(this, "raws"), this.raws.namespace = S) : this.raws && delete this.raws.namespace;
    } }, { key: "ns", get: function() {
      return this._namespace;
    }, set: function(y) {
      this.namespace = y;
    } }, { key: "namespaceString", get: function() {
      if (this.namespace) {
        var y = this.stringifyProperty("namespace");
        return y === true ? "" : y;
      } else return "";
    } }]), e;
  }(A.default);
  s.default = u, a3.exports = s.default;
})(Ul, Ul.exports);
var Bu = Ul.exports;
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = A(Bu), b = Xt;
  function A(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function R(l, n) {
    l.prototype = Object.create(n.prototype), l.prototype.constructor = l, P(l, n);
  }
  function P(l, n) {
    return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, e) {
      return c.__proto__ = e, c;
    }, P(l, n);
  }
  var t = function(l) {
    R(n, l);
    function n(u) {
      var c;
      return c = l.call(this, u) || this, c.type = b.TAG, c;
    }
    return n;
  }(o.default);
  s.default = t, a3.exports = s.default;
})($l, $l.exports);
var mh = $l.exports, Vl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = A(gs), b = Xt;
  function A(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function R(l, n) {
    l.prototype = Object.create(n.prototype), l.prototype.constructor = l, P(l, n);
  }
  function P(l, n) {
    return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, e) {
      return c.__proto__ = e, c;
    }, P(l, n);
  }
  var t = function(l) {
    R(n, l);
    function n(u) {
      var c;
      return c = l.call(this, u) || this, c.type = b.STRING, c;
    }
    return n;
  }(o.default);
  s.default = t, a3.exports = s.default;
})(Vl, Vl.exports);
var yh = Vl.exports, Wl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = A(Lu), b = Xt;
  function A(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function R(l, n) {
    l.prototype = Object.create(n.prototype), l.prototype.constructor = l, P(l, n);
  }
  function P(l, n) {
    return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, e) {
      return c.__proto__ = e, c;
    }, P(l, n);
  }
  var t = function(l) {
    R(n, l);
    function n(c) {
      var e;
      return e = l.call(this, c) || this, e.type = b.PSEUDO, e;
    }
    var u = n.prototype;
    return u.toString = function() {
      var e = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), e, this.rawSpaceAfter].join("");
    }, n;
  }(o.default);
  s.default = t, a3.exports = s.default;
})(Wl, Wl.exports);
var bh = Wl.exports, $u = {}, E0 = S0;
function S0(a3, s) {
  if (Ro("noDeprecation")) return a3;
  var o = false;
  function b() {
    if (!o) {
      if (Ro("throwDeprecation")) throw new Error(s);
      Ro("traceDeprecation") ? console.trace(s) : console.warn(s), o = true;
    }
    return a3.apply(this, arguments);
  }
  return b;
}
function Ro(a3) {
  try {
    if (!Yn.localStorage) return false;
  } catch {
    return false;
  }
  var s = Yn.localStorage[a3];
  return s == null ? false : String(s).toLowerCase() === "true";
}
(function(a3) {
  a3.__esModule = true, a3.default = void 0, a3.unescapeValue = S;
  var s = P(Mu), o = P(ju), b = P(Bu), A = Xt, R;
  function P(m) {
    return m && m.__esModule ? m : { default: m };
  }
  function t(m, E) {
    for (var _ = 0; _ < E.length; _++) {
      var C = E[_];
      C.enumerable = C.enumerable || false, C.configurable = true, "value" in C && (C.writable = true), Object.defineProperty(m, C.key, C);
    }
  }
  function l(m, E, _) {
    return E && t(m.prototype, E), Object.defineProperty(m, "prototype", { writable: false }), m;
  }
  function n(m, E) {
    m.prototype = Object.create(E.prototype), m.prototype.constructor = m, u(m, E);
  }
  function u(m, E) {
    return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(C, w) {
      return C.__proto__ = w, C;
    }, u(m, E);
  }
  var c = E0, e = /^('|")([^]*)\1$/, r = c(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), f = c(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), y = c(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function S(m) {
    var E = false, _ = null, C = m, w = C.match(e);
    return w && (_ = w[1], C = w[2]), C = (0, o.default)(C), C !== m && (E = true), { deprecatedUsage: E, unescaped: C, quoteMark: _ };
  }
  function T(m) {
    if (m.quoteMark !== void 0 || m.value === void 0) return m;
    y();
    var E = S(m.value), _ = E.quoteMark, C = E.unescaped;
    return m.raws || (m.raws = {}), m.raws.value === void 0 && (m.raws.value = m.value), m.value = C, m.quoteMark = _, m;
  }
  var d = function(m) {
    n(E, m);
    function E(C) {
      var w;
      return C === void 0 && (C = {}), w = m.call(this, T(C)) || this, w.type = A.ATTRIBUTE, w.raws = w.raws || {}, Object.defineProperty(w.raws, "unquoted", { get: c(function() {
        return w.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: c(function() {
        return w.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), w._constructed = true, w;
    }
    var _ = E.prototype;
    return _.getQuotedValue = function(w) {
      w === void 0 && (w = {});
      var I = this._determineQuoteMark(w), D = p[I], j = (0, s.default)(this._value, D);
      return j;
    }, _._determineQuoteMark = function(w) {
      return w.smart ? this.smartQuoteMark(w) : this.preferredQuoteMark(w);
    }, _.setValue = function(w, I) {
      I === void 0 && (I = {}), this._value = w, this._quoteMark = this._determineQuoteMark(I), this._syncRawValue();
    }, _.smartQuoteMark = function(w) {
      var I = this.value, D = I.replace(/[^']/g, "").length, j = I.replace(/[^"]/g, "").length;
      if (D + j === 0) {
        var L = (0, s.default)(I, { isIdentifier: true });
        if (L === I) return E.NO_QUOTE;
        var k = this.preferredQuoteMark(w);
        if (k === E.NO_QUOTE) {
          var N = this.quoteMark || w.quoteMark || E.DOUBLE_QUOTE, F = p[N], W = (0, s.default)(I, F);
          if (W.length < L.length) return N;
        }
        return k;
      } else return j === D ? this.preferredQuoteMark(w) : j < D ? E.DOUBLE_QUOTE : E.SINGLE_QUOTE;
    }, _.preferredQuoteMark = function(w) {
      var I = w.preferCurrentQuoteMark ? this.quoteMark : w.quoteMark;
      return I === void 0 && (I = w.preferCurrentQuoteMark ? w.quoteMark : this.quoteMark), I === void 0 && (I = E.DOUBLE_QUOTE), I;
    }, _._syncRawValue = function() {
      var w = (0, s.default)(this._value, p[this.quoteMark]);
      w === this._value ? this.raws && delete this.raws.value : this.raws.value = w;
    }, _._handleEscapes = function(w, I) {
      if (this._constructed) {
        var D = (0, s.default)(I, { isIdentifier: true });
        D !== I ? this.raws[w] = D : delete this.raws[w];
      }
    }, _._spacesFor = function(w) {
      var I = { before: "", after: "" }, D = this.spaces[w] || {}, j = this.raws.spaces && this.raws.spaces[w] || {};
      return Object.assign(I, D, j);
    }, _._stringFor = function(w, I, D) {
      I === void 0 && (I = w), D === void 0 && (D = h);
      var j = this._spacesFor(I);
      return D(this.stringifyProperty(w), j);
    }, _.offsetOf = function(w) {
      var I = 1, D = this._spacesFor("attribute");
      if (I += D.before.length, w === "namespace" || w === "ns") return this.namespace ? I : -1;
      if (w === "attributeNS" || (I += this.namespaceString.length, this.namespace && (I += 1), w === "attribute")) return I;
      I += this.stringifyProperty("attribute").length, I += D.after.length;
      var j = this._spacesFor("operator");
      I += j.before.length;
      var L = this.stringifyProperty("operator");
      if (w === "operator") return L ? I : -1;
      I += L.length, I += j.after.length;
      var k = this._spacesFor("value");
      I += k.before.length;
      var N = this.stringifyProperty("value");
      if (w === "value") return N ? I : -1;
      I += N.length, I += k.after.length;
      var F = this._spacesFor("insensitive");
      return I += F.before.length, w === "insensitive" && this.insensitive ? I : -1;
    }, _.toString = function() {
      var w = this, I = [this.rawSpaceBefore, "["];
      return I.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (I.push(this._stringFor("operator")), I.push(this._stringFor("value")), I.push(this._stringFor("insensitiveFlag", "insensitive", function(D, j) {
        return D.length > 0 && !w.quoted && j.before.length === 0 && !(w.spaces.value && w.spaces.value.after) && (j.before = " "), h(D, j);
      }))), I.push("]"), I.push(this.rawSpaceAfter), I.join("");
    }, l(E, [{ key: "quoted", get: function() {
      var w = this.quoteMark;
      return w === "'" || w === '"';
    }, set: function(w) {
      f();
    } }, { key: "quoteMark", get: function() {
      return this._quoteMark;
    }, set: function(w) {
      if (!this._constructed) {
        this._quoteMark = w;
        return;
      }
      this._quoteMark !== w && (this._quoteMark = w, this._syncRawValue());
    } }, { key: "qualifiedAttribute", get: function() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    } }, { key: "insensitiveFlag", get: function() {
      return this.insensitive ? "i" : "";
    } }, { key: "value", get: function() {
      return this._value;
    }, set: function(w) {
      if (this._constructed) {
        var I = S(w), D = I.deprecatedUsage, j = I.unescaped, L = I.quoteMark;
        if (D && r(), j === this._value && L === this._quoteMark) return;
        this._value = j, this._quoteMark = L, this._syncRawValue();
      } else this._value = w;
    } }, { key: "insensitive", get: function() {
      return this._insensitive;
    }, set: function(w) {
      w || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = w;
    } }, { key: "attribute", get: function() {
      return this._attribute;
    }, set: function(w) {
      this._handleEscapes("attribute", w), this._attribute = w;
    } }]), E;
  }(b.default);
  a3.default = d, d.NO_QUOTE = null, d.SINGLE_QUOTE = "'", d.DOUBLE_QUOTE = '"';
  var p = (R = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }, R[null] = { isIdentifier: true }, R);
  function h(m, E) {
    return "" + E.before + m + E.after;
  }
})($u);
var Hl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = A(Bu), b = Xt;
  function A(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function R(l, n) {
    l.prototype = Object.create(n.prototype), l.prototype.constructor = l, P(l, n);
  }
  function P(l, n) {
    return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, e) {
      return c.__proto__ = e, c;
    }, P(l, n);
  }
  var t = function(l) {
    R(n, l);
    function n(u) {
      var c;
      return c = l.call(this, u) || this, c.type = b.UNIVERSAL, c.value = "*", c;
    }
    return n;
  }(o.default);
  s.default = t, a3.exports = s.default;
})(Hl, Hl.exports);
var gh = Hl.exports, Gl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = A(gs), b = Xt;
  function A(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function R(l, n) {
    l.prototype = Object.create(n.prototype), l.prototype.constructor = l, P(l, n);
  }
  function P(l, n) {
    return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, e) {
      return c.__proto__ = e, c;
    }, P(l, n);
  }
  var t = function(l) {
    R(n, l);
    function n(u) {
      var c;
      return c = l.call(this, u) || this, c.type = b.COMBINATOR, c;
    }
    return n;
  }(o.default);
  s.default = t, a3.exports = s.default;
})(Gl, Gl.exports);
var vh = Gl.exports, zl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = A(gs), b = Xt;
  function A(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function R(l, n) {
    l.prototype = Object.create(n.prototype), l.prototype.constructor = l, P(l, n);
  }
  function P(l, n) {
    return P = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(c, e) {
      return c.__proto__ = e, c;
    }, P(l, n);
  }
  var t = function(l) {
    R(n, l);
    function n(u) {
      var c;
      return c = l.call(this, u) || this, c.type = b.NESTING, c.value = "&", c;
    }
    return n;
  }(o.default);
  s.default = t, a3.exports = s.default;
})(zl, zl.exports);
var Eh = zl.exports, Kl = { exports: {} };
(function(a3, s) {
  s.__esModule = true, s.default = o;
  function o(b) {
    return b.sort(function(A, R) {
      return A - R;
    });
  }
  a3.exports = s.default;
})(Kl, Kl.exports);
var _0 = Kl.exports, Sh = {}, xt = {};
xt.__esModule = true;
xt.word = xt.tilde = xt.tab = xt.str = xt.space = xt.slash = xt.singleQuote = xt.semicolon = xt.plus = xt.pipe = xt.openSquare = xt.openParenthesis = xt.newline = xt.greaterThan = xt.feed = xt.equals = xt.doubleQuote = xt.dollar = xt.cr = xt.comment = xt.comma = xt.combinator = xt.colon = xt.closeSquare = xt.closeParenthesis = xt.caret = xt.bang = xt.backslash = xt.at = xt.asterisk = xt.ampersand = void 0;
var T0 = 38;
xt.ampersand = T0;
var w0 = 42;
xt.asterisk = w0;
var P0 = 64;
xt.at = P0;
var x0 = 44;
xt.comma = x0;
var A0 = 58;
xt.colon = A0;
var C0 = 59;
xt.semicolon = C0;
var I0 = 40;
xt.openParenthesis = I0;
var k0 = 41;
xt.closeParenthesis = k0;
var O0 = 91;
xt.openSquare = O0;
var D0 = 93;
xt.closeSquare = D0;
var N0 = 36;
xt.dollar = N0;
var R0 = 126;
xt.tilde = R0;
var j0 = 94;
xt.caret = j0;
var L0 = 43;
xt.plus = L0;
var F0 = 61;
xt.equals = F0;
var M0 = 124;
xt.pipe = M0;
var B0 = 62;
xt.greaterThan = B0;
var $0 = 32;
xt.space = $0;
var _h = 39;
xt.singleQuote = _h;
var U0 = 34;
xt.doubleQuote = U0;
var V0 = 47;
xt.slash = V0;
var W0 = 33;
xt.bang = W0;
var H0 = 92;
xt.backslash = H0;
var G0 = 13;
xt.cr = G0;
var z0 = 12;
xt.feed = z0;
var K0 = 10;
xt.newline = K0;
var q0 = 9;
xt.tab = q0;
var Y0 = _h;
xt.str = Y0;
var X0 = -1;
xt.comment = X0;
var J0 = -2;
xt.word = J0;
var Q0 = -3;
xt.combinator = Q0;
(function(a3) {
  a3.__esModule = true, a3.FIELDS = void 0, a3.default = f;
  var s = R(xt), o, b;
  function A(y) {
    if (typeof WeakMap != "function") return null;
    var S = /* @__PURE__ */ new WeakMap(), T = /* @__PURE__ */ new WeakMap();
    return (A = function(p) {
      return p ? T : S;
    })(y);
  }
  function R(y, S) {
    if (y && y.__esModule) return y;
    if (y === null || typeof y != "object" && typeof y != "function") return { default: y };
    var T = A(S);
    if (T && T.has(y)) return T.get(y);
    var d = {}, p = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var h in y) if (h !== "default" && Object.prototype.hasOwnProperty.call(y, h)) {
      var m = p ? Object.getOwnPropertyDescriptor(y, h) : null;
      m && (m.get || m.set) ? Object.defineProperty(d, h, m) : d[h] = y[h];
    }
    return d.default = y, T && T.set(y, d), d;
  }
  for (var P = (o = {}, o[s.tab] = true, o[s.newline] = true, o[s.cr] = true, o[s.feed] = true, o), t = (b = {}, b[s.space] = true, b[s.tab] = true, b[s.newline] = true, b[s.cr] = true, b[s.feed] = true, b[s.ampersand] = true, b[s.asterisk] = true, b[s.bang] = true, b[s.comma] = true, b[s.colon] = true, b[s.semicolon] = true, b[s.openParenthesis] = true, b[s.closeParenthesis] = true, b[s.openSquare] = true, b[s.closeSquare] = true, b[s.singleQuote] = true, b[s.doubleQuote] = true, b[s.plus] = true, b[s.pipe] = true, b[s.tilde] = true, b[s.greaterThan] = true, b[s.equals] = true, b[s.dollar] = true, b[s.caret] = true, b[s.slash] = true, b), l = {}, n = "0123456789abcdefABCDEF", u = 0; u < n.length; u++) l[n.charCodeAt(u)] = true;
  function c(y, S) {
    var T = S, d;
    do {
      if (d = y.charCodeAt(T), t[d]) return T - 1;
      d === s.backslash ? T = e(y, T) + 1 : T++;
    } while (T < y.length);
    return T - 1;
  }
  function e(y, S) {
    var T = S, d = y.charCodeAt(T + 1);
    if (!P[d]) if (l[d]) {
      var p = 0;
      do
        T++, p++, d = y.charCodeAt(T + 1);
      while (l[d] && p < 6);
      p < 6 && d === s.space && T++;
    } else T++;
    return T;
  }
  var r = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  a3.FIELDS = r;
  function f(y) {
    var S = [], T = y.css.valueOf(), d = T, p = d.length, h = -1, m = 1, E = 0, _ = 0, C, w, I, D, j, L, k, N, F, W, X, H, U;
    function q(ee, re) {
      if (y.safe) T += re, F = T.length - 1;
      else throw y.error("Unclosed " + ee, m, E - h, E);
    }
    for (; E < p; ) {
      switch (C = T.charCodeAt(E), C === s.newline && (h = E, m += 1), C) {
        case s.space:
        case s.tab:
        case s.newline:
        case s.cr:
        case s.feed:
          F = E;
          do
            F += 1, C = T.charCodeAt(F), C === s.newline && (h = F, m += 1);
          while (C === s.space || C === s.newline || C === s.tab || C === s.cr || C === s.feed);
          U = s.space, D = m, I = F - h - 1, _ = F;
          break;
        case s.plus:
        case s.greaterThan:
        case s.tilde:
        case s.pipe:
          F = E;
          do
            F += 1, C = T.charCodeAt(F);
          while (C === s.plus || C === s.greaterThan || C === s.tilde || C === s.pipe);
          U = s.combinator, D = m, I = E - h, _ = F;
          break;
        case s.asterisk:
        case s.ampersand:
        case s.bang:
        case s.comma:
        case s.equals:
        case s.dollar:
        case s.caret:
        case s.openSquare:
        case s.closeSquare:
        case s.colon:
        case s.semicolon:
        case s.openParenthesis:
        case s.closeParenthesis:
          F = E, U = C, D = m, I = E - h, _ = F + 1;
          break;
        case s.singleQuote:
        case s.doubleQuote:
          H = C === s.singleQuote ? "'" : '"', F = E;
          do
            for (j = false, F = T.indexOf(H, F + 1), F === -1 && q("quote", H), L = F; T.charCodeAt(L - 1) === s.backslash; ) L -= 1, j = !j;
          while (j);
          U = s.str, D = m, I = E - h, _ = F + 1;
          break;
        default:
          C === s.slash && T.charCodeAt(E + 1) === s.asterisk ? (F = T.indexOf("*/", E + 2) + 1, F === 0 && q("comment", "*/"), w = T.slice(E, F + 1), N = w.split(`
`), k = N.length - 1, k > 0 ? (W = m + k, X = F - N[k].length) : (W = m, X = h), U = s.comment, m = W, D = W, I = F - X) : C === s.slash ? (F = E, U = C, D = m, I = E - h, _ = F + 1) : (F = c(T, E), U = s.word, D = m, I = F - h), _ = F + 1;
          break;
      }
      S.push([U, m, E - h, D, I, E, _]), X && (h = X, X = null), E = _;
    }
    return S;
  }
})(Sh);
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = _(ch), b = _(ph), A = _(dh), R = _(fh), P = _(hh), t = _(mh), l = _(yh), n = _(bh), u = E($u), c = _(gh), e = _(vh), r = _(Eh), f = _(_0), y = E(Sh), S = E(xt), T = E(Xt), d = hr, p, h;
  function m(q) {
    if (typeof WeakMap != "function") return null;
    var ee = /* @__PURE__ */ new WeakMap(), re = /* @__PURE__ */ new WeakMap();
    return (m = function(Z) {
      return Z ? re : ee;
    })(q);
  }
  function E(q, ee) {
    if (q && q.__esModule) return q;
    if (q === null || typeof q != "object" && typeof q != "function") return { default: q };
    var re = m(ee);
    if (re && re.has(q)) return re.get(q);
    var Y = {}, Z = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var G in q) if (G !== "default" && Object.prototype.hasOwnProperty.call(q, G)) {
      var B = Z ? Object.getOwnPropertyDescriptor(q, G) : null;
      B && (B.get || B.set) ? Object.defineProperty(Y, G, B) : Y[G] = q[G];
    }
    return Y.default = q, re && re.set(q, Y), Y;
  }
  function _(q) {
    return q && q.__esModule ? q : { default: q };
  }
  function C(q, ee) {
    for (var re = 0; re < ee.length; re++) {
      var Y = ee[re];
      Y.enumerable = Y.enumerable || false, Y.configurable = true, "value" in Y && (Y.writable = true), Object.defineProperty(q, Y.key, Y);
    }
  }
  function w(q, ee, re) {
    return ee && C(q.prototype, ee), Object.defineProperty(q, "prototype", { writable: false }), q;
  }
  var I = (p = {}, p[S.space] = true, p[S.cr] = true, p[S.feed] = true, p[S.newline] = true, p[S.tab] = true, p), D = Object.assign({}, I, (h = {}, h[S.comment] = true, h));
  function j(q) {
    return { line: q[y.FIELDS.START_LINE], column: q[y.FIELDS.START_COL] };
  }
  function L(q) {
    return { line: q[y.FIELDS.END_LINE], column: q[y.FIELDS.END_COL] };
  }
  function k(q, ee, re, Y) {
    return { start: { line: q, column: ee }, end: { line: re, column: Y } };
  }
  function N(q) {
    return k(q[y.FIELDS.START_LINE], q[y.FIELDS.START_COL], q[y.FIELDS.END_LINE], q[y.FIELDS.END_COL]);
  }
  function F(q, ee) {
    if (q) return k(q[y.FIELDS.START_LINE], q[y.FIELDS.START_COL], ee[y.FIELDS.END_LINE], ee[y.FIELDS.END_COL]);
  }
  function W(q, ee) {
    var re = q[ee];
    if (typeof re == "string") return re.indexOf("\\") !== -1 && ((0, d.ensureObject)(q, "raws"), q[ee] = (0, d.unesc)(re), q.raws[ee] === void 0 && (q.raws[ee] = re)), q;
  }
  function X(q, ee) {
    for (var re = -1, Y = []; (re = q.indexOf(ee, re + 1)) !== -1; ) Y.push(re);
    return Y;
  }
  function H() {
    var q = Array.prototype.concat.apply([], arguments);
    return q.filter(function(ee, re) {
      return re === q.indexOf(ee);
    });
  }
  var U = function() {
    function q(re, Y) {
      Y === void 0 && (Y = {}), this.rule = re, this.options = Object.assign({ lossy: false, safe: false }, Y), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, y.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
      var Z = F(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new o.default({ source: Z }), this.root.errorGenerator = this._errorGenerator();
      var G = new b.default({ source: { start: { line: 1, column: 1 } }, sourceIndex: 0 });
      this.root.append(G), this.current = G, this.loop();
    }
    var ee = q.prototype;
    return ee._errorGenerator = function() {
      var Y = this;
      return function(Z, G) {
        return typeof Y.rule == "string" ? new Error(Z) : Y.rule.error(Z, G);
      };
    }, ee.attribute = function() {
      var Y = [], Z = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[y.FIELDS.TYPE] !== S.closeSquare; ) Y.push(this.currToken), this.position++;
      if (this.currToken[y.FIELDS.TYPE] !== S.closeSquare) return this.expected("closing square bracket", this.currToken[y.FIELDS.START_POS]);
      var G = Y.length, B = { source: k(Z[1], Z[2], this.currToken[3], this.currToken[4]), sourceIndex: Z[y.FIELDS.START_POS] };
      if (G === 1 && !~[S.word].indexOf(Y[0][y.FIELDS.TYPE])) return this.expected("attribute", Y[0][y.FIELDS.START_POS]);
      for (var z = 0, M = "", K = "", Q = null, ie = false; z < G; ) {
        var ue = Y[z], ge = this.content(ue), Te = Y[z + 1];
        switch (ue[y.FIELDS.TYPE]) {
          case S.space:
            if (ie = true, this.options.lossy) break;
            if (Q) {
              (0, d.ensureObject)(B, "spaces", Q);
              var le = B.spaces[Q].after || "";
              B.spaces[Q].after = le + ge;
              var fe = (0, d.getProp)(B, "raws", "spaces", Q, "after") || null;
              fe && (B.raws.spaces[Q].after = fe + ge);
            } else M = M + ge, K = K + ge;
            break;
          case S.asterisk:
            if (Te[y.FIELDS.TYPE] === S.equals) B.operator = ge, Q = "operator";
            else if ((!B.namespace || Q === "namespace" && !ie) && Te) {
              M && ((0, d.ensureObject)(B, "spaces", "attribute"), B.spaces.attribute.before = M, M = ""), K && ((0, d.ensureObject)(B, "raws", "spaces", "attribute"), B.raws.spaces.attribute.before = M, K = ""), B.namespace = (B.namespace || "") + ge;
              var Pe = (0, d.getProp)(B, "raws", "namespace") || null;
              Pe && (B.raws.namespace += ge), Q = "namespace";
            }
            ie = false;
            break;
          case S.dollar:
            if (Q === "value") {
              var xe = (0, d.getProp)(B, "raws", "value");
              B.value += "$", xe && (B.raws.value = xe + "$");
              break;
            }
          case S.caret:
            Te[y.FIELDS.TYPE] === S.equals && (B.operator = ge, Q = "operator"), ie = false;
            break;
          case S.combinator:
            if (ge === "~" && Te[y.FIELDS.TYPE] === S.equals && (B.operator = ge, Q = "operator"), ge !== "|") {
              ie = false;
              break;
            }
            Te[y.FIELDS.TYPE] === S.equals ? (B.operator = ge, Q = "operator") : !B.namespace && !B.attribute && (B.namespace = true), ie = false;
            break;
          case S.word:
            if (Te && this.content(Te) === "|" && Y[z + 2] && Y[z + 2][y.FIELDS.TYPE] !== S.equals && !B.operator && !B.namespace) B.namespace = ge, Q = "namespace";
            else if (!B.attribute || Q === "attribute" && !ie) {
              M && ((0, d.ensureObject)(B, "spaces", "attribute"), B.spaces.attribute.before = M, M = ""), K && ((0, d.ensureObject)(B, "raws", "spaces", "attribute"), B.raws.spaces.attribute.before = K, K = ""), B.attribute = (B.attribute || "") + ge;
              var we = (0, d.getProp)(B, "raws", "attribute") || null;
              we && (B.raws.attribute += ge), Q = "attribute";
            } else if (!B.value && B.value !== "" || Q === "value" && !(ie || B.quoteMark)) {
              var me = (0, d.unesc)(ge), ye = (0, d.getProp)(B, "raws", "value") || "", pe = B.value || "";
              B.value = pe + me, B.quoteMark = null, (me !== ge || ye) && ((0, d.ensureObject)(B, "raws"), B.raws.value = (ye || pe) + ge), Q = "value";
            } else {
              var J = ge === "i" || ge === "I";
              (B.value || B.value === "") && (B.quoteMark || ie) ? (B.insensitive = J, (!J || ge === "I") && ((0, d.ensureObject)(B, "raws"), B.raws.insensitiveFlag = ge), Q = "insensitive", M && ((0, d.ensureObject)(B, "spaces", "insensitive"), B.spaces.insensitive.before = M, M = ""), K && ((0, d.ensureObject)(B, "raws", "spaces", "insensitive"), B.raws.spaces.insensitive.before = K, K = "")) : (B.value || B.value === "") && (Q = "value", B.value += ge, B.raws.value && (B.raws.value += ge));
            }
            ie = false;
            break;
          case S.str:
            if (!B.attribute || !B.operator) return this.error("Expected an attribute followed by an operator preceding the string.", { index: ue[y.FIELDS.START_POS] });
            var Ee = (0, u.unescapeValue)(ge), Me = Ee.unescaped, Ue = Ee.quoteMark;
            B.value = Me, B.quoteMark = Ue, Q = "value", (0, d.ensureObject)(B, "raws"), B.raws.value = ge, ie = false;
            break;
          case S.equals:
            if (!B.attribute) return this.expected("attribute", ue[y.FIELDS.START_POS], ge);
            if (B.value) return this.error('Unexpected "=" found; an operator was already defined.', { index: ue[y.FIELDS.START_POS] });
            B.operator = B.operator ? B.operator + ge : ge, Q = "operator", ie = false;
            break;
          case S.comment:
            if (Q) if (ie || Te && Te[y.FIELDS.TYPE] === S.space || Q === "insensitive") {
              var qe = (0, d.getProp)(B, "spaces", Q, "after") || "", He = (0, d.getProp)(B, "raws", "spaces", Q, "after") || qe;
              (0, d.ensureObject)(B, "raws", "spaces", Q), B.raws.spaces[Q].after = He + ge;
            } else {
              var Ie = B[Q] || "", Re = (0, d.getProp)(B, "raws", Q) || Ie;
              (0, d.ensureObject)(B, "raws"), B.raws[Q] = Re + ge;
            }
            else K = K + ge;
            break;
          default:
            return this.error('Unexpected "' + ge + '" found.', { index: ue[y.FIELDS.START_POS] });
        }
        z++;
      }
      W(B, "attribute"), W(B, "namespace"), this.newNode(new u.default(B)), this.position++;
    }, ee.parseWhitespaceEquivalentTokens = function(Y) {
      Y < 0 && (Y = this.tokens.length);
      var Z = this.position, G = [], B = "", z = void 0;
      do
        if (I[this.currToken[y.FIELDS.TYPE]]) this.options.lossy || (B += this.content());
        else if (this.currToken[y.FIELDS.TYPE] === S.comment) {
          var M = {};
          B && (M.before = B, B = ""), z = new R.default({ value: this.content(), source: N(this.currToken), sourceIndex: this.currToken[y.FIELDS.START_POS], spaces: M }), G.push(z);
        }
      while (++this.position < Y);
      if (B) {
        if (z) z.spaces.after = B;
        else if (!this.options.lossy) {
          var K = this.tokens[Z], Q = this.tokens[this.position - 1];
          G.push(new l.default({ value: "", source: k(K[y.FIELDS.START_LINE], K[y.FIELDS.START_COL], Q[y.FIELDS.END_LINE], Q[y.FIELDS.END_COL]), sourceIndex: K[y.FIELDS.START_POS], spaces: { before: B, after: "" } }));
        }
      }
      return G;
    }, ee.convertWhitespaceNodesToSpace = function(Y, Z) {
      var G = this;
      Z === void 0 && (Z = false);
      var B = "", z = "";
      Y.forEach(function(K) {
        var Q = G.lossySpace(K.spaces.before, Z), ie = G.lossySpace(K.rawSpaceBefore, Z);
        B += Q + G.lossySpace(K.spaces.after, Z && Q.length === 0), z += Q + K.value + G.lossySpace(K.rawSpaceAfter, Z && ie.length === 0);
      }), z === B && (z = void 0);
      var M = { space: B, rawSpace: z };
      return M;
    }, ee.isNamedCombinator = function(Y) {
      return Y === void 0 && (Y = this.position), this.tokens[Y + 0] && this.tokens[Y + 0][y.FIELDS.TYPE] === S.slash && this.tokens[Y + 1] && this.tokens[Y + 1][y.FIELDS.TYPE] === S.word && this.tokens[Y + 2] && this.tokens[Y + 2][y.FIELDS.TYPE] === S.slash;
    }, ee.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var Y = this.content(this.tokens[this.position + 1]), Z = (0, d.unesc)(Y).toLowerCase(), G = {};
        Z !== Y && (G.value = "/" + Y + "/");
        var B = new e.default({ value: "/" + Z + "/", source: k(this.currToken[y.FIELDS.START_LINE], this.currToken[y.FIELDS.START_COL], this.tokens[this.position + 2][y.FIELDS.END_LINE], this.tokens[this.position + 2][y.FIELDS.END_COL]), sourceIndex: this.currToken[y.FIELDS.START_POS], raws: G });
        return this.position = this.position + 3, B;
      } else this.unexpected();
    }, ee.combinator = function() {
      var Y = this;
      if (this.content() === "|") return this.namespace();
      var Z = this.locateNextMeaningfulToken(this.position);
      if (Z < 0 || this.tokens[Z][y.FIELDS.TYPE] === S.comma || this.tokens[Z][y.FIELDS.TYPE] === S.closeParenthesis) {
        var G = this.parseWhitespaceEquivalentTokens(Z);
        if (G.length > 0) {
          var B = this.current.last;
          if (B) {
            var z = this.convertWhitespaceNodesToSpace(G), M = z.space, K = z.rawSpace;
            K !== void 0 && (B.rawSpaceAfter += K), B.spaces.after += M;
          } else G.forEach(function(ye) {
            return Y.newNode(ye);
          });
        }
        return;
      }
      var Q = this.currToken, ie = void 0;
      Z > this.position && (ie = this.parseWhitespaceEquivalentTokens(Z));
      var ue;
      if (this.isNamedCombinator() ? ue = this.namedCombinator() : this.currToken[y.FIELDS.TYPE] === S.combinator ? (ue = new e.default({ value: this.content(), source: N(this.currToken), sourceIndex: this.currToken[y.FIELDS.START_POS] }), this.position++) : I[this.currToken[y.FIELDS.TYPE]] || ie || this.unexpected(), ue) {
        if (ie) {
          var ge = this.convertWhitespaceNodesToSpace(ie), Te = ge.space, le = ge.rawSpace;
          ue.spaces.before = Te, ue.rawSpaceBefore = le;
        }
      } else {
        var fe = this.convertWhitespaceNodesToSpace(ie, true), Pe = fe.space, xe = fe.rawSpace;
        xe || (xe = Pe);
        var we = {}, me = { spaces: {} };
        Pe.endsWith(" ") && xe.endsWith(" ") ? (we.before = Pe.slice(0, Pe.length - 1), me.spaces.before = xe.slice(0, xe.length - 1)) : Pe.startsWith(" ") && xe.startsWith(" ") ? (we.after = Pe.slice(1), me.spaces.after = xe.slice(1)) : me.value = xe, ue = new e.default({ value: " ", source: F(Q, this.tokens[this.position - 1]), sourceIndex: Q[y.FIELDS.START_POS], spaces: we, raws: me });
      }
      return this.currToken && this.currToken[y.FIELDS.TYPE] === S.space && (ue.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(ue);
    }, ee.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var Y = new b.default({ source: { start: j(this.tokens[this.position + 1]) }, sourceIndex: this.tokens[this.position + 1][y.FIELDS.START_POS] });
      this.current.parent.append(Y), this.current = Y, this.position++;
    }, ee.comment = function() {
      var Y = this.currToken;
      this.newNode(new R.default({ value: this.content(), source: N(Y), sourceIndex: Y[y.FIELDS.START_POS] })), this.position++;
    }, ee.error = function(Y, Z) {
      throw this.root.error(Y, Z);
    }, ee.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[y.FIELDS.START_POS] });
    }, ee.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[y.FIELDS.START_POS]);
    }, ee.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[y.FIELDS.START_POS]);
    }, ee.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[y.FIELDS.START_POS]);
    }, ee.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[y.FIELDS.START_POS]);
    }, ee.namespace = function() {
      var Y = this.prevToken && this.content(this.prevToken) || true;
      if (this.nextToken[y.FIELDS.TYPE] === S.word) return this.position++, this.word(Y);
      if (this.nextToken[y.FIELDS.TYPE] === S.asterisk) return this.position++, this.universal(Y);
      this.unexpectedPipe();
    }, ee.nesting = function() {
      if (this.nextToken) {
        var Y = this.content(this.nextToken);
        if (Y === "|") {
          this.position++;
          return;
        }
      }
      var Z = this.currToken;
      this.newNode(new r.default({ value: this.content(), source: N(Z), sourceIndex: Z[y.FIELDS.START_POS] })), this.position++;
    }, ee.parentheses = function() {
      var Y = this.current.last, Z = 1;
      if (this.position++, Y && Y.type === T.PSEUDO) {
        var G = new b.default({ source: { start: j(this.tokens[this.position]) }, sourceIndex: this.tokens[this.position][y.FIELDS.START_POS] }), B = this.current;
        for (Y.append(G), this.current = G; this.position < this.tokens.length && Z; ) this.currToken[y.FIELDS.TYPE] === S.openParenthesis && Z++, this.currToken[y.FIELDS.TYPE] === S.closeParenthesis && Z--, Z ? this.parse() : (this.current.source.end = L(this.currToken), this.current.parent.source.end = L(this.currToken), this.position++);
        this.current = B;
      } else {
        for (var z = this.currToken, M = "(", K; this.position < this.tokens.length && Z; ) this.currToken[y.FIELDS.TYPE] === S.openParenthesis && Z++, this.currToken[y.FIELDS.TYPE] === S.closeParenthesis && Z--, K = this.currToken, M += this.parseParenthesisToken(this.currToken), this.position++;
        Y ? Y.appendToPropertyAndEscape("value", M, M) : this.newNode(new l.default({ value: M, source: k(z[y.FIELDS.START_LINE], z[y.FIELDS.START_COL], K[y.FIELDS.END_LINE], K[y.FIELDS.END_COL]), sourceIndex: z[y.FIELDS.START_POS] }));
      }
      if (Z) return this.expected("closing parenthesis", this.currToken[y.FIELDS.START_POS]);
    }, ee.pseudo = function() {
      for (var Y = this, Z = "", G = this.currToken; this.currToken && this.currToken[y.FIELDS.TYPE] === S.colon; ) Z += this.content(), this.position++;
      if (!this.currToken) return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[y.FIELDS.TYPE] === S.word) this.splitWord(false, function(B, z) {
        Z += B, Y.newNode(new n.default({ value: Z, source: F(G, Y.currToken), sourceIndex: G[y.FIELDS.START_POS] })), z > 1 && Y.nextToken && Y.nextToken[y.FIELDS.TYPE] === S.openParenthesis && Y.error("Misplaced parenthesis.", { index: Y.nextToken[y.FIELDS.START_POS] });
      });
      else return this.expected(["pseudo-class", "pseudo-element"], this.currToken[y.FIELDS.START_POS]);
    }, ee.space = function() {
      var Y = this.content();
      this.position === 0 || this.prevToken[y.FIELDS.TYPE] === S.comma || this.prevToken[y.FIELDS.TYPE] === S.openParenthesis || this.current.nodes.every(function(Z) {
        return Z.type === "comment";
      }) ? (this.spaces = this.optionalSpace(Y), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[y.FIELDS.TYPE] === S.comma || this.nextToken[y.FIELDS.TYPE] === S.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(Y), this.position++) : this.combinator();
    }, ee.string = function() {
      var Y = this.currToken;
      this.newNode(new l.default({ value: this.content(), source: N(Y), sourceIndex: Y[y.FIELDS.START_POS] })), this.position++;
    }, ee.universal = function(Y) {
      var Z = this.nextToken;
      if (Z && this.content(Z) === "|") return this.position++, this.namespace();
      var G = this.currToken;
      this.newNode(new c.default({ value: this.content(), source: N(G), sourceIndex: G[y.FIELDS.START_POS] }), Y), this.position++;
    }, ee.splitWord = function(Y, Z) {
      for (var G = this, B = this.nextToken, z = this.content(); B && ~[S.dollar, S.caret, S.equals, S.word].indexOf(B[y.FIELDS.TYPE]); ) {
        this.position++;
        var M = this.content();
        if (z += M, M.lastIndexOf("\\") === M.length - 1) {
          var K = this.nextToken;
          K && K[y.FIELDS.TYPE] === S.space && (z += this.requiredSpace(this.content(K)), this.position++);
        }
        B = this.nextToken;
      }
      var Q = X(z, ".").filter(function(Te) {
        var le = z[Te - 1] === "\\", fe = /^\d+\.\d+%$/.test(z);
        return !le && !fe;
      }), ie = X(z, "#").filter(function(Te) {
        return z[Te - 1] !== "\\";
      }), ue = X(z, "#{");
      ue.length && (ie = ie.filter(function(Te) {
        return !~ue.indexOf(Te);
      }));
      var ge = (0, f.default)(H([0].concat(Q, ie)));
      ge.forEach(function(Te, le) {
        var fe = ge[le + 1] || z.length, Pe = z.slice(Te, fe);
        if (le === 0 && Z) return Z.call(G, Pe, ge.length);
        var xe, we = G.currToken, me = we[y.FIELDS.START_POS] + ge[le], ye = k(we[1], we[2] + Te, we[3], we[2] + (fe - 1));
        if (~Q.indexOf(Te)) {
          var pe = { value: Pe.slice(1), source: ye, sourceIndex: me };
          xe = new A.default(W(pe, "value"));
        } else if (~ie.indexOf(Te)) {
          var J = { value: Pe.slice(1), source: ye, sourceIndex: me };
          xe = new P.default(W(J, "value"));
        } else {
          var Ee = { value: Pe, source: ye, sourceIndex: me };
          W(Ee, "value"), xe = new t.default(Ee);
        }
        G.newNode(xe, Y), Y = null;
      }), this.position++;
    }, ee.word = function(Y) {
      var Z = this.nextToken;
      return Z && this.content(Z) === "|" ? (this.position++, this.namespace()) : this.splitWord(Y);
    }, ee.loop = function() {
      for (; this.position < this.tokens.length; ) this.parse(true);
      return this.current._inferEndPosition(), this.root;
    }, ee.parse = function(Y) {
      switch (this.currToken[y.FIELDS.TYPE]) {
        case S.space:
          this.space();
          break;
        case S.comment:
          this.comment();
          break;
        case S.openParenthesis:
          this.parentheses();
          break;
        case S.closeParenthesis:
          Y && this.missingParenthesis();
          break;
        case S.openSquare:
          this.attribute();
          break;
        case S.dollar:
        case S.caret:
        case S.equals:
        case S.word:
          this.word();
          break;
        case S.colon:
          this.pseudo();
          break;
        case S.comma:
          this.comma();
          break;
        case S.asterisk:
          this.universal();
          break;
        case S.ampersand:
          this.nesting();
          break;
        case S.slash:
        case S.combinator:
          this.combinator();
          break;
        case S.str:
          this.string();
          break;
        case S.closeSquare:
          this.missingSquareBracket();
        case S.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, ee.expected = function(Y, Z, G) {
      if (Array.isArray(Y)) {
        var B = Y.pop();
        Y = Y.join(", ") + " or " + B;
      }
      var z = /^[aeiou]/.test(Y[0]) ? "an" : "a";
      return G ? this.error("Expected " + z + " " + Y + ', found "' + G + '" instead.', { index: Z }) : this.error("Expected " + z + " " + Y + ".", { index: Z });
    }, ee.requiredSpace = function(Y) {
      return this.options.lossy ? " " : Y;
    }, ee.optionalSpace = function(Y) {
      return this.options.lossy ? "" : Y;
    }, ee.lossySpace = function(Y, Z) {
      return this.options.lossy ? Z ? " " : "" : Y;
    }, ee.parseParenthesisToken = function(Y) {
      var Z = this.content(Y);
      return Y[y.FIELDS.TYPE] === S.space ? this.requiredSpace(Z) : Z;
    }, ee.newNode = function(Y, Z) {
      return Z && (/^ +$/.test(Z) && (this.options.lossy || (this.spaces = (this.spaces || "") + Z), Z = true), Y.namespace = Z, W(Y, "namespace")), this.spaces && (Y.spaces.before = this.spaces, this.spaces = ""), this.current.append(Y);
    }, ee.content = function(Y) {
      return Y === void 0 && (Y = this.currToken), this.css.slice(Y[y.FIELDS.START_POS], Y[y.FIELDS.END_POS]);
    }, ee.locateNextMeaningfulToken = function(Y) {
      Y === void 0 && (Y = this.position + 1);
      for (var Z = Y; Z < this.tokens.length; ) if (D[this.tokens[Z][y.FIELDS.TYPE]]) {
        Z++;
        continue;
      } else return Z;
      return -1;
    }, w(q, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), q;
  }();
  s.default = U, a3.exports = s.default;
})(Cl, Cl.exports);
var Z0 = Cl.exports;
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = b(Z0);
  function b(R) {
    return R && R.__esModule ? R : { default: R };
  }
  var A = function() {
    function R(t, l) {
      this.func = t || function() {
      }, this.funcRes = null, this.options = l;
    }
    var P = R.prototype;
    return P._shouldUpdateSelector = function(l, n) {
      n === void 0 && (n = {});
      var u = Object.assign({}, this.options, n);
      return u.updateSelector === false ? false : typeof l != "string";
    }, P._isLossy = function(l) {
      l === void 0 && (l = {});
      var n = Object.assign({}, this.options, l);
      return n.lossless === false;
    }, P._root = function(l, n) {
      n === void 0 && (n = {});
      var u = new o.default(l, this._parseOptions(n));
      return u.root;
    }, P._parseOptions = function(l) {
      return { lossy: this._isLossy(l) };
    }, P._run = function(l, n) {
      var u = this;
      return n === void 0 && (n = {}), new Promise(function(c, e) {
        try {
          var r = u._root(l, n);
          Promise.resolve(u.func(r)).then(function(f) {
            var y = void 0;
            return u._shouldUpdateSelector(l, n) && (y = r.toString(), l.selector = y), { transform: f, root: r, string: y };
          }).then(c, e);
        } catch (f) {
          e(f);
          return;
        }
      });
    }, P._runSync = function(l, n) {
      n === void 0 && (n = {});
      var u = this._root(l, n), c = this.func(u);
      if (c && typeof c.then == "function") throw new Error("Selector processor returned a promise to a synchronous call.");
      var e = void 0;
      return n.updateSelector && typeof l != "string" && (e = u.toString(), l.selector = e), { transform: c, root: u, string: e };
    }, P.ast = function(l, n) {
      return this._run(l, n).then(function(u) {
        return u.root;
      });
    }, P.astSync = function(l, n) {
      return this._runSync(l, n).root;
    }, P.transform = function(l, n) {
      return this._run(l, n).then(function(u) {
        return u.transform;
      });
    }, P.transformSync = function(l, n) {
      return this._runSync(l, n).transform;
    }, P.process = function(l, n) {
      return this._run(l, n).then(function(u) {
        return u.string || u.root.toString();
      });
    }, P.processSync = function(l, n) {
      var u = this._runSync(l, n);
      return u.string || u.root.toString();
    }, R;
  }();
  s.default = A, a3.exports = s.default;
})(Al, Al.exports);
var ev = Al.exports, Th = {}, En = {};
En.__esModule = true;
En.universal = En.tag = En.string = En.selector = En.root = En.pseudo = En.nesting = En.id = En.comment = En.combinator = En.className = En.attribute = void 0;
var tv = Ar($u), nv = Ar(dh), rv = Ar(vh), sv = Ar(fh), iv = Ar(hh), av = Ar(Eh), ov = Ar(bh), lv = Ar(ch), uv = Ar(ph), cv = Ar(yh), pv = Ar(mh), dv = Ar(gh);
function Ar(a3) {
  return a3 && a3.__esModule ? a3 : { default: a3 };
}
var fv = function(s) {
  return new tv.default(s);
};
En.attribute = fv;
var hv = function(s) {
  return new nv.default(s);
};
En.className = hv;
var mv = function(s) {
  return new rv.default(s);
};
En.combinator = mv;
var yv = function(s) {
  return new sv.default(s);
};
En.comment = yv;
var bv = function(s) {
  return new iv.default(s);
};
En.id = bv;
var gv = function(s) {
  return new av.default(s);
};
En.nesting = gv;
var vv = function(s) {
  return new ov.default(s);
};
En.pseudo = vv;
var Ev = function(s) {
  return new lv.default(s);
};
En.root = Ev;
var Sv = function(s) {
  return new uv.default(s);
};
En.selector = Sv;
var _v = function(s) {
  return new cv.default(s);
};
En.string = _v;
var Tv = function(s) {
  return new pv.default(s);
};
En.tag = Tv;
var wv = function(s) {
  return new dv.default(s);
};
En.universal = wv;
var pn = {};
pn.__esModule = true;
pn.isComment = pn.isCombinator = pn.isClassName = pn.isAttribute = void 0;
pn.isContainer = Lv;
pn.isIdentifier = void 0;
pn.isNamespace = Fv;
pn.isNesting = void 0;
pn.isNode = Uu;
pn.isPseudo = void 0;
pn.isPseudoClass = jv;
pn.isPseudoElement = xh;
pn.isUniversal = pn.isTag = pn.isString = pn.isSelector = pn.isRoot = void 0;
var An = Xt, or, Pv = (or = {}, or[An.ATTRIBUTE] = true, or[An.CLASS] = true, or[An.COMBINATOR] = true, or[An.COMMENT] = true, or[An.ID] = true, or[An.NESTING] = true, or[An.PSEUDO] = true, or[An.ROOT] = true, or[An.SELECTOR] = true, or[An.STRING] = true, or[An.TAG] = true, or[An.UNIVERSAL] = true, or);
function Uu(a3) {
  return typeof a3 == "object" && Pv[a3.type];
}
function Cr(a3, s) {
  return Uu(s) && s.type === a3;
}
var wh = Cr.bind(null, An.ATTRIBUTE);
pn.isAttribute = wh;
var xv = Cr.bind(null, An.CLASS);
pn.isClassName = xv;
var Av = Cr.bind(null, An.COMBINATOR);
pn.isCombinator = Av;
var Cv = Cr.bind(null, An.COMMENT);
pn.isComment = Cv;
var Iv = Cr.bind(null, An.ID);
pn.isIdentifier = Iv;
var kv = Cr.bind(null, An.NESTING);
pn.isNesting = kv;
var Vu = Cr.bind(null, An.PSEUDO);
pn.isPseudo = Vu;
var Ov = Cr.bind(null, An.ROOT);
pn.isRoot = Ov;
var Dv = Cr.bind(null, An.SELECTOR);
pn.isSelector = Dv;
var Nv = Cr.bind(null, An.STRING);
pn.isString = Nv;
var Ph = Cr.bind(null, An.TAG);
pn.isTag = Ph;
var Rv = Cr.bind(null, An.UNIVERSAL);
pn.isUniversal = Rv;
function xh(a3) {
  return Vu(a3) && a3.value && (a3.value.startsWith("::") || a3.value.toLowerCase() === ":before" || a3.value.toLowerCase() === ":after" || a3.value.toLowerCase() === ":first-letter" || a3.value.toLowerCase() === ":first-line");
}
function jv(a3) {
  return Vu(a3) && !xh(a3);
}
function Lv(a3) {
  return !!(Uu(a3) && a3.walk);
}
function Fv(a3) {
  return wh(a3) || Ph(a3);
}
(function(a3) {
  a3.__esModule = true;
  var s = Xt;
  Object.keys(s).forEach(function(A) {
    A === "default" || A === "__esModule" || A in a3 && a3[A] === s[A] || (a3[A] = s[A]);
  });
  var o = En;
  Object.keys(o).forEach(function(A) {
    A === "default" || A === "__esModule" || A in a3 && a3[A] === o[A] || (a3[A] = o[A]);
  });
  var b = pn;
  Object.keys(b).forEach(function(A) {
    A === "default" || A === "__esModule" || A in a3 && a3[A] === b[A] || (a3[A] = b[A]);
  });
})(Th);
(function(a3, s) {
  s.__esModule = true, s.default = void 0;
  var o = P(ev), b = R(Th);
  function A(n) {
    if (typeof WeakMap != "function") return null;
    var u = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
    return (A = function(r) {
      return r ? c : u;
    })(n);
  }
  function R(n, u) {
    if (n && n.__esModule) return n;
    if (n === null || typeof n != "object" && typeof n != "function") return { default: n };
    var c = A(u);
    if (c && c.has(n)) return c.get(n);
    var e = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var f in n) if (f !== "default" && Object.prototype.hasOwnProperty.call(n, f)) {
      var y = r ? Object.getOwnPropertyDescriptor(n, f) : null;
      y && (y.get || y.set) ? Object.defineProperty(e, f, y) : e[f] = n[f];
    }
    return e.default = n, c && c.set(n, e), e;
  }
  function P(n) {
    return n && n.__esModule ? n : { default: n };
  }
  var t = function(u) {
    return new o.default(u);
  };
  Object.assign(t, b), delete t.__esModule;
  var l = t;
  s.default = l, a3.exports = s.default;
})(xl, xl.exports);
var as = xl.exports, ki = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return A;
  } });
  const s = b(Lr), o = b(Xs);
  function b(R) {
    return R && R.__esModule ? R : { default: R };
  }
  function A(R) {
    return ["fontSize", "outline"].includes(R) ? (P) => (typeof P == "function" && (P = P({})), Array.isArray(P) && (P = P[0]), P) : R === "fontFamily" ? (P) => {
      typeof P == "function" && (P = P({}));
      let t = Array.isArray(P) && (0, o.default)(P[1]) ? P[0] : P;
      return Array.isArray(t) ? t.join(", ") : t;
    } : ["boxShadow", "transitionProperty", "transitionDuration", "transitionDelay", "transitionTimingFunction", "backgroundImage", "backgroundSize", "backgroundColor", "cursor", "animation"].includes(R) ? (P) => (typeof P == "function" && (P = P({})), Array.isArray(P) && (P = P.join(", ")), P) : ["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(R) ? (P) => (typeof P == "function" && (P = P({})), typeof P == "string" && (P = s.default.list.comma(P).join(" ")), P) : (P, t = {}) => (typeof P == "function" && (P = P(t)), P);
  }
})(ki);
var Wu = {}, Hu = { exports: {} };
const { AtRule: Mv, Rule: Ah } = Lr;
let Ch = as;
function ql(a3, s) {
  let o;
  try {
    Ch((b) => {
      o = b;
    }).processSync(a3);
  } catch (b) {
    throw a3.includes(":") ? s ? s.error("Missed semicolon") : b : s ? s.error(b.message) : b;
  }
  return o.at(0);
}
function Ih(a3, s) {
  let o = false;
  return a3.each((b) => {
    if (b.type === "nesting") {
      let A = s.clone({});
      b.value !== "&" ? b.replaceWith(ql(b.value.replace("&", A.toString()))) : b.replaceWith(A), o = true;
    } else "nodes" in b && b.nodes && Ih(b, s) && (o = true);
  }), o;
}
function kh(a3, s) {
  let o = [];
  return a3.selectors.forEach((b) => {
    let A = ql(b, a3);
    s.selectors.forEach((R) => {
      if (!R) return;
      let P = ql(R, s);
      Ih(P, A) || (P.prepend(Ch.combinator({ value: " " })), P.prepend(A.clone({}))), o.push(P.toString());
    });
  }), o;
}
function sa(a3, s) {
  let o = a3.prev();
  for (s.after(a3); o && o.type === "comment"; ) {
    let b = o.prev();
    s.after(o), o = b;
  }
  return a3;
}
function Bv(a3) {
  return function s(o, b, A, R = A) {
    let P = [];
    if (b.each((t) => {
      t.type === "rule" && A ? R && (t.selectors = kh(o, t)) : t.type === "atrule" && t.nodes ? a3[t.name] ? s(o, t, R) : b[Gu] !== false && P.push(t) : P.push(t);
    }), A && P.length) {
      let t = o.clone({ nodes: [] });
      for (let l of P) t.append(l);
      b.prepend(t);
    }
  };
}
function jo(a3, s, o) {
  let b = new Ah({ nodes: [], selector: a3 });
  return b.append(s), o.after(b), b;
}
function zp(a3, s) {
  let o = {};
  for (let b of a3) o[b] = true;
  if (s) for (let b of s) o[b.replace(/^@/, "")] = true;
  return o;
}
function $v(a3) {
  a3 = a3.trim();
  let s = a3.match(/^\((.*)\)$/);
  if (!s) return { selector: a3, type: "basic" };
  let o = s[1].match(/^(with(?:out)?):(.+)$/);
  if (o) {
    let b = o[1] === "with", A = Object.fromEntries(o[2].trim().split(/\s+/).map((P) => [P, true]));
    if (b && A.all) return { type: "noop" };
    let R = (P) => !!A[P];
    return A.all ? R = () => true : b && (R = (P) => P === "all" ? false : !A[P]), { escapes: R, type: "withrules" };
  }
  return { type: "unknown" };
}
function Uv(a3) {
  let s = [], o = a3.parent;
  for (; o && o instanceof Mv; ) s.push(o), o = o.parent;
  return s;
}
function Vv(a3) {
  let s = a3[Oh];
  if (!s) a3.after(a3.nodes);
  else {
    let o = a3.nodes, b, A = -1, R, P, t, l = Uv(a3);
    if (l.forEach((n, u) => {
      if (s(n.name)) b = n, A = u, P = t;
      else {
        let c = t;
        t = n.clone({ nodes: [] }), c && t.append(c), R = R || t;
      }
    }), b ? P ? (R.append(o), b.after(P)) : b.after(o) : a3.after(o), a3.next() && b) {
      let n;
      l.slice(0, A + 1).forEach((u, c, e) => {
        let r = n;
        n = u.clone({ nodes: [] }), r && n.append(r);
        let f = [], S = (e[c - 1] || a3).next();
        for (; S; ) f.push(S), S = S.next();
        n.append(f);
      }), n && (P || o[o.length - 1]).after(n);
    }
  }
  a3.remove();
}
const Gu = Symbol("rootRuleMergeSel"), Oh = Symbol("rootRuleEscapes");
function Wv(a3) {
  let { params: s } = a3, { escapes: o, selector: b, type: A } = $v(s);
  if (A === "unknown") throw a3.error(`Unknown @${a3.name} parameter ${JSON.stringify(s)}`);
  if (A === "basic" && b) {
    let R = new Ah({ nodes: a3.nodes, selector: b });
    a3.removeAll(), a3.append(R);
  }
  a3[Oh] = o, a3[Gu] = o ? !o("all") : A === "noop";
}
const Lo = Symbol("hasRootRule");
Hu.exports = (a3 = {}) => {
  let s = zp(["media", "supports", "layer", "container", "starting-style"], a3.bubble), o = Bv(s), b = zp(["document", "font-face", "keyframes", "-webkit-keyframes", "-moz-keyframes"], a3.unwrap), A = (a3.rootRuleName || "at-root").replace(/^@/, ""), R = a3.preserveEmpty;
  return { Once(P) {
    P.walkAtRules(A, (t) => {
      Wv(t), P[Lo] = true;
    });
  }, postcssPlugin: "postcss-nested", RootExit(P) {
    P[Lo] && (P.walkAtRules(A, Vv), P[Lo] = false);
  }, Rule(P) {
    let t = false, l = P, n = false, u = [];
    P.each((c) => {
      c.type === "rule" ? (u.length && (l = jo(P.selector, u, l), u = []), n = true, t = true, c.selectors = kh(P, c), l = sa(c, l)) : c.type === "atrule" ? (u.length && (l = jo(P.selector, u, l), u = []), c.name === A ? (t = true, o(P, c, true, c[Gu]), l = sa(c, l)) : s[c.name] ? (n = true, t = true, o(P, c, true), l = sa(c, l)) : b[c.name] ? (n = true, t = true, o(P, c, false), l = sa(c, l)) : n && u.push(c)) : c.type === "decl" && n && u.push(c);
    }), u.length && (l = jo(P.selector, u, l)), t && R !== true && (P.raws.semicolon = true, P.nodes.length === 0 && P.remove());
  } };
};
Hu.exports.postcss = true;
var Hv = Hu.exports, Kp = /-(\w|$)/g, qp = function(s, o) {
  return o.toUpperCase();
}, Gv = function(s) {
  return s = s.toLowerCase(), s === "float" ? "cssFloat" : s.charCodeAt(0) === 45 && s.charCodeAt(1) === 109 && s.charCodeAt(2) === 115 && s.charCodeAt(3) === 45 ? s.substr(1).replace(Kp, qp) : s.replace(Kp, qp);
}, zv = Gv;
let Kv = zv, qv = { boxFlex: true, boxFlexGroup: true, columnCount: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, strokeDashoffset: true, strokeOpacity: true, strokeWidth: true };
function Fo(a3) {
  return typeof a3.nodes > "u" ? true : zu(a3);
}
function zu(a3) {
  let s, o = {};
  return a3.each((b) => {
    if (b.type === "atrule") s = "@" + b.name, b.params && (s += " " + b.params), typeof o[s] > "u" ? o[s] = Fo(b) : Array.isArray(o[s]) ? o[s].push(Fo(b)) : o[s] = [o[s], Fo(b)];
    else if (b.type === "rule") {
      let A = zu(b);
      if (o[b.selector]) for (let R in A) o[b.selector][R] = A[R];
      else o[b.selector] = A;
    } else if (b.type === "decl") {
      b.prop[0] === "-" && b.prop[1] === "-" || b.parent && b.parent.selector === ":export" ? s = b.prop : s = Kv(b.prop);
      let A = b.value;
      !isNaN(b.value) && qv[s] && (A = parseFloat(b.value)), b.important && (A += " !important"), typeof o[s] > "u" ? o[s] = A : Array.isArray(o[s]) ? o[s].push(A) : o[s] = [o[s], A];
    }
  }), o;
}
var Dh = zu;
let gi = Lr, Yp = /\s*!important\s*$/i, Yv = { "box-flex": true, "box-flex-group": true, "column-count": true, flex: true, "flex-grow": true, "flex-positive": true, "flex-shrink": true, "flex-negative": true, "font-weight": true, "line-clamp": true, "line-height": true, opacity: true, order: true, orphans: true, "tab-size": true, widows: true, "z-index": true, zoom: true, "fill-opacity": true, "stroke-dashoffset": true, "stroke-opacity": true, "stroke-width": true };
function Xv(a3) {
  return a3.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
}
function Xp(a3, s, o) {
  o === false || o === null || (s.startsWith("--") || (s = Xv(s)), typeof o == "number" && (o === 0 || Yv[s] ? o = o.toString() : o += "px"), s === "css-float" && (s = "float"), Yp.test(o) ? (o = o.replace(Yp, ""), a3.push(gi.decl({ prop: s, value: o, important: true }))) : a3.push(gi.decl({ prop: s, value: o })));
}
function Jp(a3, s, o) {
  let b = gi.atRule({ name: s[1], params: s[3] || "" });
  typeof o == "object" && (b.nodes = [], Ku(o, b)), a3.push(b);
}
function Ku(a3, s) {
  let o, b, A;
  for (o in a3) if (b = a3[o], !(b === null || typeof b > "u")) if (o[0] === "@") {
    let R = o.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
    if (Array.isArray(b)) for (let P of b) Jp(s, R, P);
    else Jp(s, R, b);
  } else if (Array.isArray(b)) for (let R of b) Xp(s, o, R);
  else typeof b == "object" ? (A = gi.rule({ selector: o }), Ku(b, A), s.push(A)) : Xp(s, o, b);
}
var qu = function(a3) {
  let s = gi.root();
  return Ku(a3, s), s;
};
let Jv = Dh;
var Nh = function(s) {
  return console && console.warn && s.warnings().forEach((o) => {
    let b = o.plugin || "PostCSS";
    console.warn(b + ": " + o.text);
  }), Jv(s.root);
};
let Qv = Lr, Zv = Nh, eE = qu;
var tE = function(s) {
  let o = Qv(s);
  return async (b) => {
    let A = await o.process(b, { parser: eE, from: void 0 });
    return Zv(A);
  };
};
let nE = Lr, rE = Nh, sE = qu;
var iE = function(a3) {
  let s = nE(a3);
  return (o) => {
    let b = s.process(o, { parser: sE, from: void 0 });
    return rE(b);
  };
};
let aE = Dh, oE = qu, lE = tE, uE = iE;
var cE = { objectify: aE, parse: oE, async: lE, sync: uE };
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return R;
  } });
  const s = A(Lr), o = A(Hv), b = A(cE);
  function A(P) {
    return P && P.__esModule ? P : { default: P };
  }
  function R(P) {
    return Array.isArray(P) ? P.flatMap((t) => (0, s.default)([(0, o.default)({ bubble: ["screen"] })]).process(t, { parser: b.default }).root.nodes) : R([P]);
  }
})(Wu);
var Qa = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return b;
  } });
  const s = o(as);
  function o(A) {
    return A && A.__esModule ? A : { default: A };
  }
  function b(A, R, P = false) {
    if (A === "") return R;
    let t = typeof R == "string" ? (0, s.default)().astSync(R) : R;
    return t.walkClasses((l) => {
      let n = l.value, u = P && n.startsWith("-");
      l.value = u ? `-${A}${n.slice(1)}` : `${A}${n}`;
    }), typeof R == "string" ? t.toString() : t;
  }
})(Qa);
var Js = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return A;
  } });
  const s = b(as), o = b(Ga);
  function b(R) {
    return R && R.__esModule ? R : { default: R };
  }
  function A(R) {
    var P;
    let t = s.default.className();
    t.value = R;
    var l;
    return (0, o.default)((l = t == null || (P = t.raws) === null || P === void 0 ? void 0 : P.value) !== null && l !== void 0 ? l : t.value);
  }
})(Js);
var Yu = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(l, n) {
    for (var u in n) Object.defineProperty(l, u, { enumerable: true, get: n[u] });
  }
  s(a3, { asClass: function() {
    return R;
  }, default: function() {
    return P;
  }, formatClass: function() {
    return t;
  } });
  const o = A(Js), b = A(Ga);
  function A(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function R(l) {
    return (0, b.default)(`.${(0, o.default)(l)}`);
  }
  function P(l, n) {
    return R(t(l, n));
  }
  function t(l, n) {
    return n === "DEFAULT" ? l : n === "-" || n === "-DEFAULT" ? `-${l}` : n.startsWith("-") ? `-${l}${n}` : n.startsWith("/") ? `${l}${n}` : `${l}-${n}`;
  }
})(Yu);
var Mo = {}, Rh = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return b;
  } });
  const s = o(ki);
  function o(A) {
    return A && A.__esModule ? A : { default: A };
  }
  function b(A, R = [[A, [A]]], { filterDefault: P = false, ...t } = {}) {
    let l = (0, s.default)(A);
    return function({ matchUtilities: n, theme: u }) {
      for (let e of R) {
        let r = Array.isArray(e[0]) ? e : [e];
        var c;
        n(r.reduce((f, [y, S]) => Object.assign(f, { [y]: (T) => S.reduce((d, p) => Array.isArray(p) ? Object.assign(d, { [p[0]]: p[1] }) : Object.assign(d, { [p]: l(T) }), {}) }), {}), { ...t, values: P ? Object.fromEntries(Object.entries((c = u(A)) !== null && c !== void 0 ? c : {}).filter(([f]) => f !== "DEFAULT")) : u(A) });
      }
    };
  }
})(Rh);
var Za = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  function s(o) {
    return o = Array.isArray(o) ? o : [o], o.map((b) => {
      let A = b.values.map((R) => R.raw !== void 0 ? R.raw : [R.min && `(min-width: ${R.min})`, R.max && `(max-width: ${R.max})`].filter(Boolean).join(" and "));
      return b.not ? `not all and ${A}` : A;
    }).join(", ");
  }
})(Za);
var jh = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return c;
  } });
  const s = /* @__PURE__ */ new Set(["normal", "reverse", "alternate", "alternate-reverse"]), o = /* @__PURE__ */ new Set(["running", "paused"]), b = /* @__PURE__ */ new Set(["none", "forwards", "backwards", "both"]), A = /* @__PURE__ */ new Set(["infinite"]), R = /* @__PURE__ */ new Set(["linear", "ease", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end"]), P = ["cubic-bezier", "steps"], t = /\,(?![^(]*\))/g, l = /\ +(?![^(]*\))/g, n = /^(-?[\d.]+m?s)$/, u = /^(\d+)$/;
  function c(e) {
    return e.split(t).map((f) => {
      let y = f.trim(), S = { value: y }, T = y.split(l), d = /* @__PURE__ */ new Set();
      for (let p of T) !d.has("DIRECTIONS") && s.has(p) ? (S.direction = p, d.add("DIRECTIONS")) : !d.has("PLAY_STATES") && o.has(p) ? (S.playState = p, d.add("PLAY_STATES")) : !d.has("FILL_MODES") && b.has(p) ? (S.fillMode = p, d.add("FILL_MODES")) : !d.has("ITERATION_COUNTS") && (A.has(p) || u.test(p)) ? (S.iterationCount = p, d.add("ITERATION_COUNTS")) : !d.has("TIMING_FUNCTION") && R.has(p) || !d.has("TIMING_FUNCTION") && P.some((h) => p.startsWith(`${h}(`)) ? (S.timingFunction = p, d.add("TIMING_FUNCTION")) : !d.has("DURATION") && n.test(p) ? (S.duration = p, d.add("DURATION")) : !d.has("DELAY") && n.test(p) ? (S.delay = p, d.add("DELAY")) : d.has("NAME") ? (S.unknown || (S.unknown = []), S.unknown.push(p)) : (S.name = p, d.add("NAME"));
      return S;
    });
  }
})(jh);
var Lh = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return o;
  } });
  const s = (b) => Object.assign({}, ...Object.entries(b ?? {}).flatMap(([A, R]) => typeof R == "object" ? Object.entries(s(R)).map(([P, t]) => ({ [A + (P === "DEFAULT" ? "" : `-${P}`)]: t })) : [{ [`${A}`]: R }])), o = s;
})(Lh);
const pE = "3.4.17", dE = { version: pE };
var eo = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(t, l) {
    for (var n in l) Object.defineProperty(t, n, { enumerable: true, get: l[n] });
  }
  s(a3, { normalizeScreens: function() {
    return o;
  }, isScreenSortable: function() {
    return b;
  }, compareScreens: function() {
    return A;
  }, toScreen: function() {
    return R;
  } });
  function o(t, l = true) {
    return Array.isArray(t) ? t.map((n) => {
      if (l && Array.isArray(n)) throw new Error("The tuple syntax is not supported for `screens`.");
      if (typeof n == "string") return { name: n.toString(), not: false, values: [{ min: n, max: void 0 }] };
      let [u, c] = n;
      return u = u.toString(), typeof c == "string" ? { name: u, not: false, values: [{ min: c, max: void 0 }] } : Array.isArray(c) ? { name: u, not: false, values: c.map((e) => P(e)) } : { name: u, not: false, values: [P(c)] };
    }) : o(Object.entries(t ?? {}), false);
  }
  function b(t) {
    return t.values.length !== 1 ? { result: false, reason: "multiple-values" } : t.values[0].raw !== void 0 ? { result: false, reason: "raw-values" } : t.values[0].min !== void 0 && t.values[0].max !== void 0 ? { result: false, reason: "min-and-max" } : { result: true, reason: null };
  }
  function A(t, l, n) {
    let u = R(l, t), c = R(n, t), e = b(u), r = b(c);
    if (e.reason === "multiple-values" || r.reason === "multiple-values") throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
    if (e.reason === "raw-values" || r.reason === "raw-values") throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
    if (e.reason === "min-and-max" || r.reason === "min-and-max") throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
    let { min: f, max: y } = u.values[0], { min: S, max: T } = c.values[0];
    l.not && ([f, y] = [y, f]), n.not && ([S, T] = [T, S]), f = f === void 0 ? f : parseFloat(f), y = y === void 0 ? y : parseFloat(y), S = S === void 0 ? S : parseFloat(S), T = T === void 0 ? T : parseFloat(T);
    let [d, p] = t === "min" ? [f, S] : [T, y];
    return d - p;
  }
  function R(t, l) {
    return typeof t == "object" ? t : { name: "arbitrary-screen", values: [{ [l]: t }] };
  }
  function P({ "min-width": t, min: l = t, max: n, raw: u } = {}) {
    return { min: l, max: n, raw: u };
  }
})(eo);
var Fh = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "removeAlphaVariables", { enumerable: true, get: function() {
    return s;
  } });
  function s(o, b) {
    o.walkDecls((A) => {
      if (b.includes(A.prop)) {
        A.remove();
        return;
      }
      for (let R of b) A.value.includes(`/ var(${R})`) ? A.value = A.value.replace(`/ var(${R})`, "") : A.value.includes(`/ var(${R}, 1)`) && (A.value = A.value.replace(`/ var(${R}, 1)`, ""));
    });
  }
})(Fh);
var Qp;
function fE() {
  return Qp || (Qp = 1, function(a3) {
    Object.defineProperty(a3, "__esModule", { value: true });
    function s(k, N) {
      for (var F in N) Object.defineProperty(k, F, { enumerable: true, get: N[F] });
    }
    s(a3, { variantPlugins: function() {
      return w;
    }, corePlugins: function() {
      return L;
    } });
    const o = E(gt), b = C(gt), A = E(Lr), R = E(Rh), P = E(Za), t = E(Js), l = E(jh), n = E(Lh), u = C(xi), c = E(Pu), e = E(Xs), r = E(ki), f = dE, y = E(xr), S = eo, T = wu, d = Fh, p = is, h = Ai, m = no();
    function E(k) {
      return k && k.__esModule ? k : { default: k };
    }
    function _(k) {
      if (typeof WeakMap != "function") return null;
      var N = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap();
      return (_ = function(W) {
        return W ? F : N;
      })(k);
    }
    function C(k, N) {
      if (k && k.__esModule) return k;
      if (k === null || typeof k != "object" && typeof k != "function") return { default: k };
      var F = _(N);
      if (F && F.has(k)) return F.get(k);
      var W = {}, X = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var H in k) if (H !== "default" && Object.prototype.hasOwnProperty.call(k, H)) {
        var U = X ? Object.getOwnPropertyDescriptor(k, H) : null;
        U && (U.get || U.set) ? Object.defineProperty(W, H, U) : W[H] = k[H];
      }
      return W.default = k, F && F.set(k, W), W;
    }
    let w = { childVariant: ({ addVariant: k }) => {
      k("*", "& > *");
    }, pseudoElementVariants: ({ addVariant: k }) => {
      k("first-letter", "&::first-letter"), k("first-line", "&::first-line"), k("marker", [({ container: N }) => ((0, d.removeAlphaVariables)(N, ["--tw-text-opacity"]), "& *::marker"), ({ container: N }) => ((0, d.removeAlphaVariables)(N, ["--tw-text-opacity"]), "&::marker")]), k("selection", ["& *::selection", "&::selection"]), k("file", "&::file-selector-button"), k("placeholder", "&::placeholder"), k("backdrop", "&::backdrop"), k("before", ({ container: N }) => (N.walkRules((F) => {
        let W = false;
        F.walkDecls("content", () => {
          W = true;
        }), W || F.prepend(A.default.decl({ prop: "content", value: "var(--tw-content)" }));
      }), "&::before")), k("after", ({ container: N }) => (N.walkRules((F) => {
        let W = false;
        F.walkDecls("content", () => {
          W = true;
        }), W || F.prepend(A.default.decl({ prop: "content", value: "var(--tw-content)" }));
      }), "&::after"));
    }, pseudoClassVariants: ({ addVariant: k, matchVariant: N, config: F, prefix: W }) => {
      let X = [["first", "&:first-child"], ["last", "&:last-child"], ["only", "&:only-child"], ["odd", "&:nth-child(odd)"], ["even", "&:nth-child(even)"], "first-of-type", "last-of-type", "only-of-type", ["visited", ({ container: U }) => ((0, d.removeAlphaVariables)(U, ["--tw-text-opacity", "--tw-border-opacity", "--tw-bg-opacity"]), "&:visited")], "target", ["open", "&[open]"], "default", "checked", "indeterminate", "placeholder-shown", "autofill", "optional", "required", "valid", "invalid", "in-range", "out-of-range", "read-only", "empty", "focus-within", ["hover", (0, p.flagEnabled)(F(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"], "focus", "focus-visible", "active", "enabled", "disabled"].map((U) => Array.isArray(U) ? U : [U, `&:${U}`]);
      for (let [U, q] of X) k(U, (ee) => typeof q == "function" ? q(ee) : q);
      let H = { group: (U, { modifier: q }) => q ? [`:merge(${W(".group")}\\/${(0, t.default)(q)})`, " &"] : [`:merge(${W(".group")})`, " &"], peer: (U, { modifier: q }) => q ? [`:merge(${W(".peer")}\\/${(0, t.default)(q)})`, " ~ &"] : [`:merge(${W(".peer")})`, " ~ &"] };
      for (let [U, q] of Object.entries(H)) N(U, (ee = "", re) => {
        let Y = (0, h.normalize)(typeof ee == "function" ? ee(re) : ee);
        Y.includes("&") || (Y = "&" + Y);
        let [Z, G] = q("", re), B = null, z = null, M = 0;
        for (let K = 0; K < Y.length; ++K) {
          let Q = Y[K];
          Q === "&" ? B = K : Q === "'" || Q === '"' ? M += 1 : B !== null && Q === " " && !M && (z = K);
        }
        return B !== null && z === null && (z = Y.length), Y.slice(0, B) + Z + Y.slice(B + 1, z) + G + Y.slice(z);
      }, { values: Object.fromEntries(X), [m.INTERNAL_FEATURES]: { respectPrefix: false } });
    }, directionVariants: ({ addVariant: k }) => {
      k("ltr", '&:where([dir="ltr"], [dir="ltr"] *)'), k("rtl", '&:where([dir="rtl"], [dir="rtl"] *)');
    }, reducedMotionVariants: ({ addVariant: k }) => {
      k("motion-safe", "@media (prefers-reduced-motion: no-preference)"), k("motion-reduce", "@media (prefers-reduced-motion: reduce)");
    }, darkVariants: ({ config: k, addVariant: N }) => {
      let [F, W = ".dark"] = [].concat(k("darkMode", "media"));
      if (F === false && (F = "media", y.default.warn("darkmode-false", ["The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.", "Change `darkMode` to `media` or remove it entirely.", "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"])), F === "variant") {
        let X;
        if (Array.isArray(W) || typeof W == "function" ? X = W : typeof W == "string" && (X = [W]), Array.isArray(X)) for (let H of X) H === ".dark" ? (F = false, y.default.warn("darkmode-variant-without-selector", ["When using `variant` for `darkMode`, you must provide a selector.", 'Example: `darkMode: ["variant", ".your-selector &"]`'])) : H.includes("&") || (F = false, y.default.warn("darkmode-variant-without-ampersand", ["When using `variant` for `darkMode`, your selector must contain `&`.", 'Example `darkMode: ["variant", ".your-selector &"]`']));
        W = X;
      }
      F === "selector" ? N("dark", `&:where(${W}, ${W} *)`) : F === "media" ? N("dark", "@media (prefers-color-scheme: dark)") : F === "variant" ? N("dark", W) : F === "class" && N("dark", `&:is(${W} *)`);
    }, printVariant: ({ addVariant: k }) => {
      k("print", "@media print");
    }, screenVariants: ({ theme: k, addVariant: N, matchVariant: F }) => {
      var W;
      let X = (W = k("screens")) !== null && W !== void 0 ? W : {}, H = Object.values(X).every((ie) => typeof ie == "string"), U = (0, S.normalizeScreens)(k("screens")), q = /* @__PURE__ */ new Set([]);
      function ee(ie) {
        var ue, ge;
        return (ge = (ue = ie.match(/(\D+)$/)) === null || ue === void 0 ? void 0 : ue[1]) !== null && ge !== void 0 ? ge : "(none)";
      }
      function re(ie) {
        ie !== void 0 && q.add(ee(ie));
      }
      function Y(ie) {
        return re(ie), q.size === 1;
      }
      for (const ie of U) for (const ue of ie.values) re(ue.min), re(ue.max);
      let Z = q.size <= 1;
      function G(ie) {
        return Object.fromEntries(U.filter((ue) => (0, S.isScreenSortable)(ue).result).map((ue) => {
          let { min: ge, max: Te } = ue.values[0];
          if (Te !== void 0) return ue;
          if (ge !== void 0) return { ...ue, not: !ue.not };
        }).map((ue) => [ue.name, ue]));
      }
      function B(ie) {
        return (ue, ge) => (0, S.compareScreens)(ie, ue.value, ge.value);
      }
      let z = B("max"), M = B("min");
      function K(ie) {
        return (ue) => {
          if (H) if (Z) {
            if (typeof ue == "string" && !Y(ue)) return y.default.warn("minmax-have-mixed-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
          } else return y.default.warn("mixed-screen-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
          else return y.default.warn("complex-screen-config", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."]), [];
          return [`@media ${(0, P.default)((0, S.toScreen)(ue, ie))}`];
        };
      }
      F("max", K("max"), { sort: z, values: H ? G() : {} });
      let Q = "min-screens";
      for (let ie of U) N(ie.name, `@media ${(0, P.default)(ie)}`, { id: Q, sort: H && Z ? M : void 0, value: ie });
      F("min", K("min"), { id: Q, sort: M });
    }, supportsVariants: ({ matchVariant: k, theme: N }) => {
      var F;
      k("supports", (W = "") => {
        let X = (0, h.normalize)(W), H = /^\w*\s*\(/.test(X);
        return X = H ? X.replace(/\b(and|or|not)\b/g, " $1 ") : X, H ? `@supports ${X}` : (X.includes(":") || (X = `${X}: var(--tw)`), X.startsWith("(") && X.endsWith(")") || (X = `(${X})`), `@supports ${X}`);
      }, { values: (F = N("supports")) !== null && F !== void 0 ? F : {} });
    }, hasVariants: ({ matchVariant: k, prefix: N }) => {
      k("has", (F) => `&:has(${(0, h.normalize)(F)})`, { values: {}, [m.INTERNAL_FEATURES]: { respectPrefix: false } }), k("group-has", (F, { modifier: W }) => W ? `:merge(${N(".group")}\\/${W}):has(${(0, h.normalize)(F)}) &` : `:merge(${N(".group")}):has(${(0, h.normalize)(F)}) &`, { values: {}, [m.INTERNAL_FEATURES]: { respectPrefix: false } }), k("peer-has", (F, { modifier: W }) => W ? `:merge(${N(".peer")}\\/${W}):has(${(0, h.normalize)(F)}) ~ &` : `:merge(${N(".peer")}):has(${(0, h.normalize)(F)}) ~ &`, { values: {}, [m.INTERNAL_FEATURES]: { respectPrefix: false } });
    }, ariaVariants: ({ matchVariant: k, theme: N }) => {
      var F;
      k("aria", (H) => `&[aria-${(0, h.normalizeAttributeSelectors)((0, h.normalize)(H))}]`, { values: (F = N("aria")) !== null && F !== void 0 ? F : {} });
      var W;
      k("group-aria", (H, { modifier: U }) => U ? `:merge(.group\\/${U})[aria-${(0, h.normalizeAttributeSelectors)((0, h.normalize)(H))}] &` : `:merge(.group)[aria-${(0, h.normalizeAttributeSelectors)((0, h.normalize)(H))}] &`, { values: (W = N("aria")) !== null && W !== void 0 ? W : {} });
      var X;
      k("peer-aria", (H, { modifier: U }) => U ? `:merge(.peer\\/${U})[aria-${(0, h.normalizeAttributeSelectors)((0, h.normalize)(H))}] ~ &` : `:merge(.peer)[aria-${(0, h.normalizeAttributeSelectors)((0, h.normalize)(H))}] ~ &`, { values: (X = N("aria")) !== null && X !== void 0 ? X : {} });
    }, dataVariants: ({ matchVariant: k, theme: N }) => {
      var F;
      k("data", (H) => `&[data-${(0, h.normalizeAttributeSelectors)((0, h.normalize)(H))}]`, { values: (F = N("data")) !== null && F !== void 0 ? F : {} });
      var W;
      k("group-data", (H, { modifier: U }) => U ? `:merge(.group\\/${U})[data-${(0, h.normalizeAttributeSelectors)((0, h.normalize)(H))}] &` : `:merge(.group)[data-${(0, h.normalizeAttributeSelectors)((0, h.normalize)(H))}] &`, { values: (W = N("data")) !== null && W !== void 0 ? W : {} });
      var X;
      k("peer-data", (H, { modifier: U }) => U ? `:merge(.peer\\/${U})[data-${(0, h.normalizeAttributeSelectors)((0, h.normalize)(H))}] ~ &` : `:merge(.peer)[data-${(0, h.normalizeAttributeSelectors)((0, h.normalize)(H))}] ~ &`, { values: (X = N("data")) !== null && X !== void 0 ? X : {} });
    }, orientationVariants: ({ addVariant: k }) => {
      k("portrait", "@media (orientation: portrait)"), k("landscape", "@media (orientation: landscape)");
    }, prefersContrastVariants: ({ addVariant: k }) => {
      k("contrast-more", "@media (prefers-contrast: more)"), k("contrast-less", "@media (prefers-contrast: less)");
    }, forcedColorsVariants: ({ addVariant: k }) => {
      k("forced-colors", "@media (forced-colors: active)");
    } }, I = ["translate(var(--tw-translate-x), var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" "), D = ["var(--tw-blur)", "var(--tw-brightness)", "var(--tw-contrast)", "var(--tw-grayscale)", "var(--tw-hue-rotate)", "var(--tw-invert)", "var(--tw-saturate)", "var(--tw-sepia)", "var(--tw-drop-shadow)"].join(" "), j = ["var(--tw-backdrop-blur)", "var(--tw-backdrop-brightness)", "var(--tw-backdrop-contrast)", "var(--tw-backdrop-grayscale)", "var(--tw-backdrop-hue-rotate)", "var(--tw-backdrop-invert)", "var(--tw-backdrop-opacity)", "var(--tw-backdrop-saturate)", "var(--tw-backdrop-sepia)"].join(" "), L = { preflight: ({ addBase: k }) => {
      let N = A.default.parse(o.default.readFileSync(b.join(__dirname, "./css/preflight.css"), "utf8"));
      k([A.default.comment({ text: `! tailwindcss v${f.version} | MIT License | https://tailwindcss.com` }), ...N.nodes]);
    }, container: /* @__PURE__ */ (() => {
      function k(F = []) {
        return F.flatMap((W) => W.values.map((X) => X.min)).filter((W) => W !== void 0);
      }
      function N(F, W, X) {
        if (typeof X > "u") return [];
        if (!(typeof X == "object" && X !== null)) return [{ screen: "DEFAULT", minWidth: 0, padding: X }];
        let H = [];
        X.DEFAULT && H.push({ screen: "DEFAULT", minWidth: 0, padding: X.DEFAULT });
        for (let U of F) for (let q of W) for (let { min: ee } of q.values) ee === U && H.push({ minWidth: U, padding: X[q.name] });
        return H;
      }
      return function({ addComponents: F, theme: W }) {
        let X = (0, S.normalizeScreens)(W("container.screens", W("screens"))), H = k(X), U = N(H, X, W("container.padding")), q = (re) => {
          let Y = U.find((Z) => Z.minWidth === re);
          return Y ? { paddingRight: Y.padding, paddingLeft: Y.padding } : {};
        }, ee = Array.from(new Set(H.slice().sort((re, Y) => parseInt(re) - parseInt(Y)))).map((re) => ({ [`@media (min-width: ${re})`]: { ".container": { "max-width": re, ...q(re) } } }));
        F([{ ".container": Object.assign({ width: "100%" }, W("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {}, q(0)) }, ...ee]);
      };
    })(), accessibility: ({ addUtilities: k }) => {
      k({ ".sr-only": { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" }, ".not-sr-only": { position: "static", width: "auto", height: "auto", padding: "0", margin: "0", overflow: "visible", clip: "auto", whiteSpace: "normal" } });
    }, pointerEvents: ({ addUtilities: k }) => {
      k({ ".pointer-events-none": { "pointer-events": "none" }, ".pointer-events-auto": { "pointer-events": "auto" } });
    }, visibility: ({ addUtilities: k }) => {
      k({ ".visible": { visibility: "visible" }, ".invisible": { visibility: "hidden" }, ".collapse": { visibility: "collapse" } });
    }, position: ({ addUtilities: k }) => {
      k({ ".static": { position: "static" }, ".fixed": { position: "fixed" }, ".absolute": { position: "absolute" }, ".relative": { position: "relative" }, ".sticky": { position: "sticky" } });
    }, inset: (0, R.default)("inset", [["inset", ["inset"]], [["inset-x", ["left", "right"]], ["inset-y", ["top", "bottom"]]], [["start", ["inset-inline-start"]], ["end", ["inset-inline-end"]], ["top", ["top"]], ["right", ["right"]], ["bottom", ["bottom"]], ["left", ["left"]]]], { supportsNegativeValues: true }), isolation: ({ addUtilities: k }) => {
      k({ ".isolate": { isolation: "isolate" }, ".isolation-auto": { isolation: "auto" } });
    }, zIndex: (0, R.default)("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }), order: (0, R.default)("order", void 0, { supportsNegativeValues: true }), gridColumn: (0, R.default)("gridColumn", [["col", ["gridColumn"]]]), gridColumnStart: (0, R.default)("gridColumnStart", [["col-start", ["gridColumnStart"]]], { supportsNegativeValues: true }), gridColumnEnd: (0, R.default)("gridColumnEnd", [["col-end", ["gridColumnEnd"]]], { supportsNegativeValues: true }), gridRow: (0, R.default)("gridRow", [["row", ["gridRow"]]]), gridRowStart: (0, R.default)("gridRowStart", [["row-start", ["gridRowStart"]]], { supportsNegativeValues: true }), gridRowEnd: (0, R.default)("gridRowEnd", [["row-end", ["gridRowEnd"]]], { supportsNegativeValues: true }), float: ({ addUtilities: k }) => {
      k({ ".float-start": { float: "inline-start" }, ".float-end": { float: "inline-end" }, ".float-right": { float: "right" }, ".float-left": { float: "left" }, ".float-none": { float: "none" } });
    }, clear: ({ addUtilities: k }) => {
      k({ ".clear-start": { clear: "inline-start" }, ".clear-end": { clear: "inline-end" }, ".clear-left": { clear: "left" }, ".clear-right": { clear: "right" }, ".clear-both": { clear: "both" }, ".clear-none": { clear: "none" } });
    }, margin: (0, R.default)("margin", [["m", ["margin"]], [["mx", ["margin-left", "margin-right"]], ["my", ["margin-top", "margin-bottom"]]], [["ms", ["margin-inline-start"]], ["me", ["margin-inline-end"]], ["mt", ["margin-top"]], ["mr", ["margin-right"]], ["mb", ["margin-bottom"]], ["ml", ["margin-left"]]]], { supportsNegativeValues: true }), boxSizing: ({ addUtilities: k }) => {
      k({ ".box-border": { "box-sizing": "border-box" }, ".box-content": { "box-sizing": "content-box" } });
    }, lineClamp: ({ matchUtilities: k, addUtilities: N, theme: F }) => {
      k({ "line-clamp": (W) => ({ overflow: "hidden", display: "-webkit-box", "-webkit-box-orient": "vertical", "-webkit-line-clamp": `${W}` }) }, { values: F("lineClamp") }), N({ ".line-clamp-none": { overflow: "visible", display: "block", "-webkit-box-orient": "horizontal", "-webkit-line-clamp": "none" } });
    }, display: ({ addUtilities: k }) => {
      k({ ".block": { display: "block" }, ".inline-block": { display: "inline-block" }, ".inline": { display: "inline" }, ".flex": { display: "flex" }, ".inline-flex": { display: "inline-flex" }, ".table": { display: "table" }, ".inline-table": { display: "inline-table" }, ".table-caption": { display: "table-caption" }, ".table-cell": { display: "table-cell" }, ".table-column": { display: "table-column" }, ".table-column-group": { display: "table-column-group" }, ".table-footer-group": { display: "table-footer-group" }, ".table-header-group": { display: "table-header-group" }, ".table-row-group": { display: "table-row-group" }, ".table-row": { display: "table-row" }, ".flow-root": { display: "flow-root" }, ".grid": { display: "grid" }, ".inline-grid": { display: "inline-grid" }, ".contents": { display: "contents" }, ".list-item": { display: "list-item" }, ".hidden": { display: "none" } });
    }, aspectRatio: (0, R.default)("aspectRatio", [["aspect", ["aspect-ratio"]]]), size: (0, R.default)("size", [["size", ["width", "height"]]]), height: (0, R.default)("height", [["h", ["height"]]]), maxHeight: (0, R.default)("maxHeight", [["max-h", ["maxHeight"]]]), minHeight: (0, R.default)("minHeight", [["min-h", ["minHeight"]]]), width: (0, R.default)("width", [["w", ["width"]]]), minWidth: (0, R.default)("minWidth", [["min-w", ["minWidth"]]]), maxWidth: (0, R.default)("maxWidth", [["max-w", ["maxWidth"]]]), flex: (0, R.default)("flex"), flexShrink: (0, R.default)("flexShrink", [["flex-shrink", ["flex-shrink"]], ["shrink", ["flex-shrink"]]]), flexGrow: (0, R.default)("flexGrow", [["flex-grow", ["flex-grow"]], ["grow", ["flex-grow"]]]), flexBasis: (0, R.default)("flexBasis", [["basis", ["flex-basis"]]]), tableLayout: ({ addUtilities: k }) => {
      k({ ".table-auto": { "table-layout": "auto" }, ".table-fixed": { "table-layout": "fixed" } });
    }, captionSide: ({ addUtilities: k }) => {
      k({ ".caption-top": { "caption-side": "top" }, ".caption-bottom": { "caption-side": "bottom" } });
    }, borderCollapse: ({ addUtilities: k }) => {
      k({ ".border-collapse": { "border-collapse": "collapse" }, ".border-separate": { "border-collapse": "separate" } });
    }, borderSpacing: ({ addDefaults: k, matchUtilities: N, theme: F }) => {
      k("border-spacing", { "--tw-border-spacing-x": 0, "--tw-border-spacing-y": 0 }), N({ "border-spacing": (W) => ({ "--tw-border-spacing-x": W, "--tw-border-spacing-y": W, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-x": (W) => ({ "--tw-border-spacing-x": W, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-y": (W) => ({ "--tw-border-spacing-y": W, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }) }, { values: F("borderSpacing") });
    }, transformOrigin: (0, R.default)("transformOrigin", [["origin", ["transformOrigin"]]]), translate: (0, R.default)("translate", [[["translate-x", [["@defaults transform", {}], "--tw-translate-x", ["transform", I]]], ["translate-y", [["@defaults transform", {}], "--tw-translate-y", ["transform", I]]]]], { supportsNegativeValues: true }), rotate: (0, R.default)("rotate", [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", I]]]], { supportsNegativeValues: true }), skew: (0, R.default)("skew", [[["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", I]]], ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", I]]]]], { supportsNegativeValues: true }), scale: (0, R.default)("scale", [["scale", [["@defaults transform", {}], "--tw-scale-x", "--tw-scale-y", ["transform", I]]], [["scale-x", [["@defaults transform", {}], "--tw-scale-x", ["transform", I]]], ["scale-y", [["@defaults transform", {}], "--tw-scale-y", ["transform", I]]]]], { supportsNegativeValues: true }), transform: ({ addDefaults: k, addUtilities: N }) => {
      k("transform", { "--tw-translate-x": "0", "--tw-translate-y": "0", "--tw-rotate": "0", "--tw-skew-x": "0", "--tw-skew-y": "0", "--tw-scale-x": "1", "--tw-scale-y": "1" }), N({ ".transform": { "@defaults transform": {}, transform: I }, ".transform-cpu": { transform: I }, ".transform-gpu": { transform: I.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)") }, ".transform-none": { transform: "none" } });
    }, animation: ({ matchUtilities: k, theme: N, config: F }) => {
      let W = (U) => (0, t.default)(F("prefix") + U);
      var X;
      let H = Object.fromEntries(Object.entries((X = N("keyframes")) !== null && X !== void 0 ? X : {}).map(([U, q]) => [U, { [`@keyframes ${W(U)}`]: q }]));
      k({ animate: (U) => {
        let q = (0, l.default)(U);
        return [...q.flatMap((ee) => H[ee.name]), { animation: q.map(({ name: ee, value: re }) => ee === void 0 || H[ee] === void 0 ? re : re.replace(ee, W(ee))).join(", ") }];
      } }, { values: N("animation") });
    }, cursor: (0, R.default)("cursor"), touchAction: ({ addDefaults: k, addUtilities: N }) => {
      k("touch-action", { "--tw-pan-x": " ", "--tw-pan-y": " ", "--tw-pinch-zoom": " " });
      let F = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
      N({ ".touch-auto": { "touch-action": "auto" }, ".touch-none": { "touch-action": "none" }, ".touch-pan-x": { "@defaults touch-action": {}, "--tw-pan-x": "pan-x", "touch-action": F }, ".touch-pan-left": { "@defaults touch-action": {}, "--tw-pan-x": "pan-left", "touch-action": F }, ".touch-pan-right": { "@defaults touch-action": {}, "--tw-pan-x": "pan-right", "touch-action": F }, ".touch-pan-y": { "@defaults touch-action": {}, "--tw-pan-y": "pan-y", "touch-action": F }, ".touch-pan-up": { "@defaults touch-action": {}, "--tw-pan-y": "pan-up", "touch-action": F }, ".touch-pan-down": { "@defaults touch-action": {}, "--tw-pan-y": "pan-down", "touch-action": F }, ".touch-pinch-zoom": { "@defaults touch-action": {}, "--tw-pinch-zoom": "pinch-zoom", "touch-action": F }, ".touch-manipulation": { "touch-action": "manipulation" } });
    }, userSelect: ({ addUtilities: k }) => {
      k({ ".select-none": { "user-select": "none" }, ".select-text": { "user-select": "text" }, ".select-all": { "user-select": "all" }, ".select-auto": { "user-select": "auto" } });
    }, resize: ({ addUtilities: k }) => {
      k({ ".resize-none": { resize: "none" }, ".resize-y": { resize: "vertical" }, ".resize-x": { resize: "horizontal" }, ".resize": { resize: "both" } });
    }, scrollSnapType: ({ addDefaults: k, addUtilities: N }) => {
      k("scroll-snap-type", { "--tw-scroll-snap-strictness": "proximity" }), N({ ".snap-none": { "scroll-snap-type": "none" }, ".snap-x": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "x var(--tw-scroll-snap-strictness)" }, ".snap-y": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "y var(--tw-scroll-snap-strictness)" }, ".snap-both": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "both var(--tw-scroll-snap-strictness)" }, ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" }, ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" } });
    }, scrollSnapAlign: ({ addUtilities: k }) => {
      k({ ".snap-start": { "scroll-snap-align": "start" }, ".snap-end": { "scroll-snap-align": "end" }, ".snap-center": { "scroll-snap-align": "center" }, ".snap-align-none": { "scroll-snap-align": "none" } });
    }, scrollSnapStop: ({ addUtilities: k }) => {
      k({ ".snap-normal": { "scroll-snap-stop": "normal" }, ".snap-always": { "scroll-snap-stop": "always" } });
    }, scrollMargin: (0, R.default)("scrollMargin", [["scroll-m", ["scroll-margin"]], [["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]], ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]], [["scroll-ms", ["scroll-margin-inline-start"]], ["scroll-me", ["scroll-margin-inline-end"]], ["scroll-mt", ["scroll-margin-top"]], ["scroll-mr", ["scroll-margin-right"]], ["scroll-mb", ["scroll-margin-bottom"]], ["scroll-ml", ["scroll-margin-left"]]]], { supportsNegativeValues: true }), scrollPadding: (0, R.default)("scrollPadding", [["scroll-p", ["scroll-padding"]], [["scroll-px", ["scroll-padding-left", "scroll-padding-right"]], ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]], [["scroll-ps", ["scroll-padding-inline-start"]], ["scroll-pe", ["scroll-padding-inline-end"]], ["scroll-pt", ["scroll-padding-top"]], ["scroll-pr", ["scroll-padding-right"]], ["scroll-pb", ["scroll-padding-bottom"]], ["scroll-pl", ["scroll-padding-left"]]]]), listStylePosition: ({ addUtilities: k }) => {
      k({ ".list-inside": { "list-style-position": "inside" }, ".list-outside": { "list-style-position": "outside" } });
    }, listStyleType: (0, R.default)("listStyleType", [["list", ["listStyleType"]]]), listStyleImage: (0, R.default)("listStyleImage", [["list-image", ["listStyleImage"]]]), appearance: ({ addUtilities: k }) => {
      k({ ".appearance-none": { appearance: "none" }, ".appearance-auto": { appearance: "auto" } });
    }, columns: (0, R.default)("columns", [["columns", ["columns"]]]), breakBefore: ({ addUtilities: k }) => {
      k({ ".break-before-auto": { "break-before": "auto" }, ".break-before-avoid": { "break-before": "avoid" }, ".break-before-all": { "break-before": "all" }, ".break-before-avoid-page": { "break-before": "avoid-page" }, ".break-before-page": { "break-before": "page" }, ".break-before-left": { "break-before": "left" }, ".break-before-right": { "break-before": "right" }, ".break-before-column": { "break-before": "column" } });
    }, breakInside: ({ addUtilities: k }) => {
      k({ ".break-inside-auto": { "break-inside": "auto" }, ".break-inside-avoid": { "break-inside": "avoid" }, ".break-inside-avoid-page": { "break-inside": "avoid-page" }, ".break-inside-avoid-column": { "break-inside": "avoid-column" } });
    }, breakAfter: ({ addUtilities: k }) => {
      k({ ".break-after-auto": { "break-after": "auto" }, ".break-after-avoid": { "break-after": "avoid" }, ".break-after-all": { "break-after": "all" }, ".break-after-avoid-page": { "break-after": "avoid-page" }, ".break-after-page": { "break-after": "page" }, ".break-after-left": { "break-after": "left" }, ".break-after-right": { "break-after": "right" }, ".break-after-column": { "break-after": "column" } });
    }, gridAutoColumns: (0, R.default)("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]), gridAutoFlow: ({ addUtilities: k }) => {
      k({ ".grid-flow-row": { gridAutoFlow: "row" }, ".grid-flow-col": { gridAutoFlow: "column" }, ".grid-flow-dense": { gridAutoFlow: "dense" }, ".grid-flow-row-dense": { gridAutoFlow: "row dense" }, ".grid-flow-col-dense": { gridAutoFlow: "column dense" } });
    }, gridAutoRows: (0, R.default)("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]), gridTemplateColumns: (0, R.default)("gridTemplateColumns", [["grid-cols", ["gridTemplateColumns"]]]), gridTemplateRows: (0, R.default)("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]), flexDirection: ({ addUtilities: k }) => {
      k({ ".flex-row": { "flex-direction": "row" }, ".flex-row-reverse": { "flex-direction": "row-reverse" }, ".flex-col": { "flex-direction": "column" }, ".flex-col-reverse": { "flex-direction": "column-reverse" } });
    }, flexWrap: ({ addUtilities: k }) => {
      k({ ".flex-wrap": { "flex-wrap": "wrap" }, ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" }, ".flex-nowrap": { "flex-wrap": "nowrap" } });
    }, placeContent: ({ addUtilities: k }) => {
      k({ ".place-content-center": { "place-content": "center" }, ".place-content-start": { "place-content": "start" }, ".place-content-end": { "place-content": "end" }, ".place-content-between": { "place-content": "space-between" }, ".place-content-around": { "place-content": "space-around" }, ".place-content-evenly": { "place-content": "space-evenly" }, ".place-content-baseline": { "place-content": "baseline" }, ".place-content-stretch": { "place-content": "stretch" } });
    }, placeItems: ({ addUtilities: k }) => {
      k({ ".place-items-start": { "place-items": "start" }, ".place-items-end": { "place-items": "end" }, ".place-items-center": { "place-items": "center" }, ".place-items-baseline": { "place-items": "baseline" }, ".place-items-stretch": { "place-items": "stretch" } });
    }, alignContent: ({ addUtilities: k }) => {
      k({ ".content-normal": { "align-content": "normal" }, ".content-center": { "align-content": "center" }, ".content-start": { "align-content": "flex-start" }, ".content-end": { "align-content": "flex-end" }, ".content-between": { "align-content": "space-between" }, ".content-around": { "align-content": "space-around" }, ".content-evenly": { "align-content": "space-evenly" }, ".content-baseline": { "align-content": "baseline" }, ".content-stretch": { "align-content": "stretch" } });
    }, alignItems: ({ addUtilities: k }) => {
      k({ ".items-start": { "align-items": "flex-start" }, ".items-end": { "align-items": "flex-end" }, ".items-center": { "align-items": "center" }, ".items-baseline": { "align-items": "baseline" }, ".items-stretch": { "align-items": "stretch" } });
    }, justifyContent: ({ addUtilities: k }) => {
      k({ ".justify-normal": { "justify-content": "normal" }, ".justify-start": { "justify-content": "flex-start" }, ".justify-end": { "justify-content": "flex-end" }, ".justify-center": { "justify-content": "center" }, ".justify-between": { "justify-content": "space-between" }, ".justify-around": { "justify-content": "space-around" }, ".justify-evenly": { "justify-content": "space-evenly" }, ".justify-stretch": { "justify-content": "stretch" } });
    }, justifyItems: ({ addUtilities: k }) => {
      k({ ".justify-items-start": { "justify-items": "start" }, ".justify-items-end": { "justify-items": "end" }, ".justify-items-center": { "justify-items": "center" }, ".justify-items-stretch": { "justify-items": "stretch" } });
    }, gap: (0, R.default)("gap", [["gap", ["gap"]], [["gap-x", ["columnGap"]], ["gap-y", ["rowGap"]]]]), space: ({ matchUtilities: k, addUtilities: N, theme: F }) => {
      k({ "space-x": (W) => (W = W === "0" ? "0px" : W, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "0", "margin-right": `calc(${W} * var(--tw-space-x-reverse))`, "margin-left": `calc(${W} * calc(1 - var(--tw-space-x-reverse)))` } }), "space-y": (W) => (W = W === "0" ? "0px" : W, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "0", "margin-top": `calc(${W} * calc(1 - var(--tw-space-y-reverse)))`, "margin-bottom": `calc(${W} * var(--tw-space-y-reverse))` } }) }, { values: F("space"), supportsNegativeValues: true }), N({ ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" }, ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" } });
    }, divideWidth: ({ matchUtilities: k, addUtilities: N, theme: F }) => {
      k({ "divide-x": (W) => (W = W === "0" ? "0px" : W, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "0", "border-right-width": `calc(${W} * var(--tw-divide-x-reverse))`, "border-left-width": `calc(${W} * calc(1 - var(--tw-divide-x-reverse)))` } }), "divide-y": (W) => (W = W === "0" ? "0px" : W, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "0", "border-top-width": `calc(${W} * calc(1 - var(--tw-divide-y-reverse)))`, "border-bottom-width": `calc(${W} * var(--tw-divide-y-reverse))` } }) }, { values: F("divideWidth"), type: ["line-width", "length", "any"] }), N({ ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "1" }, ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "1" } });
    }, divideStyle: ({ addUtilities: k }) => {
      k({ ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" }, ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" }, ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" }, ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" }, ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" } });
    }, divideColor: ({ matchUtilities: k, theme: N, corePlugins: F }) => {
      k({ divide: (W) => F("divideOpacity") ? { "& > :not([hidden]) ~ :not([hidden])": (0, u.default)({ color: W, property: "border-color", variable: "--tw-divide-opacity" }) } : { "& > :not([hidden]) ~ :not([hidden])": { "border-color": (0, c.default)(W) } } }, { values: (({ DEFAULT: W, ...X }) => X)((0, n.default)(N("divideColor"))), type: ["color", "any"] });
    }, divideOpacity: ({ matchUtilities: k, theme: N }) => {
      k({ "divide-opacity": (F) => ({ "& > :not([hidden]) ~ :not([hidden])": { "--tw-divide-opacity": F } }) }, { values: N("divideOpacity") });
    }, placeSelf: ({ addUtilities: k }) => {
      k({ ".place-self-auto": { "place-self": "auto" }, ".place-self-start": { "place-self": "start" }, ".place-self-end": { "place-self": "end" }, ".place-self-center": { "place-self": "center" }, ".place-self-stretch": { "place-self": "stretch" } });
    }, alignSelf: ({ addUtilities: k }) => {
      k({ ".self-auto": { "align-self": "auto" }, ".self-start": { "align-self": "flex-start" }, ".self-end": { "align-self": "flex-end" }, ".self-center": { "align-self": "center" }, ".self-stretch": { "align-self": "stretch" }, ".self-baseline": { "align-self": "baseline" } });
    }, justifySelf: ({ addUtilities: k }) => {
      k({ ".justify-self-auto": { "justify-self": "auto" }, ".justify-self-start": { "justify-self": "start" }, ".justify-self-end": { "justify-self": "end" }, ".justify-self-center": { "justify-self": "center" }, ".justify-self-stretch": { "justify-self": "stretch" } });
    }, overflow: ({ addUtilities: k }) => {
      k({ ".overflow-auto": { overflow: "auto" }, ".overflow-hidden": { overflow: "hidden" }, ".overflow-clip": { overflow: "clip" }, ".overflow-visible": { overflow: "visible" }, ".overflow-scroll": { overflow: "scroll" }, ".overflow-x-auto": { "overflow-x": "auto" }, ".overflow-y-auto": { "overflow-y": "auto" }, ".overflow-x-hidden": { "overflow-x": "hidden" }, ".overflow-y-hidden": { "overflow-y": "hidden" }, ".overflow-x-clip": { "overflow-x": "clip" }, ".overflow-y-clip": { "overflow-y": "clip" }, ".overflow-x-visible": { "overflow-x": "visible" }, ".overflow-y-visible": { "overflow-y": "visible" }, ".overflow-x-scroll": { "overflow-x": "scroll" }, ".overflow-y-scroll": { "overflow-y": "scroll" } });
    }, overscrollBehavior: ({ addUtilities: k }) => {
      k({ ".overscroll-auto": { "overscroll-behavior": "auto" }, ".overscroll-contain": { "overscroll-behavior": "contain" }, ".overscroll-none": { "overscroll-behavior": "none" }, ".overscroll-y-auto": { "overscroll-behavior-y": "auto" }, ".overscroll-y-contain": { "overscroll-behavior-y": "contain" }, ".overscroll-y-none": { "overscroll-behavior-y": "none" }, ".overscroll-x-auto": { "overscroll-behavior-x": "auto" }, ".overscroll-x-contain": { "overscroll-behavior-x": "contain" }, ".overscroll-x-none": { "overscroll-behavior-x": "none" } });
    }, scrollBehavior: ({ addUtilities: k }) => {
      k({ ".scroll-auto": { "scroll-behavior": "auto" }, ".scroll-smooth": { "scroll-behavior": "smooth" } });
    }, textOverflow: ({ addUtilities: k }) => {
      k({ ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }, ".overflow-ellipsis": { "text-overflow": "ellipsis" }, ".text-ellipsis": { "text-overflow": "ellipsis" }, ".text-clip": { "text-overflow": "clip" } });
    }, hyphens: ({ addUtilities: k }) => {
      k({ ".hyphens-none": { hyphens: "none" }, ".hyphens-manual": { hyphens: "manual" }, ".hyphens-auto": { hyphens: "auto" } });
    }, whitespace: ({ addUtilities: k }) => {
      k({ ".whitespace-normal": { "white-space": "normal" }, ".whitespace-nowrap": { "white-space": "nowrap" }, ".whitespace-pre": { "white-space": "pre" }, ".whitespace-pre-line": { "white-space": "pre-line" }, ".whitespace-pre-wrap": { "white-space": "pre-wrap" }, ".whitespace-break-spaces": { "white-space": "break-spaces" } });
    }, textWrap: ({ addUtilities: k }) => {
      k({ ".text-wrap": { "text-wrap": "wrap" }, ".text-nowrap": { "text-wrap": "nowrap" }, ".text-balance": { "text-wrap": "balance" }, ".text-pretty": { "text-wrap": "pretty" } });
    }, wordBreak: ({ addUtilities: k }) => {
      k({ ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" }, ".break-words": { "overflow-wrap": "break-word" }, ".break-all": { "word-break": "break-all" }, ".break-keep": { "word-break": "keep-all" } });
    }, borderRadius: (0, R.default)("borderRadius", [["rounded", ["border-radius"]], [["rounded-s", ["border-start-start-radius", "border-end-start-radius"]], ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]], ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]], ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]], ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]], ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]], [["rounded-ss", ["border-start-start-radius"]], ["rounded-se", ["border-start-end-radius"]], ["rounded-ee", ["border-end-end-radius"]], ["rounded-es", ["border-end-start-radius"]], ["rounded-tl", ["border-top-left-radius"]], ["rounded-tr", ["border-top-right-radius"]], ["rounded-br", ["border-bottom-right-radius"]], ["rounded-bl", ["border-bottom-left-radius"]]]]), borderWidth: (0, R.default)("borderWidth", [["border", [["@defaults border-width", {}], "border-width"]], [["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]], ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]], [["border-s", [["@defaults border-width", {}], "border-inline-start-width"]], ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]], ["border-t", [["@defaults border-width", {}], "border-top-width"]], ["border-r", [["@defaults border-width", {}], "border-right-width"]], ["border-b", [["@defaults border-width", {}], "border-bottom-width"]], ["border-l", [["@defaults border-width", {}], "border-left-width"]]]], { type: ["line-width", "length"] }), borderStyle: ({ addUtilities: k }) => {
      k({ ".border-solid": { "border-style": "solid" }, ".border-dashed": { "border-style": "dashed" }, ".border-dotted": { "border-style": "dotted" }, ".border-double": { "border-style": "double" }, ".border-hidden": { "border-style": "hidden" }, ".border-none": { "border-style": "none" } });
    }, borderColor: ({ matchUtilities: k, theme: N, corePlugins: F }) => {
      k({ border: (W) => F("borderOpacity") ? (0, u.default)({ color: W, property: "border-color", variable: "--tw-border-opacity" }) : { "border-color": (0, c.default)(W) } }, { values: (({ DEFAULT: W, ...X }) => X)((0, n.default)(N("borderColor"))), type: ["color", "any"] }), k({ "border-x": (W) => F("borderOpacity") ? (0, u.default)({ color: W, property: ["border-left-color", "border-right-color"], variable: "--tw-border-opacity" }) : { "border-left-color": (0, c.default)(W), "border-right-color": (0, c.default)(W) }, "border-y": (W) => F("borderOpacity") ? (0, u.default)({ color: W, property: ["border-top-color", "border-bottom-color"], variable: "--tw-border-opacity" }) : { "border-top-color": (0, c.default)(W), "border-bottom-color": (0, c.default)(W) } }, { values: (({ DEFAULT: W, ...X }) => X)((0, n.default)(N("borderColor"))), type: ["color", "any"] }), k({ "border-s": (W) => F("borderOpacity") ? (0, u.default)({ color: W, property: "border-inline-start-color", variable: "--tw-border-opacity" }) : { "border-inline-start-color": (0, c.default)(W) }, "border-e": (W) => F("borderOpacity") ? (0, u.default)({ color: W, property: "border-inline-end-color", variable: "--tw-border-opacity" }) : { "border-inline-end-color": (0, c.default)(W) }, "border-t": (W) => F("borderOpacity") ? (0, u.default)({ color: W, property: "border-top-color", variable: "--tw-border-opacity" }) : { "border-top-color": (0, c.default)(W) }, "border-r": (W) => F("borderOpacity") ? (0, u.default)({ color: W, property: "border-right-color", variable: "--tw-border-opacity" }) : { "border-right-color": (0, c.default)(W) }, "border-b": (W) => F("borderOpacity") ? (0, u.default)({ color: W, property: "border-bottom-color", variable: "--tw-border-opacity" }) : { "border-bottom-color": (0, c.default)(W) }, "border-l": (W) => F("borderOpacity") ? (0, u.default)({ color: W, property: "border-left-color", variable: "--tw-border-opacity" }) : { "border-left-color": (0, c.default)(W) } }, { values: (({ DEFAULT: W, ...X }) => X)((0, n.default)(N("borderColor"))), type: ["color", "any"] });
    }, borderOpacity: (0, R.default)("borderOpacity", [["border-opacity", ["--tw-border-opacity"]]]), backgroundColor: ({ matchUtilities: k, theme: N, corePlugins: F }) => {
      k({ bg: (W) => F("backgroundOpacity") ? (0, u.default)({ color: W, property: "background-color", variable: "--tw-bg-opacity" }) : { "background-color": (0, c.default)(W) } }, { values: (0, n.default)(N("backgroundColor")), type: ["color", "any"] });
    }, backgroundOpacity: (0, R.default)("backgroundOpacity", [["bg-opacity", ["--tw-bg-opacity"]]]), backgroundImage: (0, R.default)("backgroundImage", [["bg", ["background-image"]]], { type: ["lookup", "image", "url"] }), gradientColorStops: /* @__PURE__ */ (() => {
      function k(N) {
        return (0, u.withAlphaValue)(N, 0, "rgb(255 255 255 / 0)");
      }
      return function({ matchUtilities: N, theme: F, addDefaults: W }) {
        W("gradient-color-stops", { "--tw-gradient-from-position": " ", "--tw-gradient-via-position": " ", "--tw-gradient-to-position": " " });
        let X = { values: (0, n.default)(F("gradientColorStops")), type: ["color", "any"] }, H = { values: F("gradientColorStopPositions"), type: ["length", "percentage"] };
        N({ from: (U) => {
          let q = k(U);
          return { "@defaults gradient-color-stops": {}, "--tw-gradient-from": `${(0, c.default)(U)} var(--tw-gradient-from-position)`, "--tw-gradient-to": `${q} var(--tw-gradient-to-position)`, "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)" };
        } }, X), N({ from: (U) => ({ "--tw-gradient-from-position": U }) }, H), N({ via: (U) => {
          let q = k(U);
          return { "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${q}  var(--tw-gradient-to-position)`, "--tw-gradient-stops": `var(--tw-gradient-from), ${(0, c.default)(U)} var(--tw-gradient-via-position), var(--tw-gradient-to)` };
        } }, X), N({ via: (U) => ({ "--tw-gradient-via-position": U }) }, H), N({ to: (U) => ({ "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${(0, c.default)(U)} var(--tw-gradient-to-position)` }) }, X), N({ to: (U) => ({ "--tw-gradient-to-position": U }) }, H);
      };
    })(), boxDecorationBreak: ({ addUtilities: k }) => {
      k({ ".decoration-slice": { "box-decoration-break": "slice" }, ".decoration-clone": { "box-decoration-break": "clone" }, ".box-decoration-slice": { "box-decoration-break": "slice" }, ".box-decoration-clone": { "box-decoration-break": "clone" } });
    }, backgroundSize: (0, R.default)("backgroundSize", [["bg", ["background-size"]]], { type: ["lookup", "length", "percentage", "size"] }), backgroundAttachment: ({ addUtilities: k }) => {
      k({ ".bg-fixed": { "background-attachment": "fixed" }, ".bg-local": { "background-attachment": "local" }, ".bg-scroll": { "background-attachment": "scroll" } });
    }, backgroundClip: ({ addUtilities: k }) => {
      k({ ".bg-clip-border": { "background-clip": "border-box" }, ".bg-clip-padding": { "background-clip": "padding-box" }, ".bg-clip-content": { "background-clip": "content-box" }, ".bg-clip-text": { "background-clip": "text" } });
    }, backgroundPosition: (0, R.default)("backgroundPosition", [["bg", ["background-position"]]], { type: ["lookup", ["position", { preferOnConflict: true }]] }), backgroundRepeat: ({ addUtilities: k }) => {
      k({ ".bg-repeat": { "background-repeat": "repeat" }, ".bg-no-repeat": { "background-repeat": "no-repeat" }, ".bg-repeat-x": { "background-repeat": "repeat-x" }, ".bg-repeat-y": { "background-repeat": "repeat-y" }, ".bg-repeat-round": { "background-repeat": "round" }, ".bg-repeat-space": { "background-repeat": "space" } });
    }, backgroundOrigin: ({ addUtilities: k }) => {
      k({ ".bg-origin-border": { "background-origin": "border-box" }, ".bg-origin-padding": { "background-origin": "padding-box" }, ".bg-origin-content": { "background-origin": "content-box" } });
    }, fill: ({ matchUtilities: k, theme: N }) => {
      k({ fill: (F) => ({ fill: (0, c.default)(F) }) }, { values: (0, n.default)(N("fill")), type: ["color", "any"] });
    }, stroke: ({ matchUtilities: k, theme: N }) => {
      k({ stroke: (F) => ({ stroke: (0, c.default)(F) }) }, { values: (0, n.default)(N("stroke")), type: ["color", "url", "any"] });
    }, strokeWidth: (0, R.default)("strokeWidth", [["stroke", ["stroke-width"]]], { type: ["length", "number", "percentage"] }), objectFit: ({ addUtilities: k }) => {
      k({ ".object-contain": { "object-fit": "contain" }, ".object-cover": { "object-fit": "cover" }, ".object-fill": { "object-fit": "fill" }, ".object-none": { "object-fit": "none" }, ".object-scale-down": { "object-fit": "scale-down" } });
    }, objectPosition: (0, R.default)("objectPosition", [["object", ["object-position"]]]), padding: (0, R.default)("padding", [["p", ["padding"]], [["px", ["padding-left", "padding-right"]], ["py", ["padding-top", "padding-bottom"]]], [["ps", ["padding-inline-start"]], ["pe", ["padding-inline-end"]], ["pt", ["padding-top"]], ["pr", ["padding-right"]], ["pb", ["padding-bottom"]], ["pl", ["padding-left"]]]]), textAlign: ({ addUtilities: k }) => {
      k({ ".text-left": { "text-align": "left" }, ".text-center": { "text-align": "center" }, ".text-right": { "text-align": "right" }, ".text-justify": { "text-align": "justify" }, ".text-start": { "text-align": "start" }, ".text-end": { "text-align": "end" } });
    }, textIndent: (0, R.default)("textIndent", [["indent", ["text-indent"]]], { supportsNegativeValues: true }), verticalAlign: ({ addUtilities: k, matchUtilities: N }) => {
      k({ ".align-baseline": { "vertical-align": "baseline" }, ".align-top": { "vertical-align": "top" }, ".align-middle": { "vertical-align": "middle" }, ".align-bottom": { "vertical-align": "bottom" }, ".align-text-top": { "vertical-align": "text-top" }, ".align-text-bottom": { "vertical-align": "text-bottom" }, ".align-sub": { "vertical-align": "sub" }, ".align-super": { "vertical-align": "super" } }), N({ align: (F) => ({ "vertical-align": F }) });
    }, fontFamily: ({ matchUtilities: k, theme: N }) => {
      k({ font: (F) => {
        let [W, X = {}] = Array.isArray(F) && (0, e.default)(F[1]) ? F : [F], { fontFeatureSettings: H, fontVariationSettings: U } = X;
        return { "font-family": Array.isArray(W) ? W.join(", ") : W, ...H === void 0 ? {} : { "font-feature-settings": H }, ...U === void 0 ? {} : { "font-variation-settings": U } };
      } }, { values: N("fontFamily"), type: ["lookup", "generic-name", "family-name"] });
    }, fontSize: ({ matchUtilities: k, theme: N }) => {
      k({ text: (F, { modifier: W }) => {
        let [X, H] = Array.isArray(F) ? F : [F];
        if (W) return { "font-size": X, "line-height": W };
        let { lineHeight: U, letterSpacing: q, fontWeight: ee } = (0, e.default)(H) ? H : { lineHeight: H };
        return { "font-size": X, ...U === void 0 ? {} : { "line-height": U }, ...q === void 0 ? {} : { "letter-spacing": q }, ...ee === void 0 ? {} : { "font-weight": ee } };
      } }, { values: N("fontSize"), modifiers: N("lineHeight"), type: ["absolute-size", "relative-size", "length", "percentage"] });
    }, fontWeight: (0, R.default)("fontWeight", [["font", ["fontWeight"]]], { type: ["lookup", "number", "any"] }), textTransform: ({ addUtilities: k }) => {
      k({ ".uppercase": { "text-transform": "uppercase" }, ".lowercase": { "text-transform": "lowercase" }, ".capitalize": { "text-transform": "capitalize" }, ".normal-case": { "text-transform": "none" } });
    }, fontStyle: ({ addUtilities: k }) => {
      k({ ".italic": { "font-style": "italic" }, ".not-italic": { "font-style": "normal" } });
    }, fontVariantNumeric: ({ addDefaults: k, addUtilities: N }) => {
      let F = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
      k("font-variant-numeric", { "--tw-ordinal": " ", "--tw-slashed-zero": " ", "--tw-numeric-figure": " ", "--tw-numeric-spacing": " ", "--tw-numeric-fraction": " " }), N({ ".normal-nums": { "font-variant-numeric": "normal" }, ".ordinal": { "@defaults font-variant-numeric": {}, "--tw-ordinal": "ordinal", "font-variant-numeric": F }, ".slashed-zero": { "@defaults font-variant-numeric": {}, "--tw-slashed-zero": "slashed-zero", "font-variant-numeric": F }, ".lining-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "lining-nums", "font-variant-numeric": F }, ".oldstyle-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "oldstyle-nums", "font-variant-numeric": F }, ".proportional-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "proportional-nums", "font-variant-numeric": F }, ".tabular-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "tabular-nums", "font-variant-numeric": F }, ".diagonal-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "diagonal-fractions", "font-variant-numeric": F }, ".stacked-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "stacked-fractions", "font-variant-numeric": F } });
    }, lineHeight: (0, R.default)("lineHeight", [["leading", ["lineHeight"]]]), letterSpacing: (0, R.default)("letterSpacing", [["tracking", ["letterSpacing"]]], { supportsNegativeValues: true }), textColor: ({ matchUtilities: k, theme: N, corePlugins: F }) => {
      k({ text: (W) => F("textOpacity") ? (0, u.default)({ color: W, property: "color", variable: "--tw-text-opacity" }) : { color: (0, c.default)(W) } }, { values: (0, n.default)(N("textColor")), type: ["color", "any"] });
    }, textOpacity: (0, R.default)("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]), textDecoration: ({ addUtilities: k }) => {
      k({ ".underline": { "text-decoration-line": "underline" }, ".overline": { "text-decoration-line": "overline" }, ".line-through": { "text-decoration-line": "line-through" }, ".no-underline": { "text-decoration-line": "none" } });
    }, textDecorationColor: ({ matchUtilities: k, theme: N }) => {
      k({ decoration: (F) => ({ "text-decoration-color": (0, c.default)(F) }) }, { values: (0, n.default)(N("textDecorationColor")), type: ["color", "any"] });
    }, textDecorationStyle: ({ addUtilities: k }) => {
      k({ ".decoration-solid": { "text-decoration-style": "solid" }, ".decoration-double": { "text-decoration-style": "double" }, ".decoration-dotted": { "text-decoration-style": "dotted" }, ".decoration-dashed": { "text-decoration-style": "dashed" }, ".decoration-wavy": { "text-decoration-style": "wavy" } });
    }, textDecorationThickness: (0, R.default)("textDecorationThickness", [["decoration", ["text-decoration-thickness"]]], { type: ["length", "percentage"] }), textUnderlineOffset: (0, R.default)("textUnderlineOffset", [["underline-offset", ["text-underline-offset"]]], { type: ["length", "percentage", "any"] }), fontSmoothing: ({ addUtilities: k }) => {
      k({ ".antialiased": { "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale" }, ".subpixel-antialiased": { "-webkit-font-smoothing": "auto", "-moz-osx-font-smoothing": "auto" } });
    }, placeholderColor: ({ matchUtilities: k, theme: N, corePlugins: F }) => {
      k({ placeholder: (W) => F("placeholderOpacity") ? { "&::placeholder": (0, u.default)({ color: W, property: "color", variable: "--tw-placeholder-opacity" }) } : { "&::placeholder": { color: (0, c.default)(W) } } }, { values: (0, n.default)(N("placeholderColor")), type: ["color", "any"] });
    }, placeholderOpacity: ({ matchUtilities: k, theme: N }) => {
      k({ "placeholder-opacity": (F) => ({ "&::placeholder": { "--tw-placeholder-opacity": F } }) }, { values: N("placeholderOpacity") });
    }, caretColor: ({ matchUtilities: k, theme: N }) => {
      k({ caret: (F) => ({ "caret-color": (0, c.default)(F) }) }, { values: (0, n.default)(N("caretColor")), type: ["color", "any"] });
    }, accentColor: ({ matchUtilities: k, theme: N }) => {
      k({ accent: (F) => ({ "accent-color": (0, c.default)(F) }) }, { values: (0, n.default)(N("accentColor")), type: ["color", "any"] });
    }, opacity: (0, R.default)("opacity", [["opacity", ["opacity"]]]), backgroundBlendMode: ({ addUtilities: k }) => {
      k({ ".bg-blend-normal": { "background-blend-mode": "normal" }, ".bg-blend-multiply": { "background-blend-mode": "multiply" }, ".bg-blend-screen": { "background-blend-mode": "screen" }, ".bg-blend-overlay": { "background-blend-mode": "overlay" }, ".bg-blend-darken": { "background-blend-mode": "darken" }, ".bg-blend-lighten": { "background-blend-mode": "lighten" }, ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" }, ".bg-blend-color-burn": { "background-blend-mode": "color-burn" }, ".bg-blend-hard-light": { "background-blend-mode": "hard-light" }, ".bg-blend-soft-light": { "background-blend-mode": "soft-light" }, ".bg-blend-difference": { "background-blend-mode": "difference" }, ".bg-blend-exclusion": { "background-blend-mode": "exclusion" }, ".bg-blend-hue": { "background-blend-mode": "hue" }, ".bg-blend-saturation": { "background-blend-mode": "saturation" }, ".bg-blend-color": { "background-blend-mode": "color" }, ".bg-blend-luminosity": { "background-blend-mode": "luminosity" } });
    }, mixBlendMode: ({ addUtilities: k }) => {
      k({ ".mix-blend-normal": { "mix-blend-mode": "normal" }, ".mix-blend-multiply": { "mix-blend-mode": "multiply" }, ".mix-blend-screen": { "mix-blend-mode": "screen" }, ".mix-blend-overlay": { "mix-blend-mode": "overlay" }, ".mix-blend-darken": { "mix-blend-mode": "darken" }, ".mix-blend-lighten": { "mix-blend-mode": "lighten" }, ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" }, ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" }, ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" }, ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" }, ".mix-blend-difference": { "mix-blend-mode": "difference" }, ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" }, ".mix-blend-hue": { "mix-blend-mode": "hue" }, ".mix-blend-saturation": { "mix-blend-mode": "saturation" }, ".mix-blend-color": { "mix-blend-mode": "color" }, ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" }, ".mix-blend-plus-darker": { "mix-blend-mode": "plus-darker" }, ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" } });
    }, boxShadow: (() => {
      let k = (0, r.default)("boxShadow"), N = ["var(--tw-ring-offset-shadow, 0 0 #0000)", "var(--tw-ring-shadow, 0 0 #0000)", "var(--tw-shadow)"].join(", ");
      return function({ matchUtilities: F, addDefaults: W, theme: X }) {
        W("box-shadow", { "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), F({ shadow: (H) => {
          H = k(H);
          let U = (0, T.parseBoxShadowValue)(H);
          for (let q of U) q.valid && (q.color = "var(--tw-shadow-color)");
          return { "@defaults box-shadow": {}, "--tw-shadow": H === "none" ? "0 0 #0000" : H, "--tw-shadow-colored": H === "none" ? "0 0 #0000" : (0, T.formatBoxShadowValue)(U), "box-shadow": N };
        } }, { values: X("boxShadow"), type: ["shadow"] });
      };
    })(), boxShadowColor: ({ matchUtilities: k, theme: N }) => {
      k({ shadow: (F) => ({ "--tw-shadow-color": (0, c.default)(F), "--tw-shadow": "var(--tw-shadow-colored)" }) }, { values: (0, n.default)(N("boxShadowColor")), type: ["color", "any"] });
    }, outlineStyle: ({ addUtilities: k }) => {
      k({ ".outline-none": { outline: "2px solid transparent", "outline-offset": "2px" }, ".outline": { "outline-style": "solid" }, ".outline-dashed": { "outline-style": "dashed" }, ".outline-dotted": { "outline-style": "dotted" }, ".outline-double": { "outline-style": "double" } });
    }, outlineWidth: (0, R.default)("outlineWidth", [["outline", ["outline-width"]]], { type: ["length", "number", "percentage"] }), outlineOffset: (0, R.default)("outlineOffset", [["outline-offset", ["outline-offset"]]], { type: ["length", "number", "percentage", "any"], supportsNegativeValues: true }), outlineColor: ({ matchUtilities: k, theme: N }) => {
      k({ outline: (F) => ({ "outline-color": (0, c.default)(F) }) }, { values: (0, n.default)(N("outlineColor")), type: ["color", "any"] });
    }, ringWidth: ({ matchUtilities: k, addDefaults: N, addUtilities: F, theme: W, config: X }) => {
      let H = (() => {
        var U, q;
        if ((0, p.flagEnabled)(X(), "respectDefaultRingColorOpacity")) return W("ringColor.DEFAULT");
        let ee = W("ringOpacity.DEFAULT", "0.5");
        return !((U = W("ringColor")) === null || U === void 0) && U.DEFAULT ? (0, u.withAlphaValue)((q = W("ringColor")) === null || q === void 0 ? void 0 : q.DEFAULT, ee, `rgb(147 197 253 / ${ee})`) : `rgb(147 197 253 / ${ee})`;
      })();
      N("ring-width", { "--tw-ring-inset": " ", "--tw-ring-offset-width": W("ringOffsetWidth.DEFAULT", "0px"), "--tw-ring-offset-color": W("ringOffsetColor.DEFAULT", "#fff"), "--tw-ring-color": H, "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), k({ ring: (U) => ({ "@defaults ring-width": {}, "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)", "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${U} + var(--tw-ring-offset-width)) var(--tw-ring-color)`, "box-shadow": ["var(--tw-ring-offset-shadow)", "var(--tw-ring-shadow)", "var(--tw-shadow, 0 0 #0000)"].join(", ") }) }, { values: W("ringWidth"), type: "length" }), F({ ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" } });
    }, ringColor: ({ matchUtilities: k, theme: N, corePlugins: F }) => {
      k({ ring: (W) => F("ringOpacity") ? (0, u.default)({ color: W, property: "--tw-ring-color", variable: "--tw-ring-opacity" }) : { "--tw-ring-color": (0, c.default)(W) } }, { values: Object.fromEntries(Object.entries((0, n.default)(N("ringColor"))).filter(([W]) => W !== "DEFAULT")), type: ["color", "any"] });
    }, ringOpacity: (k) => {
      let { config: N } = k;
      return (0, R.default)("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], { filterDefault: !(0, p.flagEnabled)(N(), "respectDefaultRingColorOpacity") })(k);
    }, ringOffsetWidth: (0, R.default)("ringOffsetWidth", [["ring-offset", ["--tw-ring-offset-width"]]], { type: "length" }), ringOffsetColor: ({ matchUtilities: k, theme: N }) => {
      k({ "ring-offset": (F) => ({ "--tw-ring-offset-color": (0, c.default)(F) }) }, { values: (0, n.default)(N("ringOffsetColor")), type: ["color", "any"] });
    }, blur: ({ matchUtilities: k, theme: N }) => {
      k({ blur: (F) => ({ "--tw-blur": F.trim() === "" ? " " : `blur(${F})`, "@defaults filter": {}, filter: D }) }, { values: N("blur") });
    }, brightness: ({ matchUtilities: k, theme: N }) => {
      k({ brightness: (F) => ({ "--tw-brightness": `brightness(${F})`, "@defaults filter": {}, filter: D }) }, { values: N("brightness") });
    }, contrast: ({ matchUtilities: k, theme: N }) => {
      k({ contrast: (F) => ({ "--tw-contrast": `contrast(${F})`, "@defaults filter": {}, filter: D }) }, { values: N("contrast") });
    }, dropShadow: ({ matchUtilities: k, theme: N }) => {
      k({ "drop-shadow": (F) => ({ "--tw-drop-shadow": Array.isArray(F) ? F.map((W) => `drop-shadow(${W})`).join(" ") : `drop-shadow(${F})`, "@defaults filter": {}, filter: D }) }, { values: N("dropShadow") });
    }, grayscale: ({ matchUtilities: k, theme: N }) => {
      k({ grayscale: (F) => ({ "--tw-grayscale": `grayscale(${F})`, "@defaults filter": {}, filter: D }) }, { values: N("grayscale") });
    }, hueRotate: ({ matchUtilities: k, theme: N }) => {
      k({ "hue-rotate": (F) => ({ "--tw-hue-rotate": `hue-rotate(${F})`, "@defaults filter": {}, filter: D }) }, { values: N("hueRotate"), supportsNegativeValues: true });
    }, invert: ({ matchUtilities: k, theme: N }) => {
      k({ invert: (F) => ({ "--tw-invert": `invert(${F})`, "@defaults filter": {}, filter: D }) }, { values: N("invert") });
    }, saturate: ({ matchUtilities: k, theme: N }) => {
      k({ saturate: (F) => ({ "--tw-saturate": `saturate(${F})`, "@defaults filter": {}, filter: D }) }, { values: N("saturate") });
    }, sepia: ({ matchUtilities: k, theme: N }) => {
      k({ sepia: (F) => ({ "--tw-sepia": `sepia(${F})`, "@defaults filter": {}, filter: D }) }, { values: N("sepia") });
    }, filter: ({ addDefaults: k, addUtilities: N }) => {
      k("filter", { "--tw-blur": " ", "--tw-brightness": " ", "--tw-contrast": " ", "--tw-grayscale": " ", "--tw-hue-rotate": " ", "--tw-invert": " ", "--tw-saturate": " ", "--tw-sepia": " ", "--tw-drop-shadow": " " }), N({ ".filter": { "@defaults filter": {}, filter: D }, ".filter-none": { filter: "none" } });
    }, backdropBlur: ({ matchUtilities: k, theme: N }) => {
      k({ "backdrop-blur": (F) => ({ "--tw-backdrop-blur": F.trim() === "" ? " " : `blur(${F})`, "@defaults backdrop-filter": {}, "-webkit-backdrop-filter": j, "backdrop-filter": j }) }, { values: N("backdropBlur") });
    }, backdropBrightness: ({ matchUtilities: k, theme: N }) => {
      k({ "backdrop-brightness": (F) => ({ "--tw-backdrop-brightness": `brightness(${F})`, "@defaults backdrop-filter": {}, "-webkit-backdrop-filter": j, "backdrop-filter": j }) }, { values: N("backdropBrightness") });
    }, backdropContrast: ({ matchUtilities: k, theme: N }) => {
      k({ "backdrop-contrast": (F) => ({ "--tw-backdrop-contrast": `contrast(${F})`, "@defaults backdrop-filter": {}, "-webkit-backdrop-filter": j, "backdrop-filter": j }) }, { values: N("backdropContrast") });
    }, backdropGrayscale: ({ matchUtilities: k, theme: N }) => {
      k({ "backdrop-grayscale": (F) => ({ "--tw-backdrop-grayscale": `grayscale(${F})`, "@defaults backdrop-filter": {}, "-webkit-backdrop-filter": j, "backdrop-filter": j }) }, { values: N("backdropGrayscale") });
    }, backdropHueRotate: ({ matchUtilities: k, theme: N }) => {
      k({ "backdrop-hue-rotate": (F) => ({ "--tw-backdrop-hue-rotate": `hue-rotate(${F})`, "@defaults backdrop-filter": {}, "-webkit-backdrop-filter": j, "backdrop-filter": j }) }, { values: N("backdropHueRotate"), supportsNegativeValues: true });
    }, backdropInvert: ({ matchUtilities: k, theme: N }) => {
      k({ "backdrop-invert": (F) => ({ "--tw-backdrop-invert": `invert(${F})`, "@defaults backdrop-filter": {}, "-webkit-backdrop-filter": j, "backdrop-filter": j }) }, { values: N("backdropInvert") });
    }, backdropOpacity: ({ matchUtilities: k, theme: N }) => {
      k({ "backdrop-opacity": (F) => ({ "--tw-backdrop-opacity": `opacity(${F})`, "@defaults backdrop-filter": {}, "-webkit-backdrop-filter": j, "backdrop-filter": j }) }, { values: N("backdropOpacity") });
    }, backdropSaturate: ({ matchUtilities: k, theme: N }) => {
      k({ "backdrop-saturate": (F) => ({ "--tw-backdrop-saturate": `saturate(${F})`, "@defaults backdrop-filter": {}, "-webkit-backdrop-filter": j, "backdrop-filter": j }) }, { values: N("backdropSaturate") });
    }, backdropSepia: ({ matchUtilities: k, theme: N }) => {
      k({ "backdrop-sepia": (F) => ({ "--tw-backdrop-sepia": `sepia(${F})`, "@defaults backdrop-filter": {}, "-webkit-backdrop-filter": j, "backdrop-filter": j }) }, { values: N("backdropSepia") });
    }, backdropFilter: ({ addDefaults: k, addUtilities: N }) => {
      k("backdrop-filter", { "--tw-backdrop-blur": " ", "--tw-backdrop-brightness": " ", "--tw-backdrop-contrast": " ", "--tw-backdrop-grayscale": " ", "--tw-backdrop-hue-rotate": " ", "--tw-backdrop-invert": " ", "--tw-backdrop-opacity": " ", "--tw-backdrop-saturate": " ", "--tw-backdrop-sepia": " " }), N({ ".backdrop-filter": { "@defaults backdrop-filter": {}, "-webkit-backdrop-filter": j, "backdrop-filter": j }, ".backdrop-filter-none": { "-webkit-backdrop-filter": "none", "backdrop-filter": "none" } });
    }, transitionProperty: ({ matchUtilities: k, theme: N }) => {
      let F = N("transitionTimingFunction.DEFAULT"), W = N("transitionDuration.DEFAULT");
      k({ transition: (X) => ({ "transition-property": X, ...X === "none" ? {} : { "transition-timing-function": F, "transition-duration": W } }) }, { values: N("transitionProperty") });
    }, transitionDelay: (0, R.default)("transitionDelay", [["delay", ["transitionDelay"]]]), transitionDuration: (0, R.default)("transitionDuration", [["duration", ["transitionDuration"]]], { filterDefault: true }), transitionTimingFunction: (0, R.default)("transitionTimingFunction", [["ease", ["transitionTimingFunction"]]], { filterDefault: true }), willChange: (0, R.default)("willChange", [["will-change", ["will-change"]]]), contain: ({ addDefaults: k, addUtilities: N }) => {
      let F = "var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)";
      k("contain", { "--tw-contain-size": " ", "--tw-contain-layout": " ", "--tw-contain-paint": " ", "--tw-contain-style": " " }), N({ ".contain-none": { contain: "none" }, ".contain-content": { contain: "content" }, ".contain-strict": { contain: "strict" }, ".contain-size": { "@defaults contain": {}, "--tw-contain-size": "size", contain: F }, ".contain-inline-size": { "@defaults contain": {}, "--tw-contain-size": "inline-size", contain: F }, ".contain-layout": { "@defaults contain": {}, "--tw-contain-layout": "layout", contain: F }, ".contain-paint": { "@defaults contain": {}, "--tw-contain-paint": "paint", contain: F }, ".contain-style": { "@defaults contain": {}, "--tw-contain-style": "style", contain: F } });
    }, content: (0, R.default)("content", [["content", ["--tw-content", ["content", "var(--tw-content)"]]]]), forcedColorAdjust: ({ addUtilities: k }) => {
      k({ ".forced-color-adjust-auto": { "forced-color-adjust": "auto" }, ".forced-color-adjust-none": { "forced-color-adjust": "none" } });
    } };
  }(Mo)), Mo;
}
var Os = {};
(function(a3) {
  var s = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  function o(c, e) {
    for (var r in e) Object.defineProperty(c, r, { enumerable: true, get: e[r] });
  }
  o(a3, { env: function() {
    return b;
  }, contextMap: function() {
    return A;
  }, configContextMap: function() {
    return R;
  }, contextSourcesMap: function() {
    return P;
  }, sourceHashMap: function() {
    return t;
  }, NOT_ON_DEMAND: function() {
    return l;
  }, NONE: function() {
    return n;
  }, resolveDebug: function() {
    return u;
  } });
  const b = typeof process < "u" ? { NODE_ENV: "production", DEBUG: u(s.DEBUG) } : { NODE_ENV: "production", DEBUG: false }, A = /* @__PURE__ */ new Map(), R = /* @__PURE__ */ new Map(), P = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), l = new String("*"), n = Symbol("__NONE__");
  function u(c) {
    if (c === void 0) return false;
    if (c === "true" || c === "1") return true;
    if (c === "false" || c === "0") return false;
    if (c === "*") return true;
    let e = c.split(",").map((r) => r.split(":")[0]);
    return e.includes("-tailwindcss") ? false : !!e.includes("tailwindcss");
  }
})(Os);
var Xu = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return A;
  } });
  let s = /* @__PURE__ */ new Map([["{", "}"], ["[", "]"], ["(", ")"]]), o = new Map(Array.from(s.entries()).map(([R, P]) => [P, R])), b = /* @__PURE__ */ new Set(['"', "'", "`"]);
  function A(R) {
    let P = [], t = false;
    for (let l = 0; l < R.length; l++) {
      let n = R[l];
      if (n === ":" && !t && P.length === 0) return false;
      if (b.has(n) && R[l - 1] !== "\\" && (t = !t), !t && R[l - 1] !== "\\") {
        if (s.has(n)) P.push(n);
        else if (o.has(n)) {
          let u = o.get(n);
          if (P.length <= 0 || P.pop() !== u) return false;
        }
      }
    }
    return !(P.length > 0);
  }
})(Xu);
var Bo = {}, Ju = {}, to = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "movePseudos", { enumerable: true, get: function() {
    return o;
  } });
  let s = { "::after": ["terminal", "jumpable"], "::backdrop": ["terminal", "jumpable"], "::before": ["terminal", "jumpable"], "::cue": ["terminal"], "::cue-region": ["terminal"], "::first-letter": ["terminal", "jumpable"], "::first-line": ["terminal", "jumpable"], "::grammar-error": ["terminal"], "::marker": ["terminal", "jumpable"], "::part": ["terminal", "actionable"], "::placeholder": ["terminal", "jumpable"], "::selection": ["terminal", "jumpable"], "::slotted": ["terminal"], "::spelling-error": ["terminal"], "::target-text": ["terminal"], "::file-selector-button": ["terminal", "actionable"], "::deep": ["actionable"], "::v-deep": ["actionable"], "::ng-deep": ["actionable"], ":after": ["terminal", "jumpable"], ":before": ["terminal", "jumpable"], ":first-letter": ["terminal", "jumpable"], ":first-line": ["terminal", "jumpable"], ":where": [], ":is": [], ":has": [], __default__: ["terminal", "actionable"] };
  function o(l) {
    let [n] = b(l);
    return n.forEach(([u, c]) => u.removeChild(c)), l.nodes.push(...n.map(([, u]) => u)), l;
  }
  function b(l) {
    let n = [], u = null;
    for (let e of l.nodes) if (e.type === "combinator") n = n.filter(([, r]) => t(r).includes("jumpable")), u = null;
    else if (e.type === "pseudo") {
      R(e) ? (u = e, n.push([l, e, null])) : u && P(e, u) ? n.push([l, e, u]) : u = null;
      var c;
      for (let r of (c = e.nodes) !== null && c !== void 0 ? c : []) {
        let [f, y] = b(r);
        u = y || u, n.push(...f);
      }
    }
    return [n, u];
  }
  function A(l) {
    return l.value.startsWith("::") || s[l.value] !== void 0;
  }
  function R(l) {
    return A(l) && t(l).includes("terminal");
  }
  function P(l, n) {
    return l.type !== "pseudo" || A(l) ? false : t(n).includes("actionable");
  }
  function t(l) {
    var n;
    return (n = s[l.value]) !== null && n !== void 0 ? n : s.__default__;
  }
})(to);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(S, T) {
    for (var d in T) Object.defineProperty(S, d, { enumerable: true, get: T[d] });
  }
  s(a3, { formatVariantSelector: function() {
    return u;
  }, eliminateIrrelevantSelectors: function() {
    return r;
  }, finalizeSelector: function() {
    return f;
  }, handleMergePseudo: function() {
    return y;
  } });
  const o = l(as), b = l(ju), A = l(Js), R = l(Qa), P = to, t = Is;
  function l(S) {
    return S && S.__esModule ? S : { default: S };
  }
  let n = ":merge";
  function u(S, { context: T, candidate: d }) {
    var p;
    let h = (p = T == null ? void 0 : T.tailwindConfig.prefix) !== null && p !== void 0 ? p : "", m = S.map((_) => {
      let C = (0, o.default)().astSync(_.format);
      return { ..._, ast: _.respectPrefix ? (0, R.default)(h, C) : C };
    }), E = o.default.root({ nodes: [o.default.selector({ nodes: [o.default.className({ value: (0, A.default)(d) })] })] });
    for (let { ast: _ } of m) [E, _] = y(E, _), _.walkNesting((C) => C.replaceWith(...E.nodes[0].nodes)), E = _;
    return E;
  }
  function c(S) {
    let T = [];
    for (; S.prev() && S.prev().type !== "combinator"; ) S = S.prev();
    for (; S && S.type !== "combinator"; ) T.push(S), S = S.next();
    return T;
  }
  function e(S) {
    return S.sort((T, d) => T.type === "tag" && d.type === "class" ? -1 : T.type === "class" && d.type === "tag" ? 1 : T.type === "class" && d.type === "pseudo" && d.value.startsWith("::") ? -1 : T.type === "pseudo" && T.value.startsWith("::") && d.type === "class" ? 1 : S.index(T) - S.index(d)), S;
  }
  function r(S, T) {
    let d = false;
    S.walk((p) => {
      if (p.type === "class" && p.value === T) return d = true, false;
    }), d || S.remove();
  }
  function f(S, T, { context: d, candidate: p, base: h }) {
    var m, E;
    let _ = (E = d == null || (m = d.tailwindConfig) === null || m === void 0 ? void 0 : m.separator) !== null && E !== void 0 ? E : ":";
    h = h ?? (0, t.splitAtTopLevelOnly)(p, _).pop();
    let C = (0, o.default)().astSync(S);
    if (C.walkClasses((j) => {
      j.raws && j.value.includes(h) && (j.raws.value = (0, A.default)((0, b.default)(j.raws.value)));
    }), C.each((j) => r(j, h)), C.length === 0) return null;
    let w = Array.isArray(T) ? u(T, { context: d, candidate: p }) : T;
    if (w === null) return C.toString();
    let I = o.default.comment({ value: "/*__simple__*/" }), D = o.default.comment({ value: "/*__simple__*/" });
    return C.walkClasses((j) => {
      if (j.value !== h) return;
      let L = j.parent, k = w.nodes[0].nodes;
      if (L.nodes.length === 1) {
        j.replaceWith(...k);
        return;
      }
      let N = c(j);
      L.insertBefore(N[0], I), L.insertAfter(N[N.length - 1], D);
      for (let W of k) L.insertBefore(N[0], W.clone());
      j.remove(), N = c(I);
      let F = L.index(I);
      L.nodes.splice(F, N.length, ...e(o.default.selector({ nodes: N })).nodes), I.remove(), D.remove();
    }), C.walkPseudos((j) => {
      j.value === n && j.replaceWith(j.nodes);
    }), C.each((j) => (0, P.movePseudos)(j)), C.toString();
  }
  function y(S, T) {
    let d = [];
    return S.walkPseudos((p) => {
      p.value === n && d.push({ pseudo: p, value: p.nodes[0].toString() });
    }), T.walkPseudos((p) => {
      if (p.value !== n) return;
      let h = p.nodes[0].toString(), m = d.find((w) => w.value === h);
      if (!m) return;
      let E = [], _ = p.next();
      for (; _ && _.type !== "combinator"; ) E.push(_), _ = _.next();
      let C = _;
      m.pseudo.parent.insertAfter(m.pseudo, o.default.selector({ nodes: E.map((w) => w.clone()) })), p.remove(), E.forEach((w) => w.remove()), C && C.type === "combinator" && C.remove();
    }), [S, T];
  }
})(Ju);
var Qu = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "applyImportantSelector", { enumerable: true, get: function() {
    return A;
  } });
  const s = b(as), o = to;
  function b(R) {
    return R && R.__esModule ? R : { default: R };
  }
  function A(R, P) {
    let t = (0, s.default)().astSync(R);
    return t.each((l) => {
      l.nodes.some((u) => u.type === "combinator") && (l.nodes = [s.default.pseudo({ value: ":is", nodes: [l.clone()] })]), (0, o.movePseudos)(l);
    }), `${P} ${t.toString()}`;
  }
})(Qu);
var Zp;
function Zu() {
  return Zp || (Zp = 1, function(a3) {
    Object.defineProperty(a3, "__esModule", { value: true });
    function s(B, z) {
      for (var M in z) Object.defineProperty(B, M, { enumerable: true, get: z[M] });
    }
    s(a3, { getClassNameFromSelector: function() {
      return E;
    }, resolveMatches: function() {
      return q;
    }, generateRules: function() {
      return Z;
    } });
    const o = d(Lr), b = d(as), A = d(Wu), R = d(Xs), P = d(Qa), t = Pi, l = d(xr), n = h(Os), u = Ju, c = Yu, e = Ai, r = no(), f = d(Xu), y = Is, S = is, T = Qu;
    function d(B) {
      return B && B.__esModule ? B : { default: B };
    }
    function p(B) {
      if (typeof WeakMap != "function") return null;
      var z = /* @__PURE__ */ new WeakMap(), M = /* @__PURE__ */ new WeakMap();
      return (p = function(K) {
        return K ? M : z;
      })(B);
    }
    function h(B, z) {
      if (B && B.__esModule) return B;
      if (B === null || typeof B != "object" && typeof B != "function") return { default: B };
      var M = p(z);
      if (M && M.has(B)) return M.get(B);
      var K = {}, Q = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var ie in B) if (ie !== "default" && Object.prototype.hasOwnProperty.call(B, ie)) {
        var ue = Q ? Object.getOwnPropertyDescriptor(B, ie) : null;
        ue && (ue.get || ue.set) ? Object.defineProperty(K, ie, ue) : K[ie] = B[ie];
      }
      return K.default = B, M && M.set(B, K), K;
    }
    let m = (0, b.default)((B) => B.first.filter(({ type: z }) => z === "class").pop().value);
    function E(B) {
      return m.transformSync(B);
    }
    function* _(B) {
      let z = 1 / 0;
      for (; z >= 0; ) {
        let M, K = false;
        if (z === 1 / 0 && B.endsWith("]")) {
          let ue = B.indexOf("[");
          B[ue - 1] === "-" ? M = ue - 1 : B[ue - 1] === "/" ? (M = ue - 1, K = true) : M = -1;
        } else z === 1 / 0 && B.includes("/") ? (M = B.lastIndexOf("/"), K = true) : M = B.lastIndexOf("-", z);
        if (M < 0) break;
        let Q = B.slice(0, M), ie = B.slice(K ? M : M + 1);
        z = M - 1, !(Q === "" || ie === "/") && (yield [Q, ie]);
      }
    }
    function C(B, z) {
      if (B.length === 0 || z.tailwindConfig.prefix === "") return B;
      for (let M of B) {
        let [K] = M;
        if (K.options.respectPrefix) {
          let Q = o.default.root({ nodes: [M[1].clone()] }), ie = M[1].raws.tailwind.classCandidate;
          Q.walkRules((ue) => {
            let ge = ie.startsWith("-");
            ue.selector = (0, P.default)(z.tailwindConfig.prefix, ue.selector, ge);
          }), M[1] = Q.nodes[0];
        }
      }
      return B;
    }
    function w(B, z) {
      if (B.length === 0) return B;
      let M = [];
      function K(Q) {
        return Q.parent && Q.parent.type === "atrule" && Q.parent.name === "keyframes";
      }
      for (let [Q, ie] of B) {
        let ue = o.default.root({ nodes: [ie.clone()] });
        ue.walkRules((ge) => {
          if (K(ge)) return;
          let Te = (0, b.default)().astSync(ge.selector);
          Te.each((le) => (0, u.eliminateIrrelevantSelectors)(le, z)), (0, t.updateAllClasses)(Te, (le) => le === z ? `!${le}` : le), ge.selector = Te.toString(), ge.walkDecls((le) => le.important = true);
        }), M.push([{ ...Q, important: true }, ue.nodes[0]]);
      }
      return M;
    }
    function I(B, z, M) {
      if (z.length === 0) return z;
      let K = { modifier: null, value: n.NONE };
      {
        let [ge, ...Te] = (0, y.splitAtTopLevelOnly)(B, "/");
        if (Te.length > 1 && (ge = ge + "/" + Te.slice(0, -1).join("/"), Te = Te.slice(-1)), Te.length && !M.variantMap.has(B) && (B = ge, K.modifier = Te[0], !(0, S.flagEnabled)(M.tailwindConfig, "generalizedModifiers"))) return [];
      }
      if (B.endsWith("]") && !B.startsWith("[")) {
        let ge = /(.)(-?)\[(.*)\]/g.exec(B);
        if (ge) {
          let [, Te, le, fe] = ge;
          if (Te === "@" && le === "-") return [];
          if (Te !== "@" && le === "") return [];
          B = B.replace(`${le}[${fe}]`, ""), K.value = fe;
        }
      }
      if (G(B) && !M.variantMap.has(B)) {
        let ge = M.offsets.recordVariant(B), Te = (0, e.normalize)(B.slice(1, -1)), le = (0, y.splitAtTopLevelOnly)(Te, ",");
        if (le.length > 1) return [];
        if (!le.every(r.isValidVariantFormatString)) return [];
        let fe = le.map((Pe, xe) => [M.offsets.applyParallelOffset(ge, xe), (0, r.parseVariant)(Pe.trim())]);
        M.variantMap.set(B, fe);
      }
      if (M.variantMap.has(B)) {
        var Q;
        let ge = G(B);
        var ie;
        let Te = (ie = (Q = M.variantOptions.get(B)) === null || Q === void 0 ? void 0 : Q[r.INTERNAL_FEATURES]) !== null && ie !== void 0 ? ie : {}, le = M.variantMap.get(B).slice(), fe = [], Pe = !(ge || Te.respectPrefix === false);
        for (let [xe, we] of z) {
          if (xe.layer === "user") continue;
          let me = o.default.root({ nodes: [we.clone()] });
          for (let [ye, pe, J] of le) {
            let Ue = function() {
              Ee.raws.neededBackup || (Ee.raws.neededBackup = true, Ee.walkRules((Re) => Re.raws.originalSelector = Re.selector));
            }, qe = function(Re) {
              return Ue(), Ee.each((Be) => {
                Be.type === "rule" && (Be.selectors = Be.selectors.map((je) => Re({ get className() {
                  return E(je);
                }, selector: je })));
              }), Ee;
            }, Ee = (J ?? me).clone(), Me = [], He = pe({ get container() {
              return Ue(), Ee;
            }, separator: M.tailwindConfig.separator, modifySelectors: qe, wrap(Re) {
              let Be = Ee.nodes;
              Ee.removeAll(), Re.append(Be), Ee.append(Re);
            }, format(Re) {
              Me.push({ format: Re, respectPrefix: Pe });
            }, args: K });
            if (Array.isArray(He)) {
              for (let [Re, Be] of He.entries()) le.push([M.offsets.applyParallelOffset(ye, Re), Be, Ee.clone()]);
              continue;
            }
            if (typeof He == "string" && Me.push({ format: He, respectPrefix: Pe }), He === null) continue;
            Ee.raws.neededBackup && (delete Ee.raws.neededBackup, Ee.walkRules((Re) => {
              let Be = Re.raws.originalSelector;
              if (!Be || (delete Re.raws.originalSelector, Be === Re.selector)) return;
              let je = Re.selector, he = (0, b.default)((oe) => {
                oe.walkClasses((_e) => {
                  _e.value = `${B}${M.tailwindConfig.separator}${_e.value}`;
                });
              }).processSync(Be);
              Me.push({ format: je.replace(he, "&"), respectPrefix: Pe }), Re.selector = Be;
            })), Ee.nodes[0].raws.tailwind = { ...Ee.nodes[0].raws.tailwind, parentLayer: xe.layer };
            var ue;
            let Ie = [{ ...xe, sort: M.offsets.applyVariantOffset(xe.sort, ye, Object.assign(K, M.variantOptions.get(B))), collectedFormats: ((ue = xe.collectedFormats) !== null && ue !== void 0 ? ue : []).concat(Me) }, Ee.nodes[0]];
            fe.push(Ie);
          }
        }
        return fe;
      }
      return [];
    }
    function D(B, z, M = {}) {
      return !(0, R.default)(B) && !Array.isArray(B) ? [[B], M] : Array.isArray(B) ? D(B[0], z, B[1]) : (z.has(B) || z.set(B, (0, A.default)(B)), [z.get(B), M]);
    }
    const j = /^[a-z_-]/;
    function L(B) {
      return j.test(B);
    }
    function k(B) {
      if (!B.includes("://")) return false;
      try {
        const z = new URL(B);
        return z.scheme !== "" && z.host !== "";
      } catch {
        return false;
      }
    }
    function N(B) {
      let z = true;
      return B.walkDecls((M) => {
        if (!F(M.prop, M.value)) return z = false, false;
      }), z;
    }
    function F(B, z) {
      if (k(`${B}:${z}`)) return false;
      try {
        return o.default.parse(`a{${B}:${z}}`).toResult(), true;
      } catch {
        return false;
      }
    }
    function W(B, z) {
      var M;
      let [, K, Q] = (M = B.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && M !== void 0 ? M : [];
      if (Q === void 0 || !L(K) || !(0, f.default)(Q)) return null;
      let ie = (0, e.normalize)(Q, { property: K });
      return F(K, ie) ? [[{ sort: z.offsets.arbitraryProperty(B), layer: "utilities", options: { respectImportant: true } }, () => ({ [(0, c.asClass)(B)]: { [K]: ie } })]] : null;
    }
    function* X(B, z) {
      z.candidateRuleMap.has(B) && (yield [z.candidateRuleMap.get(B), "DEFAULT"]), yield* function* (ge) {
        ge !== null && (yield [ge, "DEFAULT"]);
      }(W(B, z));
      let M = B, K = false;
      const Q = z.tailwindConfig.prefix, ie = Q.length, ue = M.startsWith(Q) || M.startsWith(`-${Q}`);
      M[ie] === "-" && ue && (K = true, M = Q + M.slice(ie + 1)), K && z.candidateRuleMap.has(M) && (yield [z.candidateRuleMap.get(M), "-DEFAULT"]);
      for (let [ge, Te] of _(M)) z.candidateRuleMap.has(ge) && (yield [z.candidateRuleMap.get(ge), K ? `-${Te}` : Te]);
    }
    function H(B, z) {
      return B === n.NOT_ON_DEMAND ? [n.NOT_ON_DEMAND] : (0, y.splitAtTopLevelOnly)(B, z);
    }
    function* U(B, z) {
      for (const Q of B) {
        var M, K;
        Q[1].raws.tailwind = { ...Q[1].raws.tailwind, classCandidate: z, preserveSource: (K = (M = Q[0].options) === null || M === void 0 ? void 0 : M.preserveSource) !== null && K !== void 0 ? K : false }, yield Q;
      }
    }
    function* q(B, z) {
      let M = z.tailwindConfig.separator, [K, ...Q] = H(B, M).reverse(), ie = false;
      K.startsWith("!") && (ie = true, K = K.slice(1));
      for (let Pe of X(K, z)) {
        let xe = [], we = /* @__PURE__ */ new Map(), [me, ye] = Pe, pe = me.length === 1;
        for (let [J, Ee] of me) {
          let Me = [];
          if (typeof Ee == "function") for (let Ue of [].concat(Ee(ye, { isOnlyPlugin: pe }))) {
            let [qe, He] = D(Ue, z.postCssNodeCache);
            for (let Ie of qe) Me.push([{ ...J, options: { ...J.options, ...He } }, Ie]);
          }
          else if (ye === "DEFAULT" || ye === "-DEFAULT") {
            let Ue = Ee, [qe, He] = D(Ue, z.postCssNodeCache);
            for (let Ie of qe) Me.push([{ ...J, options: { ...J.options, ...He } }, Ie]);
          }
          if (Me.length > 0) {
            var ue, ge, Te;
            let Ue = Array.from((0, t.getMatchingTypes)((ge = (ue = J.options) === null || ue === void 0 ? void 0 : ue.types) !== null && ge !== void 0 ? ge : [], ye, (Te = J.options) !== null && Te !== void 0 ? Te : {}, z.tailwindConfig)).map(([qe, He]) => He);
            Ue.length > 0 && we.set(Me, Ue), xe.push(Me);
          }
        }
        if (G(ye)) {
          if (xe.length > 1) {
            let Me = function(qe) {
              return qe.length === 1 ? qe[0] : qe.find((He) => {
                let Ie = we.get(He);
                return He.some(([{ options: Re }, Be]) => N(Be) ? Re.types.some(({ type: je, preferOnConflict: he }) => Ie.includes(je) && he) : false);
              });
            }, [J, Ee] = xe.reduce((qe, He) => (He.some(([{ options: Re }]) => Re.types.some(({ type: Be }) => Be === "any")) ? qe[0].push(He) : qe[1].push(He), qe), [[], []]);
            var le;
            let Ue = (le = Me(Ee)) !== null && le !== void 0 ? le : Me(J);
            if (Ue) xe = [Ue];
            else {
              var fe;
              let qe = xe.map((Ie) => /* @__PURE__ */ new Set([...(fe = we.get(Ie)) !== null && fe !== void 0 ? fe : []]));
              for (let Ie of qe) for (let Re of Ie) {
                let Be = false;
                for (let je of qe) Ie !== je && je.has(Re) && (je.delete(Re), Be = true);
                Be && Ie.delete(Re);
              }
              let He = [];
              for (let [Ie, Re] of qe.entries()) for (let Be of Re) {
                let je = xe[Ie].map(([, he]) => he).flat().map((he) => he.toString().split(`
`).slice(1, -1).map((oe) => oe.trim()).map((oe) => `      ${oe}`).join(`
`)).join(`

`);
                He.push(`  Use \`${B.replace("[", `[${Be}:`)}\` for \`${je.trim()}\``);
                break;
              }
              l.default.warn([`The class \`${B}\` is ambiguous and matches multiple utilities.`, ...He, `If this is content and not a class, replace it with \`${B.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`]);
              continue;
            }
          }
          xe = xe.map((J) => J.filter((Ee) => N(Ee[1])));
        }
        xe = xe.flat(), xe = Array.from(U(xe, K)), xe = C(xe, z), ie && (xe = w(xe, K));
        for (let J of Q) xe = I(J, xe, z);
        for (let J of xe) J[1].raws.tailwind = { ...J[1].raws.tailwind, candidate: B }, J = ee(J, { context: z, candidate: B }), J !== null && (yield J);
      }
    }
    function ee(B, { context: z, candidate: M }) {
      if (!B[0].collectedFormats) return B;
      let K = true, Q;
      try {
        Q = (0, u.formatVariantSelector)(B[0].collectedFormats, { context: z, candidate: M });
      } catch {
        return null;
      }
      let ie = o.default.root({ nodes: [B[1].clone()] });
      return ie.walkRules((ue) => {
        if (!re(ue)) try {
          let ge = (0, u.finalizeSelector)(ue.selector, Q, { candidate: M, context: z });
          if (ge === null) {
            ue.remove();
            return;
          }
          ue.selector = ge;
        } catch {
          return K = false, false;
        }
      }), !K || ie.nodes.length === 0 ? null : (B[1] = ie.nodes[0], B);
    }
    function re(B) {
      return B.parent && B.parent.type === "atrule" && B.parent.name === "keyframes";
    }
    function Y(B) {
      if (B === true) return (z) => {
        re(z) || z.walkDecls((M) => {
          M.parent.type === "rule" && !re(M.parent) && (M.important = true);
        });
      };
      if (typeof B == "string") return (z) => {
        re(z) || (z.selectors = z.selectors.map((M) => (0, T.applyImportantSelector)(M, B)));
      };
    }
    function Z(B, z, M = false) {
      let K = [], Q = Y(z.tailwindConfig.important);
      for (let ue of B) {
        if (z.notClassCache.has(ue)) continue;
        if (z.candidateRuleCache.has(ue)) {
          K = K.concat(Array.from(z.candidateRuleCache.get(ue)));
          continue;
        }
        let ge = Array.from(q(ue, z));
        if (ge.length === 0) {
          z.notClassCache.add(ue);
          continue;
        }
        z.classCache.set(ue, ge);
        var ie;
        let Te = (ie = z.candidateRuleCache.get(ue)) !== null && ie !== void 0 ? ie : /* @__PURE__ */ new Set();
        z.candidateRuleCache.set(ue, Te);
        for (const le of ge) {
          let [{ sort: fe, options: Pe }, xe] = le;
          if (Pe.respectImportant && Q) {
            let me = o.default.root({ nodes: [xe.clone()] });
            me.walkRules(Q), xe = me.nodes[0];
          }
          let we = [fe, M ? xe.clone() : xe];
          Te.add(we), z.ruleCache.add(we), K.push(we);
        }
      }
      return K;
    }
    function G(B) {
      return B.startsWith("[") && B.endsWith("]");
    }
  }(Bo)), Bo;
}
var Mh = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "hasContentChanged", { enumerable: true, get: function() {
    return t;
  } });
  const s = b(gt), o = R(Os);
  function b(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function A(l) {
    if (typeof WeakMap != "function") return null;
    var n = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
    return (A = function(c) {
      return c ? u : n;
    })(l);
  }
  function R(l, n) {
    if (l && l.__esModule) return l;
    if (l === null || typeof l != "object" && typeof l != "function") return { default: l };
    var u = A(n);
    if (u && u.has(l)) return u.get(l);
    var c = {}, e = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var r in l) if (r !== "default" && Object.prototype.hasOwnProperty.call(l, r)) {
      var f = e ? Object.getOwnPropertyDescriptor(l, r) : null;
      f && (f.get || f.set) ? Object.defineProperty(c, r, f) : c[r] = l[r];
    }
    return c.default = l, u && u.set(l, c), c;
  }
  function P(l) {
    try {
      return s.default.createHash("md5").update(l, "utf-8").digest("binary");
    } catch {
      return "";
    }
  }
  function t(l, n) {
    let u = n.toString();
    if (!u.includes("@tailwind")) return false;
    let c = o.sourceHashMap.get(l), e = P(u), r = c !== e;
    return o.sourceHashMap.set(l, e), r;
  }
})(Mh);
var Bh = {}, $h = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  function s(o) {
    return (o > 0n) - (o < 0n);
  }
})($h);
var Uh = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "remapBitfield", { enumerable: true, get: function() {
    return s;
  } });
  function s(o, b) {
    let A = 0n, R = 0n;
    for (let [P, t] of b) o & P && (A = A | P, R = R | t);
    return o & ~A | R;
  }
})(Uh);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "Offsets", { enumerable: true, get: function() {
    return A;
  } });
  const s = b($h), o = Uh;
  function b(t) {
    return t && t.__esModule ? t : { default: t };
  }
  class A {
    constructor() {
      this.offsets = { defaults: 0n, base: 0n, components: 0n, utilities: 0n, variants: 0n, user: 0n }, this.layerPositions = { defaults: 0n, base: 1n, components: 2n, utilities: 3n, user: 4n, variants: 5n }, this.reservedVariantBits = 0n, this.variantOffsets = /* @__PURE__ */ new Map();
    }
    create(l) {
      return { layer: l, parentLayer: l, arbitrary: 0n, variants: 0n, parallelIndex: 0n, index: this.offsets[l]++, propertyOffset: 0n, property: "", options: [] };
    }
    arbitraryProperty(l) {
      return { ...this.create("utilities"), arbitrary: 1n, property: l };
    }
    forVariant(l, n = 0) {
      let u = this.variantOffsets.get(l);
      if (u === void 0) throw new Error(`Cannot find offset for unknown variant ${l}`);
      return { ...this.create("variants"), variants: u << BigInt(n) };
    }
    applyVariantOffset(l, n, u) {
      return u.variant = n.variants, { ...l, layer: "variants", parentLayer: l.layer === "variants" ? l.parentLayer : l.layer, variants: l.variants | n.variants, options: u.sort ? [].concat(u, l.options) : l.options, parallelIndex: R([l.parallelIndex, n.parallelIndex]) };
    }
    applyParallelOffset(l, n) {
      return { ...l, parallelIndex: BigInt(n) };
    }
    recordVariants(l, n) {
      for (let u of l) this.recordVariant(u, n(u));
    }
    recordVariant(l, n = 1) {
      return this.variantOffsets.set(l, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(n), { ...this.create("variants"), variants: this.variantOffsets.get(l) };
    }
    compare(l, n) {
      if (l.layer !== n.layer) return this.layerPositions[l.layer] - this.layerPositions[n.layer];
      if (l.parentLayer !== n.parentLayer) return this.layerPositions[l.parentLayer] - this.layerPositions[n.parentLayer];
      for (let c of l.options) for (let e of n.options) {
        if (c.id !== e.id || !c.sort || !e.sort) continue;
        var u;
        let r = (u = R([c.variant, e.variant])) !== null && u !== void 0 ? u : 0n, f = ~(r | r - 1n), y = l.variants & f, S = n.variants & f;
        if (y !== S) continue;
        let T = c.sort({ value: c.value, modifier: c.modifier }, { value: e.value, modifier: e.modifier });
        if (T !== 0) return T;
      }
      return l.variants !== n.variants ? l.variants - n.variants : l.parallelIndex !== n.parallelIndex ? l.parallelIndex - n.parallelIndex : l.arbitrary !== n.arbitrary ? l.arbitrary - n.arbitrary : l.propertyOffset !== n.propertyOffset ? l.propertyOffset - n.propertyOffset : l.index - n.index;
    }
    recalculateVariantOffsets() {
      let l = Array.from(this.variantOffsets.entries()).filter(([c]) => c.startsWith("[")).sort(([c], [e]) => P(c, e)), n = l.map(([, c]) => c).sort((c, e) => (0, s.default)(c - e));
      return l.map(([, c], e) => [c, n[e]]).filter(([c, e]) => c !== e);
    }
    remapArbitraryVariantOffsets(l) {
      let n = this.recalculateVariantOffsets();
      return n.length === 0 ? l : l.map((u) => {
        let [c, e] = u;
        return c = { ...c, variants: (0, o.remapBitfield)(c.variants, n) }, [c, e];
      });
    }
    sortArbitraryProperties(l) {
      let n = /* @__PURE__ */ new Set();
      for (let [r] of l) r.arbitrary === 1n && n.add(r.property);
      if (n.size === 0) return l;
      let u = Array.from(n).sort(), c = /* @__PURE__ */ new Map(), e = 1n;
      for (let r of u) c.set(r, e++);
      return l.map((r) => {
        let [f, y] = r;
        var S;
        return f = { ...f, propertyOffset: (S = c.get(f.property)) !== null && S !== void 0 ? S : 0n }, [f, y];
      });
    }
    sort(l) {
      return l = this.remapArbitraryVariantOffsets(l), l = this.sortArbitraryProperties(l), l.sort(([n], [u]) => (0, s.default)(this.compare(n, u)));
    }
  }
  function R(t) {
    let l = null;
    for (const n of t) l = l ?? n, l = l > n ? l : n;
    return l;
  }
  function P(t, l) {
    let n = t.length, u = l.length, c = n < u ? n : u;
    for (let e = 0; e < c; e++) {
      let r = t.charCodeAt(e) - l.charCodeAt(e);
      if (r !== 0) return r;
    }
    return n - u;
  }
})(Bh);
var ed;
function no() {
  return ed || (ed = 1, function(a3) {
    Object.defineProperty(a3, "__esModule", { value: true });
    function s(me, ye) {
      for (var pe in ye) Object.defineProperty(me, pe, { enumerable: true, get: ye[pe] });
    }
    s(a3, { INTERNAL_FEATURES: function() {
      return j;
    }, isValidVariantFormatString: function() {
      return Y;
    }, parseVariant: function() {
      return Z;
    }, getFileModifiedMap: function() {
      return z;
    }, createContext: function() {
      return le;
    }, getContext: function() {
      return we;
    } });
    const o = w(gt), b = w(gt), A = w(Lr), R = w(uh), P = w(as), t = w(ki), l = w(Wu), n = w(Qa), u = w(Xs), c = w(Js), e = D(Yu), r = Pi, f = fE(), y = D(Os), S = Ha, T = w(xr), d = w(Wa), p = w(Xu), h = Zu(), m = Mh, E = Bh, _ = is, C = Ju;
    function w(me) {
      return me && me.__esModule ? me : { default: me };
    }
    function I(me) {
      if (typeof WeakMap != "function") return null;
      var ye = /* @__PURE__ */ new WeakMap(), pe = /* @__PURE__ */ new WeakMap();
      return (I = function(J) {
        return J ? pe : ye;
      })(me);
    }
    function D(me, ye) {
      if (me && me.__esModule) return me;
      if (me === null || typeof me != "object" && typeof me != "function") return { default: me };
      var pe = I(ye);
      if (pe && pe.has(me)) return pe.get(me);
      var J = {}, Ee = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var Me in me) if (Me !== "default" && Object.prototype.hasOwnProperty.call(me, Me)) {
        var Ue = Ee ? Object.getOwnPropertyDescriptor(me, Me) : null;
        Ue && (Ue.get || Ue.set) ? Object.defineProperty(J, Me, Ue) : J[Me] = me[Me];
      }
      return J.default = me, pe && pe.set(me, J), J;
    }
    const j = Symbol(), L = { MatchVariant: Symbol.for("MATCH_VARIANT") }, k = { Base: 1, Dynamic: 2 };
    function N(me, ye) {
      let pe = me.tailwindConfig.prefix;
      return typeof pe == "function" ? pe(ye) : pe + ye;
    }
    function F({ type: me = "any", ...ye }) {
      let pe = [].concat(me);
      return { ...ye, types: pe.map((J) => Array.isArray(J) ? { type: J[0], ...J[1] } : { type: J, preferOnConflict: false }) };
    }
    function W(me) {
      let ye = [], pe = "", J = 0;
      for (let Ee = 0; Ee < me.length; Ee++) {
        let Me = me[Ee];
        if (Me === "\\") pe += "\\" + me[++Ee];
        else if (Me === "{") ++J, ye.push(pe.trim()), pe = "";
        else if (Me === "}") {
          if (--J < 0) throw new Error("Your { and } are unbalanced.");
          ye.push(pe.trim()), pe = "";
        } else pe += Me;
      }
      return pe.length > 0 && ye.push(pe.trim()), ye = ye.filter((Ee) => Ee !== ""), ye;
    }
    function X(me, ye, { before: pe = [] } = {}) {
      if (pe = [].concat(pe), pe.length <= 0) {
        me.push(ye);
        return;
      }
      let J = me.length - 1;
      for (let Ee of pe) {
        let Me = me.indexOf(Ee);
        Me !== -1 && (J = Math.min(J, Me));
      }
      me.splice(J, 0, ye);
    }
    function H(me) {
      return Array.isArray(me) ? me.flatMap((ye) => !Array.isArray(ye) && !(0, u.default)(ye) ? ye : (0, l.default)(ye)) : H([me]);
    }
    function U(me, ye) {
      return (0, P.default)((J) => {
        let Ee = [];
        return ye && ye(J), J.walkClasses((Me) => {
          Ee.push(Me.value);
        }), Ee;
      }).transformSync(me);
    }
    function q(me) {
      me.walkPseudos((ye) => {
        ye.value === ":not" && ye.remove();
      });
    }
    function ee(me, ye = { containsNonOnDemandable: false }, pe = 0) {
      let J = [], Ee = [];
      me.type === "rule" ? Ee.push(...me.selectors) : me.type === "atrule" && me.walkRules((Me) => Ee.push(...Me.selectors));
      for (let Me of Ee) {
        let Ue = U(Me, q);
        Ue.length === 0 && (ye.containsNonOnDemandable = true);
        for (let qe of Ue) J.push(qe);
      }
      return pe === 0 ? [ye.containsNonOnDemandable || J.length === 0, J] : J;
    }
    function re(me) {
      return H(me).flatMap((ye) => {
        let pe = /* @__PURE__ */ new Map(), [J, Ee] = ee(ye);
        return J && Ee.unshift(y.NOT_ON_DEMAND), Ee.map((Me) => (pe.has(ye) || pe.set(ye, ye), [Me, pe.get(ye)]));
      });
    }
    function Y(me) {
      return me.startsWith("@") || me.includes("&");
    }
    function Z(me) {
      me = me.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
      let ye = W(me).map((pe) => {
        if (!pe.startsWith("@")) return ({ format: Ue }) => Ue(pe);
        let [, J, Ee] = /@(\S*)( .+|[({].*)?/g.exec(pe);
        var Me;
        return ({ wrap: Ue }) => Ue(A.default.atRule({ name: J, params: (Me = Ee == null ? void 0 : Ee.trim()) !== null && Me !== void 0 ? Me : "" }));
      }).reverse();
      return (pe) => {
        for (let J of ye) J(pe);
      };
    }
    function G(me, ye, { variantList: pe, variantMap: J, offsets: Ee, classList: Me }) {
      function Ue(je, he) {
        return je ? (0, R.default)(me, je, he) : me;
      }
      function qe(je) {
        return (0, n.default)(me.prefix, je);
      }
      function He(je, he) {
        return je === y.NOT_ON_DEMAND ? y.NOT_ON_DEMAND : he.respectPrefix ? ye.tailwindConfig.prefix + je : je;
      }
      function Ie(je, he, oe = {}) {
        let _e = (0, S.toPath)(je), Ne = Ue(["theme", ..._e], he);
        return (0, t.default)(_e[0])(Ne, oe);
      }
      let Re = 0, Be = { postcss: A.default, prefix: qe, e: c.default, config: Ue, theme: Ie, corePlugins: (je) => Array.isArray(me.corePlugins) ? me.corePlugins.includes(je) : Ue(["corePlugins", je], true), variants: () => [], addBase(je) {
        for (let [he, oe] of re(je)) {
          let _e = He(he, {}), Ne = Ee.create("base");
          ye.candidateRuleMap.has(_e) || ye.candidateRuleMap.set(_e, []), ye.candidateRuleMap.get(_e).push([{ sort: Ne, layer: "base" }, oe]);
        }
      }, addDefaults(je, he) {
        const oe = { [`@defaults ${je}`]: he };
        for (let [_e, Ne] of re(oe)) {
          let $e = He(_e, {});
          ye.candidateRuleMap.has($e) || ye.candidateRuleMap.set($e, []), ye.candidateRuleMap.get($e).push([{ sort: Ee.create("defaults"), layer: "defaults" }, Ne]);
        }
      }, addComponents(je, he) {
        he = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: false }, Array.isArray(he) ? {} : he);
        for (let [_e, Ne] of re(je)) {
          let $e = He(_e, he);
          Me.add($e), ye.candidateRuleMap.has($e) || ye.candidateRuleMap.set($e, []), ye.candidateRuleMap.get($e).push([{ sort: Ee.create("components"), layer: "components", options: he }, Ne]);
        }
      }, addUtilities(je, he) {
        he = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: true }, Array.isArray(he) ? {} : he);
        for (let [_e, Ne] of re(je)) {
          let $e = He(_e, he);
          Me.add($e), ye.candidateRuleMap.has($e) || ye.candidateRuleMap.set($e, []), ye.candidateRuleMap.get($e).push([{ sort: Ee.create("utilities"), layer: "utilities", options: he }, Ne]);
        }
      }, matchUtilities: function(je, he) {
        he = F({ ...{ respectPrefix: true, respectImportant: true, modifiers: false }, ...he });
        let _e = Ee.create("utilities");
        for (let Ne in je) {
          let Je = function(be, { isOnlyPlugin: ke }) {
            let [Ve, ze, rt] = (0, r.coerceValue)(he.types, be, he, me);
            if (Ve === void 0) return [];
            if (!he.types.some(({ type: pt }) => pt === ze)) if (ke) T.default.warn([`Unnecessary typehint \`${ze}\` in \`${Ne}-${be}\`.`, `You can safely update it to \`${Ne}-${be.replace(ze + ":", "")}\`.`]);
            else return [];
            if (!(0, p.default)(Ve)) return [];
            let it = { get modifier() {
              return he.modifiers || T.default.warn(`modifier-used-without-options-for-${Ne}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), rt;
            } }, Ye = (0, _.flagEnabled)(me, "generalizedModifiers");
            return [].concat(Ye ? Xe(Ve, it) : Xe(Ve)).filter(Boolean).map((pt) => ({ [(0, e.default)(Ne, be)]: pt }));
          }, $e = He(Ne, he), Xe = je[Ne];
          Me.add([$e, he]);
          let st = [{ sort: _e, layer: "utilities", options: he }, Je];
          ye.candidateRuleMap.has($e) || ye.candidateRuleMap.set($e, []), ye.candidateRuleMap.get($e).push(st);
        }
      }, matchComponents: function(je, he) {
        he = F({ ...{ respectPrefix: true, respectImportant: false, modifiers: false }, ...he });
        let _e = Ee.create("components");
        for (let Ne in je) {
          let Je = function(be, { isOnlyPlugin: ke }) {
            let [Ve, ze, rt] = (0, r.coerceValue)(he.types, be, he, me);
            if (Ve === void 0) return [];
            if (!he.types.some(({ type: pt }) => pt === ze)) if (ke) T.default.warn([`Unnecessary typehint \`${ze}\` in \`${Ne}-${be}\`.`, `You can safely update it to \`${Ne}-${be.replace(ze + ":", "")}\`.`]);
            else return [];
            if (!(0, p.default)(Ve)) return [];
            let it = { get modifier() {
              return he.modifiers || T.default.warn(`modifier-used-without-options-for-${Ne}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), rt;
            } }, Ye = (0, _.flagEnabled)(me, "generalizedModifiers");
            return [].concat(Ye ? Xe(Ve, it) : Xe(Ve)).filter(Boolean).map((pt) => ({ [(0, e.default)(Ne, be)]: pt }));
          }, $e = He(Ne, he), Xe = je[Ne];
          Me.add([$e, he]);
          let st = [{ sort: _e, layer: "components", options: he }, Je];
          ye.candidateRuleMap.has($e) || ye.candidateRuleMap.set($e, []), ye.candidateRuleMap.get($e).push(st);
        }
      }, addVariant(je, he, oe = {}) {
        he = [].concat(he).map((_e) => {
          if (typeof _e != "string") return (Ne = {}) => {
            let { args: $e, modifySelectors: Xe, container: Je, separator: st, wrap: be, format: ke } = Ne, Ve = _e(Object.assign({ modifySelectors: Xe, container: Je, separator: st }, oe.type === L.MatchVariant && { args: $e, wrap: be, format: ke }));
            if (typeof Ve == "string" && !Y(Ve)) throw new Error(`Your custom variant \`${je}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
            return Array.isArray(Ve) ? Ve.filter((ze) => typeof ze == "string").map((ze) => Z(ze)) : Ve && typeof Ve == "string" && Z(Ve)(Ne);
          };
          if (!Y(_e)) throw new Error(`Your custom variant \`${je}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
          return Z(_e);
        }), X(pe, je, oe), J.set(je, he), ye.variantOptions.set(je, oe);
      }, matchVariant(je, he, oe) {
        var _e;
        let Ne = (_e = oe == null ? void 0 : oe.id) !== null && _e !== void 0 ? _e : ++Re, $e = je === "@", Xe = (0, _.flagEnabled)(me, "generalizedModifiers");
        var Je;
        for (let [ke, Ve] of Object.entries((Je = oe == null ? void 0 : oe.values) !== null && Je !== void 0 ? Je : {})) ke !== "DEFAULT" && Be.addVariant($e ? `${je}${ke}` : `${je}-${ke}`, ({ args: ze, container: rt }) => he(Ve, Xe ? { modifier: ze == null ? void 0 : ze.modifier, container: rt } : { container: rt }), { ...oe, value: Ve, id: Ne, type: L.MatchVariant, variantInfo: k.Base });
        var st;
        let be = "DEFAULT" in ((st = oe == null ? void 0 : oe.values) !== null && st !== void 0 ? st : {});
        Be.addVariant(je, ({ args: ke, container: Ve }) => {
          if ((ke == null ? void 0 : ke.value) === y.NONE && !be) return null;
          var ze;
          return he((ke == null ? void 0 : ke.value) === y.NONE ? oe.values.DEFAULT : (ze = ke == null ? void 0 : ke.value) !== null && ze !== void 0 ? ze : typeof ke == "string" ? ke : "", Xe ? { modifier: ke == null ? void 0 : ke.modifier, container: Ve } : { container: Ve });
        }, { ...oe, id: Ne, type: L.MatchVariant, variantInfo: k.Dynamic });
      } };
      return Be;
    }
    let B = /* @__PURE__ */ new WeakMap();
    function z(me) {
      return B.has(me) || B.set(me, /* @__PURE__ */ new Map()), B.get(me);
    }
    function M(me, ye) {
      let pe = false, J = /* @__PURE__ */ new Map();
      for (let Me of me) {
        var Ee;
        if (!Me) continue;
        let Ue = b.default.parse(Me), qe = Ue.hash ? Ue.href.replace(Ue.hash, "") : Ue.href;
        qe = Ue.search ? qe.replace(Ue.search, "") : qe;
        let He = (Ee = o.default.statSync(decodeURIComponent(qe), { throwIfNoEntry: false })) === null || Ee === void 0 ? void 0 : Ee.mtimeMs;
        He && ((!ye.has(Me) || He > ye.get(Me)) && (pe = true), J.set(Me, He));
      }
      return [pe, J];
    }
    function K(me) {
      me.walkAtRules((ye) => {
        ["responsive", "variants"].includes(ye.name) && (K(ye), ye.before(ye.nodes), ye.remove());
      });
    }
    function Q(me) {
      let ye = [];
      return me.each((pe) => {
        pe.type === "atrule" && ["responsive", "variants"].includes(pe.name) && (pe.name = "layer", pe.params = "utilities");
      }), me.walkAtRules("layer", (pe) => {
        if (K(pe), pe.params === "base") {
          for (let J of pe.nodes) ye.push(function({ addBase: Ee }) {
            Ee(J, { respectPrefix: false });
          });
          pe.remove();
        } else if (pe.params === "components") {
          for (let J of pe.nodes) ye.push(function({ addComponents: Ee }) {
            Ee(J, { respectPrefix: false, preserveSource: true });
          });
          pe.remove();
        } else if (pe.params === "utilities") {
          for (let J of pe.nodes) ye.push(function({ addUtilities: Ee }) {
            Ee(J, { respectPrefix: false, preserveSource: true });
          });
          pe.remove();
        }
      }), ye;
    }
    function ie(me, ye) {
      let pe = Object.entries({ ...f.variantPlugins, ...f.corePlugins }).map(([He, Ie]) => me.tailwindConfig.corePlugins.includes(He) ? Ie : null).filter(Boolean), J = me.tailwindConfig.plugins.map((He) => (He.__isOptionsFunction && (He = He()), typeof He == "function" ? He : He.handler)), Ee = Q(ye), Me = [f.variantPlugins.childVariant, f.variantPlugins.pseudoElementVariants, f.variantPlugins.pseudoClassVariants, f.variantPlugins.hasVariants, f.variantPlugins.ariaVariants, f.variantPlugins.dataVariants], Ue = [f.variantPlugins.supportsVariants, f.variantPlugins.reducedMotionVariants, f.variantPlugins.prefersContrastVariants, f.variantPlugins.screenVariants, f.variantPlugins.orientationVariants, f.variantPlugins.directionVariants, f.variantPlugins.darkVariants, f.variantPlugins.forcedColorsVariants, f.variantPlugins.printVariant];
      return (me.tailwindConfig.darkMode === "class" || Array.isArray(me.tailwindConfig.darkMode) && me.tailwindConfig.darkMode[0] === "class") && (Ue = [f.variantPlugins.supportsVariants, f.variantPlugins.reducedMotionVariants, f.variantPlugins.prefersContrastVariants, f.variantPlugins.darkVariants, f.variantPlugins.screenVariants, f.variantPlugins.orientationVariants, f.variantPlugins.directionVariants, f.variantPlugins.forcedColorsVariants, f.variantPlugins.printVariant]), [...pe, ...Me, ...J, ...Ue, ...Ee];
    }
    function ue(me, ye) {
      let pe = [], J = /* @__PURE__ */ new Map();
      ye.variantMap = J;
      let Ee = new E.Offsets();
      ye.offsets = Ee;
      let Me = /* @__PURE__ */ new Set(), Ue = G(ye.tailwindConfig, ye, { variantList: pe, variantMap: J, offsets: Ee, classList: Me });
      for (let he of me) if (Array.isArray(he)) for (let oe of he) oe(Ue);
      else he == null ? void 0 : he(Ue);
      Ee.recordVariants(pe, (he) => J.get(he).length);
      for (let [he, oe] of J.entries()) ye.variantMap.set(he, oe.map((_e, Ne) => [Ee.forVariant(he, Ne), _e]));
      var qe;
      let He = ((qe = ye.tailwindConfig.safelist) !== null && qe !== void 0 ? qe : []).filter(Boolean);
      if (He.length > 0) {
        let he = [];
        for (let oe of He) {
          if (typeof oe == "string") {
            ye.changedContent.push({ content: oe, extension: "html" });
            continue;
          }
          if (oe instanceof RegExp) {
            T.default.warn("root-regex", ["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.", "Update your `safelist` configuration to eliminate this warning.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
            continue;
          }
          he.push(oe);
        }
        if (he.length > 0) {
          let oe = /* @__PURE__ */ new Map(), _e = ye.tailwindConfig.prefix.length, Ne = he.some(($e) => $e.pattern.source.includes("!"));
          for (let $e of Me) {
            let Xe = Array.isArray($e) ? (() => {
              let [Je, st] = $e;
              var be;
              let Ve = Object.keys((be = st == null ? void 0 : st.values) !== null && be !== void 0 ? be : {}).map((ze) => (0, e.formatClass)(Je, ze));
              return (st == null ? void 0 : st.supportsNegativeValues) && (Ve = [...Ve, ...Ve.map((ze) => "-" + ze)], Ve = [...Ve, ...Ve.map((ze) => ze.slice(0, _e) + "-" + ze.slice(_e))]), st.types.some(({ type: ze }) => ze === "color") && (Ve = [...Ve, ...Ve.flatMap((ze) => Object.keys(ye.tailwindConfig.theme.opacity).map((rt) => `${ze}/${rt}`))]), Ne && (st == null ? void 0 : st.respectImportant) && (Ve = [...Ve, ...Ve.map((ze) => "!" + ze)]), Ve;
            })() : [$e];
            for (let Je of Xe) for (let { pattern: st, variants: be = [] } of he) if (st.lastIndex = 0, oe.has(st) || oe.set(st, 0), !!st.test(Je)) {
              oe.set(st, oe.get(st) + 1), ye.changedContent.push({ content: Je, extension: "html" });
              for (let ke of be) ye.changedContent.push({ content: ke + ye.tailwindConfig.separator + Je, extension: "html" });
            }
          }
          for (let [$e, Xe] of oe.entries()) Xe === 0 && T.default.warn([`The safelist pattern \`${$e}\` doesn't match any Tailwind CSS classes.`, "Fix this pattern or remove it from your `safelist` configuration.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
        }
      }
      var Ie, Re;
      let Be = (Re = [].concat((Ie = ye.tailwindConfig.darkMode) !== null && Ie !== void 0 ? Ie : "media")[1]) !== null && Re !== void 0 ? Re : "dark", je = [N(ye, Be), N(ye, "group"), N(ye, "peer")];
      ye.getClassOrder = function(oe) {
        let _e = [...oe].sort((st, be) => st === be ? 0 : st < be ? -1 : 1), Ne = new Map(_e.map((st) => [st, null])), $e = (0, h.generateRules)(new Set(_e), ye, true);
        $e = ye.offsets.sort($e);
        let Xe = BigInt(je.length);
        for (const [, st] of $e) {
          let be = st.raws.tailwind.candidate;
          var Je;
          Ne.set(be, (Je = Ne.get(be)) !== null && Je !== void 0 ? Je : Xe++);
        }
        return oe.map((st) => {
          var be;
          let ke = (be = Ne.get(st)) !== null && be !== void 0 ? be : null, Ve = je.indexOf(st);
          return ke === null && Ve !== -1 && (ke = BigInt(Ve)), [st, ke];
        });
      }, ye.getClassList = function(oe = {}) {
        let _e = [];
        for (let st of Me) if (Array.isArray(st)) {
          var Ne;
          let [be, ke] = st, Ve = [];
          var $e;
          let ze = Object.keys(($e = ke == null ? void 0 : ke.modifiers) !== null && $e !== void 0 ? $e : {});
          if (!(ke == null || (Ne = ke.types) === null || Ne === void 0) && Ne.some(({ type: Ye }) => Ye === "color")) {
            var Xe;
            ze.push(...Object.keys((Xe = ye.tailwindConfig.theme.opacity) !== null && Xe !== void 0 ? Xe : {}));
          }
          let rt = { modifiers: ze }, it = oe.includeMetadata && ze.length > 0;
          var Je;
          for (let [Ye, tt] of Object.entries((Je = ke == null ? void 0 : ke.values) !== null && Je !== void 0 ? Je : {})) {
            if (tt == null) continue;
            let pt = (0, e.formatClass)(be, Ye);
            if (_e.push(it ? [pt, rt] : pt), (ke == null ? void 0 : ke.supportsNegativeValues) && (0, d.default)(tt)) {
              let Et = (0, e.formatClass)(be, `-${Ye}`);
              Ve.push(it ? [Et, rt] : Et);
            }
          }
          _e.push(...Ve);
        } else _e.push(st);
        return _e;
      }, ye.getVariants = function() {
        let oe = Math.random().toString(36).substring(7).toUpperCase(), _e = [];
        for (let [$e, Xe] of ye.variantOptions.entries()) if (Xe.variantInfo !== k.Base) {
          var Ne;
          _e.push({ name: $e, isArbitrary: Xe.type === Symbol.for("MATCH_VARIANT"), values: Object.keys((Ne = Xe.values) !== null && Ne !== void 0 ? Ne : {}), hasDash: $e !== "@", selectors({ modifier: Je, value: st } = {}) {
            let be = `TAILWINDPLACEHOLDER${oe}`, ke = A.default.rule({ selector: `.${be}` }), Ve = A.default.root({ nodes: [ke.clone()] }), ze = Ve.toString();
            var rt;
            let it = ((rt = ye.variantMap.get($e)) !== null && rt !== void 0 ? rt : []).flatMap(([Kt, Jt]) => Jt), Ye = [];
            for (let Kt of it) {
              var tt;
              let Jt = [];
              var pt;
              let Ft = { args: { modifier: Je, value: (pt = (tt = Xe.values) === null || tt === void 0 ? void 0 : tt[st]) !== null && pt !== void 0 ? pt : st }, separator: ye.tailwindConfig.separator, modifySelectors(_t) {
                return Ve.each((Xn) => {
                  Xn.type === "rule" && (Xn.selectors = Xn.selectors.map((Jn) => _t({ get className() {
                    return (0, h.getClassNameFromSelector)(Jn);
                  }, selector: Jn })));
                }), Ve;
              }, format(_t) {
                Jt.push(_t);
              }, wrap(_t) {
                Jt.push(`@${_t.name} ${_t.params} { & }`);
              }, container: Ve }, fn = Kt(Ft);
              if (Jt.length > 0 && Ye.push(Jt), Array.isArray(fn)) for (let _t of fn) Jt = [], _t(Ft), Ye.push(Jt);
            }
            let Et = [], Qe = Ve.toString();
            ze !== Qe && (Ve.walkRules((Kt) => {
              let Jt = Kt.selector, Ft = (0, P.default)((fn) => {
                fn.walkClasses((_t) => {
                  _t.value = `${$e}${ye.tailwindConfig.separator}${_t.value}`;
                });
              }).processSync(Jt);
              Et.push(Jt.replace(Ft, "&").replace(be, "&"));
            }), Ve.walkAtRules((Kt) => {
              Et.push(`@${Kt.name} (${Kt.params}) { & }`);
            }));
            var yt;
            let vt = !(st in ((yt = Xe.values) !== null && yt !== void 0 ? yt : {}));
            var kt;
            let qt = (kt = Xe[j]) !== null && kt !== void 0 ? kt : {}, sn = !(vt || qt.respectPrefix === false);
            Ye = Ye.map((Kt) => Kt.map((Jt) => ({ format: Jt, respectPrefix: sn }))), Et = Et.map((Kt) => ({ format: Kt, respectPrefix: sn }));
            let _n = { candidate: be, context: ye }, bn = Ye.map((Kt) => (0, C.finalizeSelector)(`.${be}`, (0, C.formatVariantSelector)(Kt, _n), _n).replace(`.${be}`, "&").replace("{ & }", "").trim());
            return Et.length > 0 && bn.push((0, C.formatVariantSelector)(Et, _n).toString().replace(`.${be}`, "&")), bn;
          } });
        }
        return _e;
      };
    }
    function ge(me, ye) {
      me.classCache.has(ye) && (me.notClassCache.add(ye), me.classCache.delete(ye), me.applyClassCache.delete(ye), me.candidateRuleMap.delete(ye), me.candidateRuleCache.delete(ye), me.stylesheetCache = null);
    }
    function Te(me, ye) {
      let pe = ye.raws.tailwind.candidate;
      if (pe) {
        for (const J of me.ruleCache) J[1].raws.tailwind.candidate === pe && me.ruleCache.delete(J);
        ge(me, pe);
      }
    }
    function le(me, ye = [], pe = A.default.root()) {
      var J;
      let Ee = { disposables: [], ruleCache: /* @__PURE__ */ new Set(), candidateRuleCache: /* @__PURE__ */ new Map(), classCache: /* @__PURE__ */ new Map(), applyClassCache: /* @__PURE__ */ new Map(), notClassCache: new Set((J = me.blocklist) !== null && J !== void 0 ? J : []), postCssNodeCache: /* @__PURE__ */ new Map(), candidateRuleMap: /* @__PURE__ */ new Map(), tailwindConfig: me, changedContent: ye, variantMap: /* @__PURE__ */ new Map(), stylesheetCache: null, variantOptions: /* @__PURE__ */ new Map(), markInvalidUtilityCandidate: (Ue) => ge(Ee, Ue), markInvalidUtilityNode: (Ue) => Te(Ee, Ue) }, Me = ie(Ee, pe);
      return ue(Me, Ee), Ee;
    }
    let fe = y.contextMap, Pe = y.configContextMap, xe = y.contextSourcesMap;
    function we(me, ye, pe, J, Ee, Me) {
      let Ue = ye.opts.from, qe = J !== null;
      y.env.DEBUG && console.log("Source path:", Ue);
      let He;
      if (qe && fe.has(Ue)) He = fe.get(Ue);
      else if (Pe.has(Ee)) {
        let je = Pe.get(Ee);
        xe.get(je).add(Ue), fe.set(Ue, je), He = je;
      }
      let Ie = (0, m.hasContentChanged)(Ue, me);
      if (He) {
        let [je, he] = M([...Me], z(He));
        if (!je && !Ie) return [He, false, he];
      }
      if (fe.has(Ue)) {
        let je = fe.get(Ue);
        if (xe.has(je) && (xe.get(je).delete(Ue), xe.get(je).size === 0)) {
          xe.delete(je);
          for (let [he, oe] of Pe) oe === je && Pe.delete(he);
          for (let he of je.disposables.splice(0)) he(je);
        }
      }
      y.env.DEBUG && console.log("Setting up new context...");
      let Re = le(pe, [], me);
      Object.assign(Re, { userConfigPath: J });
      let [, Be] = M([...Me], z(Re));
      return Pe.set(Ee, Re), fe.set(Ue, Re), xe.has(Re) || xe.set(Re, /* @__PURE__ */ new Set()), xe.get(Re).add(Ue), [Re, true, Be];
    }
  }(Io)), Io;
}
var Vh = {};
(function(a3) {
  var s = {};
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return o;
  } });
  function o(b) {
    return b.ignore ? [] : b.glob ? s.ROLLUP_WATCH === "true" ? [{ type: "dependency", file: b.base }] : [{ type: "dir-dependency", dir: b.base, glob: b.glob }] : [{ type: "dependency", file: b.base }];
  }
})(Vh);
var Wh = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "validateConfig", { enumerable: true, get: function() {
    return b;
  } });
  const s = o(xr);
  function o(A) {
    return A && A.__esModule ? A : { default: A };
  }
  function b(A) {
    A.content.files.length === 0 && s.default.warn("content-problems", ["The `content` option in your Tailwind CSS configuration is missing or empty.", "Configure your content sources or your generated CSS will be missing styles.", "https://tailwindcss.com/docs/content-configuration"]);
    try {
      let R = require("@tailwindcss/line-clamp");
      A.plugins.includes(R) && (s.default.warn("line-clamp-in-core", ["As of Tailwind CSS v3.3, the `@tailwindcss/line-clamp` plugin is now included by default.", "Remove it from the `plugins` array in your configuration to eliminate this warning."]), A.plugins = A.plugins.filter((P) => P !== R));
    } catch {
    }
    return A;
  }
})(Wh);
var Hh = {};
/*!
* is-extglob <https://github.com/jonschlinkert/is-extglob>
*
* Copyright (c) 2014-2016, Jon Schlinkert.
* Licensed under the MIT License.
*/
var hE = function(s) {
  if (typeof s != "string" || s === "") return false;
  for (var o; o = /(\\).|([@?!+*]\(.*\))/g.exec(s); ) {
    if (o[2]) return true;
    s = s.slice(o.index + o[0].length);
  }
  return false;
};
/*!
* is-glob <https://github.com/jonschlinkert/is-glob>
*
* Copyright (c) 2014-2017, Jon Schlinkert.
* Released under the MIT License.
*/
var mE = hE, Gh = { "{": "}", "(": ")", "[": "]" }, yE = function(a3) {
  if (a3[0] === "!") return true;
  for (var s = 0, o = -2, b = -2, A = -2, R = -2, P = -2; s < a3.length; ) {
    if (a3[s] === "*" || a3[s + 1] === "?" && /[\].+)]/.test(a3[s]) || b !== -1 && a3[s] === "[" && a3[s + 1] !== "]" && (b < s && (b = a3.indexOf("]", s)), b > s && (P === -1 || P > b || (P = a3.indexOf("\\", s), P === -1 || P > b))) || A !== -1 && a3[s] === "{" && a3[s + 1] !== "}" && (A = a3.indexOf("}", s), A > s && (P = a3.indexOf("\\", s), P === -1 || P > A)) || R !== -1 && a3[s] === "(" && a3[s + 1] === "?" && /[:!=]/.test(a3[s + 2]) && a3[s + 3] !== ")" && (R = a3.indexOf(")", s), R > s && (P = a3.indexOf("\\", s), P === -1 || P > R)) || o !== -1 && a3[s] === "(" && a3[s + 1] !== "|" && (o < s && (o = a3.indexOf("|", s)), o !== -1 && a3[o + 1] !== ")" && (R = a3.indexOf(")", o), R > o && (P = a3.indexOf("\\", o), P === -1 || P > R)))) return true;
    if (a3[s] === "\\") {
      var t = a3[s + 1];
      s += 2;
      var l = Gh[t];
      if (l) {
        var n = a3.indexOf(l, s);
        n !== -1 && (s = n + 1);
      }
      if (a3[s] === "!") return true;
    } else s++;
  }
  return false;
}, bE = function(a3) {
  if (a3[0] === "!") return true;
  for (var s = 0; s < a3.length; ) {
    if (/[*?{}()[\]]/.test(a3[s])) return true;
    if (a3[s] === "\\") {
      var o = a3[s + 1];
      s += 2;
      var b = Gh[o];
      if (b) {
        var A = a3.indexOf(b, s);
        A !== -1 && (s = A + 1);
      }
      if (a3[s] === "!") return true;
    } else s++;
  }
  return false;
}, ec = function(s, o) {
  if (typeof s != "string" || s === "") return false;
  if (mE(s)) return true;
  var b = yE;
  return o && o.strict === false && (b = bE), b(s);
}, qn = {}, Dn = {}, Ks = {};
Object.defineProperty(Ks, "__esModule", { value: true });
Ks.splitWhen = Ks.flatten = void 0;
function gE(a3) {
  return a3.reduce((s, o) => [].concat(s, o), []);
}
Ks.flatten = gE;
function vE(a3, s) {
  const o = [[]];
  let b = 0;
  for (const A of a3) s(A) ? (b++, o[b] = []) : o[b].push(A);
  return o;
}
Ks.splitWhen = vE;
var ro = {};
Object.defineProperty(ro, "__esModule", { value: true });
ro.isEnoentCodeError = void 0;
function EE(a3) {
  return a3.code === "ENOENT";
}
ro.isEnoentCodeError = EE;
var so = {};
Object.defineProperty(so, "__esModule", { value: true });
so.createDirentFromStats = void 0;
let SE = class {
  constructor(s, o) {
    this.name = s, this.isBlockDevice = o.isBlockDevice.bind(o), this.isCharacterDevice = o.isCharacterDevice.bind(o), this.isDirectory = o.isDirectory.bind(o), this.isFIFO = o.isFIFO.bind(o), this.isFile = o.isFile.bind(o), this.isSocket = o.isSocket.bind(o), this.isSymbolicLink = o.isSymbolicLink.bind(o);
  }
};
function _E(a3, s) {
  return new SE(a3, s);
}
so.createDirentFromStats = _E;
var Fn = {};
Object.defineProperty(Fn, "__esModule", { value: true });
Fn.convertPosixPathToPattern = Fn.convertWindowsPathToPattern = Fn.convertPathToPattern = Fn.escapePosixPath = Fn.escapeWindowsPath = Fn.escape = Fn.removeLeadingDotSegment = Fn.makeAbsolute = Fn.unixify = void 0;
const TE = gt, wE = gt, zh = TE.platform() === "win32", PE = 2, xE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g, AE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g, CE = /^\\\\([.?])/, IE = /\\(?![!()+@[\]{}])/g;
function kE(a3) {
  return a3.replace(/\\/g, "/");
}
Fn.unixify = kE;
function OE(a3, s) {
  return wE.resolve(a3, s);
}
Fn.makeAbsolute = OE;
function DE(a3) {
  if (a3.charAt(0) === ".") {
    const s = a3.charAt(1);
    if (s === "/" || s === "\\") return a3.slice(PE);
  }
  return a3;
}
Fn.removeLeadingDotSegment = DE;
Fn.escape = zh ? tc : nc;
function tc(a3) {
  return a3.replace(AE, "\\$2");
}
Fn.escapeWindowsPath = tc;
function nc(a3) {
  return a3.replace(xE, "\\$2");
}
Fn.escapePosixPath = nc;
Fn.convertPathToPattern = zh ? Kh : qh;
function Kh(a3) {
  return tc(a3).replace(CE, "//$1").replace(IE, "/");
}
Fn.convertWindowsPathToPattern = Kh;
function qh(a3) {
  return nc(a3);
}
Fn.convertPosixPathToPattern = qh;
var $t = {}, NE = ec, RE = gt.posix.dirname, jE = gt.platform() === "win32", $o = "/", LE = /\\/g, FE = /[\{\[].*[\}\]]$/, ME = /(^|[^\\])([\{\[]|\([^\)]+$)/, BE = /\\([\!\*\?\|\[\]\(\)\{\}])/g, $E = function(s, o) {
  var b = Object.assign({ flipBackslashes: true }, o);
  b.flipBackslashes && jE && s.indexOf($o) < 0 && (s = s.replace(LE, $o)), FE.test(s) && (s += $o), s += "a";
  do
    s = RE(s);
  while (NE(s) || ME.test(s));
  return s.replace(BE, "$1");
}, io = {};
(function(a3) {
  a3.isInteger = (s) => typeof s == "number" ? Number.isInteger(s) : typeof s == "string" && s.trim() !== "" ? Number.isInteger(Number(s)) : false, a3.find = (s, o) => s.nodes.find((b) => b.type === o), a3.exceedsLimit = (s, o, b = 1, A) => A === false || !a3.isInteger(s) || !a3.isInteger(o) ? false : (Number(o) - Number(s)) / Number(b) >= A, a3.escapeNode = (s, o = 0, b) => {
    const A = s.nodes[o];
    A && (b && A.type === b || A.type === "open" || A.type === "close") && A.escaped !== true && (A.value = "\\" + A.value, A.escaped = true);
  }, a3.encloseBrace = (s) => s.type !== "brace" || s.commas >> 0 + s.ranges >> 0 ? false : (s.invalid = true, true), a3.isInvalidBrace = (s) => s.type !== "brace" ? false : s.invalid === true || s.dollar ? true : !(s.commas >> 0 + s.ranges >> 0) || s.open !== true || s.close !== true ? (s.invalid = true, true) : false, a3.isOpenOrClose = (s) => s.type === "open" || s.type === "close" ? true : s.open === true || s.close === true, a3.reduce = (s) => s.reduce((o, b) => (b.type === "text" && o.push(b.value), b.type === "range" && (b.type = "text"), o), []), a3.flatten = (...s) => {
    const o = [], b = (A) => {
      for (let R = 0; R < A.length; R++) {
        const P = A[R];
        if (Array.isArray(P)) {
          b(P);
          continue;
        }
        P !== void 0 && o.push(P);
      }
      return o;
    };
    return b(s), o;
  };
})(io);
const td = io;
var rc = (a3, s = {}) => {
  const o = (b, A = {}) => {
    const R = s.escapeInvalid && td.isInvalidBrace(A), P = b.invalid === true && s.escapeInvalid === true;
    let t = "";
    if (b.value) return (R || P) && td.isOpenOrClose(b) ? "\\" + b.value : b.value;
    if (b.value) return b.value;
    if (b.nodes) for (const l of b.nodes) t += o(l);
    return t;
  };
  return o(a3);
};
/*!
* is-number <https://github.com/jonschlinkert/is-number>
*
* Copyright (c) 2014-present, Jon Schlinkert.
* Released under the MIT License.
*/
var UE = function(a3) {
  return typeof a3 == "number" ? a3 - a3 === 0 : typeof a3 == "string" && a3.trim() !== "" ? Number.isFinite ? Number.isFinite(+a3) : isFinite(+a3) : false;
};
/*!
* to-regex-range <https://github.com/micromatch/to-regex-range>
*
* Copyright (c) 2015-present, Jon Schlinkert.
* Released under the MIT License.
*/
const nd = UE, Ps = (a3, s, o) => {
  if (nd(a3) === false) throw new TypeError("toRegexRange: expected the first argument to be a number");
  if (s === void 0 || a3 === s) return String(a3);
  if (nd(s) === false) throw new TypeError("toRegexRange: expected the second argument to be a number.");
  let b = { relaxZeros: true, ...o };
  typeof b.strictZeros == "boolean" && (b.relaxZeros = b.strictZeros === false);
  let A = String(b.relaxZeros), R = String(b.shorthand), P = String(b.capture), t = String(b.wrap), l = a3 + ":" + s + "=" + A + R + P + t;
  if (Ps.cache.hasOwnProperty(l)) return Ps.cache[l].result;
  let n = Math.min(a3, s), u = Math.max(a3, s);
  if (Math.abs(n - u) === 1) {
    let y = a3 + "|" + s;
    return b.capture ? `(${y})` : b.wrap === false ? y : `(?:${y})`;
  }
  let c = ld(a3) || ld(s), e = { min: a3, max: s, a: n, b: u }, r = [], f = [];
  if (c && (e.isPadded = c, e.maxLen = String(e.max).length), n < 0) {
    let y = u < 0 ? Math.abs(u) : 1;
    f = rd(y, Math.abs(n), e, b), n = e.a = 0;
  }
  return u >= 0 && (r = rd(n, u, e, b)), e.negatives = f, e.positives = r, e.result = VE(f, r), b.capture === true ? e.result = `(${e.result})` : b.wrap !== false && r.length + f.length > 1 && (e.result = `(?:${e.result})`), Ps.cache[l] = e, e.result;
};
function VE(a3, s, o) {
  let b = Uo(a3, s, "-", false) || [], A = Uo(s, a3, "", false) || [], R = Uo(a3, s, "-?", true) || [];
  return b.concat(R).concat(A).join("|");
}
function WE(a3, s) {
  let o = 1, b = 1, A = id(a3, o), R = /* @__PURE__ */ new Set([s]);
  for (; a3 <= A && A <= s; ) R.add(A), o += 1, A = id(a3, o);
  for (A = ad(s + 1, b) - 1; a3 < A && A <= s; ) R.add(A), b += 1, A = ad(s + 1, b) - 1;
  return R = [...R], R.sort(zE), R;
}
function HE(a3, s, o) {
  if (a3 === s) return { pattern: a3, count: [], digits: 0 };
  let b = GE(a3, s), A = b.length, R = "", P = 0;
  for (let t = 0; t < A; t++) {
    let [l, n] = b[t];
    l === n ? R += l : l !== "0" || n !== "9" ? R += KE(l, n) : P++;
  }
  return P && (R += o.shorthand === true ? "\\d" : "[0-9]"), { pattern: R, count: [P], digits: A };
}
function rd(a3, s, o, b) {
  let A = WE(a3, s), R = [], P = a3, t;
  for (let l = 0; l < A.length; l++) {
    let n = A[l], u = HE(String(P), String(n), b), c = "";
    if (!o.isPadded && t && t.pattern === u.pattern) {
      t.count.length > 1 && t.count.pop(), t.count.push(u.count[0]), t.string = t.pattern + od(t.count), P = n + 1;
      continue;
    }
    o.isPadded && (c = qE(n, o, b)), u.string = c + u.pattern + od(u.count), R.push(u), P = n + 1, t = u;
  }
  return R;
}
function Uo(a3, s, o, b, A) {
  let R = [];
  for (let P of a3) {
    let { string: t } = P;
    !b && !sd(s, "string", t) && R.push(o + t), b && sd(s, "string", t) && R.push(o + t);
  }
  return R;
}
function GE(a3, s) {
  let o = [];
  for (let b = 0; b < a3.length; b++) o.push([a3[b], s[b]]);
  return o;
}
function zE(a3, s) {
  return a3 > s ? 1 : s > a3 ? -1 : 0;
}
function sd(a3, s, o) {
  return a3.some((b) => b[s] === o);
}
function id(a3, s) {
  return Number(String(a3).slice(0, -s) + "9".repeat(s));
}
function ad(a3, s) {
  return a3 - a3 % Math.pow(10, s);
}
function od(a3) {
  let [s = 0, o = ""] = a3;
  return o || s > 1 ? `{${s + (o ? "," + o : "")}}` : "";
}
function KE(a3, s, o) {
  return `[${a3}${s - a3 === 1 ? "" : "-"}${s}]`;
}
function ld(a3) {
  return /^-?(0+)\d/.test(a3);
}
function qE(a3, s, o) {
  if (!s.isPadded) return a3;
  let b = Math.abs(s.maxLen - String(a3).length), A = o.relaxZeros !== false;
  switch (b) {
    case 0:
      return "";
    case 1:
      return A ? "0?" : "0";
    case 2:
      return A ? "0{0,2}" : "00";
    default:
      return A ? `0{0,${b}}` : `0{${b}}`;
  }
}
Ps.cache = {};
Ps.clearCache = () => Ps.cache = {};
var YE = Ps;
/*!
* fill-range <https://github.com/jonschlinkert/fill-range>
*
* Copyright (c) 2014-present, Jon Schlinkert.
* Licensed under the MIT License.
*/
const XE = gt, Yh = YE, ud = (a3) => a3 !== null && typeof a3 == "object" && !Array.isArray(a3), JE = (a3) => (s) => a3 === true ? Number(s) : String(s), Vo = (a3) => typeof a3 == "number" || typeof a3 == "string" && a3 !== "", pi = (a3) => Number.isInteger(+a3), Wo = (a3) => {
  let s = `${a3}`, o = -1;
  if (s[0] === "-" && (s = s.slice(1)), s === "0") return false;
  for (; s[++o] === "0"; ) ;
  return o > 0;
}, QE = (a3, s, o) => typeof a3 == "string" || typeof s == "string" ? true : o.stringify === true, ZE = (a3, s, o) => {
  if (s > 0) {
    let b = a3[0] === "-" ? "-" : "";
    b && (a3 = a3.slice(1)), a3 = b + a3.padStart(b ? s - 1 : s, "0");
  }
  return o === false ? String(a3) : a3;
}, Aa = (a3, s) => {
  let o = a3[0] === "-" ? "-" : "";
  for (o && (a3 = a3.slice(1), s--); a3.length < s; ) a3 = "0" + a3;
  return o ? "-" + a3 : a3;
}, eS = (a3, s, o) => {
  a3.negatives.sort((t, l) => t < l ? -1 : t > l ? 1 : 0), a3.positives.sort((t, l) => t < l ? -1 : t > l ? 1 : 0);
  let b = s.capture ? "" : "?:", A = "", R = "", P;
  return a3.positives.length && (A = a3.positives.map((t) => Aa(String(t), o)).join("|")), a3.negatives.length && (R = `-(${b}${a3.negatives.map((t) => Aa(String(t), o)).join("|")})`), A && R ? P = `${A}|${R}` : P = A || R, s.wrap ? `(${b}${P})` : P;
}, Xh = (a3, s, o, b) => {
  if (o) return Yh(a3, s, { wrap: false, ...b });
  let A = String.fromCharCode(a3);
  if (a3 === s) return A;
  let R = String.fromCharCode(s);
  return `[${A}-${R}]`;
}, Jh = (a3, s, o) => {
  if (Array.isArray(a3)) {
    let b = o.wrap === true, A = o.capture ? "" : "?:";
    return b ? `(${A}${a3.join("|")})` : a3.join("|");
  }
  return Yh(a3, s, o);
}, Qh = (...a3) => new RangeError("Invalid range arguments: " + XE.inspect(...a3)), Zh = (a3, s, o) => {
  if (o.strictRanges === true) throw Qh([a3, s]);
  return [];
}, tS = (a3, s) => {
  if (s.strictRanges === true) throw new TypeError(`Expected step "${a3}" to be a number`);
  return [];
}, nS = (a3, s, o = 1, b = {}) => {
  let A = Number(a3), R = Number(s);
  if (!Number.isInteger(A) || !Number.isInteger(R)) {
    if (b.strictRanges === true) throw Qh([a3, s]);
    return [];
  }
  A === 0 && (A = 0), R === 0 && (R = 0);
  let P = A > R, t = String(a3), l = String(s), n = String(o);
  o = Math.max(Math.abs(o), 1);
  let u = Wo(t) || Wo(l) || Wo(n), c = u ? Math.max(t.length, l.length, n.length) : 0, e = u === false && QE(a3, s, b) === false, r = b.transform || JE(e);
  if (b.toRegex && o === 1) return Xh(Aa(a3, c), Aa(s, c), true, b);
  let f = { negatives: [], positives: [] }, y = (d) => f[d < 0 ? "negatives" : "positives"].push(Math.abs(d)), S = [], T = 0;
  for (; P ? A >= R : A <= R; ) b.toRegex === true && o > 1 ? y(A) : S.push(ZE(r(A, T), c, e)), A = P ? A - o : A + o, T++;
  return b.toRegex === true ? o > 1 ? eS(f, b, c) : Jh(S, null, { wrap: false, ...b }) : S;
}, rS = (a3, s, o = 1, b = {}) => {
  if (!pi(a3) && a3.length > 1 || !pi(s) && s.length > 1) return Zh(a3, s, b);
  let A = b.transform || ((e) => String.fromCharCode(e)), R = `${a3}`.charCodeAt(0), P = `${s}`.charCodeAt(0), t = R > P, l = Math.min(R, P), n = Math.max(R, P);
  if (b.toRegex && o === 1) return Xh(l, n, false, b);
  let u = [], c = 0;
  for (; t ? R >= P : R <= P; ) u.push(A(R, c)), R = t ? R - o : R + o, c++;
  return b.toRegex === true ? Jh(u, null, { wrap: false, options: b }) : u;
}, ba = (a3, s, o, b = {}) => {
  if (s == null && Vo(a3)) return [a3];
  if (!Vo(a3) || !Vo(s)) return Zh(a3, s, b);
  if (typeof o == "function") return ba(a3, s, 1, { transform: o });
  if (ud(o)) return ba(a3, s, 0, o);
  let A = { ...b };
  return A.capture === true && (A.wrap = true), o = o || A.step || 1, pi(o) ? pi(a3) && pi(s) ? nS(a3, s, o, A) : rS(a3, s, Math.max(Math.abs(o), 1), A) : o != null && !ud(o) ? tS(o, A) : ba(a3, s, 1, o);
};
var em = ba;
const sS = em, cd = io, iS = (a3, s = {}) => {
  const o = (b, A = {}) => {
    const R = cd.isInvalidBrace(A), P = b.invalid === true && s.escapeInvalid === true, t = R === true || P === true, l = s.escapeInvalid === true ? "\\" : "";
    let n = "";
    if (b.isOpen === true) return l + b.value;
    if (b.isClose === true) return console.log("node.isClose", l, b.value), l + b.value;
    if (b.type === "open") return t ? l + b.value : "(";
    if (b.type === "close") return t ? l + b.value : ")";
    if (b.type === "comma") return b.prev.type === "comma" ? "" : t ? b.value : "|";
    if (b.value) return b.value;
    if (b.nodes && b.ranges > 0) {
      const u = cd.reduce(b.nodes), c = sS(...u, { ...s, wrap: false, toRegex: true, strictZeros: true });
      if (c.length !== 0) return u.length > 1 && c.length > 1 ? `(${c})` : c;
    }
    if (b.nodes) for (const u of b.nodes) n += o(u, b);
    return n;
  };
  return o(a3);
};
var aS = iS;
const oS = em, pd = rc, Ws = io, Ss = (a3 = "", s = "", o = false) => {
  const b = [];
  if (a3 = [].concat(a3), s = [].concat(s), !s.length) return a3;
  if (!a3.length) return o ? Ws.flatten(s).map((A) => `{${A}}`) : s;
  for (const A of a3) if (Array.isArray(A)) for (const R of A) b.push(Ss(R, s, o));
  else for (let R of s) o === true && typeof R == "string" && (R = `{${R}}`), b.push(Array.isArray(R) ? Ss(A, R, o) : A + R);
  return Ws.flatten(b);
}, lS = (a3, s = {}) => {
  const o = s.rangeLimit === void 0 ? 1e3 : s.rangeLimit, b = (A, R = {}) => {
    A.queue = [];
    let P = R, t = R.queue;
    for (; P.type !== "brace" && P.type !== "root" && P.parent; ) P = P.parent, t = P.queue;
    if (A.invalid || A.dollar) {
      t.push(Ss(t.pop(), pd(A, s)));
      return;
    }
    if (A.type === "brace" && A.invalid !== true && A.nodes.length === 2) {
      t.push(Ss(t.pop(), ["{}"]));
      return;
    }
    if (A.nodes && A.ranges > 0) {
      const c = Ws.reduce(A.nodes);
      if (Ws.exceedsLimit(...c, s.step, o)) throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
      let e = oS(...c, s);
      e.length === 0 && (e = pd(A, s)), t.push(Ss(t.pop(), e)), A.nodes = [];
      return;
    }
    const l = Ws.encloseBrace(A);
    let n = A.queue, u = A;
    for (; u.type !== "brace" && u.type !== "root" && u.parent; ) u = u.parent, n = u.queue;
    for (let c = 0; c < A.nodes.length; c++) {
      const e = A.nodes[c];
      if (e.type === "comma" && A.type === "brace") {
        c === 1 && n.push(""), n.push("");
        continue;
      }
      if (e.type === "close") {
        t.push(Ss(t.pop(), n, l));
        continue;
      }
      if (e.value && e.type !== "open") {
        n.push(Ss(n.pop(), e.value));
        continue;
      }
      e.nodes && b(e, A);
    }
    return n;
  };
  return Ws.flatten(b(a3));
};
var uS = lS, cS = { MAX_LENGTH: 1e4, CHAR_LEFT_PARENTHESES: "(", CHAR_RIGHT_PARENTHESES: ")", CHAR_BACKSLASH: "\\", CHAR_BACKTICK: "`", CHAR_COMMA: ",", CHAR_DOT: ".", CHAR_DOUBLE_QUOTE: '"', CHAR_LEFT_CURLY_BRACE: "{", CHAR_LEFT_SQUARE_BRACKET: "[", CHAR_NO_BREAK_SPACE: "\xA0", CHAR_RIGHT_CURLY_BRACE: "}", CHAR_RIGHT_SQUARE_BRACKET: "]", CHAR_SINGLE_QUOTE: "'", CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF" };
const pS = rc, { MAX_LENGTH: dd, CHAR_BACKSLASH: Ho, CHAR_BACKTICK: dS, CHAR_COMMA: fS, CHAR_DOT: hS, CHAR_LEFT_PARENTHESES: mS, CHAR_RIGHT_PARENTHESES: yS, CHAR_LEFT_CURLY_BRACE: bS, CHAR_RIGHT_CURLY_BRACE: gS, CHAR_LEFT_SQUARE_BRACKET: fd, CHAR_RIGHT_SQUARE_BRACKET: hd, CHAR_DOUBLE_QUOTE: vS, CHAR_SINGLE_QUOTE: ES, CHAR_NO_BREAK_SPACE: SS, CHAR_ZERO_WIDTH_NOBREAK_SPACE: _S } = cS, TS = (a3, s = {}) => {
  if (typeof a3 != "string") throw new TypeError("Expected a string");
  const o = s || {}, b = typeof o.maxLength == "number" ? Math.min(dd, o.maxLength) : dd;
  if (a3.length > b) throw new SyntaxError(`Input length (${a3.length}), exceeds max characters (${b})`);
  const A = { type: "root", input: a3, nodes: [] }, R = [A];
  let P = A, t = A, l = 0;
  const n = a3.length;
  let u = 0, c = 0, e;
  const r = () => a3[u++], f = (y) => {
    if (y.type === "text" && t.type === "dot" && (t.type = "text"), t && t.type === "text" && y.type === "text") {
      t.value += y.value;
      return;
    }
    return P.nodes.push(y), y.parent = P, y.prev = t, t = y, y;
  };
  for (f({ type: "bos" }); u < n; ) if (P = R[R.length - 1], e = r(), !(e === _S || e === SS)) {
    if (e === Ho) {
      f({ type: "text", value: (s.keepEscaping ? e : "") + r() });
      continue;
    }
    if (e === hd) {
      f({ type: "text", value: "\\" + e });
      continue;
    }
    if (e === fd) {
      l++;
      let y;
      for (; u < n && (y = r()); ) {
        if (e += y, y === fd) {
          l++;
          continue;
        }
        if (y === Ho) {
          e += r();
          continue;
        }
        if (y === hd && (l--, l === 0)) break;
      }
      f({ type: "text", value: e });
      continue;
    }
    if (e === mS) {
      P = f({ type: "paren", nodes: [] }), R.push(P), f({ type: "text", value: e });
      continue;
    }
    if (e === yS) {
      if (P.type !== "paren") {
        f({ type: "text", value: e });
        continue;
      }
      P = R.pop(), f({ type: "text", value: e }), P = R[R.length - 1];
      continue;
    }
    if (e === vS || e === ES || e === dS) {
      const y = e;
      let S;
      for (s.keepQuotes !== true && (e = ""); u < n && (S = r()); ) {
        if (S === Ho) {
          e += S + r();
          continue;
        }
        if (S === y) {
          s.keepQuotes === true && (e += S);
          break;
        }
        e += S;
      }
      f({ type: "text", value: e });
      continue;
    }
    if (e === bS) {
      c++;
      const S = { type: "brace", open: true, close: false, dollar: t.value && t.value.slice(-1) === "$" || P.dollar === true, depth: c, commas: 0, ranges: 0, nodes: [] };
      P = f(S), R.push(P), f({ type: "open", value: e });
      continue;
    }
    if (e === gS) {
      if (P.type !== "brace") {
        f({ type: "text", value: e });
        continue;
      }
      const y = "close";
      P = R.pop(), P.close = true, f({ type: y, value: e }), c--, P = R[R.length - 1];
      continue;
    }
    if (e === fS && c > 0) {
      if (P.ranges > 0) {
        P.ranges = 0;
        const y = P.nodes.shift();
        P.nodes = [y, { type: "text", value: pS(P) }];
      }
      f({ type: "comma", value: e }), P.commas++;
      continue;
    }
    if (e === hS && c > 0 && P.commas === 0) {
      const y = P.nodes;
      if (c === 0 || y.length === 0) {
        f({ type: "text", value: e });
        continue;
      }
      if (t.type === "dot") {
        if (P.range = [], t.value += e, t.type = "range", P.nodes.length !== 3 && P.nodes.length !== 5) {
          P.invalid = true, P.ranges = 0, t.type = "text";
          continue;
        }
        P.ranges++, P.args = [];
        continue;
      }
      if (t.type === "range") {
        y.pop();
        const S = y[y.length - 1];
        S.value += t.value + e, t = S, P.ranges--;
        continue;
      }
      f({ type: "dot", value: e });
      continue;
    }
    f({ type: "text", value: e });
  }
  do
    if (P = R.pop(), P.type !== "root") {
      P.nodes.forEach((T) => {
        T.nodes || (T.type === "open" && (T.isOpen = true), T.type === "close" && (T.isClose = true), T.nodes || (T.type = "text"), T.invalid = true);
      });
      const y = R[R.length - 1], S = y.nodes.indexOf(P);
      y.nodes.splice(S, 1, ...P.nodes);
    }
  while (R.length > 0);
  return f({ type: "eos" }), A;
};
var wS = TS;
const md = rc, PS = aS, xS = uS, AS = wS, yr = (a3, s = {}) => {
  let o = [];
  if (Array.isArray(a3)) for (const b of a3) {
    const A = yr.create(b, s);
    Array.isArray(A) ? o.push(...A) : o.push(A);
  }
  else o = [].concat(yr.create(a3, s));
  return s && s.expand === true && s.nodupes === true && (o = [...new Set(o)]), o;
};
yr.parse = (a3, s = {}) => AS(a3, s);
yr.stringify = (a3, s = {}) => md(typeof a3 == "string" ? yr.parse(a3, s) : a3, s);
yr.compile = (a3, s = {}) => (typeof a3 == "string" && (a3 = yr.parse(a3, s)), PS(a3, s));
yr.expand = (a3, s = {}) => {
  typeof a3 == "string" && (a3 = yr.parse(a3, s));
  let o = xS(a3, s);
  return s.noempty === true && (o = o.filter(Boolean)), s.nodupes === true && (o = [...new Set(o)]), o;
};
yr.create = (a3, s = {}) => a3 === "" || a3.length < 3 ? [a3] : s.expand !== true ? yr.compile(a3, s) : yr.expand(a3, s);
var CS = yr, Oi = {};
const IS = gt, Wr = "\\\\/", yd = `[^${Wr}]`, ns = "\\.", kS = "\\+", OS = "\\?", ao = "\\/", DS = "(?=.)", tm = "[^/]", sc = `(?:${ao}|$)`, nm = `(?:^|${ao})`, ic = `${ns}{1,2}${sc}`, NS = `(?!${ns})`, RS = `(?!${nm}${ic})`, jS = `(?!${ns}{0,1}${sc})`, LS = `(?!${ic})`, FS = `[^.${ao}]`, MS = `${tm}*?`, rm = { DOT_LITERAL: ns, PLUS_LITERAL: kS, QMARK_LITERAL: OS, SLASH_LITERAL: ao, ONE_CHAR: DS, QMARK: tm, END_ANCHOR: sc, DOTS_SLASH: ic, NO_DOT: NS, NO_DOTS: RS, NO_DOT_SLASH: jS, NO_DOTS_SLASH: LS, QMARK_NO_DOT: FS, STAR: MS, START_ANCHOR: nm }, BS = { ...rm, SLASH_LITERAL: `[${Wr}]`, QMARK: yd, STAR: `${yd}*?`, DOTS_SLASH: `${ns}{1,2}(?:[${Wr}]|$)`, NO_DOT: `(?!${ns})`, NO_DOTS: `(?!(?:^|[${Wr}])${ns}{1,2}(?:[${Wr}]|$))`, NO_DOT_SLASH: `(?!${ns}{0,1}(?:[${Wr}]|$))`, NO_DOTS_SLASH: `(?!${ns}{1,2}(?:[${Wr}]|$))`, QMARK_NO_DOT: `[^.${Wr}]`, START_ANCHOR: `(?:^|[${Wr}])`, END_ANCHOR: `(?:[${Wr}]|$)` }, $S = { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "\\x21-\\x7E", lower: "a-z", print: "\\x20-\\x7E ", punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~", space: " \\t\\r\\n\\v\\f", upper: "A-Z", word: "A-Za-z0-9_", xdigit: "A-Fa-f0-9" };
var oo = { MAX_LENGTH: 1024 * 64, POSIX_REGEX_SOURCE: $S, REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g, REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/, REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/, REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g, REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g, REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g, REPLACEMENTS: { "***": "*", "**/**": "**", "**/**/**": "**" }, CHAR_0: 48, CHAR_9: 57, CHAR_UPPERCASE_A: 65, CHAR_LOWERCASE_A: 97, CHAR_UPPERCASE_Z: 90, CHAR_LOWERCASE_Z: 122, CHAR_LEFT_PARENTHESES: 40, CHAR_RIGHT_PARENTHESES: 41, CHAR_ASTERISK: 42, CHAR_AMPERSAND: 38, CHAR_AT: 64, CHAR_BACKWARD_SLASH: 92, CHAR_CARRIAGE_RETURN: 13, CHAR_CIRCUMFLEX_ACCENT: 94, CHAR_COLON: 58, CHAR_COMMA: 44, CHAR_DOT: 46, CHAR_DOUBLE_QUOTE: 34, CHAR_EQUAL: 61, CHAR_EXCLAMATION_MARK: 33, CHAR_FORM_FEED: 12, CHAR_FORWARD_SLASH: 47, CHAR_GRAVE_ACCENT: 96, CHAR_HASH: 35, CHAR_HYPHEN_MINUS: 45, CHAR_LEFT_ANGLE_BRACKET: 60, CHAR_LEFT_CURLY_BRACE: 123, CHAR_LEFT_SQUARE_BRACKET: 91, CHAR_LINE_FEED: 10, CHAR_NO_BREAK_SPACE: 160, CHAR_PERCENT: 37, CHAR_PLUS: 43, CHAR_QUESTION_MARK: 63, CHAR_RIGHT_ANGLE_BRACKET: 62, CHAR_RIGHT_CURLY_BRACE: 125, CHAR_RIGHT_SQUARE_BRACKET: 93, CHAR_SEMICOLON: 59, CHAR_SINGLE_QUOTE: 39, CHAR_SPACE: 32, CHAR_TAB: 9, CHAR_UNDERSCORE: 95, CHAR_VERTICAL_LINE: 124, CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, SEP: IS.sep, extglobChars(a3) {
  return { "!": { type: "negate", open: "(?:(?!(?:", close: `))${a3.STAR})` }, "?": { type: "qmark", open: "(?:", close: ")?" }, "+": { type: "plus", open: "(?:", close: ")+" }, "*": { type: "star", open: "(?:", close: ")*" }, "@": { type: "at", open: "(?:", close: ")" } };
}, globChars(a3) {
  return a3 === true ? BS : rm;
} };
(function(a3) {
  const s = gt, o = process.platform === "win32", { REGEX_BACKSLASH: b, REGEX_REMOVE_BACKSLASH: A, REGEX_SPECIAL_CHARS: R, REGEX_SPECIAL_CHARS_GLOBAL: P } = oo;
  a3.isObject = (t) => t !== null && typeof t == "object" && !Array.isArray(t), a3.hasRegexChars = (t) => R.test(t), a3.isRegexChar = (t) => t.length === 1 && a3.hasRegexChars(t), a3.escapeRegex = (t) => t.replace(P, "\\$1"), a3.toPosixSlashes = (t) => t.replace(b, "/"), a3.removeBackslashes = (t) => t.replace(A, (l) => l === "\\" ? "" : l), a3.supportsLookbehinds = () => {
    const t = process.version.slice(1).split(".").map(Number);
    return t.length === 3 && t[0] >= 9 || t[0] === 8 && t[1] >= 10;
  }, a3.isWindows = (t) => t && typeof t.windows == "boolean" ? t.windows : o === true || s.sep === "\\", a3.escapeLast = (t, l, n) => {
    const u = t.lastIndexOf(l, n);
    return u === -1 ? t : t[u - 1] === "\\" ? a3.escapeLast(t, l, u - 1) : `${t.slice(0, u)}\\${t.slice(u)}`;
  }, a3.removePrefix = (t, l = {}) => {
    let n = t;
    return n.startsWith("./") && (n = n.slice(2), l.prefix = "./"), n;
  }, a3.wrapOutput = (t, l = {}, n = {}) => {
    const u = n.contains ? "" : "^", c = n.contains ? "" : "$";
    let e = `${u}(?:${t})${c}`;
    return l.negated === true && (e = `(?:^(?!${e}).*$)`), e;
  };
})(Oi);
const bd = Oi, { CHAR_ASTERISK: Go, CHAR_AT: US, CHAR_BACKWARD_SLASH: ui, CHAR_COMMA: VS, CHAR_DOT: zo, CHAR_EXCLAMATION_MARK: Ko, CHAR_FORWARD_SLASH: sm, CHAR_LEFT_CURLY_BRACE: qo, CHAR_LEFT_PARENTHESES: Yo, CHAR_LEFT_SQUARE_BRACKET: WS, CHAR_PLUS: HS, CHAR_QUESTION_MARK: gd, CHAR_RIGHT_CURLY_BRACE: GS, CHAR_RIGHT_PARENTHESES: vd, CHAR_RIGHT_SQUARE_BRACKET: zS } = oo, Ed = (a3) => a3 === sm || a3 === ui, Sd = (a3) => {
  a3.isPrefix !== true && (a3.depth = a3.isGlobstar ? 1 / 0 : 1);
}, KS = (a3, s) => {
  const o = s || {}, b = a3.length - 1, A = o.parts === true || o.scanToEnd === true, R = [], P = [], t = [];
  let l = a3, n = -1, u = 0, c = 0, e = false, r = false, f = false, y = false, S = false, T = false, d = false, p = false, h = false, m = false, E = 0, _, C, w = { value: "", depth: 0, isGlob: false };
  const I = () => n >= b, D = () => l.charCodeAt(n + 1), j = () => (_ = C, l.charCodeAt(++n));
  for (; n < b; ) {
    C = j();
    let W;
    if (C === ui) {
      d = w.backslashes = true, C = j(), C === qo && (T = true);
      continue;
    }
    if (T === true || C === qo) {
      for (E++; I() !== true && (C = j()); ) {
        if (C === ui) {
          d = w.backslashes = true, j();
          continue;
        }
        if (C === qo) {
          E++;
          continue;
        }
        if (T !== true && C === zo && (C = j()) === zo) {
          if (e = w.isBrace = true, f = w.isGlob = true, m = true, A === true) continue;
          break;
        }
        if (T !== true && C === VS) {
          if (e = w.isBrace = true, f = w.isGlob = true, m = true, A === true) continue;
          break;
        }
        if (C === GS && (E--, E === 0)) {
          T = false, e = w.isBrace = true, m = true;
          break;
        }
      }
      if (A === true) continue;
      break;
    }
    if (C === sm) {
      if (R.push(n), P.push(w), w = { value: "", depth: 0, isGlob: false }, m === true) continue;
      if (_ === zo && n === u + 1) {
        u += 2;
        continue;
      }
      c = n + 1;
      continue;
    }
    if (o.noext !== true && (C === HS || C === US || C === Go || C === gd || C === Ko) === true && D() === Yo) {
      if (f = w.isGlob = true, y = w.isExtglob = true, m = true, C === Ko && n === u && (h = true), A === true) {
        for (; I() !== true && (C = j()); ) {
          if (C === ui) {
            d = w.backslashes = true, C = j();
            continue;
          }
          if (C === vd) {
            f = w.isGlob = true, m = true;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (C === Go) {
      if (_ === Go && (S = w.isGlobstar = true), f = w.isGlob = true, m = true, A === true) continue;
      break;
    }
    if (C === gd) {
      if (f = w.isGlob = true, m = true, A === true) continue;
      break;
    }
    if (C === WS) {
      for (; I() !== true && (W = j()); ) {
        if (W === ui) {
          d = w.backslashes = true, j();
          continue;
        }
        if (W === zS) {
          r = w.isBracket = true, f = w.isGlob = true, m = true;
          break;
        }
      }
      if (A === true) continue;
      break;
    }
    if (o.nonegate !== true && C === Ko && n === u) {
      p = w.negated = true, u++;
      continue;
    }
    if (o.noparen !== true && C === Yo) {
      if (f = w.isGlob = true, A === true) {
        for (; I() !== true && (C = j()); ) {
          if (C === Yo) {
            d = w.backslashes = true, C = j();
            continue;
          }
          if (C === vd) {
            m = true;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (f === true) {
      if (m = true, A === true) continue;
      break;
    }
  }
  o.noext === true && (y = false, f = false);
  let L = l, k = "", N = "";
  u > 0 && (k = l.slice(0, u), l = l.slice(u), c -= u), L && f === true && c > 0 ? (L = l.slice(0, c), N = l.slice(c)) : f === true ? (L = "", N = l) : L = l, L && L !== "" && L !== "/" && L !== l && Ed(L.charCodeAt(L.length - 1)) && (L = L.slice(0, -1)), o.unescape === true && (N && (N = bd.removeBackslashes(N)), L && d === true && (L = bd.removeBackslashes(L)));
  const F = { prefix: k, input: a3, start: u, base: L, glob: N, isBrace: e, isBracket: r, isGlob: f, isExtglob: y, isGlobstar: S, negated: p, negatedExtglob: h };
  if (o.tokens === true && (F.maxDepth = 0, Ed(C) || P.push(w), F.tokens = P), o.parts === true || o.tokens === true) {
    let W;
    for (let X = 0; X < R.length; X++) {
      const H = W ? W + 1 : u, U = R[X], q = a3.slice(H, U);
      o.tokens && (X === 0 && u !== 0 ? (P[X].isPrefix = true, P[X].value = k) : P[X].value = q, Sd(P[X]), F.maxDepth += P[X].depth), (X !== 0 || q !== "") && t.push(q), W = U;
    }
    if (W && W + 1 < a3.length) {
      const X = a3.slice(W + 1);
      t.push(X), o.tokens && (P[P.length - 1].value = X, Sd(P[P.length - 1]), F.maxDepth += P[P.length - 1].depth);
    }
    F.slashes = R, F.parts = t;
  }
  return F;
};
var qS = KS;
const Ca = oo, fr = Oi, { MAX_LENGTH: Ia, POSIX_REGEX_SOURCE: YS, REGEX_NON_SPECIAL_CHARS: XS, REGEX_SPECIAL_CHARS_BACKREF: JS, REPLACEMENTS: im } = Ca, QS = (a3, s) => {
  if (typeof s.expandRange == "function") return s.expandRange(...a3, s);
  a3.sort();
  const o = `[${a3.join("-")}]`;
  try {
    new RegExp(o);
  } catch {
    return a3.map((A) => fr.escapeRegex(A)).join("..");
  }
  return o;
}, Bs = (a3, s) => `Missing ${a3}: "${s}" - use "\\\\${s}" to match literal characters`, ac = (a3, s) => {
  if (typeof a3 != "string") throw new TypeError("Expected a string");
  a3 = im[a3] || a3;
  const o = { ...s }, b = typeof o.maxLength == "number" ? Math.min(Ia, o.maxLength) : Ia;
  let A = a3.length;
  if (A > b) throw new SyntaxError(`Input length: ${A}, exceeds maximum allowed length: ${b}`);
  const R = { type: "bos", value: "", output: o.prepend || "" }, P = [R], t = o.capture ? "" : "?:", l = fr.isWindows(s), n = Ca.globChars(l), u = Ca.extglobChars(n), { DOT_LITERAL: c, PLUS_LITERAL: e, SLASH_LITERAL: r, ONE_CHAR: f, DOTS_SLASH: y, NO_DOT: S, NO_DOT_SLASH: T, NO_DOTS_SLASH: d, QMARK: p, QMARK_NO_DOT: h, STAR: m, START_ANCHOR: E } = n, _ = (M) => `(${t}(?:(?!${E}${M.dot ? y : c}).)*?)`, C = o.dot ? "" : S, w = o.dot ? p : h;
  let I = o.bash === true ? _(o) : m;
  o.capture && (I = `(${I})`), typeof o.noext == "boolean" && (o.noextglob = o.noext);
  const D = { input: a3, index: -1, start: 0, dot: o.dot === true, consumed: "", output: "", prefix: "", backtrack: false, negated: false, brackets: 0, braces: 0, parens: 0, quotes: 0, globstar: false, tokens: P };
  a3 = fr.removePrefix(a3, D), A = a3.length;
  const j = [], L = [], k = [];
  let N = R, F;
  const W = () => D.index === A - 1, X = D.peek = (M = 1) => a3[D.index + M], H = D.advance = () => a3[++D.index] || "", U = () => a3.slice(D.index + 1), q = (M = "", K = 0) => {
    D.consumed += M, D.index += K;
  }, ee = (M) => {
    D.output += M.output != null ? M.output : M.value, q(M.value);
  }, re = () => {
    let M = 1;
    for (; X() === "!" && (X(2) !== "(" || X(3) === "?"); ) H(), D.start++, M++;
    return M % 2 === 0 ? false : (D.negated = true, D.start++, true);
  }, Y = (M) => {
    D[M]++, k.push(M);
  }, Z = (M) => {
    D[M]--, k.pop();
  }, G = (M) => {
    if (N.type === "globstar") {
      const K = D.braces > 0 && (M.type === "comma" || M.type === "brace"), Q = M.extglob === true || j.length && (M.type === "pipe" || M.type === "paren");
      M.type !== "slash" && M.type !== "paren" && !K && !Q && (D.output = D.output.slice(0, -N.output.length), N.type = "star", N.value = "*", N.output = I, D.output += N.output);
    }
    if (j.length && M.type !== "paren" && (j[j.length - 1].inner += M.value), (M.value || M.output) && ee(M), N && N.type === "text" && M.type === "text") {
      N.value += M.value, N.output = (N.output || "") + M.value;
      return;
    }
    M.prev = N, P.push(M), N = M;
  }, B = (M, K) => {
    const Q = { ...u[K], conditions: 1, inner: "" };
    Q.prev = N, Q.parens = D.parens, Q.output = D.output;
    const ie = (o.capture ? "(" : "") + Q.open;
    Y("parens"), G({ type: M, value: K, output: D.output ? "" : f }), G({ type: "paren", extglob: true, value: H(), output: ie }), j.push(Q);
  }, z = (M) => {
    let K = M.close + (o.capture ? ")" : ""), Q;
    if (M.type === "negate") {
      let ie = I;
      if (M.inner && M.inner.length > 1 && M.inner.includes("/") && (ie = _(o)), (ie !== I || W() || /^\)+$/.test(U())) && (K = M.close = `)$))${ie}`), M.inner.includes("*") && (Q = U()) && /^\.[^\\/.]+$/.test(Q)) {
        const ue = ac(Q, { ...s, fastpaths: false }).output;
        K = M.close = `)${ue})${ie})`;
      }
      M.prev.type === "bos" && (D.negatedExtglob = true);
    }
    G({ type: "paren", extglob: true, value: F, output: K }), Z("parens");
  };
  if (o.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(a3)) {
    let M = false, K = a3.replace(JS, (Q, ie, ue, ge, Te, le) => ge === "\\" ? (M = true, Q) : ge === "?" ? ie ? ie + ge + (Te ? p.repeat(Te.length) : "") : le === 0 ? w + (Te ? p.repeat(Te.length) : "") : p.repeat(ue.length) : ge === "." ? c.repeat(ue.length) : ge === "*" ? ie ? ie + ge + (Te ? I : "") : I : ie ? Q : `\\${Q}`);
    return M === true && (o.unescape === true ? K = K.replace(/\\/g, "") : K = K.replace(/\\+/g, (Q) => Q.length % 2 === 0 ? "\\\\" : Q ? "\\" : "")), K === a3 && o.contains === true ? (D.output = a3, D) : (D.output = fr.wrapOutput(K, D, s), D);
  }
  for (; !W(); ) {
    if (F = H(), F === "\0") continue;
    if (F === "\\") {
      const Q = X();
      if (Q === "/" && o.bash !== true || Q === "." || Q === ";") continue;
      if (!Q) {
        F += "\\", G({ type: "text", value: F });
        continue;
      }
      const ie = /^\\+/.exec(U());
      let ue = 0;
      if (ie && ie[0].length > 2 && (ue = ie[0].length, D.index += ue, ue % 2 !== 0 && (F += "\\")), o.unescape === true ? F = H() : F += H(), D.brackets === 0) {
        G({ type: "text", value: F });
        continue;
      }
    }
    if (D.brackets > 0 && (F !== "]" || N.value === "[" || N.value === "[^")) {
      if (o.posix !== false && F === ":") {
        const Q = N.value.slice(1);
        if (Q.includes("[") && (N.posix = true, Q.includes(":"))) {
          const ie = N.value.lastIndexOf("["), ue = N.value.slice(0, ie), ge = N.value.slice(ie + 2), Te = YS[ge];
          if (Te) {
            N.value = ue + Te, D.backtrack = true, H(), !R.output && P.indexOf(N) === 1 && (R.output = f);
            continue;
          }
        }
      }
      (F === "[" && X() !== ":" || F === "-" && X() === "]") && (F = `\\${F}`), F === "]" && (N.value === "[" || N.value === "[^") && (F = `\\${F}`), o.posix === true && F === "!" && N.value === "[" && (F = "^"), N.value += F, ee({ value: F });
      continue;
    }
    if (D.quotes === 1 && F !== '"') {
      F = fr.escapeRegex(F), N.value += F, ee({ value: F });
      continue;
    }
    if (F === '"') {
      D.quotes = D.quotes === 1 ? 0 : 1, o.keepQuotes === true && G({ type: "text", value: F });
      continue;
    }
    if (F === "(") {
      Y("parens"), G({ type: "paren", value: F });
      continue;
    }
    if (F === ")") {
      if (D.parens === 0 && o.strictBrackets === true) throw new SyntaxError(Bs("opening", "("));
      const Q = j[j.length - 1];
      if (Q && D.parens === Q.parens + 1) {
        z(j.pop());
        continue;
      }
      G({ type: "paren", value: F, output: D.parens ? ")" : "\\)" }), Z("parens");
      continue;
    }
    if (F === "[") {
      if (o.nobracket === true || !U().includes("]")) {
        if (o.nobracket !== true && o.strictBrackets === true) throw new SyntaxError(Bs("closing", "]"));
        F = `\\${F}`;
      } else Y("brackets");
      G({ type: "bracket", value: F });
      continue;
    }
    if (F === "]") {
      if (o.nobracket === true || N && N.type === "bracket" && N.value.length === 1) {
        G({ type: "text", value: F, output: `\\${F}` });
        continue;
      }
      if (D.brackets === 0) {
        if (o.strictBrackets === true) throw new SyntaxError(Bs("opening", "["));
        G({ type: "text", value: F, output: `\\${F}` });
        continue;
      }
      Z("brackets");
      const Q = N.value.slice(1);
      if (N.posix !== true && Q[0] === "^" && !Q.includes("/") && (F = `/${F}`), N.value += F, ee({ value: F }), o.literalBrackets === false || fr.hasRegexChars(Q)) continue;
      const ie = fr.escapeRegex(N.value);
      if (D.output = D.output.slice(0, -N.value.length), o.literalBrackets === true) {
        D.output += ie, N.value = ie;
        continue;
      }
      N.value = `(${t}${ie}|${N.value})`, D.output += N.value;
      continue;
    }
    if (F === "{" && o.nobrace !== true) {
      Y("braces");
      const Q = { type: "brace", value: F, output: "(", outputIndex: D.output.length, tokensIndex: D.tokens.length };
      L.push(Q), G(Q);
      continue;
    }
    if (F === "}") {
      const Q = L[L.length - 1];
      if (o.nobrace === true || !Q) {
        G({ type: "text", value: F, output: F });
        continue;
      }
      let ie = ")";
      if (Q.dots === true) {
        const ue = P.slice(), ge = [];
        for (let Te = ue.length - 1; Te >= 0 && (P.pop(), ue[Te].type !== "brace"); Te--) ue[Te].type !== "dots" && ge.unshift(ue[Te].value);
        ie = QS(ge, o), D.backtrack = true;
      }
      if (Q.comma !== true && Q.dots !== true) {
        const ue = D.output.slice(0, Q.outputIndex), ge = D.tokens.slice(Q.tokensIndex);
        Q.value = Q.output = "\\{", F = ie = "\\}", D.output = ue;
        for (const Te of ge) D.output += Te.output || Te.value;
      }
      G({ type: "brace", value: F, output: ie }), Z("braces"), L.pop();
      continue;
    }
    if (F === "|") {
      j.length > 0 && j[j.length - 1].conditions++, G({ type: "text", value: F });
      continue;
    }
    if (F === ",") {
      let Q = F;
      const ie = L[L.length - 1];
      ie && k[k.length - 1] === "braces" && (ie.comma = true, Q = "|"), G({ type: "comma", value: F, output: Q });
      continue;
    }
    if (F === "/") {
      if (N.type === "dot" && D.index === D.start + 1) {
        D.start = D.index + 1, D.consumed = "", D.output = "", P.pop(), N = R;
        continue;
      }
      G({ type: "slash", value: F, output: r });
      continue;
    }
    if (F === ".") {
      if (D.braces > 0 && N.type === "dot") {
        N.value === "." && (N.output = c);
        const Q = L[L.length - 1];
        N.type = "dots", N.output += F, N.value += F, Q.dots = true;
        continue;
      }
      if (D.braces + D.parens === 0 && N.type !== "bos" && N.type !== "slash") {
        G({ type: "text", value: F, output: c });
        continue;
      }
      G({ type: "dot", value: F, output: c });
      continue;
    }
    if (F === "?") {
      if (!(N && N.value === "(") && o.noextglob !== true && X() === "(" && X(2) !== "?") {
        B("qmark", F);
        continue;
      }
      if (N && N.type === "paren") {
        const ie = X();
        let ue = F;
        if (ie === "<" && !fr.supportsLookbehinds()) throw new Error("Node.js v10 or higher is required for regex lookbehinds");
        (N.value === "(" && !/[!=<:]/.test(ie) || ie === "<" && !/<([!=]|\w+>)/.test(U())) && (ue = `\\${F}`), G({ type: "text", value: F, output: ue });
        continue;
      }
      if (o.dot !== true && (N.type === "slash" || N.type === "bos")) {
        G({ type: "qmark", value: F, output: h });
        continue;
      }
      G({ type: "qmark", value: F, output: p });
      continue;
    }
    if (F === "!") {
      if (o.noextglob !== true && X() === "(" && (X(2) !== "?" || !/[!=<:]/.test(X(3)))) {
        B("negate", F);
        continue;
      }
      if (o.nonegate !== true && D.index === 0) {
        re();
        continue;
      }
    }
    if (F === "+") {
      if (o.noextglob !== true && X() === "(" && X(2) !== "?") {
        B("plus", F);
        continue;
      }
      if (N && N.value === "(" || o.regex === false) {
        G({ type: "plus", value: F, output: e });
        continue;
      }
      if (N && (N.type === "bracket" || N.type === "paren" || N.type === "brace") || D.parens > 0) {
        G({ type: "plus", value: F });
        continue;
      }
      G({ type: "plus", value: e });
      continue;
    }
    if (F === "@") {
      if (o.noextglob !== true && X() === "(" && X(2) !== "?") {
        G({ type: "at", extglob: true, value: F, output: "" });
        continue;
      }
      G({ type: "text", value: F });
      continue;
    }
    if (F !== "*") {
      (F === "$" || F === "^") && (F = `\\${F}`);
      const Q = XS.exec(U());
      Q && (F += Q[0], D.index += Q[0].length), G({ type: "text", value: F });
      continue;
    }
    if (N && (N.type === "globstar" || N.star === true)) {
      N.type = "star", N.star = true, N.value += F, N.output = I, D.backtrack = true, D.globstar = true, q(F);
      continue;
    }
    let M = U();
    if (o.noextglob !== true && /^\([^?]/.test(M)) {
      B("star", F);
      continue;
    }
    if (N.type === "star") {
      if (o.noglobstar === true) {
        q(F);
        continue;
      }
      const Q = N.prev, ie = Q.prev, ue = Q.type === "slash" || Q.type === "bos", ge = ie && (ie.type === "star" || ie.type === "globstar");
      if (o.bash === true && (!ue || M[0] && M[0] !== "/")) {
        G({ type: "star", value: F, output: "" });
        continue;
      }
      const Te = D.braces > 0 && (Q.type === "comma" || Q.type === "brace"), le = j.length && (Q.type === "pipe" || Q.type === "paren");
      if (!ue && Q.type !== "paren" && !Te && !le) {
        G({ type: "star", value: F, output: "" });
        continue;
      }
      for (; M.slice(0, 3) === "/**"; ) {
        const fe = a3[D.index + 4];
        if (fe && fe !== "/") break;
        M = M.slice(3), q("/**", 3);
      }
      if (Q.type === "bos" && W()) {
        N.type = "globstar", N.value += F, N.output = _(o), D.output = N.output, D.globstar = true, q(F);
        continue;
      }
      if (Q.type === "slash" && Q.prev.type !== "bos" && !ge && W()) {
        D.output = D.output.slice(0, -(Q.output + N.output).length), Q.output = `(?:${Q.output}`, N.type = "globstar", N.output = _(o) + (o.strictSlashes ? ")" : "|$)"), N.value += F, D.globstar = true, D.output += Q.output + N.output, q(F);
        continue;
      }
      if (Q.type === "slash" && Q.prev.type !== "bos" && M[0] === "/") {
        const fe = M[1] !== void 0 ? "|$" : "";
        D.output = D.output.slice(0, -(Q.output + N.output).length), Q.output = `(?:${Q.output}`, N.type = "globstar", N.output = `${_(o)}${r}|${r}${fe})`, N.value += F, D.output += Q.output + N.output, D.globstar = true, q(F + H()), G({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (Q.type === "bos" && M[0] === "/") {
        N.type = "globstar", N.value += F, N.output = `(?:^|${r}|${_(o)}${r})`, D.output = N.output, D.globstar = true, q(F + H()), G({ type: "slash", value: "/", output: "" });
        continue;
      }
      D.output = D.output.slice(0, -N.output.length), N.type = "globstar", N.output = _(o), N.value += F, D.output += N.output, D.globstar = true, q(F);
      continue;
    }
    const K = { type: "star", value: F, output: I };
    if (o.bash === true) {
      K.output = ".*?", (N.type === "bos" || N.type === "slash") && (K.output = C + K.output), G(K);
      continue;
    }
    if (N && (N.type === "bracket" || N.type === "paren") && o.regex === true) {
      K.output = F, G(K);
      continue;
    }
    (D.index === D.start || N.type === "slash" || N.type === "dot") && (N.type === "dot" ? (D.output += T, N.output += T) : o.dot === true ? (D.output += d, N.output += d) : (D.output += C, N.output += C), X() !== "*" && (D.output += f, N.output += f)), G(K);
  }
  for (; D.brackets > 0; ) {
    if (o.strictBrackets === true) throw new SyntaxError(Bs("closing", "]"));
    D.output = fr.escapeLast(D.output, "["), Z("brackets");
  }
  for (; D.parens > 0; ) {
    if (o.strictBrackets === true) throw new SyntaxError(Bs("closing", ")"));
    D.output = fr.escapeLast(D.output, "("), Z("parens");
  }
  for (; D.braces > 0; ) {
    if (o.strictBrackets === true) throw new SyntaxError(Bs("closing", "}"));
    D.output = fr.escapeLast(D.output, "{"), Z("braces");
  }
  if (o.strictSlashes !== true && (N.type === "star" || N.type === "bracket") && G({ type: "maybe_slash", value: "", output: `${r}?` }), D.backtrack === true) {
    D.output = "";
    for (const M of D.tokens) D.output += M.output != null ? M.output : M.value, M.suffix && (D.output += M.suffix);
  }
  return D;
};
ac.fastpaths = (a3, s) => {
  const o = { ...s }, b = typeof o.maxLength == "number" ? Math.min(Ia, o.maxLength) : Ia, A = a3.length;
  if (A > b) throw new SyntaxError(`Input length: ${A}, exceeds maximum allowed length: ${b}`);
  a3 = im[a3] || a3;
  const R = fr.isWindows(s), { DOT_LITERAL: P, SLASH_LITERAL: t, ONE_CHAR: l, DOTS_SLASH: n, NO_DOT: u, NO_DOTS: c, NO_DOTS_SLASH: e, STAR: r, START_ANCHOR: f } = Ca.globChars(R), y = o.dot ? c : u, S = o.dot ? e : u, T = o.capture ? "" : "?:", d = { negated: false, prefix: "" };
  let p = o.bash === true ? ".*?" : r;
  o.capture && (p = `(${p})`);
  const h = (C) => C.noglobstar === true ? p : `(${T}(?:(?!${f}${C.dot ? n : P}).)*?)`, m = (C) => {
    switch (C) {
      case "*":
        return `${y}${l}${p}`;
      case ".*":
        return `${P}${l}${p}`;
      case "*.*":
        return `${y}${p}${P}${l}${p}`;
      case "*/*":
        return `${y}${p}${t}${l}${S}${p}`;
      case "**":
        return y + h(o);
      case "**/*":
        return `(?:${y}${h(o)}${t})?${S}${l}${p}`;
      case "**/*.*":
        return `(?:${y}${h(o)}${t})?${S}${p}${P}${l}${p}`;
      case "**/.*":
        return `(?:${y}${h(o)}${t})?${P}${l}${p}`;
      default: {
        const w = /^(.*?)\.(\w+)$/.exec(C);
        if (!w) return;
        const I = m(w[1]);
        return I ? I + P + w[2] : void 0;
      }
    }
  }, E = fr.removePrefix(a3, d);
  let _ = m(E);
  return _ && o.strictSlashes !== true && (_ += `${t}?`), _;
};
var ZS = ac;
const e_ = gt, t_ = qS, Yl = ZS, oc = Oi, n_ = oo, r_ = (a3) => a3 && typeof a3 == "object" && !Array.isArray(a3), jn = (a3, s, o = false) => {
  if (Array.isArray(a3)) {
    const u = a3.map((e) => jn(e, s, o));
    return (e) => {
      for (const r of u) {
        const f = r(e);
        if (f) return f;
      }
      return false;
    };
  }
  const b = r_(a3) && a3.tokens && a3.input;
  if (a3 === "" || typeof a3 != "string" && !b) throw new TypeError("Expected pattern to be a non-empty string");
  const A = s || {}, R = oc.isWindows(s), P = b ? jn.compileRe(a3, s) : jn.makeRe(a3, s, false, true), t = P.state;
  delete P.state;
  let l = () => false;
  if (A.ignore) {
    const u = { ...s, ignore: null, onMatch: null, onResult: null };
    l = jn(A.ignore, u, o);
  }
  const n = (u, c = false) => {
    const { isMatch: e, match: r, output: f } = jn.test(u, P, s, { glob: a3, posix: R }), y = { glob: a3, state: t, regex: P, posix: R, input: u, output: f, match: r, isMatch: e };
    return typeof A.onResult == "function" && A.onResult(y), e === false ? (y.isMatch = false, c ? y : false) : l(u) ? (typeof A.onIgnore == "function" && A.onIgnore(y), y.isMatch = false, c ? y : false) : (typeof A.onMatch == "function" && A.onMatch(y), c ? y : true);
  };
  return o && (n.state = t), n;
};
jn.test = (a3, s, o, { glob: b, posix: A } = {}) => {
  if (typeof a3 != "string") throw new TypeError("Expected input to be a string");
  if (a3 === "") return { isMatch: false, output: "" };
  const R = o || {}, P = R.format || (A ? oc.toPosixSlashes : null);
  let t = a3 === b, l = t && P ? P(a3) : a3;
  return t === false && (l = P ? P(a3) : a3, t = l === b), (t === false || R.capture === true) && (R.matchBase === true || R.basename === true ? t = jn.matchBase(a3, s, o, A) : t = s.exec(l)), { isMatch: !!t, match: t, output: l };
};
jn.matchBase = (a3, s, o, b = oc.isWindows(o)) => (s instanceof RegExp ? s : jn.makeRe(s, o)).test(e_.basename(a3));
jn.isMatch = (a3, s, o) => jn(s, o)(a3);
jn.parse = (a3, s) => Array.isArray(a3) ? a3.map((o) => jn.parse(o, s)) : Yl(a3, { ...s, fastpaths: false });
jn.scan = (a3, s) => t_(a3, s);
jn.compileRe = (a3, s, o = false, b = false) => {
  if (o === true) return a3.output;
  const A = s || {}, R = A.contains ? "" : "^", P = A.contains ? "" : "$";
  let t = `${R}(?:${a3.output})${P}`;
  a3 && a3.negated === true && (t = `^(?!${t}).*$`);
  const l = jn.toRegex(t, s);
  return b === true && (l.state = a3), l;
};
jn.makeRe = (a3, s = {}, o = false, b = false) => {
  if (!a3 || typeof a3 != "string") throw new TypeError("Expected a non-empty string");
  let A = { negated: false, fastpaths: true };
  return s.fastpaths !== false && (a3[0] === "." || a3[0] === "*") && (A.output = Yl.fastpaths(a3, s)), A.output || (A = Yl(a3, s)), jn.compileRe(A, s, o, b);
};
jn.toRegex = (a3, s) => {
  try {
    const o = s || {};
    return new RegExp(a3, o.flags || (o.nocase ? "i" : ""));
  } catch (o) {
    if (s && s.debug === true) throw o;
    return /$^/;
  }
};
jn.constants = n_;
var s_ = jn, i_ = s_;
const am = gt, om = CS, Xr = i_, Xl = Oi, _d = (a3) => a3 === "" || a3 === "./", lm = (a3) => {
  const s = a3.indexOf("{");
  return s > -1 && a3.indexOf("}", s) > -1;
}, xn = (a3, s, o) => {
  s = [].concat(s), a3 = [].concat(a3);
  let b = /* @__PURE__ */ new Set(), A = /* @__PURE__ */ new Set(), R = /* @__PURE__ */ new Set(), P = 0, t = (u) => {
    R.add(u.output), o && o.onResult && o.onResult(u);
  };
  for (let u = 0; u < s.length; u++) {
    let c = Xr(String(s[u]), { ...o, onResult: t }, true), e = c.state.negated || c.state.negatedExtglob;
    e && P++;
    for (let r of a3) {
      let f = c(r, true);
      (e ? !f.isMatch : f.isMatch) && (e ? b.add(f.output) : (b.delete(f.output), A.add(f.output)));
    }
  }
  let n = (P === s.length ? [...R] : [...A]).filter((u) => !b.has(u));
  if (o && n.length === 0) {
    if (o.failglob === true) throw new Error(`No matches found for "${s.join(", ")}"`);
    if (o.nonull === true || o.nullglob === true) return o.unescape ? s.map((u) => u.replace(/\\/g, "")) : s;
  }
  return n;
};
xn.match = xn;
xn.matcher = (a3, s) => Xr(a3, s);
xn.isMatch = (a3, s, o) => Xr(s, o)(a3);
xn.any = xn.isMatch;
xn.not = (a3, s, o = {}) => {
  s = [].concat(s).map(String);
  let b = /* @__PURE__ */ new Set(), A = [], R = (t) => {
    o.onResult && o.onResult(t), A.push(t.output);
  }, P = new Set(xn(a3, s, { ...o, onResult: R }));
  for (let t of A) P.has(t) || b.add(t);
  return [...b];
};
xn.contains = (a3, s, o) => {
  if (typeof a3 != "string") throw new TypeError(`Expected a string: "${am.inspect(a3)}"`);
  if (Array.isArray(s)) return s.some((b) => xn.contains(a3, b, o));
  if (typeof s == "string") {
    if (_d(a3) || _d(s)) return false;
    if (a3.includes(s) || a3.startsWith("./") && a3.slice(2).includes(s)) return true;
  }
  return xn.isMatch(a3, s, { ...o, contains: true });
};
xn.matchKeys = (a3, s, o) => {
  if (!Xl.isObject(a3)) throw new TypeError("Expected the first argument to be an object");
  let b = xn(Object.keys(a3), s, o), A = {};
  for (let R of b) A[R] = a3[R];
  return A;
};
xn.some = (a3, s, o) => {
  let b = [].concat(a3);
  for (let A of [].concat(s)) {
    let R = Xr(String(A), o);
    if (b.some((P) => R(P))) return true;
  }
  return false;
};
xn.every = (a3, s, o) => {
  let b = [].concat(a3);
  for (let A of [].concat(s)) {
    let R = Xr(String(A), o);
    if (!b.every((P) => R(P))) return false;
  }
  return true;
};
xn.all = (a3, s, o) => {
  if (typeof a3 != "string") throw new TypeError(`Expected a string: "${am.inspect(a3)}"`);
  return [].concat(s).every((b) => Xr(b, o)(a3));
};
xn.capture = (a3, s, o) => {
  let b = Xl.isWindows(o), R = Xr.makeRe(String(a3), { ...o, capture: true }).exec(b ? Xl.toPosixSlashes(s) : s);
  if (R) return R.slice(1).map((P) => P === void 0 ? "" : P);
};
xn.makeRe = (...a3) => Xr.makeRe(...a3);
xn.scan = (...a3) => Xr.scan(...a3);
xn.parse = (a3, s) => {
  let o = [];
  for (let b of [].concat(a3 || [])) for (let A of om(String(b), s)) o.push(Xr.parse(A, s));
  return o;
};
xn.braces = (a3, s) => {
  if (typeof a3 != "string") throw new TypeError("Expected a string");
  return s && s.nobrace === true || !lm(a3) ? [a3] : om(a3, s);
};
xn.braceExpand = (a3, s) => {
  if (typeof a3 != "string") throw new TypeError("Expected a string");
  return xn.braces(a3, { ...s, expand: true });
};
xn.hasBraces = lm;
var um = xn;
Object.defineProperty($t, "__esModule", { value: true });
$t.isAbsolute = $t.partitionAbsoluteAndRelative = $t.removeDuplicateSlashes = $t.matchAny = $t.convertPatternsToRe = $t.makeRe = $t.getPatternParts = $t.expandBraceExpansion = $t.expandPatternsWithBraceExpansion = $t.isAffectDepthOfReadingPattern = $t.endsWithSlashGlobStar = $t.hasGlobStar = $t.getBaseDirectory = $t.isPatternRelatedToParentDirectory = $t.getPatternsOutsideCurrentDirectory = $t.getPatternsInsideCurrentDirectory = $t.getPositivePatterns = $t.getNegativePatterns = $t.isPositivePattern = $t.isNegativePattern = $t.convertToNegativePattern = $t.convertToPositivePattern = $t.isDynamicPattern = $t.isStaticPattern = void 0;
const cm = gt, a_ = $E, lc = um, pm = "**", o_ = "\\", l_ = /[*?]|^!/, u_ = /\[[^[]*]/, c_ = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/, p_ = /[!*+?@]\([^(]*\)/, d_ = /,|\.\./, f_ = /(?!^)\/{2,}/g;
function dm(a3, s = {}) {
  return !fm(a3, s);
}
$t.isStaticPattern = dm;
function fm(a3, s = {}) {
  return a3 === "" ? false : !!(s.caseSensitiveMatch === false || a3.includes(o_) || l_.test(a3) || u_.test(a3) || c_.test(a3) || s.extglob !== false && p_.test(a3) || s.braceExpansion !== false && h_(a3));
}
$t.isDynamicPattern = fm;
function h_(a3) {
  const s = a3.indexOf("{");
  if (s === -1) return false;
  const o = a3.indexOf("}", s + 1);
  if (o === -1) return false;
  const b = a3.slice(s, o);
  return d_.test(b);
}
function m_(a3) {
  return lo(a3) ? a3.slice(1) : a3;
}
$t.convertToPositivePattern = m_;
function y_(a3) {
  return "!" + a3;
}
$t.convertToNegativePattern = y_;
function lo(a3) {
  return a3.startsWith("!") && a3[1] !== "(";
}
$t.isNegativePattern = lo;
function hm(a3) {
  return !lo(a3);
}
$t.isPositivePattern = hm;
function b_(a3) {
  return a3.filter(lo);
}
$t.getNegativePatterns = b_;
function g_(a3) {
  return a3.filter(hm);
}
$t.getPositivePatterns = g_;
function v_(a3) {
  return a3.filter((s) => !uc(s));
}
$t.getPatternsInsideCurrentDirectory = v_;
function E_(a3) {
  return a3.filter(uc);
}
$t.getPatternsOutsideCurrentDirectory = E_;
function uc(a3) {
  return a3.startsWith("..") || a3.startsWith("./..");
}
$t.isPatternRelatedToParentDirectory = uc;
function S_(a3) {
  return a_(a3, { flipBackslashes: false });
}
$t.getBaseDirectory = S_;
function __(a3) {
  return a3.includes(pm);
}
$t.hasGlobStar = __;
function mm(a3) {
  return a3.endsWith("/" + pm);
}
$t.endsWithSlashGlobStar = mm;
function T_(a3) {
  const s = cm.basename(a3);
  return mm(a3) || dm(s);
}
$t.isAffectDepthOfReadingPattern = T_;
function w_(a3) {
  return a3.reduce((s, o) => s.concat(ym(o)), []);
}
$t.expandPatternsWithBraceExpansion = w_;
function ym(a3) {
  const s = lc.braces(a3, { expand: true, nodupes: true, keepEscaping: true });
  return s.sort((o, b) => o.length - b.length), s.filter((o) => o !== "");
}
$t.expandBraceExpansion = ym;
function P_(a3, s) {
  let { parts: o } = lc.scan(a3, Object.assign(Object.assign({}, s), { parts: true }));
  return o.length === 0 && (o = [a3]), o[0].startsWith("/") && (o[0] = o[0].slice(1), o.unshift("")), o;
}
$t.getPatternParts = P_;
function bm(a3, s) {
  return lc.makeRe(a3, s);
}
$t.makeRe = bm;
function x_(a3, s) {
  return a3.map((o) => bm(o, s));
}
$t.convertPatternsToRe = x_;
function A_(a3, s) {
  return s.some((o) => o.test(a3));
}
$t.matchAny = A_;
function C_(a3) {
  return a3.replace(f_, "/");
}
$t.removeDuplicateSlashes = C_;
function I_(a3) {
  const s = [], o = [];
  for (const b of a3) gm(b) ? s.push(b) : o.push(b);
  return [s, o];
}
$t.partitionAbsoluteAndRelative = I_;
function gm(a3) {
  return cm.isAbsolute(a3);
}
$t.isAbsolute = gm;
var uo = {};
const k_ = gt, vm = k_.PassThrough, O_ = Array.prototype.slice;
var D_ = N_;
function N_() {
  const a3 = [], s = O_.call(arguments);
  let o = false, b = s[s.length - 1];
  b && !Array.isArray(b) && b.pipe == null ? s.pop() : b = {};
  const A = b.end !== false, R = b.pipeError === true;
  b.objectMode == null && (b.objectMode = true), b.highWaterMark == null && (b.highWaterMark = 64 * 1024);
  const P = vm(b);
  function t() {
    for (let u = 0, c = arguments.length; u < c; u++) a3.push(Em(arguments[u], b));
    return l(), this;
  }
  function l() {
    if (o) return;
    o = true;
    let u = a3.shift();
    if (!u) {
      process.nextTick(n);
      return;
    }
    Array.isArray(u) || (u = [u]);
    let c = u.length + 1;
    function e() {
      --c > 0 || (o = false, l());
    }
    function r(f) {
      function y() {
        f.removeListener("merge2UnpipeEnd", y), f.removeListener("end", y), R && f.removeListener("error", S), e();
      }
      function S(T) {
        P.emit("error", T);
      }
      if (f._readableState.endEmitted) return e();
      f.on("merge2UnpipeEnd", y), f.on("end", y), R && f.on("error", S), f.pipe(P, { end: false }), f.resume();
    }
    for (let f = 0; f < u.length; f++) r(u[f]);
    e();
  }
  function n() {
    o = false, P.emit("queueDrain"), A && P.end();
  }
  return P.setMaxListeners(0), P.add = t, P.on("unpipe", function(u) {
    u.emit("merge2UnpipeEnd");
  }), s.length && t.apply(null, s), P;
}
function Em(a3, s) {
  if (Array.isArray(a3)) for (let o = 0, b = a3.length; o < b; o++) a3[o] = Em(a3[o], s);
  else {
    if (!a3._readableState && a3.pipe && (a3 = a3.pipe(vm(s))), !a3._readableState || !a3.pause || !a3.pipe) throw new Error("Only readable stream can be merged.");
    a3.pause();
  }
  return a3;
}
Object.defineProperty(uo, "__esModule", { value: true });
uo.merge = void 0;
const R_ = D_;
function j_(a3) {
  const s = R_(a3);
  return a3.forEach((o) => {
    o.once("error", (b) => s.emit("error", b));
  }), s.once("close", () => Td(a3)), s.once("end", () => Td(a3)), s;
}
uo.merge = j_;
function Td(a3) {
  a3.forEach((s) => s.emit("close"));
}
var qs = {};
Object.defineProperty(qs, "__esModule", { value: true });
qs.isEmpty = qs.isString = void 0;
function L_(a3) {
  return typeof a3 == "string";
}
qs.isString = L_;
function F_(a3) {
  return a3 === "";
}
qs.isEmpty = F_;
Object.defineProperty(Dn, "__esModule", { value: true });
Dn.string = Dn.stream = Dn.pattern = Dn.path = Dn.fs = Dn.errno = Dn.array = void 0;
const M_ = Ks;
Dn.array = M_;
const B_ = ro;
Dn.errno = B_;
const $_ = so;
Dn.fs = $_;
const U_ = Fn;
Dn.path = U_;
const V_ = $t;
Dn.pattern = V_;
const W_ = uo;
Dn.stream = W_;
const H_ = qs;
Dn.string = H_;
Object.defineProperty(qn, "__esModule", { value: true });
qn.convertPatternGroupToTask = qn.convertPatternGroupsToTasks = qn.groupPatternsByBaseDirectory = qn.getNegativePatternsAsPositive = qn.getPositivePatterns = qn.convertPatternsToTasks = qn.generate = void 0;
const Rr = Dn;
function G_(a3, s) {
  const o = wd(a3, s), b = wd(s.ignore, s), A = Sm(o), R = _m(o, b), P = A.filter((u) => Rr.pattern.isStaticPattern(u, s)), t = A.filter((u) => Rr.pattern.isDynamicPattern(u, s)), l = Jl(P, R, false), n = Jl(t, R, true);
  return l.concat(n);
}
qn.generate = G_;
function wd(a3, s) {
  let o = a3;
  return s.braceExpansion && (o = Rr.pattern.expandPatternsWithBraceExpansion(o)), s.baseNameMatch && (o = o.map((b) => b.includes("/") ? b : `**/${b}`)), o.map((b) => Rr.pattern.removeDuplicateSlashes(b));
}
function Jl(a3, s, o) {
  const b = [], A = Rr.pattern.getPatternsOutsideCurrentDirectory(a3), R = Rr.pattern.getPatternsInsideCurrentDirectory(a3), P = Ql(A), t = Ql(R);
  return b.push(...Zl(P, s, o)), "." in t ? b.push(cc(".", R, s, o)) : b.push(...Zl(t, s, o)), b;
}
qn.convertPatternsToTasks = Jl;
function Sm(a3) {
  return Rr.pattern.getPositivePatterns(a3);
}
qn.getPositivePatterns = Sm;
function _m(a3, s) {
  return Rr.pattern.getNegativePatterns(a3).concat(s).map(Rr.pattern.convertToPositivePattern);
}
qn.getNegativePatternsAsPositive = _m;
function Ql(a3) {
  const s = {};
  return a3.reduce((o, b) => {
    const A = Rr.pattern.getBaseDirectory(b);
    return A in o ? o[A].push(b) : o[A] = [b], o;
  }, s);
}
qn.groupPatternsByBaseDirectory = Ql;
function Zl(a3, s, o) {
  return Object.keys(a3).map((b) => cc(b, a3[b], s, o));
}
qn.convertPatternGroupsToTasks = Zl;
function cc(a3, s, o, b) {
  return { dynamic: b, positive: s, negative: o, base: a3, patterns: [].concat(s, o.map(Rr.pattern.convertToNegativePattern)) };
}
qn.convertPatternGroupToTask = cc;
var pc = {}, dc = {}, Tr = {}, fc = {}, co = {}, Gr = {}, ds = {}, br = {}, po = {};
Object.defineProperty(po, "__esModule", { value: true });
po.read = void 0;
function z_(a3, s, o) {
  s.fs.lstat(a3, (b, A) => {
    if (b !== null) {
      Pd(o, b);
      return;
    }
    if (!A.isSymbolicLink() || !s.followSymbolicLink) {
      Xo(o, A);
      return;
    }
    s.fs.stat(a3, (R, P) => {
      if (R !== null) {
        if (s.throwErrorOnBrokenSymbolicLink) {
          Pd(o, R);
          return;
        }
        Xo(o, A);
        return;
      }
      s.markSymbolicLink && (P.isSymbolicLink = () => true), Xo(o, P);
    });
  });
}
po.read = z_;
function Pd(a3, s) {
  a3(s);
}
function Xo(a3, s) {
  a3(null, s);
}
var fo = {};
Object.defineProperty(fo, "__esModule", { value: true });
fo.read = void 0;
function K_(a3, s) {
  const o = s.fs.lstatSync(a3);
  if (!o.isSymbolicLink() || !s.followSymbolicLink) return o;
  try {
    const b = s.fs.statSync(a3);
    return s.markSymbolicLink && (b.isSymbolicLink = () => true), b;
  } catch (b) {
    if (!s.throwErrorOnBrokenSymbolicLink) return o;
    throw b;
  }
}
fo.read = K_;
var hc = {}, Tm = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), a3.createFileSystemAdapter = a3.FILE_SYSTEM_ADAPTER = void 0;
  const s = gt;
  a3.FILE_SYSTEM_ADAPTER = { lstat: s.lstat, stat: s.stat, lstatSync: s.lstatSync, statSync: s.statSync };
  function o(b) {
    return b === void 0 ? a3.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, a3.FILE_SYSTEM_ADAPTER), b);
  }
  a3.createFileSystemAdapter = o;
})(Tm);
Object.defineProperty(hc, "__esModule", { value: true });
const q_ = Tm;
let Y_ = class {
  constructor(s = {}) {
    this._options = s, this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true), this.fs = q_.createFileSystemAdapter(this._options.fs), this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
  }
  _getValue(s, o) {
    return s ?? o;
  }
};
hc.default = Y_;
Object.defineProperty(br, "__esModule", { value: true });
br.statSync = br.stat = br.Settings = void 0;
const xd = po, X_ = fo, eu = hc;
br.Settings = eu.default;
function J_(a3, s, o) {
  if (typeof s == "function") {
    xd.read(a3, tu(), s);
    return;
  }
  xd.read(a3, tu(s), o);
}
br.stat = J_;
function Q_(a3, s) {
  const o = tu(s);
  return X_.read(a3, o);
}
br.statSync = Q_;
function tu(a3 = {}) {
  return a3 instanceof eu.default ? a3 : new eu.default(a3);
}
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let Ad;
var Z_ = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : Yn) : (a3) => (Ad || (Ad = Promise.resolve())).then(a3).catch((s) => setTimeout(() => {
  throw s;
}, 0));
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var eT = nT;
const tT = Z_;
function nT(a3, s) {
  let o, b, A, R = true;
  Array.isArray(a3) ? (o = [], b = a3.length) : (A = Object.keys(a3), o = {}, b = A.length);
  function P(l) {
    function n() {
      s && s(l, o), s = null;
    }
    R ? tT(n) : n();
  }
  function t(l, n, u) {
    o[l] = u, (--b === 0 || n) && P(n);
  }
  b ? A ? A.forEach(function(l) {
    a3[l](function(n, u) {
      t(l, n, u);
    });
  }) : a3.forEach(function(l, n) {
    l(function(u, c) {
      t(n, u, c);
    });
  }) : P(null), R = false;
}
var Di = {};
Object.defineProperty(Di, "__esModule", { value: true });
Di.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
const ka = process.versions.node.split(".");
if (ka[0] === void 0 || ka[1] === void 0) throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
const wm = Number.parseInt(ka[0], 10), rT = Number.parseInt(ka[1], 10), Pm = 10, sT = 10, iT = wm > Pm, aT = wm === Pm && rT >= sT;
Di.IS_SUPPORT_READDIR_WITH_FILE_TYPES = iT || aT;
var Ni = {}, ho = {};
Object.defineProperty(ho, "__esModule", { value: true });
ho.createDirentFromStats = void 0;
class oT {
  constructor(s, o) {
    this.name = s, this.isBlockDevice = o.isBlockDevice.bind(o), this.isCharacterDevice = o.isCharacterDevice.bind(o), this.isDirectory = o.isDirectory.bind(o), this.isFIFO = o.isFIFO.bind(o), this.isFile = o.isFile.bind(o), this.isSocket = o.isSocket.bind(o), this.isSymbolicLink = o.isSymbolicLink.bind(o);
  }
}
function lT(a3, s) {
  return new oT(a3, s);
}
ho.createDirentFromStats = lT;
Object.defineProperty(Ni, "__esModule", { value: true });
Ni.fs = void 0;
const uT = ho;
Ni.fs = uT;
var Ri = {};
Object.defineProperty(Ri, "__esModule", { value: true });
Ri.joinPathSegments = void 0;
function cT(a3, s, o) {
  return a3.endsWith(o) ? a3 + s : a3 + o + s;
}
Ri.joinPathSegments = cT;
Object.defineProperty(ds, "__esModule", { value: true });
ds.readdir = ds.readdirWithFileTypes = ds.read = void 0;
const pT = br, xm = eT, dT = Di, Am = Ni, Cm = Ri;
function fT(a3, s, o) {
  if (!s.stats && dT.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    Im(a3, s, o);
    return;
  }
  km(a3, s, o);
}
ds.read = fT;
function Im(a3, s, o) {
  s.fs.readdir(a3, { withFileTypes: true }, (b, A) => {
    if (b !== null) {
      Oa(o, b);
      return;
    }
    const R = A.map((t) => ({ dirent: t, name: t.name, path: Cm.joinPathSegments(a3, t.name, s.pathSegmentSeparator) }));
    if (!s.followSymbolicLinks) {
      nu(o, R);
      return;
    }
    const P = R.map((t) => hT(t, s));
    xm(P, (t, l) => {
      if (t !== null) {
        Oa(o, t);
        return;
      }
      nu(o, l);
    });
  });
}
ds.readdirWithFileTypes = Im;
function hT(a3, s) {
  return (o) => {
    if (!a3.dirent.isSymbolicLink()) {
      o(null, a3);
      return;
    }
    s.fs.stat(a3.path, (b, A) => {
      if (b !== null) {
        if (s.throwErrorOnBrokenSymbolicLink) {
          o(b);
          return;
        }
        o(null, a3);
        return;
      }
      a3.dirent = Am.fs.createDirentFromStats(a3.name, A), o(null, a3);
    });
  };
}
function km(a3, s, o) {
  s.fs.readdir(a3, (b, A) => {
    if (b !== null) {
      Oa(o, b);
      return;
    }
    const R = A.map((P) => {
      const t = Cm.joinPathSegments(a3, P, s.pathSegmentSeparator);
      return (l) => {
        pT.stat(t, s.fsStatSettings, (n, u) => {
          if (n !== null) {
            l(n);
            return;
          }
          const c = { name: P, path: t, dirent: Am.fs.createDirentFromStats(P, u) };
          s.stats && (c.stats = u), l(null, c);
        });
      };
    });
    xm(R, (P, t) => {
      if (P !== null) {
        Oa(o, P);
        return;
      }
      nu(o, t);
    });
  });
}
ds.readdir = km;
function Oa(a3, s) {
  a3(s);
}
function nu(a3, s) {
  a3(null, s);
}
var fs = {};
Object.defineProperty(fs, "__esModule", { value: true });
fs.readdir = fs.readdirWithFileTypes = fs.read = void 0;
const mT = br, yT = Di, Om = Ni, Dm = Ri;
function bT(a3, s) {
  return !s.stats && yT.IS_SUPPORT_READDIR_WITH_FILE_TYPES ? Nm(a3, s) : Rm(a3, s);
}
fs.read = bT;
function Nm(a3, s) {
  return s.fs.readdirSync(a3, { withFileTypes: true }).map((b) => {
    const A = { dirent: b, name: b.name, path: Dm.joinPathSegments(a3, b.name, s.pathSegmentSeparator) };
    if (A.dirent.isSymbolicLink() && s.followSymbolicLinks) try {
      const R = s.fs.statSync(A.path);
      A.dirent = Om.fs.createDirentFromStats(A.name, R);
    } catch (R) {
      if (s.throwErrorOnBrokenSymbolicLink) throw R;
    }
    return A;
  });
}
fs.readdirWithFileTypes = Nm;
function Rm(a3, s) {
  return s.fs.readdirSync(a3).map((b) => {
    const A = Dm.joinPathSegments(a3, b, s.pathSegmentSeparator), R = mT.statSync(A, s.fsStatSettings), P = { name: b, path: A, dirent: Om.fs.createDirentFromStats(b, R) };
    return s.stats && (P.stats = R), P;
  });
}
fs.readdir = Rm;
var mc = {}, jm = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), a3.createFileSystemAdapter = a3.FILE_SYSTEM_ADAPTER = void 0;
  const s = gt;
  a3.FILE_SYSTEM_ADAPTER = { lstat: s.lstat, stat: s.stat, lstatSync: s.lstatSync, statSync: s.statSync, readdir: s.readdir, readdirSync: s.readdirSync };
  function o(b) {
    return b === void 0 ? a3.FILE_SYSTEM_ADAPTER : Object.assign(Object.assign({}, a3.FILE_SYSTEM_ADAPTER), b);
  }
  a3.createFileSystemAdapter = o;
})(jm);
Object.defineProperty(mc, "__esModule", { value: true });
const gT = gt, vT = br, ET = jm;
let ST = class {
  constructor(s = {}) {
    this._options = s, this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false), this.fs = ET.createFileSystemAdapter(this._options.fs), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, gT.sep), this.stats = this._getValue(this._options.stats, false), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true), this.fsStatSettings = new vT.Settings({ followSymbolicLink: this.followSymbolicLinks, fs: this.fs, throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink });
  }
  _getValue(s, o) {
    return s ?? o;
  }
};
mc.default = ST;
Object.defineProperty(Gr, "__esModule", { value: true });
Gr.Settings = Gr.scandirSync = Gr.scandir = void 0;
const Cd = ds, _T = fs, ru = mc;
Gr.Settings = ru.default;
function TT(a3, s, o) {
  if (typeof s == "function") {
    Cd.read(a3, su(), s);
    return;
  }
  Cd.read(a3, su(s), o);
}
Gr.scandir = TT;
function wT(a3, s) {
  const o = su(s);
  return _T.read(a3, o);
}
Gr.scandirSync = wT;
function su(a3 = {}) {
  return a3 instanceof ru.default ? a3 : new ru.default(a3);
}
var yc = { exports: {} };
function PT(a3) {
  var s = new a3(), o = s;
  function b() {
    var R = s;
    return R.next ? s = R.next : (s = new a3(), o = s), R.next = null, R;
  }
  function A(R) {
    o.next = R, o = R;
  }
  return { get: b, release: A };
}
var xT = PT, AT = xT;
function Lm(a3, s, o) {
  if (typeof a3 == "function" && (o = s, s = a3, a3 = null), !(o >= 1)) throw new Error("fastqueue concurrency must be equal to or greater than 1");
  var b = AT(CT), A = null, R = null, P = 0, t = null, l = { push: y, drain: _r, saturated: _r, pause: u, paused: false, get concurrency() {
    return o;
  }, set concurrency(m) {
    if (!(m >= 1)) throw new Error("fastqueue concurrency must be equal to or greater than 1");
    if (o = m, !l.paused) for (; A && P < o; ) P++, T();
  }, running: n, resume: r, idle: f, length: c, getQueue: e, unshift: S, empty: _r, kill: d, killAndDrain: p, error: h };
  return l;
  function n() {
    return P;
  }
  function u() {
    l.paused = true;
  }
  function c() {
    for (var m = A, E = 0; m; ) m = m.next, E++;
    return E;
  }
  function e() {
    for (var m = A, E = []; m; ) E.push(m.value), m = m.next;
    return E;
  }
  function r() {
    if (l.paused) {
      if (l.paused = false, A === null) {
        P++, T();
        return;
      }
      for (; A && P < o; ) P++, T();
    }
  }
  function f() {
    return P === 0 && l.length() === 0;
  }
  function y(m, E) {
    var _ = b.get();
    _.context = a3, _.release = T, _.value = m, _.callback = E || _r, _.errorHandler = t, P >= o || l.paused ? R ? (R.next = _, R = _) : (A = _, R = _, l.saturated()) : (P++, s.call(a3, _.value, _.worked));
  }
  function S(m, E) {
    var _ = b.get();
    _.context = a3, _.release = T, _.value = m, _.callback = E || _r, _.errorHandler = t, P >= o || l.paused ? A ? (_.next = A, A = _) : (A = _, R = _, l.saturated()) : (P++, s.call(a3, _.value, _.worked));
  }
  function T(m) {
    m && b.release(m);
    var E = A;
    E && P <= o ? l.paused ? P-- : (R === A && (R = null), A = E.next, E.next = null, s.call(a3, E.value, E.worked), R === null && l.empty()) : --P === 0 && l.drain();
  }
  function d() {
    A = null, R = null, l.drain = _r;
  }
  function p() {
    A = null, R = null, l.drain(), l.drain = _r;
  }
  function h(m) {
    t = m;
  }
}
function _r() {
}
function CT() {
  this.value = null, this.callback = _r, this.next = null, this.release = _r, this.context = null, this.errorHandler = null;
  var a3 = this;
  this.worked = function(o, b) {
    var A = a3.callback, R = a3.errorHandler, P = a3.value;
    a3.value = null, a3.callback = _r, a3.errorHandler && R(o, P), A.call(a3.context, o, b), a3.release(a3);
  };
}
function IT(a3, s, o) {
  typeof a3 == "function" && (o = s, s = a3, a3 = null);
  function b(u, c) {
    s.call(this, u).then(function(e) {
      c(null, e);
    }, c);
  }
  var A = Lm(a3, b, o), R = A.push, P = A.unshift;
  return A.push = t, A.unshift = l, A.drained = n, A;
  function t(u) {
    var c = new Promise(function(e, r) {
      R(u, function(f, y) {
        if (f) {
          r(f);
          return;
        }
        e(y);
      });
    });
    return c.catch(_r), c;
  }
  function l(u) {
    var c = new Promise(function(e, r) {
      P(u, function(f, y) {
        if (f) {
          r(f);
          return;
        }
        e(y);
      });
    });
    return c.catch(_r), c;
  }
  function n() {
    var u = new Promise(function(c) {
      process.nextTick(function() {
        if (A.idle()) c();
        else {
          var e = A.drain;
          A.drain = function() {
            typeof e == "function" && e(), c(), A.drain = e;
          };
        }
      });
    });
    return u;
  }
}
yc.exports = Lm;
yc.exports.promise = IT;
var kT = yc.exports, wr = {};
Object.defineProperty(wr, "__esModule", { value: true });
wr.joinPathSegments = wr.replacePathSegmentSeparator = wr.isAppliedFilter = wr.isFatalError = void 0;
function OT(a3, s) {
  return a3.errorFilter === null ? true : !a3.errorFilter(s);
}
wr.isFatalError = OT;
function DT(a3, s) {
  return a3 === null || a3(s);
}
wr.isAppliedFilter = DT;
function NT(a3, s) {
  return a3.split(/[/\\]/).join(s);
}
wr.replacePathSegmentSeparator = NT;
function RT(a3, s, o) {
  return a3 === "" ? s : a3.endsWith(o) ? a3 + s : a3 + o + s;
}
wr.joinPathSegments = RT;
var mo = {};
Object.defineProperty(mo, "__esModule", { value: true });
const jT = wr;
let LT = class {
  constructor(s, o) {
    this._root = s, this._settings = o, this._root = jT.replacePathSegmentSeparator(s, o.pathSegmentSeparator);
  }
};
mo.default = LT;
Object.defineProperty(co, "__esModule", { value: true });
const FT = gt, MT = Gr, BT = kT, ia = wr, $T = mo;
class UT extends $T.default {
  constructor(s, o) {
    super(s, o), this._settings = o, this._scandir = MT.scandir, this._emitter = new FT.EventEmitter(), this._queue = BT(this._worker.bind(this), this._settings.concurrency), this._isFatalError = false, this._isDestroyed = false, this._queue.drain = () => {
      this._isFatalError || this._emitter.emit("end");
    };
  }
  read() {
    return this._isFatalError = false, this._isDestroyed = false, setImmediate(() => {
      this._pushToQueue(this._root, this._settings.basePath);
    }), this._emitter;
  }
  get isDestroyed() {
    return this._isDestroyed;
  }
  destroy() {
    if (this._isDestroyed) throw new Error("The reader is already destroyed");
    this._isDestroyed = true, this._queue.killAndDrain();
  }
  onEntry(s) {
    this._emitter.on("entry", s);
  }
  onError(s) {
    this._emitter.once("error", s);
  }
  onEnd(s) {
    this._emitter.once("end", s);
  }
  _pushToQueue(s, o) {
    const b = { directory: s, base: o };
    this._queue.push(b, (A) => {
      A !== null && this._handleError(A);
    });
  }
  _worker(s, o) {
    this._scandir(s.directory, this._settings.fsScandirSettings, (b, A) => {
      if (b !== null) {
        o(b, void 0);
        return;
      }
      for (const R of A) this._handleEntry(R, s.base);
      o(null, void 0);
    });
  }
  _handleError(s) {
    this._isDestroyed || !ia.isFatalError(this._settings, s) || (this._isFatalError = true, this._isDestroyed = true, this._emitter.emit("error", s));
  }
  _handleEntry(s, o) {
    if (this._isDestroyed || this._isFatalError) return;
    const b = s.path;
    o !== void 0 && (s.path = ia.joinPathSegments(o, s.name, this._settings.pathSegmentSeparator)), ia.isAppliedFilter(this._settings.entryFilter, s) && this._emitEntry(s), s.dirent.isDirectory() && ia.isAppliedFilter(this._settings.deepFilter, s) && this._pushToQueue(b, o === void 0 ? void 0 : s.path);
  }
  _emitEntry(s) {
    this._emitter.emit("entry", s);
  }
}
co.default = UT;
Object.defineProperty(fc, "__esModule", { value: true });
const VT = co;
class WT {
  constructor(s, o) {
    this._root = s, this._settings = o, this._reader = new VT.default(this._root, this._settings), this._storage = [];
  }
  read(s) {
    this._reader.onError((o) => {
      HT(s, o);
    }), this._reader.onEntry((o) => {
      this._storage.push(o);
    }), this._reader.onEnd(() => {
      GT(s, this._storage);
    }), this._reader.read();
  }
}
fc.default = WT;
function HT(a3, s) {
  a3(s);
}
function GT(a3, s) {
  a3(null, s);
}
var bc = {};
Object.defineProperty(bc, "__esModule", { value: true });
const zT = gt, KT = co;
class qT {
  constructor(s, o) {
    this._root = s, this._settings = o, this._reader = new KT.default(this._root, this._settings), this._stream = new zT.Readable({ objectMode: true, read: () => {
    }, destroy: () => {
      this._reader.isDestroyed || this._reader.destroy();
    } });
  }
  read() {
    return this._reader.onError((s) => {
      this._stream.emit("error", s);
    }), this._reader.onEntry((s) => {
      this._stream.push(s);
    }), this._reader.onEnd(() => {
      this._stream.push(null);
    }), this._reader.read(), this._stream;
  }
}
bc.default = qT;
var gc = {}, vc = {};
Object.defineProperty(vc, "__esModule", { value: true });
const YT = Gr, aa = wr, XT = mo;
class JT extends XT.default {
  constructor() {
    super(...arguments), this._scandir = YT.scandirSync, this._storage = [], this._queue = /* @__PURE__ */ new Set();
  }
  read() {
    return this._pushToQueue(this._root, this._settings.basePath), this._handleQueue(), this._storage;
  }
  _pushToQueue(s, o) {
    this._queue.add({ directory: s, base: o });
  }
  _handleQueue() {
    for (const s of this._queue.values()) this._handleDirectory(s.directory, s.base);
  }
  _handleDirectory(s, o) {
    try {
      const b = this._scandir(s, this._settings.fsScandirSettings);
      for (const A of b) this._handleEntry(A, o);
    } catch (b) {
      this._handleError(b);
    }
  }
  _handleError(s) {
    if (aa.isFatalError(this._settings, s)) throw s;
  }
  _handleEntry(s, o) {
    const b = s.path;
    o !== void 0 && (s.path = aa.joinPathSegments(o, s.name, this._settings.pathSegmentSeparator)), aa.isAppliedFilter(this._settings.entryFilter, s) && this._pushToStorage(s), s.dirent.isDirectory() && aa.isAppliedFilter(this._settings.deepFilter, s) && this._pushToQueue(b, o === void 0 ? void 0 : s.path);
  }
  _pushToStorage(s) {
    this._storage.push(s);
  }
}
vc.default = JT;
Object.defineProperty(gc, "__esModule", { value: true });
const QT = vc;
class ZT {
  constructor(s, o) {
    this._root = s, this._settings = o, this._reader = new QT.default(this._root, this._settings);
  }
  read() {
    return this._reader.read();
  }
}
gc.default = ZT;
var Ec = {};
Object.defineProperty(Ec, "__esModule", { value: true });
const ew = gt, tw = Gr;
class nw {
  constructor(s = {}) {
    this._options = s, this.basePath = this._getValue(this._options.basePath, void 0), this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY), this.deepFilter = this._getValue(this._options.deepFilter, null), this.entryFilter = this._getValue(this._options.entryFilter, null), this.errorFilter = this._getValue(this._options.errorFilter, null), this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, ew.sep), this.fsScandirSettings = new tw.Settings({ followSymbolicLinks: this._options.followSymbolicLinks, fs: this._options.fs, pathSegmentSeparator: this._options.pathSegmentSeparator, stats: this._options.stats, throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink });
  }
  _getValue(s, o) {
    return s ?? o;
  }
}
Ec.default = nw;
Object.defineProperty(Tr, "__esModule", { value: true });
Tr.Settings = Tr.walkStream = Tr.walkSync = Tr.walk = void 0;
const Id = fc, rw = bc, sw = gc, iu = Ec;
Tr.Settings = iu.default;
function iw(a3, s, o) {
  if (typeof s == "function") {
    new Id.default(a3, Da()).read(s);
    return;
  }
  new Id.default(a3, Da(s)).read(o);
}
Tr.walk = iw;
function aw(a3, s) {
  const o = Da(s);
  return new sw.default(a3, o).read();
}
Tr.walkSync = aw;
function ow(a3, s) {
  const o = Da(s);
  return new rw.default(a3, o).read();
}
Tr.walkStream = ow;
function Da(a3 = {}) {
  return a3 instanceof iu.default ? a3 : new iu.default(a3);
}
var ji = {};
Object.defineProperty(ji, "__esModule", { value: true });
const lw = gt, uw = br, kd = Dn;
class cw {
  constructor(s) {
    this._settings = s, this._fsStatSettings = new uw.Settings({ followSymbolicLink: this._settings.followSymbolicLinks, fs: this._settings.fs, throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks });
  }
  _getFullEntryPath(s) {
    return lw.resolve(this._settings.cwd, s);
  }
  _makeEntry(s, o) {
    const b = { name: o, path: o, dirent: kd.fs.createDirentFromStats(o, s) };
    return this._settings.stats && (b.stats = s), b;
  }
  _isFatalError(s) {
    return !kd.errno.isEnoentCodeError(s) && !this._settings.suppressErrors;
  }
}
ji.default = cw;
var yo = {};
Object.defineProperty(yo, "__esModule", { value: true });
const pw = gt, dw = br, fw = Tr, hw = ji;
class mw extends hw.default {
  constructor() {
    super(...arguments), this._walkStream = fw.walkStream, this._stat = dw.stat;
  }
  dynamic(s, o) {
    return this._walkStream(s, o);
  }
  static(s, o) {
    const b = s.map(this._getFullEntryPath, this), A = new pw.PassThrough({ objectMode: true });
    A._write = (R, P, t) => this._getEntry(b[R], s[R], o).then((l) => {
      l !== null && o.entryFilter(l) && A.push(l), R === b.length - 1 && A.end(), t();
    }).catch(t);
    for (let R = 0; R < b.length; R++) A.write(R);
    return A;
  }
  _getEntry(s, o, b) {
    return this._getStat(s).then((A) => this._makeEntry(A, o)).catch((A) => {
      if (b.errorFilter(A)) return null;
      throw A;
    });
  }
  _getStat(s) {
    return new Promise((o, b) => {
      this._stat(s, this._fsStatSettings, (A, R) => A === null ? o(R) : b(A));
    });
  }
}
yo.default = mw;
Object.defineProperty(dc, "__esModule", { value: true });
const yw = Tr, bw = ji, gw = yo;
class vw extends bw.default {
  constructor() {
    super(...arguments), this._walkAsync = yw.walk, this._readerStream = new gw.default(this._settings);
  }
  dynamic(s, o) {
    return new Promise((b, A) => {
      this._walkAsync(s, o, (R, P) => {
        R === null ? b(P) : A(R);
      });
    });
  }
  async static(s, o) {
    const b = [], A = this._readerStream.static(s, o);
    return new Promise((R, P) => {
      A.once("error", P), A.on("data", (t) => b.push(t)), A.once("end", () => R(b));
    });
  }
}
dc.default = vw;
var Li = {}, Sc = {}, _c = {}, Tc = {};
Object.defineProperty(Tc, "__esModule", { value: true });
const ai = Dn;
class Ew {
  constructor(s, o, b) {
    this._patterns = s, this._settings = o, this._micromatchOptions = b, this._storage = [], this._fillStorage();
  }
  _fillStorage() {
    for (const s of this._patterns) {
      const o = this._getPatternSegments(s), b = this._splitSegmentsIntoSections(o);
      this._storage.push({ complete: b.length <= 1, pattern: s, segments: o, sections: b });
    }
  }
  _getPatternSegments(s) {
    return ai.pattern.getPatternParts(s, this._micromatchOptions).map((b) => ai.pattern.isDynamicPattern(b, this._settings) ? { dynamic: true, pattern: b, patternRe: ai.pattern.makeRe(b, this._micromatchOptions) } : { dynamic: false, pattern: b });
  }
  _splitSegmentsIntoSections(s) {
    return ai.array.splitWhen(s, (o) => o.dynamic && ai.pattern.hasGlobStar(o.pattern));
  }
}
Tc.default = Ew;
Object.defineProperty(_c, "__esModule", { value: true });
const Sw = Tc;
class _w extends Sw.default {
  match(s) {
    const o = s.split("/"), b = o.length, A = this._storage.filter((R) => !R.complete || R.segments.length > b);
    for (const R of A) {
      const P = R.sections[0];
      if (!R.complete && b > P.length || o.every((l, n) => {
        const u = R.segments[n];
        return !!(u.dynamic && u.patternRe.test(l) || !u.dynamic && u.pattern === l);
      })) return true;
    }
    return false;
  }
}
_c.default = _w;
Object.defineProperty(Sc, "__esModule", { value: true });
const oa = Dn, Tw = _c;
class ww {
  constructor(s, o) {
    this._settings = s, this._micromatchOptions = o;
  }
  getFilter(s, o, b) {
    const A = this._getMatcher(o), R = this._getNegativePatternsRe(b);
    return (P) => this._filter(s, P, A, R);
  }
  _getMatcher(s) {
    return new Tw.default(s, this._settings, this._micromatchOptions);
  }
  _getNegativePatternsRe(s) {
    const o = s.filter(oa.pattern.isAffectDepthOfReadingPattern);
    return oa.pattern.convertPatternsToRe(o, this._micromatchOptions);
  }
  _filter(s, o, b, A) {
    if (this._isSkippedByDeep(s, o.path) || this._isSkippedSymbolicLink(o)) return false;
    const R = oa.path.removeLeadingDotSegment(o.path);
    return this._isSkippedByPositivePatterns(R, b) ? false : this._isSkippedByNegativePatterns(R, A);
  }
  _isSkippedByDeep(s, o) {
    return this._settings.deep === 1 / 0 ? false : this._getEntryLevel(s, o) >= this._settings.deep;
  }
  _getEntryLevel(s, o) {
    const b = o.split("/").length;
    if (s === "") return b;
    const A = s.split("/").length;
    return b - A;
  }
  _isSkippedSymbolicLink(s) {
    return !this._settings.followSymbolicLinks && s.dirent.isSymbolicLink();
  }
  _isSkippedByPositivePatterns(s, o) {
    return !this._settings.baseNameMatch && !o.match(s);
  }
  _isSkippedByNegativePatterns(s, o) {
    return !oa.pattern.matchAny(s, o);
  }
}
Sc.default = ww;
var wc = {};
Object.defineProperty(wc, "__esModule", { value: true });
const cs = Dn;
class Pw {
  constructor(s, o) {
    this._settings = s, this._micromatchOptions = o, this.index = /* @__PURE__ */ new Map();
  }
  getFilter(s, o) {
    const [b, A] = cs.pattern.partitionAbsoluteAndRelative(o), R = { positive: { all: cs.pattern.convertPatternsToRe(s, this._micromatchOptions) }, negative: { absolute: cs.pattern.convertPatternsToRe(b, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true })), relative: cs.pattern.convertPatternsToRe(A, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true })) } };
    return (P) => this._filter(P, R);
  }
  _filter(s, o) {
    const b = cs.path.removeLeadingDotSegment(s.path);
    if (this._settings.unique && this._isDuplicateEntry(b) || this._onlyFileFilter(s) || this._onlyDirectoryFilter(s)) return false;
    const A = this._isMatchToPatternsSet(b, o, s.dirent.isDirectory());
    return this._settings.unique && A && this._createIndexRecord(b), A;
  }
  _isDuplicateEntry(s) {
    return this.index.has(s);
  }
  _createIndexRecord(s) {
    this.index.set(s, void 0);
  }
  _onlyFileFilter(s) {
    return this._settings.onlyFiles && !s.dirent.isFile();
  }
  _onlyDirectoryFilter(s) {
    return this._settings.onlyDirectories && !s.dirent.isDirectory();
  }
  _isMatchToPatternsSet(s, o, b) {
    return !(!this._isMatchToPatterns(s, o.positive.all, b) || this._isMatchToPatterns(s, o.negative.relative, b) || this._isMatchToAbsoluteNegative(s, o.negative.absolute, b));
  }
  _isMatchToAbsoluteNegative(s, o, b) {
    if (o.length === 0) return false;
    const A = cs.path.makeAbsolute(this._settings.cwd, s);
    return this._isMatchToPatterns(A, o, b);
  }
  _isMatchToPatterns(s, o, b) {
    if (o.length === 0) return false;
    const A = cs.pattern.matchAny(s, o);
    return !A && b ? cs.pattern.matchAny(s + "/", o) : A;
  }
}
wc.default = Pw;
var Pc = {};
Object.defineProperty(Pc, "__esModule", { value: true });
const xw = Dn;
class Aw {
  constructor(s) {
    this._settings = s;
  }
  getFilter() {
    return (s) => this._isNonFatalError(s);
  }
  _isNonFatalError(s) {
    return xw.errno.isEnoentCodeError(s) || this._settings.suppressErrors;
  }
}
Pc.default = Aw;
var xc = {};
Object.defineProperty(xc, "__esModule", { value: true });
const Od = Dn;
class Cw {
  constructor(s) {
    this._settings = s;
  }
  getTransformer() {
    return (s) => this._transform(s);
  }
  _transform(s) {
    let o = s.path;
    return this._settings.absolute && (o = Od.path.makeAbsolute(this._settings.cwd, o), o = Od.path.unixify(o)), this._settings.markDirectories && s.dirent.isDirectory() && (o += "/"), this._settings.objectMode ? Object.assign(Object.assign({}, s), { path: o }) : o;
  }
}
xc.default = Cw;
Object.defineProperty(Li, "__esModule", { value: true });
const Iw = gt, kw = Sc, Ow = wc, Dw = Pc, Nw = xc;
class Rw {
  constructor(s) {
    this._settings = s, this.errorFilter = new Dw.default(this._settings), this.entryFilter = new Ow.default(this._settings, this._getMicromatchOptions()), this.deepFilter = new kw.default(this._settings, this._getMicromatchOptions()), this.entryTransformer = new Nw.default(this._settings);
  }
  _getRootDirectory(s) {
    return Iw.resolve(this._settings.cwd, s.base);
  }
  _getReaderOptions(s) {
    const o = s.base === "." ? "" : s.base;
    return { basePath: o, pathSegmentSeparator: "/", concurrency: this._settings.concurrency, deepFilter: this.deepFilter.getFilter(o, s.positive, s.negative), entryFilter: this.entryFilter.getFilter(s.positive, s.negative), errorFilter: this.errorFilter.getFilter(), followSymbolicLinks: this._settings.followSymbolicLinks, fs: this._settings.fs, stats: this._settings.stats, throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink, transform: this.entryTransformer.getTransformer() };
  }
  _getMicromatchOptions() {
    return { dot: this._settings.dot, matchBase: this._settings.baseNameMatch, nobrace: !this._settings.braceExpansion, nocase: !this._settings.caseSensitiveMatch, noext: !this._settings.extglob, noglobstar: !this._settings.globstar, posix: true, strictSlashes: false };
  }
}
Li.default = Rw;
Object.defineProperty(pc, "__esModule", { value: true });
const jw = dc, Lw = Li;
class Fw extends Lw.default {
  constructor() {
    super(...arguments), this._reader = new jw.default(this._settings);
  }
  async read(s) {
    const o = this._getRootDirectory(s), b = this._getReaderOptions(s);
    return (await this.api(o, s, b)).map((R) => b.transform(R));
  }
  api(s, o, b) {
    return o.dynamic ? this._reader.dynamic(s, b) : this._reader.static(o.patterns, b);
  }
}
pc.default = Fw;
var Ac = {};
Object.defineProperty(Ac, "__esModule", { value: true });
const Mw = gt, Bw = yo, $w = Li;
class Uw extends $w.default {
  constructor() {
    super(...arguments), this._reader = new Bw.default(this._settings);
  }
  read(s) {
    const o = this._getRootDirectory(s), b = this._getReaderOptions(s), A = this.api(o, s, b), R = new Mw.Readable({ objectMode: true, read: () => {
    } });
    return A.once("error", (P) => R.emit("error", P)).on("data", (P) => R.emit("data", b.transform(P))).once("end", () => R.emit("end")), R.once("close", () => A.destroy()), R;
  }
  api(s, o, b) {
    return o.dynamic ? this._reader.dynamic(s, b) : this._reader.static(o.patterns, b);
  }
}
Ac.default = Uw;
var Cc = {}, Ic = {};
Object.defineProperty(Ic, "__esModule", { value: true });
const Vw = br, Ww = Tr, Hw = ji;
class Gw extends Hw.default {
  constructor() {
    super(...arguments), this._walkSync = Ww.walkSync, this._statSync = Vw.statSync;
  }
  dynamic(s, o) {
    return this._walkSync(s, o);
  }
  static(s, o) {
    const b = [];
    for (const A of s) {
      const R = this._getFullEntryPath(A), P = this._getEntry(R, A, o);
      P === null || !o.entryFilter(P) || b.push(P);
    }
    return b;
  }
  _getEntry(s, o, b) {
    try {
      const A = this._getStat(s);
      return this._makeEntry(A, o);
    } catch (A) {
      if (b.errorFilter(A)) return null;
      throw A;
    }
  }
  _getStat(s) {
    return this._statSync(s, this._fsStatSettings);
  }
}
Ic.default = Gw;
Object.defineProperty(Cc, "__esModule", { value: true });
const zw = Ic, Kw = Li;
class qw extends Kw.default {
  constructor() {
    super(...arguments), this._reader = new zw.default(this._settings);
  }
  read(s) {
    const o = this._getRootDirectory(s), b = this._getReaderOptions(s);
    return this.api(o, s, b).map(b.transform);
  }
  api(s, o, b) {
    return o.dynamic ? this._reader.dynamic(s, b) : this._reader.static(o.patterns, b);
  }
}
Cc.default = qw;
var Fm = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), a3.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  const s = gt, b = Math.max(gt.cpus().length, 1);
  a3.DEFAULT_FILE_SYSTEM_ADAPTER = { lstat: s.lstat, lstatSync: s.lstatSync, stat: s.stat, statSync: s.statSync, readdir: s.readdir, readdirSync: s.readdirSync };
  class A {
    constructor(P = {}) {
      this._options = P, this.absolute = this._getValue(this._options.absolute, false), this.baseNameMatch = this._getValue(this._options.baseNameMatch, false), this.braceExpansion = this._getValue(this._options.braceExpansion, true), this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true), this.concurrency = this._getValue(this._options.concurrency, b), this.cwd = this._getValue(this._options.cwd, process.cwd()), this.deep = this._getValue(this._options.deep, 1 / 0), this.dot = this._getValue(this._options.dot, false), this.extglob = this._getValue(this._options.extglob, true), this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true), this.fs = this._getFileSystemMethods(this._options.fs), this.globstar = this._getValue(this._options.globstar, true), this.ignore = this._getValue(this._options.ignore, []), this.markDirectories = this._getValue(this._options.markDirectories, false), this.objectMode = this._getValue(this._options.objectMode, false), this.onlyDirectories = this._getValue(this._options.onlyDirectories, false), this.onlyFiles = this._getValue(this._options.onlyFiles, true), this.stats = this._getValue(this._options.stats, false), this.suppressErrors = this._getValue(this._options.suppressErrors, false), this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false), this.unique = this._getValue(this._options.unique, true), this.onlyDirectories && (this.onlyFiles = false), this.stats && (this.objectMode = true), this.ignore = [].concat(this.ignore);
    }
    _getValue(P, t) {
      return P === void 0 ? t : P;
    }
    _getFileSystemMethods(P = {}) {
      return Object.assign(Object.assign({}, a3.DEFAULT_FILE_SYSTEM_ADAPTER), P);
    }
  }
  a3.default = A;
})(Fm);
const Mm = qn, Yw = pc, Xw = Ac, Jw = Cc, au = Fm, Sr = Dn;
async function ou(a3, s) {
  Dr(a3);
  const o = lu(a3, Yw.default, s), b = await Promise.all(o);
  return Sr.array.flatten(b);
}
(function(a3) {
  a3.glob = a3, a3.globSync = s, a3.globStream = o, a3.async = a3;
  function s(t, l) {
    Dr(t);
    const n = lu(t, Jw.default, l);
    return Sr.array.flatten(n);
  }
  a3.sync = s;
  function o(t, l) {
    Dr(t);
    const n = lu(t, Xw.default, l);
    return Sr.stream.merge(n);
  }
  a3.stream = o;
  function b(t, l) {
    Dr(t);
    const n = [].concat(t), u = new au.default(l);
    return Mm.generate(n, u);
  }
  a3.generateTasks = b;
  function A(t, l) {
    Dr(t);
    const n = new au.default(l);
    return Sr.pattern.isDynamicPattern(t, n);
  }
  a3.isDynamicPattern = A;
  function R(t) {
    return Dr(t), Sr.path.escape(t);
  }
  a3.escapePath = R;
  function P(t) {
    return Dr(t), Sr.path.convertPathToPattern(t);
  }
  a3.convertPathToPattern = P, function(t) {
    function l(u) {
      return Dr(u), Sr.path.escapePosixPath(u);
    }
    t.escapePath = l;
    function n(u) {
      return Dr(u), Sr.path.convertPosixPathToPattern(u);
    }
    t.convertPathToPattern = n;
  }(a3.posix || (a3.posix = {})), function(t) {
    function l(u) {
      return Dr(u), Sr.path.escapeWindowsPath(u);
    }
    t.escapePath = l;
    function n(u) {
      return Dr(u), Sr.path.convertWindowsPathToPattern(u);
    }
    t.convertPathToPattern = n;
  }(a3.win32 || (a3.win32 = {}));
})(ou || (ou = {}));
function lu(a3, s, o) {
  const b = [].concat(a3), A = new au.default(o), R = Mm.generate(b, A), P = new s(A);
  return R.map(P.read, P);
}
function Dr(a3) {
  if (![].concat(a3).every((b) => Sr.string.isString(b) && !Sr.string.isEmpty(b))) throw new TypeError("Patterns must be a string (non empty) or an array of strings");
}
var Qw = ou;
/*!
* normalize-path <https://github.com/jonschlinkert/normalize-path>
*
* Copyright (c) 2014-2018, Jon Schlinkert.
* Released under the MIT License.
*/
var Zw = function(a3, s) {
  if (typeof a3 != "string") throw new TypeError("expected path to be a string");
  if (a3 === "\\" || a3 === "/") return "/";
  var o = a3.length;
  if (o <= 1) return a3;
  var b = "";
  if (o > 4 && a3[3] === "\\") {
    var A = a3[2];
    (A === "?" || A === ".") && a3.slice(0, 2) === "\\\\" && (a3 = a3.slice(2), b = "//");
  }
  var R = a3.split(/[/\\]+/);
  return s !== false && R[R.length - 1] === "" && R.pop(), b + R.join("/");
}, Bm = {}, eP = ec, tP = gt.posix.dirname, nP = gt.platform() === "win32", ga = "/", rP = /\\/g, sP = /\\([!*?|[\](){}])/g, iP = function(s, o) {
  var b = Object.assign({ flipBackslashes: true }, o);
  b.flipBackslashes && nP && s.indexOf(ga) < 0 && (s = s.replace(rP, ga)), aP(s) && (s += ga), s += "a";
  do
    s = tP(s);
  while (oP(s));
  return s.replace(sP, "$1");
};
function aP(a3) {
  var s = a3.slice(-1), o;
  switch (s) {
    case "}":
      o = "{";
      break;
    case "]":
      o = "[";
      break;
    default:
      return false;
  }
  var b = a3.indexOf(o);
  return b < 0 ? false : a3.slice(b + 1, -1).includes(ga);
}
function oP(a3) {
  return /\([^()]+$/.test(a3) || a3[0] === "{" || a3[0] === "[" || /[^\\][{[]/.test(a3) ? true : eP(a3);
}
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "parseGlob", { enumerable: true, get: function() {
    return b;
  } });
  const s = o(iP);
  function o(A) {
    return A && A.__esModule ? A : { default: A };
  }
  function b(A) {
    let R = A, P = (0, s.default)(A);
    return P !== "." && (R = A.substr(P.length), R.charAt(0) === "/" && (R = R.substr(1))), R.substr(0, 2) === "./" ? R = R.substr(2) : R.charAt(0) === "/" && (R = R.substr(1)), { base: P, glob: R };
  }
})(Bm);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(E, _) {
    for (var C in _) Object.defineProperty(E, C, { enumerable: true, get: _[C] });
  }
  s(a3, { parseCandidateFiles: function() {
    return e;
  }, resolvedChangedContent: function() {
    return T;
  }, createBroadPatternCheck: function() {
    return h;
  } });
  const o = c(gt), b = c(gt), A = c(ec), R = c(Qw), P = c(Zw), t = Bm, l = Os, n = c(xr), u = c(um);
  function c(E) {
    return E && E.__esModule ? E : { default: E };
  }
  function e(E, _) {
    let C = _.content.files;
    C = C.filter((L) => typeof L == "string"), C = C.map(P.default);
    let w = R.default.generateTasks(C), I = [], D = [];
    for (const L of w) I.push(...L.positive.map((k) => r(k, false))), D.push(...L.negative.map((k) => r(k, true)));
    let j = [...I, ...D];
    return j = y(E, j), j = j.flatMap(S), j = j.map(f), j;
  }
  function r(E, _) {
    let C = { original: E, base: E, ignore: _, pattern: E, glob: null };
    return (0, A.default)(E) && Object.assign(C, (0, t.parseGlob)(E)), C;
  }
  function f(E) {
    let _ = (0, P.default)(E.base);
    return _ = R.default.escapePath(_), E.pattern = E.glob ? `${_}/${E.glob}` : _, E.pattern = E.ignore ? `!${E.pattern}` : E.pattern, E;
  }
  function y(E, _) {
    let C = [];
    return E.userConfigPath && E.tailwindConfig.content.relative && (C = [b.default.dirname(E.userConfigPath)]), _.map((w) => (w.base = b.default.resolve(...C, w.base), w));
  }
  function S(E) {
    let _ = [E];
    try {
      let C = o.default.realpathSync(E.base);
      C !== E.base && _.push({ ...E, base: C });
    } catch {
    }
    return _;
  }
  function T(E, _, C) {
    let w = E.tailwindConfig.content.files.filter((j) => typeof j.raw == "string").map(({ raw: j, extension: L = "html" }) => ({ content: j, extension: L })), [I, D] = m(_, C);
    for (let j of I) {
      let L = b.default.extname(j).slice(1);
      w.push({ file: j, extension: L });
    }
    return [w, D];
  }
  const d = ["node_modules"], p = new RegExp(`(${d.map((E) => String.raw`\b${E}\b`).join("|")})`);
  function h(E) {
    if (!E.some((D) => D.includes("**") && !p.test(D))) return () => {
    };
    let C = [], w = [];
    for (let D of E) {
      let j = u.default.matcher(D);
      p.test(D) && w.push(j), C.push(j);
    }
    let I = false;
    return (D) => {
      if (I || w.some((F) => F(D))) return;
      let j = C.findIndex((F) => F(D));
      if (j === -1) return;
      let L = E[j], k = b.default.relative(process.cwd(), L);
      k[0] !== "." && (k = `./${k}`);
      let N = d.find((F) => D.includes(F));
      N && (I = true, n.default.warn("broad-content-glob-pattern", [`Your \`content\` configuration includes a pattern which looks like it's accidentally matching all of \`${N}\` and can cause serious performance issues.`, `Pattern: \`${k}\``, "See our documentation for recommendations:", "https://tailwindcss.com/docs/content-configuration#pattern-recommendations"]));
    };
  }
  function m(E, _) {
    let C = E.map((L) => L.pattern), w = /* @__PURE__ */ new Map(), I = h(C), D = /* @__PURE__ */ new Set();
    l.env.DEBUG && console.time("Finding changed files");
    let j = R.default.sync(C, { absolute: true });
    for (let L of j) {
      I(L);
      let k = _.get(L) || -1 / 0, N = o.default.statSync(L).mtimeMs;
      N > k && (D.add(L), w.set(L, N));
    }
    return l.env.DEBUG && console.timeEnd("Finding changed files"), [D, w];
  }
})(Hh);
var $m = {}, Jo = { exports: {} }, Dd;
function lP() {
  return Dd || (Dd = 1, function(a3) {
    var s = {};
    (() => {
      var o = { "./node_modules/.pnpm/create-require@1.1.1/node_modules/create-require/create-require.js": (P, t, l) => {
        const n = l("module"), u = l("path"), c = l("fs");
        P.exports = function(e) {
          return e || (e = process.cwd()), function(r) {
            try {
              return c.lstatSync(r).isDirectory();
            } catch {
              return false;
            }
          }(e) && (e = u.join(e, "index.js")), n.createRequire ? n.createRequire(e) : n.createRequireFromPath ? n.createRequireFromPath(e) : function(r) {
            const f = new n.Module(r, null);
            return f.filename = r, f.paths = n.Module._nodeModulePaths(u.dirname(r)), f._compile("module.exports = require;", r), f.exports;
          }(e);
        };
      }, "./node_modules/.pnpm/mlly@1.7.3/node_modules/mlly/dist lazy recursive": (P) => {
        function t(l) {
          return Promise.resolve().then(() => {
            var n = new Error("Cannot find module '" + l + "'");
            throw n.code = "MODULE_NOT_FOUND", n;
          });
        }
        t.keys = () => [], t.resolve = t, t.id = "./node_modules/.pnpm/mlly@1.7.3/node_modules/mlly/dist lazy recursive", P.exports = t;
      }, "./node_modules/.pnpm/object-hash@3.0.0/node_modules/object-hash/index.js": (P, t, l) => {
        var n = l("crypto");
        function u(T, d) {
          return function(p, h) {
            var m;
            m = h.algorithm !== "passthrough" ? n.createHash(h.algorithm) : new S(), m.write === void 0 && (m.write = m.update, m.end = m.update);
            var E = y(h, m);
            if (E.dispatch(p), m.update || m.end(""), m.digest) return m.digest(h.encoding === "buffer" ? void 0 : h.encoding);
            var _ = m.read();
            return h.encoding === "buffer" ? _ : _.toString(h.encoding);
          }(T, d = r(T, d));
        }
        (t = P.exports = u).sha1 = function(T) {
          return u(T);
        }, t.keys = function(T) {
          return u(T, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
        }, t.MD5 = function(T) {
          return u(T, { algorithm: "md5", encoding: "hex" });
        }, t.keysMD5 = function(T) {
          return u(T, { algorithm: "md5", encoding: "hex", excludeValues: true });
        };
        var c = n.getHashes ? n.getHashes().slice() : ["sha1", "md5"];
        c.push("passthrough");
        var e = ["buffer", "hex", "binary", "base64"];
        function r(T, d) {
          d = d || {};
          var p = {};
          if (p.algorithm = d.algorithm || "sha1", p.encoding = d.encoding || "hex", p.excludeValues = !!d.excludeValues, p.algorithm = p.algorithm.toLowerCase(), p.encoding = p.encoding.toLowerCase(), p.ignoreUnknown = d.ignoreUnknown === true, p.respectType = d.respectType !== false, p.respectFunctionNames = d.respectFunctionNames !== false, p.respectFunctionProperties = d.respectFunctionProperties !== false, p.unorderedArrays = d.unorderedArrays === true, p.unorderedSets = d.unorderedSets !== false, p.unorderedObjects = d.unorderedObjects !== false, p.replacer = d.replacer || void 0, p.excludeKeys = d.excludeKeys || void 0, T === void 0) throw new Error("Object argument required.");
          for (var h = 0; h < c.length; ++h) c[h].toLowerCase() === p.algorithm.toLowerCase() && (p.algorithm = c[h]);
          if (c.indexOf(p.algorithm) === -1) throw new Error('Algorithm "' + p.algorithm + '"  not supported. supported values: ' + c.join(", "));
          if (e.indexOf(p.encoding) === -1 && p.algorithm !== "passthrough") throw new Error('Encoding "' + p.encoding + '"  not supported. supported values: ' + e.join(", "));
          return p;
        }
        function f(T) {
          return typeof T != "function" ? false : /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(T)) != null;
        }
        function y(T, d, p) {
          p = p || [];
          var h = function(m) {
            return d.update ? d.update(m, "utf8") : d.write(m, "utf8");
          };
          return { dispatch: function(m) {
            T.replacer && (m = T.replacer(m));
            var E = typeof m;
            return m === null && (E = "null"), this["_" + E](m);
          }, _object: function(m) {
            var E = Object.prototype.toString.call(m), _ = /\[object (.*)\]/i.exec(E);
            _ = (_ = _ ? _[1] : "unknown:[" + E + "]").toLowerCase();
            var C;
            if ((C = p.indexOf(m)) >= 0) return this.dispatch("[CIRCULAR:" + C + "]");
            if (p.push(m), typeof Buffer < "u" && Buffer.isBuffer && Buffer.isBuffer(m)) return h("buffer:"), h(m);
            if (_ === "object" || _ === "function" || _ === "asyncfunction") {
              var w = Object.keys(m);
              T.unorderedObjects && (w = w.sort()), T.respectType === false || f(m) || w.splice(0, 0, "prototype", "__proto__", "constructor"), T.excludeKeys && (w = w.filter(function(D) {
                return !T.excludeKeys(D);
              })), h("object:" + w.length + ":");
              var I = this;
              return w.forEach(function(D) {
                I.dispatch(D), h(":"), T.excludeValues || I.dispatch(m[D]), h(",");
              });
            }
            if (!this["_" + _]) {
              if (T.ignoreUnknown) return h("[" + _ + "]");
              throw new Error('Unknown object type "' + _ + '"');
            }
            this["_" + _](m);
          }, _array: function(m, E) {
            E = E !== void 0 ? E : T.unorderedArrays !== false;
            var _ = this;
            if (h("array:" + m.length + ":"), !E || m.length <= 1) return m.forEach(function(I) {
              return _.dispatch(I);
            });
            var C = [], w = m.map(function(I) {
              var D = new S(), j = p.slice();
              return y(T, D, j).dispatch(I), C = C.concat(j.slice(p.length)), D.read().toString();
            });
            return p = p.concat(C), w.sort(), this._array(w, false);
          }, _date: function(m) {
            return h("date:" + m.toJSON());
          }, _symbol: function(m) {
            return h("symbol:" + m.toString());
          }, _error: function(m) {
            return h("error:" + m.toString());
          }, _boolean: function(m) {
            return h("bool:" + m.toString());
          }, _string: function(m) {
            h("string:" + m.length + ":"), h(m.toString());
          }, _function: function(m) {
            h("fn:"), f(m) ? this.dispatch("[native]") : this.dispatch(m.toString()), T.respectFunctionNames !== false && this.dispatch("function-name:" + String(m.name)), T.respectFunctionProperties && this._object(m);
          }, _number: function(m) {
            return h("number:" + m.toString());
          }, _xml: function(m) {
            return h("xml:" + m.toString());
          }, _null: function() {
            return h("Null");
          }, _undefined: function() {
            return h("Undefined");
          }, _regexp: function(m) {
            return h("regex:" + m.toString());
          }, _uint8array: function(m) {
            return h("uint8array:"), this.dispatch(Array.prototype.slice.call(m));
          }, _uint8clampedarray: function(m) {
            return h("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(m));
          }, _int8array: function(m) {
            return h("int8array:"), this.dispatch(Array.prototype.slice.call(m));
          }, _uint16array: function(m) {
            return h("uint16array:"), this.dispatch(Array.prototype.slice.call(m));
          }, _int16array: function(m) {
            return h("int16array:"), this.dispatch(Array.prototype.slice.call(m));
          }, _uint32array: function(m) {
            return h("uint32array:"), this.dispatch(Array.prototype.slice.call(m));
          }, _int32array: function(m) {
            return h("int32array:"), this.dispatch(Array.prototype.slice.call(m));
          }, _float32array: function(m) {
            return h("float32array:"), this.dispatch(Array.prototype.slice.call(m));
          }, _float64array: function(m) {
            return h("float64array:"), this.dispatch(Array.prototype.slice.call(m));
          }, _arraybuffer: function(m) {
            return h("arraybuffer:"), this.dispatch(new Uint8Array(m));
          }, _url: function(m) {
            return h("url:" + m.toString());
          }, _map: function(m) {
            h("map:");
            var E = Array.from(m);
            return this._array(E, T.unorderedSets !== false);
          }, _set: function(m) {
            h("set:");
            var E = Array.from(m);
            return this._array(E, T.unorderedSets !== false);
          }, _file: function(m) {
            return h("file:"), this.dispatch([m.name, m.size, m.type, m.lastModfied]);
          }, _blob: function() {
            if (T.ignoreUnknown) return h("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return h("domwindow");
          }, _bigint: function(m) {
            return h("bigint:" + m.toString());
          }, _process: function() {
            return h("process");
          }, _timer: function() {
            return h("timer");
          }, _pipe: function() {
            return h("pipe");
          }, _tcp: function() {
            return h("tcp");
          }, _udp: function() {
            return h("udp");
          }, _tty: function() {
            return h("tty");
          }, _statwatcher: function() {
            return h("statwatcher");
          }, _securecontext: function() {
            return h("securecontext");
          }, _connection: function() {
            return h("connection");
          }, _zlib: function() {
            return h("zlib");
          }, _context: function() {
            return h("context");
          }, _nodescript: function() {
            return h("nodescript");
          }, _httpparser: function() {
            return h("httpparser");
          }, _dataview: function() {
            return h("dataview");
          }, _signal: function() {
            return h("signal");
          }, _fsevent: function() {
            return h("fsevent");
          }, _tlswrap: function() {
            return h("tlswrap");
          } };
        }
        function S() {
          return { buf: "", write: function(T) {
            this.buf += T;
          }, end: function(T) {
            this.buf += T;
          }, read: function() {
            return this.buf;
          } };
        }
        t.writeToStream = function(T, d, p) {
          return p === void 0 && (p = d, d = {}), y(d = r(T, d), p).dispatch(T);
        };
      }, "./node_modules/.pnpm/pirates@4.0.6/node_modules/pirates/lib/index.js": (P, t, l) => {
        P = l.nmd(P), Object.defineProperty(t, "__esModule", { value: true }), t.addHook = function(y, S = {}) {
          let T = false;
          const d = [], p = [];
          let h;
          const m = r._extensions[".js"], E = S.matcher || null, _ = S.ignoreNodeModules !== false;
          return h = S.extensions || S.exts || S.extension || S.ext || [".js"], Array.isArray(h) || (h = [h]), h.forEach((C) => {
            if (typeof C != "string") throw new TypeError(`Invalid Extension: ${C}`);
            const w = r._extensions[C] || m;
            p[C] = r._extensions[C], d[C] = r._extensions[C] = function(I, D) {
              let j;
              T || function(L, k, N, F) {
                if (typeof L != "string" || k.indexOf(u.default.extname(L)) === -1) return false;
                const W = u.default.resolve(L);
                return F && e.test(W) ? false : N && typeof N == "function" ? !!N(W) : true;
              }(D, h, E, _) && (j = I._compile, I._compile = function(L) {
                I._compile = j;
                const k = y(L, D);
                if (typeof k != "string") throw new Error(f);
                return I._compile(k, D);
              }), w(I, D);
            };
          }), function() {
            T || (T = true, h.forEach((C) => {
              r._extensions[C] === d[C] && (p[C] ? r._extensions[C] = p[C] : delete r._extensions[C]);
            }));
          };
        };
        var n = c(l("module")), u = c(l("path"));
        function c(y) {
          return y && y.__esModule ? y : { default: y };
        }
        const e = /^(?:.*[\\/])?node_modules(?:[\\/].*)?$/, r = P.constructor.length > 1 ? P.constructor : n.default, f = `[Pirates] A hook returned a non-string, or nothing at all! This is a violation of intergalactic law!
--------------------
If you have no idea what this means or what Pirates is, let me explain: Pirates is a module that makes is easy to implement require hooks. One of the require hooks you're using uses it. One of these require hooks didn't return anything from it's handler, so we don't know what to do. You might want to debug this.`;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/comparator.js": (P, t, l) => {
        const n = Symbol("SemVer ANY");
        class u {
          static get ANY() {
            return n;
          }
          constructor(p, h) {
            if (h = c(h), p instanceof u) {
              if (p.loose === !!h.loose) return p;
              p = p.value;
            }
            p = p.trim().split(/\s+/).join(" "), y("comparator", p, h), this.options = h, this.loose = !!h.loose, this.parse(p), this.semver === n ? this.value = "" : this.value = this.operator + this.semver.version, y("comp", this);
          }
          parse(p) {
            const h = this.options.loose ? e[r.COMPARATORLOOSE] : e[r.COMPARATOR], m = p.match(h);
            if (!m) throw new TypeError(`Invalid comparator: ${p}`);
            this.operator = m[1] !== void 0 ? m[1] : "", this.operator === "=" && (this.operator = ""), m[2] ? this.semver = new S(m[2], this.options.loose) : this.semver = n;
          }
          toString() {
            return this.value;
          }
          test(p) {
            if (y("Comparator.test", p, this.options.loose), this.semver === n || p === n) return true;
            if (typeof p == "string") try {
              p = new S(p, this.options);
            } catch {
              return false;
            }
            return f(p, this.operator, this.semver, this.options);
          }
          intersects(p, h) {
            if (!(p instanceof u)) throw new TypeError("a Comparator is required");
            return this.operator === "" ? this.value === "" || new T(p.value, h).test(this.value) : p.operator === "" ? p.value === "" || new T(this.value, h).test(p.semver) : (!(h = c(h)).includePrerelease || this.value !== "<0.0.0-0" && p.value !== "<0.0.0-0") && !(!h.includePrerelease && (this.value.startsWith("<0.0.0") || p.value.startsWith("<0.0.0"))) && (!(!this.operator.startsWith(">") || !p.operator.startsWith(">")) || !(!this.operator.startsWith("<") || !p.operator.startsWith("<")) || !(this.semver.version !== p.semver.version || !this.operator.includes("=") || !p.operator.includes("=")) || !!(f(this.semver, "<", p.semver, h) && this.operator.startsWith(">") && p.operator.startsWith("<")) || !!(f(this.semver, ">", p.semver, h) && this.operator.startsWith("<") && p.operator.startsWith(">")));
          }
        }
        P.exports = u;
        const c = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/parse-options.js"), { safeRe: e, t: r } = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/re.js"), f = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/cmp.js"), y = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/debug.js"), S = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js"), T = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js");
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js": (P, t, l) => {
        const n = /\s+/g;
        class u {
          constructor(re, Y) {
            if (Y = e(Y), re instanceof u) return re.loose === !!Y.loose && re.includePrerelease === !!Y.includePrerelease ? re : new u(re.raw, Y);
            if (re instanceof r) return this.raw = re.value, this.set = [[re]], this.formatted = void 0, this;
            if (this.options = Y, this.loose = !!Y.loose, this.includePrerelease = !!Y.includePrerelease, this.raw = re.trim().replace(n, " "), this.set = this.raw.split("||").map((Z) => this.parseRange(Z.trim())).filter((Z) => Z.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
            if (this.set.length > 1) {
              const Z = this.set[0];
              if (this.set = this.set.filter((G) => !_(G[0])), this.set.length === 0) this.set = [Z];
              else if (this.set.length > 1) {
                for (const G of this.set) if (G.length === 1 && C(G[0])) {
                  this.set = [G];
                  break;
                }
              }
            }
            this.formatted = void 0;
          }
          get range() {
            if (this.formatted === void 0) {
              this.formatted = "";
              for (let re = 0; re < this.set.length; re++) {
                re > 0 && (this.formatted += "||");
                const Y = this.set[re];
                for (let Z = 0; Z < Y.length; Z++) Z > 0 && (this.formatted += " "), this.formatted += Y[Z].toString().trim();
              }
            }
            return this.formatted;
          }
          format() {
            return this.range;
          }
          toString() {
            return this.range;
          }
          parseRange(re) {
            const Y = ((this.options.includePrerelease && m) | (this.options.loose && E)) + ":" + re, Z = c.get(Y);
            if (Z) return Z;
            const G = this.options.loose, B = G ? S[T.HYPHENRANGELOOSE] : S[T.HYPHENRANGE];
            re = re.replace(B, U(this.options.includePrerelease)), f("hyphen replace", re), re = re.replace(S[T.COMPARATORTRIM], d), f("comparator trim", re), re = re.replace(S[T.TILDETRIM], p), f("tilde trim", re), re = re.replace(S[T.CARETTRIM], h), f("caret trim", re);
            let z = re.split(" ").map((ie) => I(ie, this.options)).join(" ").split(/\s+/).map((ie) => H(ie, this.options));
            G && (z = z.filter((ie) => (f("loose invalid filter", ie, this.options), !!ie.match(S[T.COMPARATORLOOSE])))), f("range list", z);
            const M = /* @__PURE__ */ new Map(), K = z.map((ie) => new r(ie, this.options));
            for (const ie of K) {
              if (_(ie)) return [ie];
              M.set(ie.value, ie);
            }
            M.size > 1 && M.has("") && M.delete("");
            const Q = [...M.values()];
            return c.set(Y, Q), Q;
          }
          intersects(re, Y) {
            if (!(re instanceof u)) throw new TypeError("a Range is required");
            return this.set.some((Z) => w(Z, Y) && re.set.some((G) => w(G, Y) && Z.every((B) => G.every((z) => B.intersects(z, Y)))));
          }
          test(re) {
            if (!re) return false;
            if (typeof re == "string") try {
              re = new y(re, this.options);
            } catch {
              return false;
            }
            for (let Y = 0; Y < this.set.length; Y++) if (q(this.set[Y], re, this.options)) return true;
            return false;
          }
        }
        P.exports = u;
        const c = new (l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/lrucache.js"))(), e = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/parse-options.js"), r = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/comparator.js"), f = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/debug.js"), y = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js"), { safeRe: S, t: T, comparatorTrimReplace: d, tildeTrimReplace: p, caretTrimReplace: h } = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/re.js"), { FLAG_INCLUDE_PRERELEASE: m, FLAG_LOOSE: E } = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/constants.js"), _ = (ee) => ee.value === "<0.0.0-0", C = (ee) => ee.value === "", w = (ee, re) => {
          let Y = true;
          const Z = ee.slice();
          let G = Z.pop();
          for (; Y && Z.length; ) Y = Z.every((B) => G.intersects(B, re)), G = Z.pop();
          return Y;
        }, I = (ee, re) => (f("comp", ee, re), ee = k(ee, re), f("caret", ee), ee = j(ee, re), f("tildes", ee), ee = F(ee, re), f("xrange", ee), ee = X(ee, re), f("stars", ee), ee), D = (ee) => !ee || ee.toLowerCase() === "x" || ee === "*", j = (ee, re) => ee.trim().split(/\s+/).map((Y) => L(Y, re)).join(" "), L = (ee, re) => {
          const Y = re.loose ? S[T.TILDELOOSE] : S[T.TILDE];
          return ee.replace(Y, (Z, G, B, z, M) => {
            let K;
            return f("tilde", ee, Z, G, B, z, M), D(G) ? K = "" : D(B) ? K = `>=${G}.0.0 <${+G + 1}.0.0-0` : D(z) ? K = `>=${G}.${B}.0 <${G}.${+B + 1}.0-0` : M ? (f("replaceTilde pr", M), K = `>=${G}.${B}.${z}-${M} <${G}.${+B + 1}.0-0`) : K = `>=${G}.${B}.${z} <${G}.${+B + 1}.0-0`, f("tilde return", K), K;
          });
        }, k = (ee, re) => ee.trim().split(/\s+/).map((Y) => N(Y, re)).join(" "), N = (ee, re) => {
          f("caret", ee, re);
          const Y = re.loose ? S[T.CARETLOOSE] : S[T.CARET], Z = re.includePrerelease ? "-0" : "";
          return ee.replace(Y, (G, B, z, M, K) => {
            let Q;
            return f("caret", ee, G, B, z, M, K), D(B) ? Q = "" : D(z) ? Q = `>=${B}.0.0${Z} <${+B + 1}.0.0-0` : D(M) ? Q = B === "0" ? `>=${B}.${z}.0${Z} <${B}.${+z + 1}.0-0` : `>=${B}.${z}.0${Z} <${+B + 1}.0.0-0` : K ? (f("replaceCaret pr", K), Q = B === "0" ? z === "0" ? `>=${B}.${z}.${M}-${K} <${B}.${z}.${+M + 1}-0` : `>=${B}.${z}.${M}-${K} <${B}.${+z + 1}.0-0` : `>=${B}.${z}.${M}-${K} <${+B + 1}.0.0-0`) : (f("no pr"), Q = B === "0" ? z === "0" ? `>=${B}.${z}.${M}${Z} <${B}.${z}.${+M + 1}-0` : `>=${B}.${z}.${M}${Z} <${B}.${+z + 1}.0-0` : `>=${B}.${z}.${M} <${+B + 1}.0.0-0`), f("caret return", Q), Q;
          });
        }, F = (ee, re) => (f("replaceXRanges", ee, re), ee.split(/\s+/).map((Y) => W(Y, re)).join(" ")), W = (ee, re) => {
          ee = ee.trim();
          const Y = re.loose ? S[T.XRANGELOOSE] : S[T.XRANGE];
          return ee.replace(Y, (Z, G, B, z, M, K) => {
            f("xRange", ee, Z, G, B, z, M, K);
            const Q = D(B), ie = Q || D(z), ue = ie || D(M), ge = ue;
            return G === "=" && ge && (G = ""), K = re.includePrerelease ? "-0" : "", Q ? Z = G === ">" || G === "<" ? "<0.0.0-0" : "*" : G && ge ? (ie && (z = 0), M = 0, G === ">" ? (G = ">=", ie ? (B = +B + 1, z = 0, M = 0) : (z = +z + 1, M = 0)) : G === "<=" && (G = "<", ie ? B = +B + 1 : z = +z + 1), G === "<" && (K = "-0"), Z = `${G + B}.${z}.${M}${K}`) : ie ? Z = `>=${B}.0.0${K} <${+B + 1}.0.0-0` : ue && (Z = `>=${B}.${z}.0${K} <${B}.${+z + 1}.0-0`), f("xRange return", Z), Z;
          });
        }, X = (ee, re) => (f("replaceStars", ee, re), ee.trim().replace(S[T.STAR], "")), H = (ee, re) => (f("replaceGTE0", ee, re), ee.trim().replace(S[re.includePrerelease ? T.GTE0PRE : T.GTE0], "")), U = (ee) => (re, Y, Z, G, B, z, M, K, Q, ie, ue, ge) => `${Y = D(Z) ? "" : D(G) ? `>=${Z}.0.0${ee ? "-0" : ""}` : D(B) ? `>=${Z}.${G}.0${ee ? "-0" : ""}` : z ? `>=${Y}` : `>=${Y}${ee ? "-0" : ""}`} ${K = D(Q) ? "" : D(ie) ? `<${+Q + 1}.0.0-0` : D(ue) ? `<${Q}.${+ie + 1}.0-0` : ge ? `<=${Q}.${ie}.${ue}-${ge}` : ee ? `<${Q}.${ie}.${+ue + 1}-0` : `<=${K}`}`.trim(), q = (ee, re, Y) => {
          for (let Z = 0; Z < ee.length; Z++) if (!ee[Z].test(re)) return false;
          if (re.prerelease.length && !Y.includePrerelease) {
            for (let Z = 0; Z < ee.length; Z++) if (f(ee[Z].semver), ee[Z].semver !== r.ANY && ee[Z].semver.prerelease.length > 0) {
              const G = ee[Z].semver;
              if (G.major === re.major && G.minor === re.minor && G.patch === re.patch) return true;
            }
            return false;
          }
          return true;
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/debug.js"), { MAX_LENGTH: u, MAX_SAFE_INTEGER: c } = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/constants.js"), { safeRe: e, t: r } = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/re.js"), f = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/parse-options.js"), { compareIdentifiers: y } = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/identifiers.js");
        class S {
          constructor(d, p) {
            if (p = f(p), d instanceof S) {
              if (d.loose === !!p.loose && d.includePrerelease === !!p.includePrerelease) return d;
              d = d.version;
            } else if (typeof d != "string") throw new TypeError(`Invalid version. Must be a string. Got type "${typeof d}".`);
            if (d.length > u) throw new TypeError(`version is longer than ${u} characters`);
            n("SemVer", d, p), this.options = p, this.loose = !!p.loose, this.includePrerelease = !!p.includePrerelease;
            const h = d.trim().match(p.loose ? e[r.LOOSE] : e[r.FULL]);
            if (!h) throw new TypeError(`Invalid Version: ${d}`);
            if (this.raw = d, this.major = +h[1], this.minor = +h[2], this.patch = +h[3], this.major > c || this.major < 0) throw new TypeError("Invalid major version");
            if (this.minor > c || this.minor < 0) throw new TypeError("Invalid minor version");
            if (this.patch > c || this.patch < 0) throw new TypeError("Invalid patch version");
            h[4] ? this.prerelease = h[4].split(".").map((m) => {
              if (/^[0-9]+$/.test(m)) {
                const E = +m;
                if (E >= 0 && E < c) return E;
              }
              return m;
            }) : this.prerelease = [], this.build = h[5] ? h[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(d) {
            if (n("SemVer.compare", this.version, this.options, d), !(d instanceof S)) {
              if (typeof d == "string" && d === this.version) return 0;
              d = new S(d, this.options);
            }
            return d.version === this.version ? 0 : this.compareMain(d) || this.comparePre(d);
          }
          compareMain(d) {
            return d instanceof S || (d = new S(d, this.options)), y(this.major, d.major) || y(this.minor, d.minor) || y(this.patch, d.patch);
          }
          comparePre(d) {
            if (d instanceof S || (d = new S(d, this.options)), this.prerelease.length && !d.prerelease.length) return -1;
            if (!this.prerelease.length && d.prerelease.length) return 1;
            if (!this.prerelease.length && !d.prerelease.length) return 0;
            let p = 0;
            do {
              const h = this.prerelease[p], m = d.prerelease[p];
              if (n("prerelease compare", p, h, m), h === void 0 && m === void 0) return 0;
              if (m === void 0) return 1;
              if (h === void 0) return -1;
              if (h !== m) return y(h, m);
            } while (++p);
          }
          compareBuild(d) {
            d instanceof S || (d = new S(d, this.options));
            let p = 0;
            do {
              const h = this.build[p], m = d.build[p];
              if (n("build compare", p, h, m), h === void 0 && m === void 0) return 0;
              if (m === void 0) return 1;
              if (h === void 0) return -1;
              if (h !== m) return y(h, m);
            } while (++p);
          }
          inc(d, p, h) {
            switch (d) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", p, h);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", p, h);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", p, h), this.inc("pre", p, h);
                break;
              case "prerelease":
                this.prerelease.length === 0 && this.inc("patch", p, h), this.inc("pre", p, h);
                break;
              case "major":
                this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                break;
              case "pre": {
                const m = Number(h) ? 1 : 0;
                if (!p && h === false) throw new Error("invalid increment argument: identifier is empty");
                if (this.prerelease.length === 0) this.prerelease = [m];
                else {
                  let E = this.prerelease.length;
                  for (; --E >= 0; ) typeof this.prerelease[E] == "number" && (this.prerelease[E]++, E = -2);
                  if (E === -1) {
                    if (p === this.prerelease.join(".") && h === false) throw new Error("invalid increment argument: identifier already exists");
                    this.prerelease.push(m);
                  }
                }
                if (p) {
                  let E = [p, m];
                  h === false && (E = [p]), y(this.prerelease[0], p) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = E) : this.prerelease = E;
                }
                break;
              }
              default:
                throw new Error(`invalid increment argument: ${d}`);
            }
            return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
          }
        }
        P.exports = S;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/clean.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/parse.js");
        P.exports = (u, c) => {
          const e = n(u.trim().replace(/^[=v]+/, ""), c);
          return e ? e.version : null;
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/cmp.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/eq.js"), u = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/neq.js"), c = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gt.js"), e = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gte.js"), r = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lt.js"), f = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lte.js");
        P.exports = (y, S, T, d) => {
          switch (S) {
            case "===":
              return typeof y == "object" && (y = y.version), typeof T == "object" && (T = T.version), y === T;
            case "!==":
              return typeof y == "object" && (y = y.version), typeof T == "object" && (T = T.version), y !== T;
            case "":
            case "=":
            case "==":
              return n(y, T, d);
            case "!=":
              return u(y, T, d);
            case ">":
              return c(y, T, d);
            case ">=":
              return e(y, T, d);
            case "<":
              return r(y, T, d);
            case "<=":
              return f(y, T, d);
            default:
              throw new TypeError(`Invalid operator: ${S}`);
          }
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/coerce.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js"), u = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/parse.js"), { safeRe: c, t: e } = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/re.js");
        P.exports = (r, f) => {
          if (r instanceof n) return r;
          if (typeof r == "number" && (r = String(r)), typeof r != "string") return null;
          let y = null;
          if ((f = f || {}).rtl) {
            const m = f.includePrerelease ? c[e.COERCERTLFULL] : c[e.COERCERTL];
            let E;
            for (; (E = m.exec(r)) && (!y || y.index + y[0].length !== r.length); ) y && E.index + E[0].length === y.index + y[0].length || (y = E), m.lastIndex = E.index + E[1].length + E[2].length;
            m.lastIndex = -1;
          } else y = r.match(f.includePrerelease ? c[e.COERCEFULL] : c[e.COERCE]);
          if (y === null) return null;
          const S = y[2], T = y[3] || "0", d = y[4] || "0", p = f.includePrerelease && y[5] ? `-${y[5]}` : "", h = f.includePrerelease && y[6] ? `+${y[6]}` : "";
          return u(`${S}.${T}.${d}${p}${h}`, f);
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare-build.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js");
        P.exports = (u, c, e) => {
          const r = new n(u, e), f = new n(c, e);
          return r.compare(f) || r.compareBuild(f);
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare-loose.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js");
        P.exports = (u, c) => n(u, c, true);
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js");
        P.exports = (u, c, e) => new n(u, e).compare(new n(c, e));
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/diff.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/parse.js");
        P.exports = (u, c) => {
          const e = n(u, null, true), r = n(c, null, true), f = e.compare(r);
          if (f === 0) return null;
          const y = f > 0, S = y ? e : r, T = y ? r : e, d = !!S.prerelease.length;
          if (T.prerelease.length && !d) return T.patch || T.minor ? S.patch ? "patch" : S.minor ? "minor" : "major" : "major";
          const p = d ? "pre" : "";
          return e.major !== r.major ? p + "major" : e.minor !== r.minor ? p + "minor" : e.patch !== r.patch ? p + "patch" : "prerelease";
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/eq.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js");
        P.exports = (u, c, e) => n(u, c, e) === 0;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gt.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js");
        P.exports = (u, c, e) => n(u, c, e) > 0;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gte.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js");
        P.exports = (u, c, e) => n(u, c, e) >= 0;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/inc.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js");
        P.exports = (u, c, e, r, f) => {
          typeof e == "string" && (f = r, r = e, e = void 0);
          try {
            return new n(u instanceof n ? u.version : u, e).inc(c, r, f).version;
          } catch {
            return null;
          }
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lt.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js");
        P.exports = (u, c, e) => n(u, c, e) < 0;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lte.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js");
        P.exports = (u, c, e) => n(u, c, e) <= 0;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/major.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js");
        P.exports = (u, c) => new n(u, c).major;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/minor.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js");
        P.exports = (u, c) => new n(u, c).minor;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/neq.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js");
        P.exports = (u, c, e) => n(u, c, e) !== 0;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/parse.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js");
        P.exports = (u, c, e = false) => {
          if (u instanceof n) return u;
          try {
            return new n(u, c);
          } catch (r) {
            if (!e) return null;
            throw r;
          }
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/patch.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js");
        P.exports = (u, c) => new n(u, c).patch;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/prerelease.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/parse.js");
        P.exports = (u, c) => {
          const e = n(u, c);
          return e && e.prerelease.length ? e.prerelease : null;
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/rcompare.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js");
        P.exports = (u, c, e) => n(c, u, e);
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/rsort.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare-build.js");
        P.exports = (u, c) => u.sort((e, r) => n(r, e, c));
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/satisfies.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js");
        P.exports = (u, c, e) => {
          try {
            c = new n(c, e);
          } catch {
            return false;
          }
          return c.test(u);
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/sort.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare-build.js");
        P.exports = (u, c) => u.sort((e, r) => n(e, r, c));
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/valid.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/parse.js");
        P.exports = (u, c) => {
          const e = n(u, c);
          return e ? e.version : null;
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/index.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/re.js"), u = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/constants.js"), c = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js"), e = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/identifiers.js"), r = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/parse.js"), f = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/valid.js"), y = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/clean.js"), S = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/inc.js"), T = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/diff.js"), d = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/major.js"), p = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/minor.js"), h = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/patch.js"), m = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/prerelease.js"), E = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js"), _ = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/rcompare.js"), C = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare-loose.js"), w = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare-build.js"), I = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/sort.js"), D = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/rsort.js"), j = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gt.js"), L = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lt.js"), k = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/eq.js"), N = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/neq.js"), F = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gte.js"), W = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lte.js"), X = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/cmp.js"), H = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/coerce.js"), U = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/comparator.js"), q = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js"), ee = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/satisfies.js"), re = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/to-comparators.js"), Y = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/max-satisfying.js"), Z = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/min-satisfying.js"), G = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/min-version.js"), B = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/valid.js"), z = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/outside.js"), M = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/gtr.js"), K = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/ltr.js"), Q = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/intersects.js"), ie = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/simplify.js"), ue = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/subset.js");
        P.exports = { parse: r, valid: f, clean: y, inc: S, diff: T, major: d, minor: p, patch: h, prerelease: m, compare: E, rcompare: _, compareLoose: C, compareBuild: w, sort: I, rsort: D, gt: j, lt: L, eq: k, neq: N, gte: F, lte: W, cmp: X, coerce: H, Comparator: U, Range: q, satisfies: ee, toComparators: re, maxSatisfying: Y, minSatisfying: Z, minVersion: G, validRange: B, outside: z, gtr: M, ltr: K, intersects: Q, simplifyRange: ie, subset: ue, SemVer: c, re: n.re, src: n.src, tokens: n.t, SEMVER_SPEC_VERSION: u.SEMVER_SPEC_VERSION, RELEASE_TYPES: u.RELEASE_TYPES, compareIdentifiers: e.compareIdentifiers, rcompareIdentifiers: e.rcompareIdentifiers };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/constants.js": (P) => {
        const t = Number.MAX_SAFE_INTEGER || 9007199254740991;
        P.exports = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: t, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/debug.js": (P) => {
        const t = typeof process == "object" && s && s.NODE_DEBUG && /\bsemver\b/i.test(s.NODE_DEBUG) ? (...l) => console.error("SEMVER", ...l) : () => {
        };
        P.exports = t;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/identifiers.js": (P) => {
        const t = /^[0-9]+$/, l = (n, u) => {
          const c = t.test(n), e = t.test(u);
          return c && e && (n = +n, u = +u), n === u ? 0 : c && !e ? -1 : e && !c ? 1 : n < u ? -1 : 1;
        };
        P.exports = { compareIdentifiers: l, rcompareIdentifiers: (n, u) => l(u, n) };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/lrucache.js": (P) => {
        P.exports = class {
          constructor() {
            this.max = 1e3, this.map = /* @__PURE__ */ new Map();
          }
          get(t) {
            const l = this.map.get(t);
            return l === void 0 ? void 0 : (this.map.delete(t), this.map.set(t, l), l);
          }
          delete(t) {
            return this.map.delete(t);
          }
          set(t, l) {
            if (!this.delete(t) && l !== void 0) {
              if (this.map.size >= this.max) {
                const n = this.map.keys().next().value;
                this.delete(n);
              }
              this.map.set(t, l);
            }
            return this;
          }
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/parse-options.js": (P) => {
        const t = Object.freeze({ loose: true }), l = Object.freeze({});
        P.exports = (n) => n ? typeof n != "object" ? t : n : l;
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/re.js": (P, t, l) => {
        const { MAX_SAFE_COMPONENT_LENGTH: n, MAX_SAFE_BUILD_LENGTH: u, MAX_LENGTH: c } = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/constants.js"), e = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/internal/debug.js"), r = (t = P.exports = {}).re = [], f = t.safeRe = [], y = t.src = [], S = t.t = {};
        let T = 0;
        const d = [["\\s", 1], ["\\d", c], ["[a-zA-Z0-9-]", u]], p = (h, m, E) => {
          const _ = ((w) => {
            for (const [I, D] of d) w = w.split(`${I}*`).join(`${I}{0,${D}}`).split(`${I}+`).join(`${I}{1,${D}}`);
            return w;
          })(m), C = T++;
          e(h, C, m), S[h] = C, y[C] = m, r[C] = new RegExp(m, E ? "g" : void 0), f[C] = new RegExp(_, E ? "g" : void 0);
        };
        p("NUMERICIDENTIFIER", "0|[1-9]\\d*"), p("NUMERICIDENTIFIERLOOSE", "\\d+"), p("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), p("MAINVERSION", `(${y[S.NUMERICIDENTIFIER]})\\.(${y[S.NUMERICIDENTIFIER]})\\.(${y[S.NUMERICIDENTIFIER]})`), p("MAINVERSIONLOOSE", `(${y[S.NUMERICIDENTIFIERLOOSE]})\\.(${y[S.NUMERICIDENTIFIERLOOSE]})\\.(${y[S.NUMERICIDENTIFIERLOOSE]})`), p("PRERELEASEIDENTIFIER", `(?:${y[S.NUMERICIDENTIFIER]}|${y[S.NONNUMERICIDENTIFIER]})`), p("PRERELEASEIDENTIFIERLOOSE", `(?:${y[S.NUMERICIDENTIFIERLOOSE]}|${y[S.NONNUMERICIDENTIFIER]})`), p("PRERELEASE", `(?:-(${y[S.PRERELEASEIDENTIFIER]}(?:\\.${y[S.PRERELEASEIDENTIFIER]})*))`), p("PRERELEASELOOSE", `(?:-?(${y[S.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${y[S.PRERELEASEIDENTIFIERLOOSE]})*))`), p("BUILDIDENTIFIER", "[a-zA-Z0-9-]+"), p("BUILD", `(?:\\+(${y[S.BUILDIDENTIFIER]}(?:\\.${y[S.BUILDIDENTIFIER]})*))`), p("FULLPLAIN", `v?${y[S.MAINVERSION]}${y[S.PRERELEASE]}?${y[S.BUILD]}?`), p("FULL", `^${y[S.FULLPLAIN]}$`), p("LOOSEPLAIN", `[v=\\s]*${y[S.MAINVERSIONLOOSE]}${y[S.PRERELEASELOOSE]}?${y[S.BUILD]}?`), p("LOOSE", `^${y[S.LOOSEPLAIN]}$`), p("GTLT", "((?:<|>)?=?)"), p("XRANGEIDENTIFIERLOOSE", `${y[S.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), p("XRANGEIDENTIFIER", `${y[S.NUMERICIDENTIFIER]}|x|X|\\*`), p("XRANGEPLAIN", `[v=\\s]*(${y[S.XRANGEIDENTIFIER]})(?:\\.(${y[S.XRANGEIDENTIFIER]})(?:\\.(${y[S.XRANGEIDENTIFIER]})(?:${y[S.PRERELEASE]})?${y[S.BUILD]}?)?)?`), p("XRANGEPLAINLOOSE", `[v=\\s]*(${y[S.XRANGEIDENTIFIERLOOSE]})(?:\\.(${y[S.XRANGEIDENTIFIERLOOSE]})(?:\\.(${y[S.XRANGEIDENTIFIERLOOSE]})(?:${y[S.PRERELEASELOOSE]})?${y[S.BUILD]}?)?)?`), p("XRANGE", `^${y[S.GTLT]}\\s*${y[S.XRANGEPLAIN]}$`), p("XRANGELOOSE", `^${y[S.GTLT]}\\s*${y[S.XRANGEPLAINLOOSE]}$`), p("COERCEPLAIN", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?`), p("COERCE", `${y[S.COERCEPLAIN]}(?:$|[^\\d])`), p("COERCEFULL", y[S.COERCEPLAIN] + `(?:${y[S.PRERELEASE]})?(?:${y[S.BUILD]})?(?:$|[^\\d])`), p("COERCERTL", y[S.COERCE], true), p("COERCERTLFULL", y[S.COERCEFULL], true), p("LONETILDE", "(?:~>?)"), p("TILDETRIM", `(\\s*)${y[S.LONETILDE]}\\s+`, true), t.tildeTrimReplace = "$1~", p("TILDE", `^${y[S.LONETILDE]}${y[S.XRANGEPLAIN]}$`), p("TILDELOOSE", `^${y[S.LONETILDE]}${y[S.XRANGEPLAINLOOSE]}$`), p("LONECARET", "(?:\\^)"), p("CARETTRIM", `(\\s*)${y[S.LONECARET]}\\s+`, true), t.caretTrimReplace = "$1^", p("CARET", `^${y[S.LONECARET]}${y[S.XRANGEPLAIN]}$`), p("CARETLOOSE", `^${y[S.LONECARET]}${y[S.XRANGEPLAINLOOSE]}$`), p("COMPARATORLOOSE", `^${y[S.GTLT]}\\s*(${y[S.LOOSEPLAIN]})$|^$`), p("COMPARATOR", `^${y[S.GTLT]}\\s*(${y[S.FULLPLAIN]})$|^$`), p("COMPARATORTRIM", `(\\s*)${y[S.GTLT]}\\s*(${y[S.LOOSEPLAIN]}|${y[S.XRANGEPLAIN]})`, true), t.comparatorTrimReplace = "$1$2$3", p("HYPHENRANGE", `^\\s*(${y[S.XRANGEPLAIN]})\\s+-\\s+(${y[S.XRANGEPLAIN]})\\s*$`), p("HYPHENRANGELOOSE", `^\\s*(${y[S.XRANGEPLAINLOOSE]})\\s+-\\s+(${y[S.XRANGEPLAINLOOSE]})\\s*$`), p("STAR", "(<|>)?=?\\s*\\*"), p("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), p("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/gtr.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/outside.js");
        P.exports = (u, c, e) => n(u, c, ">", e);
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/intersects.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js");
        P.exports = (u, c, e) => (u = new n(u, e), c = new n(c, e), u.intersects(c, e));
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/ltr.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/outside.js");
        P.exports = (u, c, e) => n(u, c, "<", e);
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/max-satisfying.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js"), u = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js");
        P.exports = (c, e, r) => {
          let f = null, y = null, S = null;
          try {
            S = new u(e, r);
          } catch {
            return null;
          }
          return c.forEach((T) => {
            S.test(T) && (f && y.compare(T) !== -1 || (f = T, y = new n(f, r)));
          }), f;
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/min-satisfying.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js"), u = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js");
        P.exports = (c, e, r) => {
          let f = null, y = null, S = null;
          try {
            S = new u(e, r);
          } catch {
            return null;
          }
          return c.forEach((T) => {
            S.test(T) && (f && y.compare(T) !== 1 || (f = T, y = new n(f, r)));
          }), f;
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/min-version.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js"), u = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js"), c = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gt.js");
        P.exports = (e, r) => {
          e = new u(e, r);
          let f = new n("0.0.0");
          if (e.test(f) || (f = new n("0.0.0-0"), e.test(f))) return f;
          f = null;
          for (let y = 0; y < e.set.length; ++y) {
            const S = e.set[y];
            let T = null;
            S.forEach((d) => {
              const p = new n(d.semver.version);
              switch (d.operator) {
                case ">":
                  p.prerelease.length === 0 ? p.patch++ : p.prerelease.push(0), p.raw = p.format();
                case "":
                case ">=":
                  T && !c(p, T) || (T = p);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error(`Unexpected operation: ${d.operator}`);
              }
            }), !T || f && !c(f, T) || (f = T);
          }
          return f && e.test(f) ? f : null;
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/outside.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/semver.js"), u = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/comparator.js"), { ANY: c } = u, e = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js"), r = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/satisfies.js"), f = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gt.js"), y = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lt.js"), S = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/lte.js"), T = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/gte.js");
        P.exports = (d, p, h, m) => {
          let E, _, C, w, I;
          switch (d = new n(d, m), p = new e(p, m), h) {
            case ">":
              E = f, _ = S, C = y, w = ">", I = ">=";
              break;
            case "<":
              E = y, _ = T, C = f, w = "<", I = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (r(d, p, m)) return false;
          for (let D = 0; D < p.set.length; ++D) {
            const j = p.set[D];
            let L = null, k = null;
            if (j.forEach((N) => {
              N.semver === c && (N = new u(">=0.0.0")), L = L || N, k = k || N, E(N.semver, L.semver, m) ? L = N : C(N.semver, k.semver, m) && (k = N);
            }), L.operator === w || L.operator === I || (!k.operator || k.operator === w) && _(d, k.semver) || k.operator === I && C(d, k.semver)) return false;
          }
          return true;
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/simplify.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/satisfies.js"), u = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js");
        P.exports = (c, e, r) => {
          const f = [];
          let y = null, S = null;
          const T = c.sort((m, E) => u(m, E, r));
          for (const m of T) n(m, e, r) ? (S = m, y || (y = m)) : (S && f.push([y, S]), S = null, y = null);
          y && f.push([y, null]);
          const d = [];
          for (const [m, E] of f) m === E ? d.push(m) : E || m !== T[0] ? E ? m === T[0] ? d.push(`<=${E}`) : d.push(`${m} - ${E}`) : d.push(`>=${m}`) : d.push("*");
          const p = d.join(" || "), h = typeof e.raw == "string" ? e.raw : String(e);
          return p.length < h.length ? p : e;
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/subset.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js"), u = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/comparator.js"), { ANY: c } = u, e = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/satisfies.js"), r = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/functions/compare.js"), f = [new u(">=0.0.0-0")], y = [new u(">=0.0.0")], S = (p, h, m) => {
          if (p === h) return true;
          if (p.length === 1 && p[0].semver === c) {
            if (h.length === 1 && h[0].semver === c) return true;
            p = m.includePrerelease ? f : y;
          }
          if (h.length === 1 && h[0].semver === c) {
            if (m.includePrerelease) return true;
            h = y;
          }
          const E = /* @__PURE__ */ new Set();
          let _, C, w, I, D, j, L;
          for (const F of p) F.operator === ">" || F.operator === ">=" ? _ = T(_, F, m) : F.operator === "<" || F.operator === "<=" ? C = d(C, F, m) : E.add(F.semver);
          if (E.size > 1 || _ && C && (w = r(_.semver, C.semver, m), w > 0 || w === 0 && (_.operator !== ">=" || C.operator !== "<="))) return null;
          for (const F of E) {
            if (_ && !e(F, String(_), m) || C && !e(F, String(C), m)) return null;
            for (const W of h) if (!e(F, String(W), m)) return false;
            return true;
          }
          let k = !(!C || m.includePrerelease || !C.semver.prerelease.length) && C.semver, N = !(!_ || m.includePrerelease || !_.semver.prerelease.length) && _.semver;
          k && k.prerelease.length === 1 && C.operator === "<" && k.prerelease[0] === 0 && (k = false);
          for (const F of h) {
            if (L = L || F.operator === ">" || F.operator === ">=", j = j || F.operator === "<" || F.operator === "<=", _) {
              if (N && F.semver.prerelease && F.semver.prerelease.length && F.semver.major === N.major && F.semver.minor === N.minor && F.semver.patch === N.patch && (N = false), F.operator === ">" || F.operator === ">=") {
                if (I = T(_, F, m), I === F && I !== _) return false;
              } else if (_.operator === ">=" && !e(_.semver, String(F), m)) return false;
            }
            if (C) {
              if (k && F.semver.prerelease && F.semver.prerelease.length && F.semver.major === k.major && F.semver.minor === k.minor && F.semver.patch === k.patch && (k = false), F.operator === "<" || F.operator === "<=") {
                if (D = d(C, F, m), D === F && D !== C) return false;
              } else if (C.operator === "<=" && !e(C.semver, String(F), m)) return false;
            }
            if (!F.operator && (C || _) && w !== 0) return false;
          }
          return !(_ && j && !C && w !== 0) && !(C && L && !_ && w !== 0) && !N && !k;
        }, T = (p, h, m) => {
          if (!p) return h;
          const E = r(p.semver, h.semver, m);
          return E > 0 ? p : E < 0 || h.operator === ">" && p.operator === ">=" ? h : p;
        }, d = (p, h, m) => {
          if (!p) return h;
          const E = r(p.semver, h.semver, m);
          return E < 0 ? p : E > 0 || h.operator === "<" && p.operator === "<=" ? h : p;
        };
        P.exports = (p, h, m = {}) => {
          if (p === h) return true;
          p = new n(p, m), h = new n(h, m);
          let E = false;
          e: for (const _ of p.set) {
            for (const C of h.set) {
              const w = S(_, C, m);
              if (E = E || w !== null, w) continue e;
            }
            if (E) return false;
          }
          return true;
        };
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/to-comparators.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js");
        P.exports = (u, c) => new n(u, c).set.map((e) => e.map((r) => r.value).join(" ").trim().split(" "));
      }, "./node_modules/.pnpm/semver@7.6.3/node_modules/semver/ranges/valid.js": (P, t, l) => {
        const n = l("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/classes/range.js");
        P.exports = (u, c) => {
          try {
            return new n(u, c).range || "*";
          } catch {
            return null;
          }
        };
      }, crypto: (P) => {
        P.exports = gt;
      }, fs: (P) => {
        P.exports = gt;
      }, module: (P) => {
        P.exports = gt;
      }, path: (P) => {
        P.exports = gt;
      } }, b = {};
      function A(P) {
        var t = b[P];
        if (t !== void 0) return t.exports;
        var l = b[P] = { id: P, loaded: false, exports: {} };
        return o[P](l, l.exports, A), l.loaded = true, l.exports;
      }
      A.n = (P) => {
        var t = P && P.__esModule ? () => P.default : () => P;
        return A.d(t, { a: t }), t;
      }, A.d = (P, t) => {
        for (var l in t) A.o(t, l) && !A.o(P, l) && Object.defineProperty(P, l, { enumerable: true, get: t[l] });
      }, A.o = (P, t) => Object.prototype.hasOwnProperty.call(P, t), A.nmd = (P) => (P.paths = [], P.children || (P.children = []), P);
      var R = {};
      (() => {
        A.d(R, { default: () => wp });
        var P = A("fs"), t = A("module");
        const l = gt, n = gt, u = gt;
        var c = A.n(u);
        const e = gt, r = /^[A-Za-z]:\//;
        function f(g = "") {
          return g && g.replace(/\\/g, "/").replace(r, ($) => $.toUpperCase());
        }
        const y = /^[/\\]{2}/, S = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/, T = /^[A-Za-z]:$/, d = function(g) {
          if (g.length === 0) return ".";
          const $ = (g = f(g)).match(y), se = m(g), ae = g[g.length - 1] === "/";
          return (g = h(g, !se)).length === 0 ? se ? "/" : ae ? "./" : "." : (ae && (g += "/"), T.test(g) && (g += "/"), $ ? se ? `//${g}` : `//./${g}` : se && !m(g) ? `/${g}` : g);
        }, p = function(...g) {
          if (g.length === 0) return ".";
          let $;
          for (const se of g) se && se.length > 0 && ($ === void 0 ? $ = se : $ += `/${se}`);
          return $ === void 0 ? "." : d($.replace(/\/\/+/g, "/"));
        };
        function h(g, $) {
          let se = "", ae = 0, Se = -1, Oe = 0, De = null;
          for (let We = 0; We <= g.length; ++We) {
            if (We < g.length) De = g[We];
            else {
              if (De === "/") break;
              De = "/";
            }
            if (De === "/") {
              if (!(Se === We - 1 || Oe === 1)) if (Oe === 2) {
                if (se.length < 2 || ae !== 2 || se[se.length - 1] !== "." || se[se.length - 2] !== ".") {
                  if (se.length > 2) {
                    const nt = se.lastIndexOf("/");
                    nt === -1 ? (se = "", ae = 0) : (se = se.slice(0, nt), ae = se.length - 1 - se.lastIndexOf("/")), Se = We, Oe = 0;
                    continue;
                  }
                  if (se.length > 0) {
                    se = "", ae = 0, Se = We, Oe = 0;
                    continue;
                  }
                }
                $ && (se += se.length > 0 ? "/.." : "..", ae = 2);
              } else se.length > 0 ? se += `/${g.slice(Se + 1, We)}` : se = g.slice(Se + 1, We), ae = We - Se - 1;
              Se = We, Oe = 0;
            } else De === "." && Oe !== -1 ? ++Oe : Oe = -1;
          }
          return se;
        }
        const m = function(g) {
          return S.test(g);
        }, E = /.(\.[^./]+)$/, _ = function(g) {
          const $ = E.exec(f(g));
          return $ && $[1] || "";
        }, C = function(g) {
          const $ = f(g).replace(/\/$/, "").split("/").slice(0, -1);
          return $.length === 1 && T.test($[0]) && ($[0] += "/"), $.join("/") || (m(g) ? "/" : ".");
        }, w = function(g, $) {
          return f(g).split("/").pop();
        }, I = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, D = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, j = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
        function L(g, $) {
          if (!(g === "__proto__" || g === "constructor" && $ && typeof $ == "object" && "prototype" in $)) return $;
          (function(se) {
            console.warn(`[destr] Dropping "${se}" key to prevent prototype pollution.`);
          })(g);
        }
        function k(g, $ = {}) {
          if (typeof g != "string") return g;
          const se = g.trim();
          if (g[0] === '"' && g.endsWith('"') && !g.includes("\\")) return se.slice(1, -1);
          if (se.length <= 9) {
            const ae = se.toLowerCase();
            if (ae === "true") return true;
            if (ae === "false") return false;
            if (ae === "undefined") return;
            if (ae === "null") return null;
            if (ae === "nan") return Number.NaN;
            if (ae === "infinity") return Number.POSITIVE_INFINITY;
            if (ae === "-infinity") return Number.NEGATIVE_INFINITY;
          }
          if (!j.test(g)) {
            if ($.strict) throw new SyntaxError("[destr] Invalid JSON");
            return g;
          }
          try {
            if (I.test(g) || D.test(g)) {
              if ($.strict) throw new Error("[destr] Possible prototype pollution");
              return JSON.parse(g, L);
            }
            return JSON.parse(g);
          } catch (ae) {
            if ($.strict) throw ae;
            return g;
          }
        }
        function N(g) {
          if (typeof g != "string") throw new TypeError("Expected a string");
          return g.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var F = A("./node_modules/.pnpm/create-require@1.1.1/node_modules/create-require/create-require.js"), W = A.n(F), X = A("./node_modules/.pnpm/semver@7.6.3/node_modules/semver/index.js");
        const H = /* @__PURE__ */ new Set(["/", "\\", void 0]), U = Symbol.for("pathe:normalizedAlias");
        function q(g) {
          if (g[U]) return g;
          const $ = Object.fromEntries(Object.entries(g).sort(([se], [ae]) => function(Se, Oe) {
            return Oe.split("/").length - Se.split("/").length;
          }(se, ae)));
          for (const se in $) for (const ae in $) ae === se || se.startsWith(ae) || $[se].startsWith(ae) && H.has($[se][ae.length]) && ($[se] = $[ae] + $[se].slice(ae.length));
          return Object.defineProperty($, U, { value: true, enumerable: false }), $;
        }
        function ee(g = "/") {
          const $ = g[g.length - 1];
          return $ === "/" || $ === "\\";
        }
        var re = A("./node_modules/.pnpm/pirates@4.0.6/node_modules/pirates/lib/index.js"), Y = A("./node_modules/.pnpm/object-hash@3.0.0/node_modules/object-hash/index.js"), Z = A.n(Y), G = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], B = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], z = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", M = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, K = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", Q = { 5: K, "5module": K + " export import", 6: K + " const class extends export import super" }, ie = /^in(stanceof)?$/, ue = new RegExp("[" + z + "]"), ge = new RegExp("[" + z + "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65]");
        function Te(g, $) {
          for (var se = 65536, ae = 0; ae < $.length; ae += 2) {
            if ((se += $[ae]) > g) return false;
            if ((se += $[ae + 1]) >= g) return true;
          }
          return false;
        }
        function le(g, $) {
          return g < 65 ? g === 36 : g < 91 || (g < 97 ? g === 95 : g < 123 || (g <= 65535 ? g >= 170 && ue.test(String.fromCharCode(g)) : $ !== false && Te(g, B)));
        }
        function fe(g, $) {
          return g < 48 ? g === 36 : g < 58 || !(g < 65) && (g < 91 || (g < 97 ? g === 95 : g < 123 || (g <= 65535 ? g >= 170 && ge.test(String.fromCharCode(g)) : $ !== false && (Te(g, B) || Te(g, G)))));
        }
        var Pe = function(g, $) {
          $ === void 0 && ($ = {}), this.label = g, this.keyword = $.keyword, this.beforeExpr = !!$.beforeExpr, this.startsExpr = !!$.startsExpr, this.isLoop = !!$.isLoop, this.isAssign = !!$.isAssign, this.prefix = !!$.prefix, this.postfix = !!$.postfix, this.binop = $.binop || null, this.updateContext = null;
        };
        function xe(g, $) {
          return new Pe(g, { beforeExpr: true, binop: $ });
        }
        var we = { beforeExpr: true }, me = { startsExpr: true }, ye = {};
        function pe(g, $) {
          return $ === void 0 && ($ = {}), $.keyword = g, ye[g] = new Pe(g, $);
        }
        var J = { num: new Pe("num", me), regexp: new Pe("regexp", me), string: new Pe("string", me), name: new Pe("name", me), privateId: new Pe("privateId", me), eof: new Pe("eof"), bracketL: new Pe("[", { beforeExpr: true, startsExpr: true }), bracketR: new Pe("]"), braceL: new Pe("{", { beforeExpr: true, startsExpr: true }), braceR: new Pe("}"), parenL: new Pe("(", { beforeExpr: true, startsExpr: true }), parenR: new Pe(")"), comma: new Pe(",", we), semi: new Pe(";", we), colon: new Pe(":", we), dot: new Pe("."), question: new Pe("?", we), questionDot: new Pe("?."), arrow: new Pe("=>", we), template: new Pe("template"), invalidTemplate: new Pe("invalidTemplate"), ellipsis: new Pe("...", we), backQuote: new Pe("`", me), dollarBraceL: new Pe("${", { beforeExpr: true, startsExpr: true }), eq: new Pe("=", { beforeExpr: true, isAssign: true }), assign: new Pe("_=", { beforeExpr: true, isAssign: true }), incDec: new Pe("++/--", { prefix: true, postfix: true, startsExpr: true }), prefix: new Pe("!/~", { beforeExpr: true, prefix: true, startsExpr: true }), logicalOR: xe("||", 1), logicalAND: xe("&&", 2), bitwiseOR: xe("|", 3), bitwiseXOR: xe("^", 4), bitwiseAND: xe("&", 5), equality: xe("==/!=/===/!==", 6), relational: xe("</>/<=/>=", 7), bitShift: xe("<</>>/>>>", 8), plusMin: new Pe("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: xe("%", 10), star: xe("*", 10), slash: xe("/", 10), starstar: new Pe("**", { beforeExpr: true }), coalesce: xe("??", 1), _break: pe("break"), _case: pe("case", we), _catch: pe("catch"), _continue: pe("continue"), _debugger: pe("debugger"), _default: pe("default", we), _do: pe("do", { isLoop: true, beforeExpr: true }), _else: pe("else", we), _finally: pe("finally"), _for: pe("for", { isLoop: true }), _function: pe("function", me), _if: pe("if"), _return: pe("return", we), _switch: pe("switch"), _throw: pe("throw", we), _try: pe("try"), _var: pe("var"), _const: pe("const"), _while: pe("while", { isLoop: true }), _with: pe("with"), _new: pe("new", { beforeExpr: true, startsExpr: true }), _this: pe("this", me), _super: pe("super", me), _class: pe("class", me), _extends: pe("extends", we), _export: pe("export"), _import: pe("import", me), _null: pe("null", me), _true: pe("true", me), _false: pe("false", me), _in: pe("in", { beforeExpr: true, binop: 7 }), _instanceof: pe("instanceof", { beforeExpr: true, binop: 7 }), _typeof: pe("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: pe("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: pe("delete", { beforeExpr: true, prefix: true, startsExpr: true }) }, Ee = /\r\n?|\n|\u2028|\u2029/, Me = new RegExp(Ee.source, "g");
        function Ue(g) {
          return g === 10 || g === 13 || g === 8232 || g === 8233;
        }
        function qe(g, $, se) {
          se === void 0 && (se = g.length);
          for (var ae = $; ae < se; ae++) {
            var Se = g.charCodeAt(ae);
            if (Ue(Se)) return ae < se - 1 && Se === 13 && g.charCodeAt(ae + 1) === 10 ? ae + 2 : ae + 1;
          }
          return -1;
        }
        var He = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Ie = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Re = Object.prototype, Be = Re.hasOwnProperty, je = Re.toString, he = Object.hasOwn || function(g, $) {
          return Be.call(g, $);
        }, oe = Array.isArray || function(g) {
          return je.call(g) === "[object Array]";
        }, _e = /* @__PURE__ */ Object.create(null);
        function Ne(g) {
          return _e[g] || (_e[g] = new RegExp("^(?:" + g.replace(/ /g, "|") + ")$"));
        }
        function $e(g) {
          return g <= 65535 ? String.fromCharCode(g) : (g -= 65536, String.fromCharCode(55296 + (g >> 10), 56320 + (1023 & g)));
        }
        var Xe = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Je = function(g, $) {
          this.line = g, this.column = $;
        };
        Je.prototype.offset = function(g) {
          return new Je(this.line, this.column + g);
        };
        var st = function(g, $, se) {
          this.start = $, this.end = se, g.sourceFile !== null && (this.source = g.sourceFile);
        };
        function be(g, $) {
          for (var se = 1, ae = 0; ; ) {
            var Se = qe(g, ae, $);
            if (Se < 0) return new Je(se, $ - ae);
            ++se, ae = Se;
          }
        }
        var ke = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: false, checkPrivateFields: true, locations: false, onToken: null, onComment: null, ranges: false, program: null, sourceFile: null, directSourceFile: null, preserveParens: false }, Ve = false;
        function ze(g) {
          var $ = {};
          for (var se in ke) $[se] = g && he(g, se) ? g[se] : ke[se];
          if ($.ecmaVersion === "latest" ? $.ecmaVersion = 1e8 : $.ecmaVersion == null ? (!Ve && typeof console == "object" && console.warn && (Ve = true, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), $.ecmaVersion = 11) : $.ecmaVersion >= 2015 && ($.ecmaVersion -= 2009), $.allowReserved == null && ($.allowReserved = $.ecmaVersion < 5), g && g.allowHashBang != null || ($.allowHashBang = $.ecmaVersion >= 14), oe($.onToken)) {
            var ae = $.onToken;
            $.onToken = function(Se) {
              return ae.push(Se);
            };
          }
          return oe($.onComment) && ($.onComment = /* @__PURE__ */ function(Se, Oe) {
            return function(De, We, nt, ht, Ze, Pt) {
              var jt = { type: De ? "Block" : "Line", value: We, start: nt, end: ht };
              Se.locations && (jt.loc = new st(this, Ze, Pt)), Se.ranges && (jt.range = [nt, ht]), Oe.push(jt);
            };
          }($, $.onComment)), $;
        }
        function rt(g, $) {
          return 2 | (g ? 4 : 0) | ($ ? 8 : 0);
        }
        var it = function(g, $, se) {
          this.options = g = ze(g), this.sourceFile = g.sourceFile, this.keywords = Ne(Q[g.ecmaVersion >= 6 ? 6 : g.sourceType === "module" ? "5module" : 5]);
          var ae = "";
          g.allowReserved !== true && (ae = M[g.ecmaVersion >= 6 ? 6 : g.ecmaVersion === 5 ? 5 : 3], g.sourceType === "module" && (ae += " await")), this.reservedWords = Ne(ae);
          var Se = (ae ? ae + " " : "") + M.strict;
          this.reservedWordsStrict = Ne(Se), this.reservedWordsStrictBind = Ne(Se + " " + M.strictBind), this.input = String($), this.containsEsc = false, se ? (this.pos = se, this.lineStart = this.input.lastIndexOf(`
`, se - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Ee).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = J.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = g.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = false, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && g.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
        }, Ye = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
        it.prototype.parse = function() {
          var g = this.options.program || this.startNode();
          return this.nextToken(), this.parseTopLevel(g);
        }, Ye.inFunction.get = function() {
          return (2 & this.currentVarScope().flags) > 0;
        }, Ye.inGenerator.get = function() {
          return (8 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
        }, Ye.inAsync.get = function() {
          return (4 & this.currentVarScope().flags) > 0 && !this.currentVarScope().inClassFieldInit;
        }, Ye.canAwait.get = function() {
          for (var g = this.scopeStack.length - 1; g >= 0; g--) {
            var $ = this.scopeStack[g];
            if ($.inClassFieldInit || 256 & $.flags) return false;
            if (2 & $.flags) return (4 & $.flags) > 0;
          }
          return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
        }, Ye.allowSuper.get = function() {
          var g = this.currentThisScope(), $ = g.flags, se = g.inClassFieldInit;
          return (64 & $) > 0 || se || this.options.allowSuperOutsideMethod;
        }, Ye.allowDirectSuper.get = function() {
          return (128 & this.currentThisScope().flags) > 0;
        }, Ye.treatFunctionsAsVar.get = function() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }, Ye.allowNewDotTarget.get = function() {
          var g = this.currentThisScope(), $ = g.flags, se = g.inClassFieldInit;
          return (258 & $) > 0 || se;
        }, Ye.inClassStaticBlock.get = function() {
          return (256 & this.currentVarScope().flags) > 0;
        }, it.extend = function() {
          for (var g = [], $ = arguments.length; $--; ) g[$] = arguments[$];
          for (var se = this, ae = 0; ae < g.length; ae++) se = g[ae](se);
          return se;
        }, it.parse = function(g, $) {
          return new this($, g).parse();
        }, it.parseExpressionAt = function(g, $, se) {
          var ae = new this(se, g, $);
          return ae.nextToken(), ae.parseExpression();
        }, it.tokenizer = function(g, $) {
          return new this($, g);
        }, Object.defineProperties(it.prototype, Ye);
        var tt = it.prototype, pt = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
        tt.strictDirective = function(g) {
          if (this.options.ecmaVersion < 5) return false;
          for (; ; ) {
            Ie.lastIndex = g, g += Ie.exec(this.input)[0].length;
            var $ = pt.exec(this.input.slice(g));
            if (!$) return false;
            if (($[1] || $[2]) === "use strict") {
              Ie.lastIndex = g + $[0].length;
              var se = Ie.exec(this.input), ae = se.index + se[0].length, Se = this.input.charAt(ae);
              return Se === ";" || Se === "}" || Ee.test(se[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(Se) || Se === "!" && this.input.charAt(ae + 1) === "=");
            }
            g += $[0].length, Ie.lastIndex = g, g += Ie.exec(this.input)[0].length, this.input[g] === ";" && g++;
          }
        }, tt.eat = function(g) {
          return this.type === g && (this.next(), true);
        }, tt.isContextual = function(g) {
          return this.type === J.name && this.value === g && !this.containsEsc;
        }, tt.eatContextual = function(g) {
          return !!this.isContextual(g) && (this.next(), true);
        }, tt.expectContextual = function(g) {
          this.eatContextual(g) || this.unexpected();
        }, tt.canInsertSemicolon = function() {
          return this.type === J.eof || this.type === J.braceR || Ee.test(this.input.slice(this.lastTokEnd, this.start));
        }, tt.insertSemicolon = function() {
          if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
        }, tt.semicolon = function() {
          this.eat(J.semi) || this.insertSemicolon() || this.unexpected();
        }, tt.afterTrailingComma = function(g, $) {
          if (this.type === g) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), $ || this.next(), true;
        }, tt.expect = function(g) {
          this.eat(g) || this.unexpected();
        }, tt.unexpected = function(g) {
          this.raise(g ?? this.start, "Unexpected token");
        };
        var Et = function() {
          this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
        };
        tt.checkPatternErrors = function(g, $) {
          if (g) {
            g.trailingComma > -1 && this.raiseRecoverable(g.trailingComma, "Comma is not permitted after the rest element");
            var se = $ ? g.parenthesizedAssign : g.parenthesizedBind;
            se > -1 && this.raiseRecoverable(se, $ ? "Assigning to rvalue" : "Parenthesized pattern");
          }
        }, tt.checkExpressionErrors = function(g, $) {
          if (!g) return false;
          var se = g.shorthandAssign, ae = g.doubleProto;
          if (!$) return se >= 0 || ae >= 0;
          se >= 0 && this.raise(se, "Shorthand property assignments are valid only in destructuring patterns"), ae >= 0 && this.raiseRecoverable(ae, "Redefinition of __proto__ property");
        }, tt.checkYieldAwaitInDefaultParams = function() {
          this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
        }, tt.isSimpleAssignTarget = function(g) {
          return g.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(g.expression) : g.type === "Identifier" || g.type === "MemberExpression";
        };
        var Qe = it.prototype;
        Qe.parseTopLevel = function(g) {
          var $ = /* @__PURE__ */ Object.create(null);
          for (g.body || (g.body = []); this.type !== J.eof; ) {
            var se = this.parseStatement(null, true, $);
            g.body.push(se);
          }
          if (this.inModule) for (var ae = 0, Se = Object.keys(this.undefinedExports); ae < Se.length; ae += 1) {
            var Oe = Se[ae];
            this.raiseRecoverable(this.undefinedExports[Oe].start, "Export '" + Oe + "' is not defined");
          }
          return this.adaptDirectivePrologue(g.body), this.next(), g.sourceType = this.options.sourceType, this.finishNode(g, "Program");
        };
        var yt = { kind: "loop" }, vt = { kind: "switch" };
        Qe.isLet = function(g) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
          Ie.lastIndex = this.pos;
          var $ = Ie.exec(this.input), se = this.pos + $[0].length, ae = this.input.charCodeAt(se);
          if (ae === 91 || ae === 92) return true;
          if (g) return false;
          if (ae === 123 || ae > 55295 && ae < 56320) return true;
          if (le(ae, true)) {
            for (var Se = se + 1; fe(ae = this.input.charCodeAt(Se), true); ) ++Se;
            if (ae === 92 || ae > 55295 && ae < 56320) return true;
            var Oe = this.input.slice(se, Se);
            if (!ie.test(Oe)) return true;
          }
          return false;
        }, Qe.isAsyncFunction = function() {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
          Ie.lastIndex = this.pos;
          var g, $ = Ie.exec(this.input), se = this.pos + $[0].length;
          return !(Ee.test(this.input.slice(this.pos, se)) || this.input.slice(se, se + 8) !== "function" || se + 8 !== this.input.length && (fe(g = this.input.charCodeAt(se + 8)) || g > 55295 && g < 56320));
        }, Qe.parseStatement = function(g, $, se) {
          var ae, Se = this.type, Oe = this.startNode();
          switch (this.isLet(g) && (Se = J._var, ae = "let"), Se) {
            case J._break:
            case J._continue:
              return this.parseBreakContinueStatement(Oe, Se.keyword);
            case J._debugger:
              return this.parseDebuggerStatement(Oe);
            case J._do:
              return this.parseDoStatement(Oe);
            case J._for:
              return this.parseForStatement(Oe);
            case J._function:
              return g && (this.strict || g !== "if" && g !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(Oe, false, !g);
            case J._class:
              return g && this.unexpected(), this.parseClass(Oe, true);
            case J._if:
              return this.parseIfStatement(Oe);
            case J._return:
              return this.parseReturnStatement(Oe);
            case J._switch:
              return this.parseSwitchStatement(Oe);
            case J._throw:
              return this.parseThrowStatement(Oe);
            case J._try:
              return this.parseTryStatement(Oe);
            case J._const:
            case J._var:
              return ae = ae || this.value, g && ae !== "var" && this.unexpected(), this.parseVarStatement(Oe, ae);
            case J._while:
              return this.parseWhileStatement(Oe);
            case J._with:
              return this.parseWithStatement(Oe);
            case J.braceL:
              return this.parseBlock(true, Oe);
            case J.semi:
              return this.parseEmptyStatement(Oe);
            case J._export:
            case J._import:
              if (this.options.ecmaVersion > 10 && Se === J._import) {
                Ie.lastIndex = this.pos;
                var De = Ie.exec(this.input), We = this.pos + De[0].length, nt = this.input.charCodeAt(We);
                if (nt === 40 || nt === 46) return this.parseExpressionStatement(Oe, this.parseExpression());
              }
              return this.options.allowImportExportEverywhere || ($ || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), Se === J._import ? this.parseImport(Oe) : this.parseExport(Oe, se);
            default:
              if (this.isAsyncFunction()) return g && this.unexpected(), this.next(), this.parseFunctionStatement(Oe, true, !g);
              var ht = this.value, Ze = this.parseExpression();
              return Se === J.name && Ze.type === "Identifier" && this.eat(J.colon) ? this.parseLabeledStatement(Oe, ht, Ze, g) : this.parseExpressionStatement(Oe, Ze);
          }
        }, Qe.parseBreakContinueStatement = function(g, $) {
          var se = $ === "break";
          this.next(), this.eat(J.semi) || this.insertSemicolon() ? g.label = null : this.type !== J.name ? this.unexpected() : (g.label = this.parseIdent(), this.semicolon());
          for (var ae = 0; ae < this.labels.length; ++ae) {
            var Se = this.labels[ae];
            if ((g.label == null || Se.name === g.label.name) && (Se.kind != null && (se || Se.kind === "loop") || g.label && se)) break;
          }
          return ae === this.labels.length && this.raise(g.start, "Unsyntactic " + $), this.finishNode(g, se ? "BreakStatement" : "ContinueStatement");
        }, Qe.parseDebuggerStatement = function(g) {
          return this.next(), this.semicolon(), this.finishNode(g, "DebuggerStatement");
        }, Qe.parseDoStatement = function(g) {
          return this.next(), this.labels.push(yt), g.body = this.parseStatement("do"), this.labels.pop(), this.expect(J._while), g.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(J.semi) : this.semicolon(), this.finishNode(g, "DoWhileStatement");
        }, Qe.parseForStatement = function(g) {
          this.next();
          var $ = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
          if (this.labels.push(yt), this.enterScope(0), this.expect(J.parenL), this.type === J.semi) return $ > -1 && this.unexpected($), this.parseFor(g, null);
          var se = this.isLet();
          if (this.type === J._var || this.type === J._const || se) {
            var ae = this.startNode(), Se = se ? "let" : this.value;
            return this.next(), this.parseVar(ae, true, Se), this.finishNode(ae, "VariableDeclaration"), (this.type === J._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && ae.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === J._in ? $ > -1 && this.unexpected($) : g.await = $ > -1), this.parseForIn(g, ae)) : ($ > -1 && this.unexpected($), this.parseFor(g, ae));
          }
          var Oe = this.isContextual("let"), De = false, We = this.containsEsc, nt = new Et(), ht = this.start, Ze = $ > -1 ? this.parseExprSubscripts(nt, "await") : this.parseExpression(true, nt);
          return this.type === J._in || (De = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? ($ > -1 ? (this.type === J._in && this.unexpected($), g.await = true) : De && this.options.ecmaVersion >= 8 && (Ze.start !== ht || We || Ze.type !== "Identifier" || Ze.name !== "async" ? this.options.ecmaVersion >= 9 && (g.await = false) : this.unexpected()), Oe && De && this.raise(Ze.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(Ze, false, nt), this.checkLValPattern(Ze), this.parseForIn(g, Ze)) : (this.checkExpressionErrors(nt, true), $ > -1 && this.unexpected($), this.parseFor(g, Ze));
        }, Qe.parseFunctionStatement = function(g, $, se) {
          return this.next(), this.parseFunction(g, qt | (se ? 0 : sn), false, $);
        }, Qe.parseIfStatement = function(g) {
          return this.next(), g.test = this.parseParenExpression(), g.consequent = this.parseStatement("if"), g.alternate = this.eat(J._else) ? this.parseStatement("if") : null, this.finishNode(g, "IfStatement");
        }, Qe.parseReturnStatement = function(g) {
          return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(J.semi) || this.insertSemicolon() ? g.argument = null : (g.argument = this.parseExpression(), this.semicolon()), this.finishNode(g, "ReturnStatement");
        }, Qe.parseSwitchStatement = function(g) {
          var $;
          this.next(), g.discriminant = this.parseParenExpression(), g.cases = [], this.expect(J.braceL), this.labels.push(vt), this.enterScope(0);
          for (var se = false; this.type !== J.braceR; ) if (this.type === J._case || this.type === J._default) {
            var ae = this.type === J._case;
            $ && this.finishNode($, "SwitchCase"), g.cases.push($ = this.startNode()), $.consequent = [], this.next(), ae ? $.test = this.parseExpression() : (se && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), se = true, $.test = null), this.expect(J.colon);
          } else $ || this.unexpected(), $.consequent.push(this.parseStatement(null));
          return this.exitScope(), $ && this.finishNode($, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(g, "SwitchStatement");
        }, Qe.parseThrowStatement = function(g) {
          return this.next(), Ee.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), g.argument = this.parseExpression(), this.semicolon(), this.finishNode(g, "ThrowStatement");
        };
        var kt = [];
        Qe.parseCatchClauseParam = function() {
          var g = this.parseBindingAtom(), $ = g.type === "Identifier";
          return this.enterScope($ ? 32 : 0), this.checkLValPattern(g, $ ? 4 : 2), this.expect(J.parenR), g;
        }, Qe.parseTryStatement = function(g) {
          if (this.next(), g.block = this.parseBlock(), g.handler = null, this.type === J._catch) {
            var $ = this.startNode();
            this.next(), this.eat(J.parenL) ? $.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), $.param = null, this.enterScope(0)), $.body = this.parseBlock(false), this.exitScope(), g.handler = this.finishNode($, "CatchClause");
          }
          return g.finalizer = this.eat(J._finally) ? this.parseBlock() : null, g.handler || g.finalizer || this.raise(g.start, "Missing catch or finally clause"), this.finishNode(g, "TryStatement");
        }, Qe.parseVarStatement = function(g, $, se) {
          return this.next(), this.parseVar(g, false, $, se), this.semicolon(), this.finishNode(g, "VariableDeclaration");
        }, Qe.parseWhileStatement = function(g) {
          return this.next(), g.test = this.parseParenExpression(), this.labels.push(yt), g.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(g, "WhileStatement");
        }, Qe.parseWithStatement = function(g) {
          return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), g.object = this.parseParenExpression(), g.body = this.parseStatement("with"), this.finishNode(g, "WithStatement");
        }, Qe.parseEmptyStatement = function(g) {
          return this.next(), this.finishNode(g, "EmptyStatement");
        }, Qe.parseLabeledStatement = function(g, $, se, ae) {
          for (var Se = 0, Oe = this.labels; Se < Oe.length; Se += 1) Oe[Se].name === $ && this.raise(se.start, "Label '" + $ + "' is already declared");
          for (var De = this.type.isLoop ? "loop" : this.type === J._switch ? "switch" : null, We = this.labels.length - 1; We >= 0; We--) {
            var nt = this.labels[We];
            if (nt.statementStart !== g.start) break;
            nt.statementStart = this.start, nt.kind = De;
          }
          return this.labels.push({ name: $, kind: De, statementStart: this.start }), g.body = this.parseStatement(ae ? ae.indexOf("label") === -1 ? ae + "label" : ae : "label"), this.labels.pop(), g.label = se, this.finishNode(g, "LabeledStatement");
        }, Qe.parseExpressionStatement = function(g, $) {
          return g.expression = $, this.semicolon(), this.finishNode(g, "ExpressionStatement");
        }, Qe.parseBlock = function(g, $, se) {
          for (g === void 0 && (g = true), $ === void 0 && ($ = this.startNode()), $.body = [], this.expect(J.braceL), g && this.enterScope(0); this.type !== J.braceR; ) {
            var ae = this.parseStatement(null);
            $.body.push(ae);
          }
          return se && (this.strict = false), this.next(), g && this.exitScope(), this.finishNode($, "BlockStatement");
        }, Qe.parseFor = function(g, $) {
          return g.init = $, this.expect(J.semi), g.test = this.type === J.semi ? null : this.parseExpression(), this.expect(J.semi), g.update = this.type === J.parenR ? null : this.parseExpression(), this.expect(J.parenR), g.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(g, "ForStatement");
        }, Qe.parseForIn = function(g, $) {
          var se = this.type === J._in;
          return this.next(), $.type === "VariableDeclaration" && $.declarations[0].init != null && (!se || this.options.ecmaVersion < 8 || this.strict || $.kind !== "var" || $.declarations[0].id.type !== "Identifier") && this.raise($.start, (se ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), g.left = $, g.right = se ? this.parseExpression() : this.parseMaybeAssign(), this.expect(J.parenR), g.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(g, se ? "ForInStatement" : "ForOfStatement");
        }, Qe.parseVar = function(g, $, se, ae) {
          for (g.declarations = [], g.kind = se; ; ) {
            var Se = this.startNode();
            if (this.parseVarId(Se, se), this.eat(J.eq) ? Se.init = this.parseMaybeAssign($) : ae || se !== "const" || this.type === J._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? ae || Se.id.type === "Identifier" || $ && (this.type === J._in || this.isContextual("of")) ? Se.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), g.declarations.push(this.finishNode(Se, "VariableDeclarator")), !this.eat(J.comma)) break;
          }
          return g;
        }, Qe.parseVarId = function(g, $) {
          g.id = this.parseBindingAtom(), this.checkLValPattern(g.id, $ === "var" ? 1 : 2, false);
        };
        var qt = 1, sn = 2;
        function _n(g, $) {
          var se = $.key.name, ae = g[se], Se = "true";
          return $.type !== "MethodDefinition" || $.kind !== "get" && $.kind !== "set" || (Se = ($.static ? "s" : "i") + $.kind), ae === "iget" && Se === "iset" || ae === "iset" && Se === "iget" || ae === "sget" && Se === "sset" || ae === "sset" && Se === "sget" ? (g[se] = "true", false) : !!ae || (g[se] = Se, false);
        }
        function bn(g, $) {
          var se = g.computed, ae = g.key;
          return !se && (ae.type === "Identifier" && ae.name === $ || ae.type === "Literal" && ae.value === $);
        }
        Qe.parseFunction = function(g, $, se, ae, Se) {
          this.initFunction(g), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !ae) && (this.type === J.star && $ & sn && this.unexpected(), g.generator = this.eat(J.star)), this.options.ecmaVersion >= 8 && (g.async = !!ae), $ & qt && (g.id = 4 & $ && this.type !== J.name ? null : this.parseIdent(), !g.id || $ & sn || this.checkLValSimple(g.id, this.strict || g.generator || g.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
          var Oe = this.yieldPos, De = this.awaitPos, We = this.awaitIdentPos;
          return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(rt(g.async, g.generator)), $ & qt || (g.id = this.type === J.name ? this.parseIdent() : null), this.parseFunctionParams(g), this.parseFunctionBody(g, se, false, Se), this.yieldPos = Oe, this.awaitPos = De, this.awaitIdentPos = We, this.finishNode(g, $ & qt ? "FunctionDeclaration" : "FunctionExpression");
        }, Qe.parseFunctionParams = function(g) {
          this.expect(J.parenL), g.params = this.parseBindingList(J.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
        }, Qe.parseClass = function(g, $) {
          this.next();
          var se = this.strict;
          this.strict = true, this.parseClassId(g, $), this.parseClassSuper(g);
          var ae = this.enterClassBody(), Se = this.startNode(), Oe = false;
          for (Se.body = [], this.expect(J.braceL); this.type !== J.braceR; ) {
            var De = this.parseClassElement(g.superClass !== null);
            De && (Se.body.push(De), De.type === "MethodDefinition" && De.kind === "constructor" ? (Oe && this.raiseRecoverable(De.start, "Duplicate constructor in the same class"), Oe = true) : De.key && De.key.type === "PrivateIdentifier" && _n(ae, De) && this.raiseRecoverable(De.key.start, "Identifier '#" + De.key.name + "' has already been declared"));
          }
          return this.strict = se, this.next(), g.body = this.finishNode(Se, "ClassBody"), this.exitClassBody(), this.finishNode(g, $ ? "ClassDeclaration" : "ClassExpression");
        }, Qe.parseClassElement = function(g) {
          if (this.eat(J.semi)) return null;
          var $ = this.options.ecmaVersion, se = this.startNode(), ae = "", Se = false, Oe = false, De = "method", We = false;
          if (this.eatContextual("static")) {
            if ($ >= 13 && this.eat(J.braceL)) return this.parseClassStaticBlock(se), se;
            this.isClassElementNameStart() || this.type === J.star ? We = true : ae = "static";
          }
          if (se.static = We, !ae && $ >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== J.star || this.canInsertSemicolon() ? ae = "async" : Oe = true), !ae && ($ >= 9 || !Oe) && this.eat(J.star) && (Se = true), !ae && !Oe && !Se) {
            var nt = this.value;
            (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? De = nt : ae = nt);
          }
          if (ae ? (se.computed = false, se.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), se.key.name = ae, this.finishNode(se.key, "Identifier")) : this.parseClassElementName(se), $ < 13 || this.type === J.parenL || De !== "method" || Se || Oe) {
            var ht = !se.static && bn(se, "constructor"), Ze = ht && g;
            ht && De !== "method" && this.raise(se.key.start, "Constructor can't have get/set modifier"), se.kind = ht ? "constructor" : De, this.parseClassMethod(se, Se, Oe, Ze);
          } else this.parseClassField(se);
          return se;
        }, Qe.isClassElementNameStart = function() {
          return this.type === J.name || this.type === J.privateId || this.type === J.num || this.type === J.string || this.type === J.bracketL || this.type.keyword;
        }, Qe.parseClassElementName = function(g) {
          this.type === J.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), g.computed = false, g.key = this.parsePrivateIdent()) : this.parsePropertyName(g);
        }, Qe.parseClassMethod = function(g, $, se, ae) {
          var Se = g.key;
          g.kind === "constructor" ? ($ && this.raise(Se.start, "Constructor can't be a generator"), se && this.raise(Se.start, "Constructor can't be an async method")) : g.static && bn(g, "prototype") && this.raise(Se.start, "Classes may not have a static property named prototype");
          var Oe = g.value = this.parseMethod($, se, ae);
          return g.kind === "get" && Oe.params.length !== 0 && this.raiseRecoverable(Oe.start, "getter should have no params"), g.kind === "set" && Oe.params.length !== 1 && this.raiseRecoverable(Oe.start, "setter should have exactly one param"), g.kind === "set" && Oe.params[0].type === "RestElement" && this.raiseRecoverable(Oe.params[0].start, "Setter cannot use rest params"), this.finishNode(g, "MethodDefinition");
        }, Qe.parseClassField = function(g) {
          if (bn(g, "constructor") ? this.raise(g.key.start, "Classes can't have a field named 'constructor'") : g.static && bn(g, "prototype") && this.raise(g.key.start, "Classes can't have a static field named 'prototype'"), this.eat(J.eq)) {
            var $ = this.currentThisScope(), se = $.inClassFieldInit;
            $.inClassFieldInit = true, g.value = this.parseMaybeAssign(), $.inClassFieldInit = se;
          } else g.value = null;
          return this.semicolon(), this.finishNode(g, "PropertyDefinition");
        }, Qe.parseClassStaticBlock = function(g) {
          g.body = [];
          var $ = this.labels;
          for (this.labels = [], this.enterScope(320); this.type !== J.braceR; ) {
            var se = this.parseStatement(null);
            g.body.push(se);
          }
          return this.next(), this.exitScope(), this.labels = $, this.finishNode(g, "StaticBlock");
        }, Qe.parseClassId = function(g, $) {
          this.type === J.name ? (g.id = this.parseIdent(), $ && this.checkLValSimple(g.id, 2, false)) : ($ === true && this.unexpected(), g.id = null);
        }, Qe.parseClassSuper = function(g) {
          g.superClass = this.eat(J._extends) ? this.parseExprSubscripts(null, false) : null;
        }, Qe.enterClassBody = function() {
          var g = { declared: /* @__PURE__ */ Object.create(null), used: [] };
          return this.privateNameStack.push(g), g.declared;
        }, Qe.exitClassBody = function() {
          var g = this.privateNameStack.pop(), $ = g.declared, se = g.used;
          if (this.options.checkPrivateFields) for (var ae = this.privateNameStack.length, Se = ae === 0 ? null : this.privateNameStack[ae - 1], Oe = 0; Oe < se.length; ++Oe) {
            var De = se[Oe];
            he($, De.name) || (Se ? Se.used.push(De) : this.raiseRecoverable(De.start, "Private field '#" + De.name + "' must be declared in an enclosing class"));
          }
        }, Qe.parseExportAllDeclaration = function(g, $) {
          return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (g.exported = this.parseModuleExportName(), this.checkExport($, g.exported, this.lastTokStart)) : g.exported = null), this.expectContextual("from"), this.type !== J.string && this.unexpected(), g.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (g.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(g, "ExportAllDeclaration");
        }, Qe.parseExport = function(g, $) {
          if (this.next(), this.eat(J.star)) return this.parseExportAllDeclaration(g, $);
          if (this.eat(J._default)) return this.checkExport($, "default", this.lastTokStart), g.declaration = this.parseExportDefaultDeclaration(), this.finishNode(g, "ExportDefaultDeclaration");
          if (this.shouldParseExportStatement()) g.declaration = this.parseExportDeclaration(g), g.declaration.type === "VariableDeclaration" ? this.checkVariableExport($, g.declaration.declarations) : this.checkExport($, g.declaration.id, g.declaration.id.start), g.specifiers = [], g.source = null;
          else {
            if (g.declaration = null, g.specifiers = this.parseExportSpecifiers($), this.eatContextual("from")) this.type !== J.string && this.unexpected(), g.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (g.attributes = this.parseWithClause());
            else {
              for (var se = 0, ae = g.specifiers; se < ae.length; se += 1) {
                var Se = ae[se];
                this.checkUnreserved(Se.local), this.checkLocalExport(Se.local), Se.local.type === "Literal" && this.raise(Se.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
              g.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(g, "ExportNamedDeclaration");
        }, Qe.parseExportDeclaration = function(g) {
          return this.parseStatement(null);
        }, Qe.parseExportDefaultDeclaration = function() {
          var g;
          if (this.type === J._function || (g = this.isAsyncFunction())) {
            var $ = this.startNode();
            return this.next(), g && this.next(), this.parseFunction($, 4 | qt, false, g);
          }
          if (this.type === J._class) {
            var se = this.startNode();
            return this.parseClass(se, "nullableID");
          }
          var ae = this.parseMaybeAssign();
          return this.semicolon(), ae;
        }, Qe.checkExport = function(g, $, se) {
          g && (typeof $ != "string" && ($ = $.type === "Identifier" ? $.name : $.value), he(g, $) && this.raiseRecoverable(se, "Duplicate export '" + $ + "'"), g[$] = true);
        }, Qe.checkPatternExport = function(g, $) {
          var se = $.type;
          if (se === "Identifier") this.checkExport(g, $, $.start);
          else if (se === "ObjectPattern") for (var ae = 0, Se = $.properties; ae < Se.length; ae += 1) {
            var Oe = Se[ae];
            this.checkPatternExport(g, Oe);
          }
          else if (se === "ArrayPattern") for (var De = 0, We = $.elements; De < We.length; De += 1) {
            var nt = We[De];
            nt && this.checkPatternExport(g, nt);
          }
          else se === "Property" ? this.checkPatternExport(g, $.value) : se === "AssignmentPattern" ? this.checkPatternExport(g, $.left) : se === "RestElement" && this.checkPatternExport(g, $.argument);
        }, Qe.checkVariableExport = function(g, $) {
          if (g) for (var se = 0, ae = $; se < ae.length; se += 1) {
            var Se = ae[se];
            this.checkPatternExport(g, Se.id);
          }
        }, Qe.shouldParseExportStatement = function() {
          return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
        }, Qe.parseExportSpecifier = function(g) {
          var $ = this.startNode();
          return $.local = this.parseModuleExportName(), $.exported = this.eatContextual("as") ? this.parseModuleExportName() : $.local, this.checkExport(g, $.exported, $.exported.start), this.finishNode($, "ExportSpecifier");
        }, Qe.parseExportSpecifiers = function(g) {
          var $ = [], se = true;
          for (this.expect(J.braceL); !this.eat(J.braceR); ) {
            if (se) se = false;
            else if (this.expect(J.comma), this.afterTrailingComma(J.braceR)) break;
            $.push(this.parseExportSpecifier(g));
          }
          return $;
        }, Qe.parseImport = function(g) {
          return this.next(), this.type === J.string ? (g.specifiers = kt, g.source = this.parseExprAtom()) : (g.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), g.source = this.type === J.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (g.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(g, "ImportDeclaration");
        }, Qe.parseImportSpecifier = function() {
          var g = this.startNode();
          return g.imported = this.parseModuleExportName(), this.eatContextual("as") ? g.local = this.parseIdent() : (this.checkUnreserved(g.imported), g.local = g.imported), this.checkLValSimple(g.local, 2), this.finishNode(g, "ImportSpecifier");
        }, Qe.parseImportDefaultSpecifier = function() {
          var g = this.startNode();
          return g.local = this.parseIdent(), this.checkLValSimple(g.local, 2), this.finishNode(g, "ImportDefaultSpecifier");
        }, Qe.parseImportNamespaceSpecifier = function() {
          var g = this.startNode();
          return this.next(), this.expectContextual("as"), g.local = this.parseIdent(), this.checkLValSimple(g.local, 2), this.finishNode(g, "ImportNamespaceSpecifier");
        }, Qe.parseImportSpecifiers = function() {
          var g = [], $ = true;
          if (this.type === J.name && (g.push(this.parseImportDefaultSpecifier()), !this.eat(J.comma))) return g;
          if (this.type === J.star) return g.push(this.parseImportNamespaceSpecifier()), g;
          for (this.expect(J.braceL); !this.eat(J.braceR); ) {
            if ($) $ = false;
            else if (this.expect(J.comma), this.afterTrailingComma(J.braceR)) break;
            g.push(this.parseImportSpecifier());
          }
          return g;
        }, Qe.parseWithClause = function() {
          var g = [];
          if (!this.eat(J._with)) return g;
          this.expect(J.braceL);
          for (var $ = {}, se = true; !this.eat(J.braceR); ) {
            if (se) se = false;
            else if (this.expect(J.comma), this.afterTrailingComma(J.braceR)) break;
            var ae = this.parseImportAttribute(), Se = ae.key.type === "Identifier" ? ae.key.name : ae.key.value;
            he($, Se) && this.raiseRecoverable(ae.key.start, "Duplicate attribute key '" + Se + "'"), $[Se] = true, g.push(ae);
          }
          return g;
        }, Qe.parseImportAttribute = function() {
          var g = this.startNode();
          return g.key = this.type === J.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never"), this.expect(J.colon), this.type !== J.string && this.unexpected(), g.value = this.parseExprAtom(), this.finishNode(g, "ImportAttribute");
        }, Qe.parseModuleExportName = function() {
          if (this.options.ecmaVersion >= 13 && this.type === J.string) {
            var g = this.parseLiteral(this.value);
            return Xe.test(g.value) && this.raise(g.start, "An export name cannot include a lone surrogate."), g;
          }
          return this.parseIdent(true);
        }, Qe.adaptDirectivePrologue = function(g) {
          for (var $ = 0; $ < g.length && this.isDirectiveCandidate(g[$]); ++$) g[$].directive = g[$].expression.raw.slice(1, -1);
        }, Qe.isDirectiveCandidate = function(g) {
          return this.options.ecmaVersion >= 5 && g.type === "ExpressionStatement" && g.expression.type === "Literal" && typeof g.expression.value == "string" && (this.input[g.start] === '"' || this.input[g.start] === "'");
        };
        var Kt = it.prototype;
        Kt.toAssignable = function(g, $, se) {
          if (this.options.ecmaVersion >= 6 && g) switch (g.type) {
            case "Identifier":
              this.inAsync && g.name === "await" && this.raise(g.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              g.type = "ObjectPattern", se && this.checkPatternErrors(se, true);
              for (var ae = 0, Se = g.properties; ae < Se.length; ae += 1) {
                var Oe = Se[ae];
                this.toAssignable(Oe, $), Oe.type !== "RestElement" || Oe.argument.type !== "ArrayPattern" && Oe.argument.type !== "ObjectPattern" || this.raise(Oe.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              g.kind !== "init" && this.raise(g.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(g.value, $);
              break;
            case "ArrayExpression":
              g.type = "ArrayPattern", se && this.checkPatternErrors(se, true), this.toAssignableList(g.elements, $);
              break;
            case "SpreadElement":
              g.type = "RestElement", this.toAssignable(g.argument, $), g.argument.type === "AssignmentPattern" && this.raise(g.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              g.operator !== "=" && this.raise(g.left.end, "Only '=' operator can be used for specifying default value."), g.type = "AssignmentPattern", delete g.operator, this.toAssignable(g.left, $);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(g.expression, $, se);
              break;
            case "ChainExpression":
              this.raiseRecoverable(g.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!$) break;
            default:
              this.raise(g.start, "Assigning to rvalue");
          }
          else se && this.checkPatternErrors(se, true);
          return g;
        }, Kt.toAssignableList = function(g, $) {
          for (var se = g.length, ae = 0; ae < se; ae++) {
            var Se = g[ae];
            Se && this.toAssignable(Se, $);
          }
          if (se) {
            var Oe = g[se - 1];
            this.options.ecmaVersion === 6 && $ && Oe && Oe.type === "RestElement" && Oe.argument.type !== "Identifier" && this.unexpected(Oe.argument.start);
          }
          return g;
        }, Kt.parseSpread = function(g) {
          var $ = this.startNode();
          return this.next(), $.argument = this.parseMaybeAssign(false, g), this.finishNode($, "SpreadElement");
        }, Kt.parseRestBinding = function() {
          var g = this.startNode();
          return this.next(), this.options.ecmaVersion === 6 && this.type !== J.name && this.unexpected(), g.argument = this.parseBindingAtom(), this.finishNode(g, "RestElement");
        }, Kt.parseBindingAtom = function() {
          if (this.options.ecmaVersion >= 6) switch (this.type) {
            case J.bracketL:
              var g = this.startNode();
              return this.next(), g.elements = this.parseBindingList(J.bracketR, true, true), this.finishNode(g, "ArrayPattern");
            case J.braceL:
              return this.parseObj(true);
          }
          return this.parseIdent();
        }, Kt.parseBindingList = function(g, $, se, ae) {
          for (var Se = [], Oe = true; !this.eat(g); ) if (Oe ? Oe = false : this.expect(J.comma), $ && this.type === J.comma) Se.push(null);
          else {
            if (se && this.afterTrailingComma(g)) break;
            if (this.type === J.ellipsis) {
              var De = this.parseRestBinding();
              this.parseBindingListItem(De), Se.push(De), this.type === J.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(g);
              break;
            }
            Se.push(this.parseAssignableListItem(ae));
          }
          return Se;
        }, Kt.parseAssignableListItem = function(g) {
          var $ = this.parseMaybeDefault(this.start, this.startLoc);
          return this.parseBindingListItem($), $;
        }, Kt.parseBindingListItem = function(g) {
          return g;
        }, Kt.parseMaybeDefault = function(g, $, se) {
          if (se = se || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(J.eq)) return se;
          var ae = this.startNodeAt(g, $);
          return ae.left = se, ae.right = this.parseMaybeAssign(), this.finishNode(ae, "AssignmentPattern");
        }, Kt.checkLValSimple = function(g, $, se) {
          $ === void 0 && ($ = 0);
          var ae = $ !== 0;
          switch (g.type) {
            case "Identifier":
              this.strict && this.reservedWordsStrictBind.test(g.name) && this.raiseRecoverable(g.start, (ae ? "Binding " : "Assigning to ") + g.name + " in strict mode"), ae && ($ === 2 && g.name === "let" && this.raiseRecoverable(g.start, "let is disallowed as a lexically bound name"), se && (he(se, g.name) && this.raiseRecoverable(g.start, "Argument name clash"), se[g.name] = true), $ !== 5 && this.declareName(g.name, $, g.start));
              break;
            case "ChainExpression":
              this.raiseRecoverable(g.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              ae && this.raiseRecoverable(g.start, "Binding member expression");
              break;
            case "ParenthesizedExpression":
              return ae && this.raiseRecoverable(g.start, "Binding parenthesized expression"), this.checkLValSimple(g.expression, $, se);
            default:
              this.raise(g.start, (ae ? "Binding" : "Assigning to") + " rvalue");
          }
        }, Kt.checkLValPattern = function(g, $, se) {
          switch ($ === void 0 && ($ = 0), g.type) {
            case "ObjectPattern":
              for (var ae = 0, Se = g.properties; ae < Se.length; ae += 1) {
                var Oe = Se[ae];
                this.checkLValInnerPattern(Oe, $, se);
              }
              break;
            case "ArrayPattern":
              for (var De = 0, We = g.elements; De < We.length; De += 1) {
                var nt = We[De];
                nt && this.checkLValInnerPattern(nt, $, se);
              }
              break;
            default:
              this.checkLValSimple(g, $, se);
          }
        }, Kt.checkLValInnerPattern = function(g, $, se) {
          switch ($ === void 0 && ($ = 0), g.type) {
            case "Property":
              this.checkLValInnerPattern(g.value, $, se);
              break;
            case "AssignmentPattern":
              this.checkLValPattern(g.left, $, se);
              break;
            case "RestElement":
              this.checkLValPattern(g.argument, $, se);
              break;
            default:
              this.checkLValPattern(g, $, se);
          }
        };
        var Jt = function(g, $, se, ae, Se) {
          this.token = g, this.isExpr = !!$, this.preserveSpace = !!se, this.override = ae, this.generator = !!Se;
        }, Ft = { b_stat: new Jt("{", false), b_expr: new Jt("{", true), b_tmpl: new Jt("${", false), p_stat: new Jt("(", false), p_expr: new Jt("(", true), q_tmpl: new Jt("`", true, true, function(g) {
          return g.tryReadTemplateToken();
        }), f_stat: new Jt("function", false), f_expr: new Jt("function", true), f_expr_gen: new Jt("function", true, false, null, true), f_gen: new Jt("function", false, false, null, true) }, fn = it.prototype;
        fn.initialContext = function() {
          return [Ft.b_stat];
        }, fn.curContext = function() {
          return this.context[this.context.length - 1];
        }, fn.braceIsBlock = function(g) {
          var $ = this.curContext();
          return $ === Ft.f_expr || $ === Ft.f_stat || (g !== J.colon || $ !== Ft.b_stat && $ !== Ft.b_expr ? g === J._return || g === J.name && this.exprAllowed ? Ee.test(this.input.slice(this.lastTokEnd, this.start)) : g === J._else || g === J.semi || g === J.eof || g === J.parenR || g === J.arrow || (g === J.braceL ? $ === Ft.b_stat : g !== J._var && g !== J._const && g !== J.name && !this.exprAllowed) : !$.isExpr);
        }, fn.inGeneratorContext = function() {
          for (var g = this.context.length - 1; g >= 1; g--) {
            var $ = this.context[g];
            if ($.token === "function") return $.generator;
          }
          return false;
        }, fn.updateContext = function(g) {
          var $, se = this.type;
          se.keyword && g === J.dot ? this.exprAllowed = false : ($ = se.updateContext) ? $.call(this, g) : this.exprAllowed = se.beforeExpr;
        }, fn.overrideContext = function(g) {
          this.curContext() !== g && (this.context[this.context.length - 1] = g);
        }, J.parenR.updateContext = J.braceR.updateContext = function() {
          if (this.context.length !== 1) {
            var g = this.context.pop();
            g === Ft.b_stat && this.curContext().token === "function" && (g = this.context.pop()), this.exprAllowed = !g.isExpr;
          } else this.exprAllowed = true;
        }, J.braceL.updateContext = function(g) {
          this.context.push(this.braceIsBlock(g) ? Ft.b_stat : Ft.b_expr), this.exprAllowed = true;
        }, J.dollarBraceL.updateContext = function() {
          this.context.push(Ft.b_tmpl), this.exprAllowed = true;
        }, J.parenL.updateContext = function(g) {
          var $ = g === J._if || g === J._for || g === J._with || g === J._while;
          this.context.push($ ? Ft.p_stat : Ft.p_expr), this.exprAllowed = true;
        }, J.incDec.updateContext = function() {
        }, J._function.updateContext = J._class.updateContext = function(g) {
          !g.beforeExpr || g === J._else || g === J.semi && this.curContext() !== Ft.p_stat || g === J._return && Ee.test(this.input.slice(this.lastTokEnd, this.start)) || (g === J.colon || g === J.braceL) && this.curContext() === Ft.b_stat ? this.context.push(Ft.f_stat) : this.context.push(Ft.f_expr), this.exprAllowed = false;
        }, J.colon.updateContext = function() {
          this.curContext().token === "function" && this.context.pop(), this.exprAllowed = true;
        }, J.backQuote.updateContext = function() {
          this.curContext() === Ft.q_tmpl ? this.context.pop() : this.context.push(Ft.q_tmpl), this.exprAllowed = false;
        }, J.star.updateContext = function(g) {
          if (g === J._function) {
            var $ = this.context.length - 1;
            this.context[$] === Ft.f_expr ? this.context[$] = Ft.f_expr_gen : this.context[$] = Ft.f_gen;
          }
          this.exprAllowed = true;
        }, J.name.updateContext = function(g) {
          var $ = false;
          this.options.ecmaVersion >= 6 && g !== J.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && ($ = true), this.exprAllowed = $;
        };
        var _t = it.prototype;
        function Xn(g) {
          return g.type === "Identifier" || g.type === "ParenthesizedExpression" && Xn(g.expression);
        }
        function Jn(g) {
          return g.type === "MemberExpression" && g.property.type === "PrivateIdentifier" || g.type === "ChainExpression" && Jn(g.expression) || g.type === "ParenthesizedExpression" && Jn(g.expression);
        }
        _t.checkPropClash = function(g, $, se) {
          if (!(this.options.ecmaVersion >= 9 && g.type === "SpreadElement" || this.options.ecmaVersion >= 6 && (g.computed || g.method || g.shorthand))) {
            var ae, Se = g.key;
            switch (Se.type) {
              case "Identifier":
                ae = Se.name;
                break;
              case "Literal":
                ae = String(Se.value);
                break;
              default:
                return;
            }
            var Oe = g.kind;
            if (this.options.ecmaVersion >= 6) ae === "__proto__" && Oe === "init" && ($.proto && (se ? se.doubleProto < 0 && (se.doubleProto = Se.start) : this.raiseRecoverable(Se.start, "Redefinition of __proto__ property")), $.proto = true);
            else {
              var De = $[ae = "$" + ae];
              De ? (Oe === "init" ? this.strict && De.init || De.get || De.set : De.init || De[Oe]) && this.raiseRecoverable(Se.start, "Redefinition of property") : De = $[ae] = { init: false, get: false, set: false }, De[Oe] = true;
            }
          }
        }, _t.parseExpression = function(g, $) {
          var se = this.start, ae = this.startLoc, Se = this.parseMaybeAssign(g, $);
          if (this.type === J.comma) {
            var Oe = this.startNodeAt(se, ae);
            for (Oe.expressions = [Se]; this.eat(J.comma); ) Oe.expressions.push(this.parseMaybeAssign(g, $));
            return this.finishNode(Oe, "SequenceExpression");
          }
          return Se;
        }, _t.parseMaybeAssign = function(g, $, se) {
          if (this.isContextual("yield")) {
            if (this.inGenerator) return this.parseYield(g);
            this.exprAllowed = false;
          }
          var ae = false, Se = -1, Oe = -1, De = -1;
          $ ? (Se = $.parenthesizedAssign, Oe = $.trailingComma, De = $.doubleProto, $.parenthesizedAssign = $.trailingComma = -1) : ($ = new Et(), ae = true);
          var We = this.start, nt = this.startLoc;
          this.type !== J.parenL && this.type !== J.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = g === "await");
          var ht = this.parseMaybeConditional(g, $);
          if (se && (ht = se.call(this, ht, We, nt)), this.type.isAssign) {
            var Ze = this.startNodeAt(We, nt);
            return Ze.operator = this.value, this.type === J.eq && (ht = this.toAssignable(ht, false, $)), ae || ($.parenthesizedAssign = $.trailingComma = $.doubleProto = -1), $.shorthandAssign >= ht.start && ($.shorthandAssign = -1), this.type === J.eq ? this.checkLValPattern(ht) : this.checkLValSimple(ht), Ze.left = ht, this.next(), Ze.right = this.parseMaybeAssign(g), De > -1 && ($.doubleProto = De), this.finishNode(Ze, "AssignmentExpression");
          }
          return ae && this.checkExpressionErrors($, true), Se > -1 && ($.parenthesizedAssign = Se), Oe > -1 && ($.trailingComma = Oe), ht;
        }, _t.parseMaybeConditional = function(g, $) {
          var se = this.start, ae = this.startLoc, Se = this.parseExprOps(g, $);
          if (this.checkExpressionErrors($)) return Se;
          if (this.eat(J.question)) {
            var Oe = this.startNodeAt(se, ae);
            return Oe.test = Se, Oe.consequent = this.parseMaybeAssign(), this.expect(J.colon), Oe.alternate = this.parseMaybeAssign(g), this.finishNode(Oe, "ConditionalExpression");
          }
          return Se;
        }, _t.parseExprOps = function(g, $) {
          var se = this.start, ae = this.startLoc, Se = this.parseMaybeUnary($, false, false, g);
          return this.checkExpressionErrors($) || Se.start === se && Se.type === "ArrowFunctionExpression" ? Se : this.parseExprOp(Se, se, ae, -1, g);
        }, _t.parseExprOp = function(g, $, se, ae, Se) {
          var Oe = this.type.binop;
          if (Oe != null && (!Se || this.type !== J._in) && Oe > ae) {
            var De = this.type === J.logicalOR || this.type === J.logicalAND, We = this.type === J.coalesce;
            We && (Oe = J.logicalAND.binop);
            var nt = this.value;
            this.next();
            var ht = this.start, Ze = this.startLoc, Pt = this.parseExprOp(this.parseMaybeUnary(null, false, false, Se), ht, Ze, Oe, Se), jt = this.buildBinary($, se, g, Pt, nt, De || We);
            return (De && this.type === J.coalesce || We && (this.type === J.logicalOR || this.type === J.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(jt, $, se, ae, Se);
          }
          return g;
        }, _t.buildBinary = function(g, $, se, ae, Se, Oe) {
          ae.type === "PrivateIdentifier" && this.raise(ae.start, "Private identifier can only be left side of binary expression");
          var De = this.startNodeAt(g, $);
          return De.left = se, De.operator = Se, De.right = ae, this.finishNode(De, Oe ? "LogicalExpression" : "BinaryExpression");
        }, _t.parseMaybeUnary = function(g, $, se, ae) {
          var Se, Oe = this.start, De = this.startLoc;
          if (this.isContextual("await") && this.canAwait) Se = this.parseAwait(ae), $ = true;
          else if (this.type.prefix) {
            var We = this.startNode(), nt = this.type === J.incDec;
            We.operator = this.value, We.prefix = true, this.next(), We.argument = this.parseMaybeUnary(null, true, nt, ae), this.checkExpressionErrors(g, true), nt ? this.checkLValSimple(We.argument) : this.strict && We.operator === "delete" && Xn(We.argument) ? this.raiseRecoverable(We.start, "Deleting local variable in strict mode") : We.operator === "delete" && Jn(We.argument) ? this.raiseRecoverable(We.start, "Private fields can not be deleted") : $ = true, Se = this.finishNode(We, nt ? "UpdateExpression" : "UnaryExpression");
          } else if ($ || this.type !== J.privateId) {
            if (Se = this.parseExprSubscripts(g, ae), this.checkExpressionErrors(g)) return Se;
            for (; this.type.postfix && !this.canInsertSemicolon(); ) {
              var ht = this.startNodeAt(Oe, De);
              ht.operator = this.value, ht.prefix = false, ht.argument = Se, this.checkLValSimple(Se), this.next(), Se = this.finishNode(ht, "UpdateExpression");
            }
          } else (ae || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), Se = this.parsePrivateIdent(), this.type !== J._in && this.unexpected();
          return se || !this.eat(J.starstar) ? Se : $ ? void this.unexpected(this.lastTokStart) : this.buildBinary(Oe, De, Se, this.parseMaybeUnary(null, false, false, ae), "**", false);
        }, _t.parseExprSubscripts = function(g, $) {
          var se = this.start, ae = this.startLoc, Se = this.parseExprAtom(g, $);
          if (Se.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return Se;
          var Oe = this.parseSubscripts(Se, se, ae, false, $);
          return g && Oe.type === "MemberExpression" && (g.parenthesizedAssign >= Oe.start && (g.parenthesizedAssign = -1), g.parenthesizedBind >= Oe.start && (g.parenthesizedBind = -1), g.trailingComma >= Oe.start && (g.trailingComma = -1)), Oe;
        }, _t.parseSubscripts = function(g, $, se, ae, Se) {
          for (var Oe = this.options.ecmaVersion >= 8 && g.type === "Identifier" && g.name === "async" && this.lastTokEnd === g.end && !this.canInsertSemicolon() && g.end - g.start == 5 && this.potentialArrowAt === g.start, De = false; ; ) {
            var We = this.parseSubscript(g, $, se, ae, Oe, De, Se);
            if (We.optional && (De = true), We === g || We.type === "ArrowFunctionExpression") {
              if (De) {
                var nt = this.startNodeAt($, se);
                nt.expression = We, We = this.finishNode(nt, "ChainExpression");
              }
              return We;
            }
            g = We;
          }
        }, _t.shouldParseAsyncArrow = function() {
          return !this.canInsertSemicolon() && this.eat(J.arrow);
        }, _t.parseSubscriptAsyncArrow = function(g, $, se, ae) {
          return this.parseArrowExpression(this.startNodeAt(g, $), se, true, ae);
        }, _t.parseSubscript = function(g, $, se, ae, Se, Oe, De) {
          var We = this.options.ecmaVersion >= 11, nt = We && this.eat(J.questionDot);
          ae && nt && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
          var ht = this.eat(J.bracketL);
          if (ht || nt && this.type !== J.parenL && this.type !== J.backQuote || this.eat(J.dot)) {
            var Ze = this.startNodeAt($, se);
            Ze.object = g, ht ? (Ze.property = this.parseExpression(), this.expect(J.bracketR)) : this.type === J.privateId && g.type !== "Super" ? Ze.property = this.parsePrivateIdent() : Ze.property = this.parseIdent(this.options.allowReserved !== "never"), Ze.computed = !!ht, We && (Ze.optional = nt), g = this.finishNode(Ze, "MemberExpression");
          } else if (!ae && this.eat(J.parenL)) {
            var Pt = new Et(), jt = this.yieldPos, rn = this.awaitPos, vn = this.awaitIdentPos;
            this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
            var $n = this.parseExprList(J.parenR, this.options.ecmaVersion >= 8, false, Pt);
            if (Se && !nt && this.shouldParseAsyncArrow()) return this.checkPatternErrors(Pt, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = jt, this.awaitPos = rn, this.awaitIdentPos = vn, this.parseSubscriptAsyncArrow($, se, $n, De);
            this.checkExpressionErrors(Pt, true), this.yieldPos = jt || this.yieldPos, this.awaitPos = rn || this.awaitPos, this.awaitIdentPos = vn || this.awaitIdentPos;
            var Kn = this.startNodeAt($, se);
            Kn.callee = g, Kn.arguments = $n, We && (Kn.optional = nt), g = this.finishNode(Kn, "CallExpression");
          } else if (this.type === J.backQuote) {
            (nt || Oe) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            var Pn = this.startNodeAt($, se);
            Pn.tag = g, Pn.quasi = this.parseTemplate({ isTagged: true }), g = this.finishNode(Pn, "TaggedTemplateExpression");
          }
          return g;
        }, _t.parseExprAtom = function(g, $, se) {
          this.type === J.slash && this.readRegexp();
          var ae, Se = this.potentialArrowAt === this.start;
          switch (this.type) {
            case J._super:
              return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), ae = this.startNode(), this.next(), this.type !== J.parenL || this.allowDirectSuper || this.raise(ae.start, "super() call outside constructor of a subclass"), this.type !== J.dot && this.type !== J.bracketL && this.type !== J.parenL && this.unexpected(), this.finishNode(ae, "Super");
            case J._this:
              return ae = this.startNode(), this.next(), this.finishNode(ae, "ThisExpression");
            case J.name:
              var Oe = this.start, De = this.startLoc, We = this.containsEsc, nt = this.parseIdent(false);
              if (this.options.ecmaVersion >= 8 && !We && nt.name === "async" && !this.canInsertSemicolon() && this.eat(J._function)) return this.overrideContext(Ft.f_expr), this.parseFunction(this.startNodeAt(Oe, De), 0, false, true, $);
              if (Se && !this.canInsertSemicolon()) {
                if (this.eat(J.arrow)) return this.parseArrowExpression(this.startNodeAt(Oe, De), [nt], false, $);
                if (this.options.ecmaVersion >= 8 && nt.name === "async" && this.type === J.name && !We && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) return nt = this.parseIdent(false), !this.canInsertSemicolon() && this.eat(J.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(Oe, De), [nt], true, $);
              }
              return nt;
            case J.regexp:
              var ht = this.value;
              return (ae = this.parseLiteral(ht.value)).regex = { pattern: ht.pattern, flags: ht.flags }, ae;
            case J.num:
            case J.string:
              return this.parseLiteral(this.value);
            case J._null:
            case J._true:
            case J._false:
              return (ae = this.startNode()).value = this.type === J._null ? null : this.type === J._true, ae.raw = this.type.keyword, this.next(), this.finishNode(ae, "Literal");
            case J.parenL:
              var Ze = this.start, Pt = this.parseParenAndDistinguishExpression(Se, $);
              return g && (g.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(Pt) && (g.parenthesizedAssign = Ze), g.parenthesizedBind < 0 && (g.parenthesizedBind = Ze)), Pt;
            case J.bracketL:
              return ae = this.startNode(), this.next(), ae.elements = this.parseExprList(J.bracketR, true, true, g), this.finishNode(ae, "ArrayExpression");
            case J.braceL:
              return this.overrideContext(Ft.b_expr), this.parseObj(false, g);
            case J._function:
              return ae = this.startNode(), this.next(), this.parseFunction(ae, 0);
            case J._class:
              return this.parseClass(this.startNode(), false);
            case J._new:
              return this.parseNew();
            case J.backQuote:
              return this.parseTemplate();
            case J._import:
              return this.options.ecmaVersion >= 11 ? this.parseExprImport(se) : this.unexpected();
            default:
              return this.parseExprAtomDefault();
          }
        }, _t.parseExprAtomDefault = function() {
          this.unexpected();
        }, _t.parseExprImport = function(g) {
          var $ = this.startNode();
          if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === J.parenL && !g) return this.parseDynamicImport($);
          if (this.type === J.dot) {
            var se = this.startNodeAt($.start, $.loc && $.loc.start);
            return se.name = "import", $.meta = this.finishNode(se, "Identifier"), this.parseImportMeta($);
          }
          this.unexpected();
        }, _t.parseDynamicImport = function(g) {
          if (this.next(), g.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16) this.eat(J.parenR) ? g.options = null : (this.expect(J.comma), this.afterTrailingComma(J.parenR) ? g.options = null : (g.options = this.parseMaybeAssign(), this.eat(J.parenR) || (this.expect(J.comma), this.afterTrailingComma(J.parenR) || this.unexpected())));
          else if (!this.eat(J.parenR)) {
            var $ = this.start;
            this.eat(J.comma) && this.eat(J.parenR) ? this.raiseRecoverable($, "Trailing comma is not allowed in import()") : this.unexpected($);
          }
          return this.finishNode(g, "ImportExpression");
        }, _t.parseImportMeta = function(g) {
          this.next();
          var $ = this.containsEsc;
          return g.property = this.parseIdent(true), g.property.name !== "meta" && this.raiseRecoverable(g.property.start, "The only valid meta property for import is 'import.meta'"), $ && this.raiseRecoverable(g.start, "'import.meta' must not contain escaped characters"), this.options.sourceType === "module" || this.options.allowImportExportEverywhere || this.raiseRecoverable(g.start, "Cannot use 'import.meta' outside a module"), this.finishNode(g, "MetaProperty");
        }, _t.parseLiteral = function(g) {
          var $ = this.startNode();
          return $.value = g, $.raw = this.input.slice(this.start, this.end), $.raw.charCodeAt($.raw.length - 1) === 110 && ($.bigint = $.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode($, "Literal");
        }, _t.parseParenExpression = function() {
          this.expect(J.parenL);
          var g = this.parseExpression();
          return this.expect(J.parenR), g;
        }, _t.shouldParseArrow = function(g) {
          return !this.canInsertSemicolon();
        }, _t.parseParenAndDistinguishExpression = function(g, $) {
          var se, ae = this.start, Se = this.startLoc, Oe = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
            var De, We = this.start, nt = this.startLoc, ht = [], Ze = true, Pt = false, jt = new Et(), rn = this.yieldPos, vn = this.awaitPos;
            for (this.yieldPos = 0, this.awaitPos = 0; this.type !== J.parenR; ) {
              if (Ze ? Ze = false : this.expect(J.comma), Oe && this.afterTrailingComma(J.parenR, true)) {
                Pt = true;
                break;
              }
              if (this.type === J.ellipsis) {
                De = this.start, ht.push(this.parseParenItem(this.parseRestBinding())), this.type === J.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                break;
              }
              ht.push(this.parseMaybeAssign(false, jt, this.parseParenItem));
            }
            var $n = this.lastTokEnd, Kn = this.lastTokEndLoc;
            if (this.expect(J.parenR), g && this.shouldParseArrow(ht) && this.eat(J.arrow)) return this.checkPatternErrors(jt, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = rn, this.awaitPos = vn, this.parseParenArrowList(ae, Se, ht, $);
            ht.length && !Pt || this.unexpected(this.lastTokStart), De && this.unexpected(De), this.checkExpressionErrors(jt, true), this.yieldPos = rn || this.yieldPos, this.awaitPos = vn || this.awaitPos, ht.length > 1 ? ((se = this.startNodeAt(We, nt)).expressions = ht, this.finishNodeAt(se, "SequenceExpression", $n, Kn)) : se = ht[0];
          } else se = this.parseParenExpression();
          if (this.options.preserveParens) {
            var Pn = this.startNodeAt(ae, Se);
            return Pn.expression = se, this.finishNode(Pn, "ParenthesizedExpression");
          }
          return se;
        }, _t.parseParenItem = function(g) {
          return g;
        }, _t.parseParenArrowList = function(g, $, se, ae) {
          return this.parseArrowExpression(this.startNodeAt(g, $), se, false, ae);
        };
        var rr = [];
        _t.parseNew = function() {
          this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
          var g = this.startNode();
          if (this.next(), this.options.ecmaVersion >= 6 && this.type === J.dot) {
            var $ = this.startNodeAt(g.start, g.loc && g.loc.start);
            $.name = "new", g.meta = this.finishNode($, "Identifier"), this.next();
            var se = this.containsEsc;
            return g.property = this.parseIdent(true), g.property.name !== "target" && this.raiseRecoverable(g.property.start, "The only valid meta property for new is 'new.target'"), se && this.raiseRecoverable(g.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(g.start, "'new.target' can only be used in functions and class static block"), this.finishNode(g, "MetaProperty");
          }
          var ae = this.start, Se = this.startLoc;
          return g.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), ae, Se, true, false), this.eat(J.parenL) ? g.arguments = this.parseExprList(J.parenR, this.options.ecmaVersion >= 8, false) : g.arguments = rr, this.finishNode(g, "NewExpression");
        }, _t.parseTemplateElement = function(g) {
          var $ = g.isTagged, se = this.startNode();
          return this.type === J.invalidTemplate ? ($ || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), se.value = { raw: this.value.replace(/\r\n?/g, `
`), cooked: null }) : se.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`), cooked: this.value }, this.next(), se.tail = this.type === J.backQuote, this.finishNode(se, "TemplateElement");
        }, _t.parseTemplate = function(g) {
          g === void 0 && (g = {});
          var $ = g.isTagged;
          $ === void 0 && ($ = false);
          var se = this.startNode();
          this.next(), se.expressions = [];
          var ae = this.parseTemplateElement({ isTagged: $ });
          for (se.quasis = [ae]; !ae.tail; ) this.type === J.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(J.dollarBraceL), se.expressions.push(this.parseExpression()), this.expect(J.braceR), se.quasis.push(ae = this.parseTemplateElement({ isTagged: $ }));
          return this.next(), this.finishNode(se, "TemplateLiteral");
        }, _t.isAsyncProp = function(g) {
          return !g.computed && g.key.type === "Identifier" && g.key.name === "async" && (this.type === J.name || this.type === J.num || this.type === J.string || this.type === J.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === J.star) && !Ee.test(this.input.slice(this.lastTokEnd, this.start));
        }, _t.parseObj = function(g, $) {
          var se = this.startNode(), ae = true, Se = {};
          for (se.properties = [], this.next(); !this.eat(J.braceR); ) {
            if (ae) ae = false;
            else if (this.expect(J.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(J.braceR)) break;
            var Oe = this.parseProperty(g, $);
            g || this.checkPropClash(Oe, Se, $), se.properties.push(Oe);
          }
          return this.finishNode(se, g ? "ObjectPattern" : "ObjectExpression");
        }, _t.parseProperty = function(g, $) {
          var se, ae, Se, Oe, De = this.startNode();
          if (this.options.ecmaVersion >= 9 && this.eat(J.ellipsis)) return g ? (De.argument = this.parseIdent(false), this.type === J.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(De, "RestElement")) : (De.argument = this.parseMaybeAssign(false, $), this.type === J.comma && $ && $.trailingComma < 0 && ($.trailingComma = this.start), this.finishNode(De, "SpreadElement"));
          this.options.ecmaVersion >= 6 && (De.method = false, De.shorthand = false, (g || $) && (Se = this.start, Oe = this.startLoc), g || (se = this.eat(J.star)));
          var We = this.containsEsc;
          return this.parsePropertyName(De), !g && !We && this.options.ecmaVersion >= 8 && !se && this.isAsyncProp(De) ? (ae = true, se = this.options.ecmaVersion >= 9 && this.eat(J.star), this.parsePropertyName(De)) : ae = false, this.parsePropertyValue(De, g, se, ae, Se, Oe, $, We), this.finishNode(De, "Property");
        }, _t.parseGetterSetter = function(g) {
          g.kind = g.key.name, this.parsePropertyName(g), g.value = this.parseMethod(false);
          var $ = g.kind === "get" ? 0 : 1;
          if (g.value.params.length !== $) {
            var se = g.value.start;
            g.kind === "get" ? this.raiseRecoverable(se, "getter should have no params") : this.raiseRecoverable(se, "setter should have exactly one param");
          } else g.kind === "set" && g.value.params[0].type === "RestElement" && this.raiseRecoverable(g.value.params[0].start, "Setter cannot use rest params");
        }, _t.parsePropertyValue = function(g, $, se, ae, Se, Oe, De, We) {
          (se || ae) && this.type === J.colon && this.unexpected(), this.eat(J.colon) ? (g.value = $ ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, De), g.kind = "init") : this.options.ecmaVersion >= 6 && this.type === J.parenL ? ($ && this.unexpected(), g.kind = "init", g.method = true, g.value = this.parseMethod(se, ae)) : $ || We || !(this.options.ecmaVersion >= 5) || g.computed || g.key.type !== "Identifier" || g.key.name !== "get" && g.key.name !== "set" || this.type === J.comma || this.type === J.braceR || this.type === J.eq ? this.options.ecmaVersion >= 6 && !g.computed && g.key.type === "Identifier" ? ((se || ae) && this.unexpected(), this.checkUnreserved(g.key), g.key.name !== "await" || this.awaitIdentPos || (this.awaitIdentPos = Se), g.kind = "init", $ ? g.value = this.parseMaybeDefault(Se, Oe, this.copyNode(g.key)) : this.type === J.eq && De ? (De.shorthandAssign < 0 && (De.shorthandAssign = this.start), g.value = this.parseMaybeDefault(Se, Oe, this.copyNode(g.key))) : g.value = this.copyNode(g.key), g.shorthand = true) : this.unexpected() : ((se || ae) && this.unexpected(), this.parseGetterSetter(g));
        }, _t.parsePropertyName = function(g) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(J.bracketL)) return g.computed = true, g.key = this.parseMaybeAssign(), this.expect(J.bracketR), g.key;
            g.computed = false;
          }
          return g.key = this.type === J.num || this.type === J.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
        }, _t.initFunction = function(g) {
          g.id = null, this.options.ecmaVersion >= 6 && (g.generator = g.expression = false), this.options.ecmaVersion >= 8 && (g.async = false);
        }, _t.parseMethod = function(g, $, se) {
          var ae = this.startNode(), Se = this.yieldPos, Oe = this.awaitPos, De = this.awaitIdentPos;
          return this.initFunction(ae), this.options.ecmaVersion >= 6 && (ae.generator = g), this.options.ecmaVersion >= 8 && (ae.async = !!$), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | rt($, ae.generator) | (se ? 128 : 0)), this.expect(J.parenL), ae.params = this.parseBindingList(J.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(ae, false, true, false), this.yieldPos = Se, this.awaitPos = Oe, this.awaitIdentPos = De, this.finishNode(ae, "FunctionExpression");
        }, _t.parseArrowExpression = function(g, $, se, ae) {
          var Se = this.yieldPos, Oe = this.awaitPos, De = this.awaitIdentPos;
          return this.enterScope(16 | rt(se, false)), this.initFunction(g), this.options.ecmaVersion >= 8 && (g.async = !!se), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, g.params = this.toAssignableList($, true), this.parseFunctionBody(g, true, false, ae), this.yieldPos = Se, this.awaitPos = Oe, this.awaitIdentPos = De, this.finishNode(g, "ArrowFunctionExpression");
        }, _t.parseFunctionBody = function(g, $, se, ae) {
          var Se = $ && this.type !== J.braceL, Oe = this.strict, De = false;
          if (Se) g.body = this.parseMaybeAssign(ae), g.expression = true, this.checkParams(g, false);
          else {
            var We = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(g.params);
            Oe && !We || (De = this.strictDirective(this.end)) && We && this.raiseRecoverable(g.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            var nt = this.labels;
            this.labels = [], De && (this.strict = true), this.checkParams(g, !Oe && !De && !$ && !se && this.isSimpleParamList(g.params)), this.strict && g.id && this.checkLValSimple(g.id, 5), g.body = this.parseBlock(false, void 0, De && !Oe), g.expression = false, this.adaptDirectivePrologue(g.body.body), this.labels = nt;
          }
          this.exitScope();
        }, _t.isSimpleParamList = function(g) {
          for (var $ = 0, se = g; $ < se.length; $ += 1) if (se[$].type !== "Identifier") return false;
          return true;
        }, _t.checkParams = function(g, $) {
          for (var se = /* @__PURE__ */ Object.create(null), ae = 0, Se = g.params; ae < Se.length; ae += 1) {
            var Oe = Se[ae];
            this.checkLValInnerPattern(Oe, 1, $ ? null : se);
          }
        }, _t.parseExprList = function(g, $, se, ae) {
          for (var Se = [], Oe = true; !this.eat(g); ) {
            if (Oe) Oe = false;
            else if (this.expect(J.comma), $ && this.afterTrailingComma(g)) break;
            var De = void 0;
            se && this.type === J.comma ? De = null : this.type === J.ellipsis ? (De = this.parseSpread(ae), ae && this.type === J.comma && ae.trailingComma < 0 && (ae.trailingComma = this.start)) : De = this.parseMaybeAssign(false, ae), Se.push(De);
          }
          return Se;
        }, _t.checkUnreserved = function(g) {
          var $ = g.start, se = g.end, ae = g.name;
          this.inGenerator && ae === "yield" && this.raiseRecoverable($, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && ae === "await" && this.raiseRecoverable($, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && ae === "arguments" && this.raiseRecoverable($, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || ae !== "arguments" && ae !== "await" || this.raise($, "Cannot use " + ae + " in class static initialization block"), this.keywords.test(ae) && this.raise($, "Unexpected keyword '" + ae + "'"), this.options.ecmaVersion < 6 && this.input.slice($, se).indexOf("\\") !== -1 || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(ae) && (this.inAsync || ae !== "await" || this.raiseRecoverable($, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable($, "The keyword '" + ae + "' is reserved"));
        }, _t.parseIdent = function(g) {
          var $ = this.parseIdentNode();
          return this.next(!!g), this.finishNode($, "Identifier"), g || (this.checkUnreserved($), $.name !== "await" || this.awaitIdentPos || (this.awaitIdentPos = $.start)), $;
        }, _t.parseIdentNode = function() {
          var g = this.startNode();
          return this.type === J.name ? g.name = this.value : this.type.keyword ? (g.name = this.type.keyword, g.name !== "class" && g.name !== "function" || this.lastTokEnd === this.lastTokStart + 1 && this.input.charCodeAt(this.lastTokStart) === 46 || this.context.pop(), this.type = J.name) : this.unexpected(), g;
        }, _t.parsePrivateIdent = function() {
          var g = this.startNode();
          return this.type === J.privateId ? g.name = this.value : this.unexpected(), this.next(), this.finishNode(g, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(g.start, "Private field '#" + g.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(g)), g;
        }, _t.parseYield = function(g) {
          this.yieldPos || (this.yieldPos = this.start);
          var $ = this.startNode();
          return this.next(), this.type === J.semi || this.canInsertSemicolon() || this.type !== J.star && !this.type.startsExpr ? ($.delegate = false, $.argument = null) : ($.delegate = this.eat(J.star), $.argument = this.parseMaybeAssign(g)), this.finishNode($, "YieldExpression");
        }, _t.parseAwait = function(g) {
          this.awaitPos || (this.awaitPos = this.start);
          var $ = this.startNode();
          return this.next(), $.argument = this.parseMaybeUnary(null, true, false, g), this.finishNode($, "AwaitExpression");
        };
        var sr = it.prototype;
        sr.raise = function(g, $) {
          var se = be(this.input, g);
          $ += " (" + se.line + ":" + se.column + ")";
          var ae = new SyntaxError($);
          throw ae.pos = g, ae.loc = se, ae.raisedAt = this.pos, ae;
        }, sr.raiseRecoverable = sr.raise, sr.curPosition = function() {
          if (this.options.locations) return new Je(this.curLine, this.pos - this.lineStart);
        };
        var Qn = it.prototype, Br = function(g) {
          this.flags = g, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = false;
        };
        Qn.enterScope = function(g) {
          this.scopeStack.push(new Br(g));
        }, Qn.exitScope = function() {
          this.scopeStack.pop();
        }, Qn.treatFunctionsAsVarInScope = function(g) {
          return 2 & g.flags || !this.inModule && 1 & g.flags;
        }, Qn.declareName = function(g, $, se) {
          var ae = false;
          if ($ === 2) {
            var Se = this.currentScope();
            ae = Se.lexical.indexOf(g) > -1 || Se.functions.indexOf(g) > -1 || Se.var.indexOf(g) > -1, Se.lexical.push(g), this.inModule && 1 & Se.flags && delete this.undefinedExports[g];
          } else if ($ === 4) this.currentScope().lexical.push(g);
          else if ($ === 3) {
            var Oe = this.currentScope();
            ae = this.treatFunctionsAsVar ? Oe.lexical.indexOf(g) > -1 : Oe.lexical.indexOf(g) > -1 || Oe.var.indexOf(g) > -1, Oe.functions.push(g);
          } else for (var De = this.scopeStack.length - 1; De >= 0; --De) {
            var We = this.scopeStack[De];
            if (We.lexical.indexOf(g) > -1 && !(32 & We.flags && We.lexical[0] === g) || !this.treatFunctionsAsVarInScope(We) && We.functions.indexOf(g) > -1) {
              ae = true;
              break;
            }
            if (We.var.push(g), this.inModule && 1 & We.flags && delete this.undefinedExports[g], 259 & We.flags) break;
          }
          ae && this.raiseRecoverable(se, "Identifier '" + g + "' has already been declared");
        }, Qn.checkLocalExport = function(g) {
          this.scopeStack[0].lexical.indexOf(g.name) === -1 && this.scopeStack[0].var.indexOf(g.name) === -1 && (this.undefinedExports[g.name] = g);
        }, Qn.currentScope = function() {
          return this.scopeStack[this.scopeStack.length - 1];
        }, Qn.currentVarScope = function() {
          for (var g = this.scopeStack.length - 1; ; g--) {
            var $ = this.scopeStack[g];
            if (259 & $.flags) return $;
          }
        }, Qn.currentThisScope = function() {
          for (var g = this.scopeStack.length - 1; ; g--) {
            var $ = this.scopeStack[g];
            if (259 & $.flags && !(16 & $.flags)) return $;
          }
        };
        var Tn = function(g, $, se) {
          this.type = "", this.start = $, this.end = 0, g.options.locations && (this.loc = new st(g, se)), g.options.directSourceFile && (this.sourceFile = g.options.directSourceFile), g.options.ranges && (this.range = [$, 0]);
        }, Zn = it.prototype;
        function Gn(g, $, se, ae) {
          return g.type = $, g.end = se, this.options.locations && (g.loc.end = ae), this.options.ranges && (g.range[1] = se), g;
        }
        Zn.startNode = function() {
          return new Tn(this, this.start, this.startLoc);
        }, Zn.startNodeAt = function(g, $) {
          return new Tn(this, g, $);
        }, Zn.finishNode = function(g, $) {
          return Gn.call(this, g, $, this.lastTokEnd, this.lastTokEndLoc);
        }, Zn.finishNodeAt = function(g, $, se, ae) {
          return Gn.call(this, g, $, se, ae);
        }, Zn.copyNode = function(g) {
          var $ = new Tn(this, g.start, this.startLoc);
          for (var se in g) $[se] = g[se];
          return $;
        };
        var gn = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", ur = gn + " Extended_Pictographic", Ir = ur + " EBase EComp EMod EPres ExtPict", zn = { 9: gn, 10: ur, 11: ur, 12: Ir, 13: Ir, 14: Ir }, kr = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji" }, Jr = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Qr = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", wt = Qr + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", $r = wt + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", vr = $r + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", Er = vr + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", Zr = { 9: Qr, 10: wt, 11: $r, 12: vr, 13: Er, 14: Er + " Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz" }, cr = {};
        function er(g) {
          var $ = cr[g] = { binary: Ne(zn[g] + " " + Jr), binaryOfStrings: Ne(kr[g]), nonBinary: { General_Category: Ne(Jr), Script: Ne(Zr[g]) } };
          $.nonBinary.Script_Extensions = $.nonBinary.Script, $.nonBinary.gc = $.nonBinary.General_Category, $.nonBinary.sc = $.nonBinary.Script, $.nonBinary.scx = $.nonBinary.Script_Extensions;
        }
        for (var dt = 0, ft = [9, 10, 11, 12, 13, 14]; dt < ft.length; dt += 1) er(ft[dt]);
        var at = it.prototype, St = function(g, $) {
          this.parent = g, this.base = $ || this;
        };
        St.prototype.separatedFrom = function(g) {
          for (var $ = this; $; $ = $.parent) for (var se = g; se; se = se.parent) if ($.base === se.base && $ !== se) return true;
          return false;
        }, St.prototype.sibling = function() {
          return new St(this.parent, this.base);
        };
        var Ct = function(g) {
          this.parser = g, this.validFlags = "gim" + (g.options.ecmaVersion >= 6 ? "uy" : "") + (g.options.ecmaVersion >= 9 ? "s" : "") + (g.options.ecmaVersion >= 13 ? "d" : "") + (g.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = cr[g.options.ecmaVersion >= 14 ? 14 : g.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchV = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
        };
        function Mt(g) {
          return g === 105 || g === 109 || g === 115;
        }
        function ct(g) {
          return g === 36 || g >= 40 && g <= 43 || g === 46 || g === 63 || g >= 91 && g <= 94 || g >= 123 && g <= 125;
        }
        function Ot(g) {
          return g >= 65 && g <= 90 || g >= 97 && g <= 122;
        }
        Ct.prototype.reset = function(g, $, se) {
          var ae = se.indexOf("v") !== -1, Se = se.indexOf("u") !== -1;
          this.start = 0 | g, this.source = $ + "", this.flags = se, ae && this.parser.options.ecmaVersion >= 15 ? (this.switchU = true, this.switchV = true, this.switchN = true) : (this.switchU = Se && this.parser.options.ecmaVersion >= 6, this.switchV = false, this.switchN = Se && this.parser.options.ecmaVersion >= 9);
        }, Ct.prototype.raise = function(g) {
          this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + g);
        }, Ct.prototype.at = function(g, $) {
          $ === void 0 && ($ = false);
          var se = this.source, ae = se.length;
          if (g >= ae) return -1;
          var Se = se.charCodeAt(g);
          if (!$ && !this.switchU || Se <= 55295 || Se >= 57344 || g + 1 >= ae) return Se;
          var Oe = se.charCodeAt(g + 1);
          return Oe >= 56320 && Oe <= 57343 ? (Se << 10) + Oe - 56613888 : Se;
        }, Ct.prototype.nextIndex = function(g, $) {
          $ === void 0 && ($ = false);
          var se = this.source, ae = se.length;
          if (g >= ae) return ae;
          var Se, Oe = se.charCodeAt(g);
          return !$ && !this.switchU || Oe <= 55295 || Oe >= 57344 || g + 1 >= ae || (Se = se.charCodeAt(g + 1)) < 56320 || Se > 57343 ? g + 1 : g + 2;
        }, Ct.prototype.current = function(g) {
          return g === void 0 && (g = false), this.at(this.pos, g);
        }, Ct.prototype.lookahead = function(g) {
          return g === void 0 && (g = false), this.at(this.nextIndex(this.pos, g), g);
        }, Ct.prototype.advance = function(g) {
          g === void 0 && (g = false), this.pos = this.nextIndex(this.pos, g);
        }, Ct.prototype.eat = function(g, $) {
          return $ === void 0 && ($ = false), this.current($) === g && (this.advance($), true);
        }, Ct.prototype.eatChars = function(g, $) {
          $ === void 0 && ($ = false);
          for (var se = this.pos, ae = 0, Se = g; ae < Se.length; ae += 1) {
            var Oe = Se[ae], De = this.at(se, $);
            if (De === -1 || De !== Oe) return false;
            se = this.nextIndex(se, $);
          }
          return this.pos = se, true;
        }, at.validateRegExpFlags = function(g) {
          for (var $ = g.validFlags, se = g.flags, ae = false, Se = false, Oe = 0; Oe < se.length; Oe++) {
            var De = se.charAt(Oe);
            $.indexOf(De) === -1 && this.raise(g.start, "Invalid regular expression flag"), se.indexOf(De, Oe + 1) > -1 && this.raise(g.start, "Duplicate regular expression flag"), De === "u" && (ae = true), De === "v" && (Se = true);
          }
          this.options.ecmaVersion >= 15 && ae && Se && this.raise(g.start, "Invalid regular expression flag");
        }, at.validateRegExpPattern = function(g) {
          this.regexp_pattern(g), !g.switchN && this.options.ecmaVersion >= 9 && function($) {
            for (var se in $) return true;
            return false;
          }(g.groupNames) && (g.switchN = true, this.regexp_pattern(g));
        }, at.regexp_pattern = function(g) {
          g.pos = 0, g.lastIntValue = 0, g.lastStringValue = "", g.lastAssertionIsQuantifiable = false, g.numCapturingParens = 0, g.maxBackReference = 0, g.groupNames = /* @__PURE__ */ Object.create(null), g.backReferenceNames.length = 0, g.branchID = null, this.regexp_disjunction(g), g.pos !== g.source.length && (g.eat(41) && g.raise("Unmatched ')'"), (g.eat(93) || g.eat(125)) && g.raise("Lone quantifier brackets")), g.maxBackReference > g.numCapturingParens && g.raise("Invalid escape");
          for (var $ = 0, se = g.backReferenceNames; $ < se.length; $ += 1) {
            var ae = se[$];
            g.groupNames[ae] || g.raise("Invalid named capture referenced");
          }
        }, at.regexp_disjunction = function(g) {
          var $ = this.options.ecmaVersion >= 16;
          for ($ && (g.branchID = new St(g.branchID, null)), this.regexp_alternative(g); g.eat(124); ) $ && (g.branchID = g.branchID.sibling()), this.regexp_alternative(g);
          $ && (g.branchID = g.branchID.parent), this.regexp_eatQuantifier(g, true) && g.raise("Nothing to repeat"), g.eat(123) && g.raise("Lone quantifier brackets");
        }, at.regexp_alternative = function(g) {
          for (; g.pos < g.source.length && this.regexp_eatTerm(g); ) ;
        }, at.regexp_eatTerm = function(g) {
          return this.regexp_eatAssertion(g) ? (g.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(g) && g.switchU && g.raise("Invalid quantifier"), true) : !!(g.switchU ? this.regexp_eatAtom(g) : this.regexp_eatExtendedAtom(g)) && (this.regexp_eatQuantifier(g), true);
        }, at.regexp_eatAssertion = function(g) {
          var $ = g.pos;
          if (g.lastAssertionIsQuantifiable = false, g.eat(94) || g.eat(36)) return true;
          if (g.eat(92)) {
            if (g.eat(66) || g.eat(98)) return true;
            g.pos = $;
          }
          if (g.eat(40) && g.eat(63)) {
            var se = false;
            if (this.options.ecmaVersion >= 9 && (se = g.eat(60)), g.eat(61) || g.eat(33)) return this.regexp_disjunction(g), g.eat(41) || g.raise("Unterminated group"), g.lastAssertionIsQuantifiable = !se, true;
          }
          return g.pos = $, false;
        }, at.regexp_eatQuantifier = function(g, $) {
          return $ === void 0 && ($ = false), !!this.regexp_eatQuantifierPrefix(g, $) && (g.eat(63), true);
        }, at.regexp_eatQuantifierPrefix = function(g, $) {
          return g.eat(42) || g.eat(43) || g.eat(63) || this.regexp_eatBracedQuantifier(g, $);
        }, at.regexp_eatBracedQuantifier = function(g, $) {
          var se = g.pos;
          if (g.eat(123)) {
            var ae = 0, Se = -1;
            if (this.regexp_eatDecimalDigits(g) && (ae = g.lastIntValue, g.eat(44) && this.regexp_eatDecimalDigits(g) && (Se = g.lastIntValue), g.eat(125))) return Se !== -1 && Se < ae && !$ && g.raise("numbers out of order in {} quantifier"), true;
            g.switchU && !$ && g.raise("Incomplete quantifier"), g.pos = se;
          }
          return false;
        }, at.regexp_eatAtom = function(g) {
          return this.regexp_eatPatternCharacters(g) || g.eat(46) || this.regexp_eatReverseSolidusAtomEscape(g) || this.regexp_eatCharacterClass(g) || this.regexp_eatUncapturingGroup(g) || this.regexp_eatCapturingGroup(g);
        }, at.regexp_eatReverseSolidusAtomEscape = function(g) {
          var $ = g.pos;
          if (g.eat(92)) {
            if (this.regexp_eatAtomEscape(g)) return true;
            g.pos = $;
          }
          return false;
        }, at.regexp_eatUncapturingGroup = function(g) {
          var $ = g.pos;
          if (g.eat(40)) {
            if (g.eat(63)) {
              if (this.options.ecmaVersion >= 16) {
                var se = this.regexp_eatModifiers(g), ae = g.eat(45);
                if (se || ae) {
                  for (var Se = 0; Se < se.length; Se++) {
                    var Oe = se.charAt(Se);
                    se.indexOf(Oe, Se + 1) > -1 && g.raise("Duplicate regular expression modifiers");
                  }
                  if (ae) {
                    var De = this.regexp_eatModifiers(g);
                    se || De || g.current() !== 58 || g.raise("Invalid regular expression modifiers");
                    for (var We = 0; We < De.length; We++) {
                      var nt = De.charAt(We);
                      (De.indexOf(nt, We + 1) > -1 || se.indexOf(nt) > -1) && g.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
              if (g.eat(58)) {
                if (this.regexp_disjunction(g), g.eat(41)) return true;
                g.raise("Unterminated group");
              }
            }
            g.pos = $;
          }
          return false;
        }, at.regexp_eatCapturingGroup = function(g) {
          if (g.eat(40)) {
            if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(g) : g.current() === 63 && g.raise("Invalid group"), this.regexp_disjunction(g), g.eat(41)) return g.numCapturingParens += 1, true;
            g.raise("Unterminated group");
          }
          return false;
        }, at.regexp_eatModifiers = function(g) {
          for (var $ = "", se = 0; (se = g.current()) !== -1 && Mt(se); ) $ += $e(se), g.advance();
          return $;
        }, at.regexp_eatExtendedAtom = function(g) {
          return g.eat(46) || this.regexp_eatReverseSolidusAtomEscape(g) || this.regexp_eatCharacterClass(g) || this.regexp_eatUncapturingGroup(g) || this.regexp_eatCapturingGroup(g) || this.regexp_eatInvalidBracedQuantifier(g) || this.regexp_eatExtendedPatternCharacter(g);
        }, at.regexp_eatInvalidBracedQuantifier = function(g) {
          return this.regexp_eatBracedQuantifier(g, true) && g.raise("Nothing to repeat"), false;
        }, at.regexp_eatSyntaxCharacter = function(g) {
          var $ = g.current();
          return !!ct($) && (g.lastIntValue = $, g.advance(), true);
        }, at.regexp_eatPatternCharacters = function(g) {
          for (var $ = g.pos, se = 0; (se = g.current()) !== -1 && !ct(se); ) g.advance();
          return g.pos !== $;
        }, at.regexp_eatExtendedPatternCharacter = function(g) {
          var $ = g.current();
          return !($ === -1 || $ === 36 || $ >= 40 && $ <= 43 || $ === 46 || $ === 63 || $ === 91 || $ === 94 || $ === 124) && (g.advance(), true);
        }, at.regexp_groupSpecifier = function(g) {
          if (g.eat(63)) {
            this.regexp_eatGroupName(g) || g.raise("Invalid group");
            var $ = this.options.ecmaVersion >= 16, se = g.groupNames[g.lastStringValue];
            if (se) if ($) for (var ae = 0, Se = se; ae < Se.length; ae += 1) Se[ae].separatedFrom(g.branchID) || g.raise("Duplicate capture group name");
            else g.raise("Duplicate capture group name");
            $ ? (se || (g.groupNames[g.lastStringValue] = [])).push(g.branchID) : g.groupNames[g.lastStringValue] = true;
          }
        }, at.regexp_eatGroupName = function(g) {
          if (g.lastStringValue = "", g.eat(60)) {
            if (this.regexp_eatRegExpIdentifierName(g) && g.eat(62)) return true;
            g.raise("Invalid capture group name");
          }
          return false;
        }, at.regexp_eatRegExpIdentifierName = function(g) {
          if (g.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(g)) {
            for (g.lastStringValue += $e(g.lastIntValue); this.regexp_eatRegExpIdentifierPart(g); ) g.lastStringValue += $e(g.lastIntValue);
            return true;
          }
          return false;
        }, at.regexp_eatRegExpIdentifierStart = function(g) {
          var $ = g.pos, se = this.options.ecmaVersion >= 11, ae = g.current(se);
          return g.advance(se), ae === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(g, se) && (ae = g.lastIntValue), function(Se) {
            return le(Se, true) || Se === 36 || Se === 95;
          }(ae) ? (g.lastIntValue = ae, true) : (g.pos = $, false);
        }, at.regexp_eatRegExpIdentifierPart = function(g) {
          var $ = g.pos, se = this.options.ecmaVersion >= 11, ae = g.current(se);
          return g.advance(se), ae === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(g, se) && (ae = g.lastIntValue), function(Se) {
            return fe(Se, true) || Se === 36 || Se === 95 || Se === 8204 || Se === 8205;
          }(ae) ? (g.lastIntValue = ae, true) : (g.pos = $, false);
        }, at.regexp_eatAtomEscape = function(g) {
          return !!(this.regexp_eatBackReference(g) || this.regexp_eatCharacterClassEscape(g) || this.regexp_eatCharacterEscape(g) || g.switchN && this.regexp_eatKGroupName(g)) || (g.switchU && (g.current() === 99 && g.raise("Invalid unicode escape"), g.raise("Invalid escape")), false);
        }, at.regexp_eatBackReference = function(g) {
          var $ = g.pos;
          if (this.regexp_eatDecimalEscape(g)) {
            var se = g.lastIntValue;
            if (g.switchU) return se > g.maxBackReference && (g.maxBackReference = se), true;
            if (se <= g.numCapturingParens) return true;
            g.pos = $;
          }
          return false;
        }, at.regexp_eatKGroupName = function(g) {
          if (g.eat(107)) {
            if (this.regexp_eatGroupName(g)) return g.backReferenceNames.push(g.lastStringValue), true;
            g.raise("Invalid named reference");
          }
          return false;
        }, at.regexp_eatCharacterEscape = function(g) {
          return this.regexp_eatControlEscape(g) || this.regexp_eatCControlLetter(g) || this.regexp_eatZero(g) || this.regexp_eatHexEscapeSequence(g) || this.regexp_eatRegExpUnicodeEscapeSequence(g, false) || !g.switchU && this.regexp_eatLegacyOctalEscapeSequence(g) || this.regexp_eatIdentityEscape(g);
        }, at.regexp_eatCControlLetter = function(g) {
          var $ = g.pos;
          if (g.eat(99)) {
            if (this.regexp_eatControlLetter(g)) return true;
            g.pos = $;
          }
          return false;
        }, at.regexp_eatZero = function(g) {
          return g.current() === 48 && !on(g.lookahead()) && (g.lastIntValue = 0, g.advance(), true);
        }, at.regexp_eatControlEscape = function(g) {
          var $ = g.current();
          return $ === 116 ? (g.lastIntValue = 9, g.advance(), true) : $ === 110 ? (g.lastIntValue = 10, g.advance(), true) : $ === 118 ? (g.lastIntValue = 11, g.advance(), true) : $ === 102 ? (g.lastIntValue = 12, g.advance(), true) : $ === 114 && (g.lastIntValue = 13, g.advance(), true);
        }, at.regexp_eatControlLetter = function(g) {
          var $ = g.current();
          return !!Ot($) && (g.lastIntValue = $ % 32, g.advance(), true);
        }, at.regexp_eatRegExpUnicodeEscapeSequence = function(g, $) {
          $ === void 0 && ($ = false);
          var se, ae = g.pos, Se = $ || g.switchU;
          if (g.eat(117)) {
            if (this.regexp_eatFixedHexDigits(g, 4)) {
              var Oe = g.lastIntValue;
              if (Se && Oe >= 55296 && Oe <= 56319) {
                var De = g.pos;
                if (g.eat(92) && g.eat(117) && this.regexp_eatFixedHexDigits(g, 4)) {
                  var We = g.lastIntValue;
                  if (We >= 56320 && We <= 57343) return g.lastIntValue = 1024 * (Oe - 55296) + (We - 56320) + 65536, true;
                }
                g.pos = De, g.lastIntValue = Oe;
              }
              return true;
            }
            if (Se && g.eat(123) && this.regexp_eatHexDigits(g) && g.eat(125) && (se = g.lastIntValue) >= 0 && se <= 1114111) return true;
            Se && g.raise("Invalid unicode escape"), g.pos = ae;
          }
          return false;
        }, at.regexp_eatIdentityEscape = function(g) {
          if (g.switchU) return !!this.regexp_eatSyntaxCharacter(g) || !!g.eat(47) && (g.lastIntValue = 47, true);
          var $ = g.current();
          return !($ === 99 || g.switchN && $ === 107) && (g.lastIntValue = $, g.advance(), true);
        }, at.regexp_eatDecimalEscape = function(g) {
          g.lastIntValue = 0;
          var $ = g.current();
          if ($ >= 49 && $ <= 57) {
            do
              g.lastIntValue = 10 * g.lastIntValue + ($ - 48), g.advance();
            while (($ = g.current()) >= 48 && $ <= 57);
            return true;
          }
          return false;
        };
        function zt(g) {
          return Ot(g) || g === 95;
        }
        function Qt(g) {
          return zt(g) || on(g);
        }
        function on(g) {
          return g >= 48 && g <= 57;
        }
        function Zt(g) {
          return g >= 48 && g <= 57 || g >= 65 && g <= 70 || g >= 97 && g <= 102;
        }
        function ln(g) {
          return g >= 65 && g <= 70 ? g - 65 + 10 : g >= 97 && g <= 102 ? g - 97 + 10 : g - 48;
        }
        function Un(g) {
          return g >= 48 && g <= 55;
        }
        at.regexp_eatCharacterClassEscape = function(g) {
          var $ = g.current();
          if (/* @__PURE__ */ function(Se) {
            return Se === 100 || Se === 68 || Se === 115 || Se === 83 || Se === 119 || Se === 87;
          }($)) return g.lastIntValue = -1, g.advance(), 1;
          var se = false;
          if (g.switchU && this.options.ecmaVersion >= 9 && ((se = $ === 80) || $ === 112)) {
            var ae;
            if (g.lastIntValue = -1, g.advance(), g.eat(123) && (ae = this.regexp_eatUnicodePropertyValueExpression(g)) && g.eat(125)) return se && ae === 2 && g.raise("Invalid property name"), ae;
            g.raise("Invalid property name");
          }
          return 0;
        }, at.regexp_eatUnicodePropertyValueExpression = function(g) {
          var $ = g.pos;
          if (this.regexp_eatUnicodePropertyName(g) && g.eat(61)) {
            var se = g.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(g)) {
              var ae = g.lastStringValue;
              return this.regexp_validateUnicodePropertyNameAndValue(g, se, ae), 1;
            }
          }
          if (g.pos = $, this.regexp_eatLoneUnicodePropertyNameOrValue(g)) {
            var Se = g.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(g, Se);
          }
          return 0;
        }, at.regexp_validateUnicodePropertyNameAndValue = function(g, $, se) {
          he(g.unicodeProperties.nonBinary, $) || g.raise("Invalid property name"), g.unicodeProperties.nonBinary[$].test(se) || g.raise("Invalid property value");
        }, at.regexp_validateUnicodePropertyNameOrValue = function(g, $) {
          return g.unicodeProperties.binary.test($) ? 1 : g.switchV && g.unicodeProperties.binaryOfStrings.test($) ? 2 : void g.raise("Invalid property name");
        }, at.regexp_eatUnicodePropertyName = function(g) {
          var $ = 0;
          for (g.lastStringValue = ""; zt($ = g.current()); ) g.lastStringValue += $e($), g.advance();
          return g.lastStringValue !== "";
        }, at.regexp_eatUnicodePropertyValue = function(g) {
          var $ = 0;
          for (g.lastStringValue = ""; Qt($ = g.current()); ) g.lastStringValue += $e($), g.advance();
          return g.lastStringValue !== "";
        }, at.regexp_eatLoneUnicodePropertyNameOrValue = function(g) {
          return this.regexp_eatUnicodePropertyValue(g);
        }, at.regexp_eatCharacterClass = function(g) {
          if (g.eat(91)) {
            var $ = g.eat(94), se = this.regexp_classContents(g);
            return g.eat(93) || g.raise("Unterminated character class"), $ && se === 2 && g.raise("Negated character class may contain strings"), true;
          }
          return false;
        }, at.regexp_classContents = function(g) {
          return g.current() === 93 ? 1 : g.switchV ? this.regexp_classSetExpression(g) : (this.regexp_nonEmptyClassRanges(g), 1);
        }, at.regexp_nonEmptyClassRanges = function(g) {
          for (; this.regexp_eatClassAtom(g); ) {
            var $ = g.lastIntValue;
            if (g.eat(45) && this.regexp_eatClassAtom(g)) {
              var se = g.lastIntValue;
              !g.switchU || $ !== -1 && se !== -1 || g.raise("Invalid character class"), $ !== -1 && se !== -1 && $ > se && g.raise("Range out of order in character class");
            }
          }
        }, at.regexp_eatClassAtom = function(g) {
          var $ = g.pos;
          if (g.eat(92)) {
            if (this.regexp_eatClassEscape(g)) return true;
            if (g.switchU) {
              var se = g.current();
              (se === 99 || Un(se)) && g.raise("Invalid class escape"), g.raise("Invalid escape");
            }
            g.pos = $;
          }
          var ae = g.current();
          return ae !== 93 && (g.lastIntValue = ae, g.advance(), true);
        }, at.regexp_eatClassEscape = function(g) {
          var $ = g.pos;
          if (g.eat(98)) return g.lastIntValue = 8, true;
          if (g.switchU && g.eat(45)) return g.lastIntValue = 45, true;
          if (!g.switchU && g.eat(99)) {
            if (this.regexp_eatClassControlLetter(g)) return true;
            g.pos = $;
          }
          return this.regexp_eatCharacterClassEscape(g) || this.regexp_eatCharacterEscape(g);
        }, at.regexp_classSetExpression = function(g) {
          var $, se = 1;
          if (!this.regexp_eatClassSetRange(g)) if ($ = this.regexp_eatClassSetOperand(g)) {
            $ === 2 && (se = 2);
            for (var ae = g.pos; g.eatChars([38, 38]); ) g.current() !== 38 && ($ = this.regexp_eatClassSetOperand(g)) ? $ !== 2 && (se = 1) : g.raise("Invalid character in character class");
            if (ae !== g.pos) return se;
            for (; g.eatChars([45, 45]); ) this.regexp_eatClassSetOperand(g) || g.raise("Invalid character in character class");
            if (ae !== g.pos) return se;
          } else g.raise("Invalid character in character class");
          for (; ; ) if (!this.regexp_eatClassSetRange(g)) {
            if (!($ = this.regexp_eatClassSetOperand(g))) return se;
            $ === 2 && (se = 2);
          }
        }, at.regexp_eatClassSetRange = function(g) {
          var $ = g.pos;
          if (this.regexp_eatClassSetCharacter(g)) {
            var se = g.lastIntValue;
            if (g.eat(45) && this.regexp_eatClassSetCharacter(g)) {
              var ae = g.lastIntValue;
              return se !== -1 && ae !== -1 && se > ae && g.raise("Range out of order in character class"), true;
            }
            g.pos = $;
          }
          return false;
        }, at.regexp_eatClassSetOperand = function(g) {
          return this.regexp_eatClassSetCharacter(g) ? 1 : this.regexp_eatClassStringDisjunction(g) || this.regexp_eatNestedClass(g);
        }, at.regexp_eatNestedClass = function(g) {
          var $ = g.pos;
          if (g.eat(91)) {
            var se = g.eat(94), ae = this.regexp_classContents(g);
            if (g.eat(93)) return se && ae === 2 && g.raise("Negated character class may contain strings"), ae;
            g.pos = $;
          }
          if (g.eat(92)) {
            var Se = this.regexp_eatCharacterClassEscape(g);
            if (Se) return Se;
            g.pos = $;
          }
          return null;
        }, at.regexp_eatClassStringDisjunction = function(g) {
          var $ = g.pos;
          if (g.eatChars([92, 113])) {
            if (g.eat(123)) {
              var se = this.regexp_classStringDisjunctionContents(g);
              if (g.eat(125)) return se;
            } else g.raise("Invalid escape");
            g.pos = $;
          }
          return null;
        }, at.regexp_classStringDisjunctionContents = function(g) {
          for (var $ = this.regexp_classString(g); g.eat(124); ) this.regexp_classString(g) === 2 && ($ = 2);
          return $;
        }, at.regexp_classString = function(g) {
          for (var $ = 0; this.regexp_eatClassSetCharacter(g); ) $++;
          return $ === 1 ? 1 : 2;
        }, at.regexp_eatClassSetCharacter = function(g) {
          var $ = g.pos;
          if (g.eat(92)) return !(!this.regexp_eatCharacterEscape(g) && !this.regexp_eatClassSetReservedPunctuator(g)) || (g.eat(98) ? (g.lastIntValue = 8, true) : (g.pos = $, false));
          var se = g.current();
          return !(se < 0 || se === g.lookahead() && function(ae) {
            return ae === 33 || ae >= 35 && ae <= 38 || ae >= 42 && ae <= 44 || ae === 46 || ae >= 58 && ae <= 64 || ae === 94 || ae === 96 || ae === 126;
          }(se)) && !function(ae) {
            return ae === 40 || ae === 41 || ae === 45 || ae === 47 || ae >= 91 && ae <= 93 || ae >= 123 && ae <= 125;
          }(se) && (g.advance(), g.lastIntValue = se, true);
        }, at.regexp_eatClassSetReservedPunctuator = function(g) {
          var $ = g.current();
          return !!function(se) {
            return se === 33 || se === 35 || se === 37 || se === 38 || se === 44 || se === 45 || se >= 58 && se <= 62 || se === 64 || se === 96 || se === 126;
          }($) && (g.lastIntValue = $, g.advance(), true);
        }, at.regexp_eatClassControlLetter = function(g) {
          var $ = g.current();
          return !(!on($) && $ !== 95) && (g.lastIntValue = $ % 32, g.advance(), true);
        }, at.regexp_eatHexEscapeSequence = function(g) {
          var $ = g.pos;
          if (g.eat(120)) {
            if (this.regexp_eatFixedHexDigits(g, 2)) return true;
            g.switchU && g.raise("Invalid escape"), g.pos = $;
          }
          return false;
        }, at.regexp_eatDecimalDigits = function(g) {
          var $ = g.pos, se = 0;
          for (g.lastIntValue = 0; on(se = g.current()); ) g.lastIntValue = 10 * g.lastIntValue + (se - 48), g.advance();
          return g.pos !== $;
        }, at.regexp_eatHexDigits = function(g) {
          var $ = g.pos, se = 0;
          for (g.lastIntValue = 0; Zt(se = g.current()); ) g.lastIntValue = 16 * g.lastIntValue + ln(se), g.advance();
          return g.pos !== $;
        }, at.regexp_eatLegacyOctalEscapeSequence = function(g) {
          if (this.regexp_eatOctalDigit(g)) {
            var $ = g.lastIntValue;
            if (this.regexp_eatOctalDigit(g)) {
              var se = g.lastIntValue;
              $ <= 3 && this.regexp_eatOctalDigit(g) ? g.lastIntValue = 64 * $ + 8 * se + g.lastIntValue : g.lastIntValue = 8 * $ + se;
            } else g.lastIntValue = $;
            return true;
          }
          return false;
        }, at.regexp_eatOctalDigit = function(g) {
          var $ = g.current();
          return Un($) ? (g.lastIntValue = $ - 48, g.advance(), true) : (g.lastIntValue = 0, false);
        }, at.regexp_eatFixedHexDigits = function(g, $) {
          var se = g.pos;
          g.lastIntValue = 0;
          for (var ae = 0; ae < $; ++ae) {
            var Se = g.current();
            if (!Zt(Se)) return g.pos = se, false;
            g.lastIntValue = 16 * g.lastIntValue + ln(Se), g.advance();
          }
          return true;
        };
        var Bn = function(g) {
          this.type = g.type, this.value = g.value, this.start = g.start, this.end = g.end, g.options.locations && (this.loc = new st(g, g.startLoc, g.endLoc)), g.options.ranges && (this.range = [g.start, g.end]);
        }, Bt = it.prototype;
        function Vn(g) {
          return typeof BigInt != "function" ? null : BigInt(g.replace(/_/g, ""));
        }
        Bt.next = function(g) {
          !g && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Bn(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
        }, Bt.getToken = function() {
          return this.next(), new Bn(this);
        }, typeof Symbol < "u" && (Bt[Symbol.iterator] = function() {
          var g = this;
          return { next: function() {
            var $ = g.getToken();
            return { done: $.type === J.eof, value: $ };
          } };
        }), Bt.nextToken = function() {
          var g = this.curContext();
          return g && g.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(J.eof) : g.override ? g.override(this) : void this.readToken(this.fullCharCodeAtPos());
        }, Bt.readToken = function(g) {
          return le(g, this.options.ecmaVersion >= 6) || g === 92 ? this.readWord() : this.getTokenFromCode(g);
        }, Bt.fullCharCodeAtPos = function() {
          var g = this.input.charCodeAt(this.pos);
          if (g <= 55295 || g >= 56320) return g;
          var $ = this.input.charCodeAt(this.pos + 1);
          return $ <= 56319 || $ >= 57344 ? g : (g << 10) + $ - 56613888;
        }, Bt.skipBlockComment = function() {
          var g = this.options.onComment && this.curPosition(), $ = this.pos, se = this.input.indexOf("*/", this.pos += 2);
          if (se === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = se + 2, this.options.locations) for (var ae = void 0, Se = $; (ae = qe(this.input, Se, this.pos)) > -1; ) ++this.curLine, Se = this.lineStart = ae;
          this.options.onComment && this.options.onComment(true, this.input.slice($ + 2, se), $, this.pos, g, this.curPosition());
        }, Bt.skipLineComment = function(g) {
          for (var $ = this.pos, se = this.options.onComment && this.curPosition(), ae = this.input.charCodeAt(this.pos += g); this.pos < this.input.length && !Ue(ae); ) ae = this.input.charCodeAt(++this.pos);
          this.options.onComment && this.options.onComment(false, this.input.slice($ + g, this.pos), $, this.pos, se, this.curPosition());
        }, Bt.skipSpace = function() {
          e: for (; this.pos < this.input.length; ) {
            var g = this.input.charCodeAt(this.pos);
            switch (g) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
              case 10:
              case 8232:
              case 8233:
                ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break e;
                }
                break;
              default:
                if (!(g > 8 && g < 14 || g >= 5760 && He.test(String.fromCharCode(g)))) break e;
                ++this.pos;
            }
          }
        }, Bt.finishToken = function(g, $) {
          this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
          var se = this.type;
          this.type = g, this.value = $, this.updateContext(se);
        }, Bt.readToken_dot = function() {
          var g = this.input.charCodeAt(this.pos + 1);
          if (g >= 48 && g <= 57) return this.readNumber(true);
          var $ = this.input.charCodeAt(this.pos + 2);
          return this.options.ecmaVersion >= 6 && g === 46 && $ === 46 ? (this.pos += 3, this.finishToken(J.ellipsis)) : (++this.pos, this.finishToken(J.dot));
        }, Bt.readToken_slash = function() {
          var g = this.input.charCodeAt(this.pos + 1);
          return this.exprAllowed ? (++this.pos, this.readRegexp()) : g === 61 ? this.finishOp(J.assign, 2) : this.finishOp(J.slash, 1);
        }, Bt.readToken_mult_modulo_exp = function(g) {
          var $ = this.input.charCodeAt(this.pos + 1), se = 1, ae = g === 42 ? J.star : J.modulo;
          return this.options.ecmaVersion >= 7 && g === 42 && $ === 42 && (++se, ae = J.starstar, $ = this.input.charCodeAt(this.pos + 2)), $ === 61 ? this.finishOp(J.assign, se + 1) : this.finishOp(ae, se);
        }, Bt.readToken_pipe_amp = function(g) {
          var $ = this.input.charCodeAt(this.pos + 1);
          return $ === g ? this.options.ecmaVersion >= 12 && this.input.charCodeAt(this.pos + 2) === 61 ? this.finishOp(J.assign, 3) : this.finishOp(g === 124 ? J.logicalOR : J.logicalAND, 2) : $ === 61 ? this.finishOp(J.assign, 2) : this.finishOp(g === 124 ? J.bitwiseOR : J.bitwiseAND, 1);
        }, Bt.readToken_caret = function() {
          return this.input.charCodeAt(this.pos + 1) === 61 ? this.finishOp(J.assign, 2) : this.finishOp(J.bitwiseXOR, 1);
        }, Bt.readToken_plus_min = function(g) {
          var $ = this.input.charCodeAt(this.pos + 1);
          return $ === g ? $ !== 45 || this.inModule || this.input.charCodeAt(this.pos + 2) !== 62 || this.lastTokEnd !== 0 && !Ee.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(J.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : $ === 61 ? this.finishOp(J.assign, 2) : this.finishOp(J.plusMin, 1);
        }, Bt.readToken_lt_gt = function(g) {
          var $ = this.input.charCodeAt(this.pos + 1), se = 1;
          return $ === g ? (se = g === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + se) === 61 ? this.finishOp(J.assign, se + 1) : this.finishOp(J.bitShift, se)) : $ !== 33 || g !== 60 || this.inModule || this.input.charCodeAt(this.pos + 2) !== 45 || this.input.charCodeAt(this.pos + 3) !== 45 ? ($ === 61 && (se = 2), this.finishOp(J.relational, se)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
        }, Bt.readToken_eq_excl = function(g) {
          var $ = this.input.charCodeAt(this.pos + 1);
          return $ === 61 ? this.finishOp(J.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : g === 61 && $ === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(J.arrow)) : this.finishOp(g === 61 ? J.eq : J.prefix, 1);
        }, Bt.readToken_question = function() {
          var g = this.options.ecmaVersion;
          if (g >= 11) {
            var $ = this.input.charCodeAt(this.pos + 1);
            if ($ === 46) {
              var se = this.input.charCodeAt(this.pos + 2);
              if (se < 48 || se > 57) return this.finishOp(J.questionDot, 2);
            }
            if ($ === 63) return g >= 12 && this.input.charCodeAt(this.pos + 2) === 61 ? this.finishOp(J.assign, 3) : this.finishOp(J.coalesce, 2);
          }
          return this.finishOp(J.question, 1);
        }, Bt.readToken_numberSign = function() {
          var g = 35;
          if (this.options.ecmaVersion >= 13 && (++this.pos, le(g = this.fullCharCodeAtPos(), true) || g === 92)) return this.finishToken(J.privateId, this.readWord1());
          this.raise(this.pos, "Unexpected character '" + $e(g) + "'");
        }, Bt.getTokenFromCode = function(g) {
          switch (g) {
            case 46:
              return this.readToken_dot();
            case 40:
              return ++this.pos, this.finishToken(J.parenL);
            case 41:
              return ++this.pos, this.finishToken(J.parenR);
            case 59:
              return ++this.pos, this.finishToken(J.semi);
            case 44:
              return ++this.pos, this.finishToken(J.comma);
            case 91:
              return ++this.pos, this.finishToken(J.bracketL);
            case 93:
              return ++this.pos, this.finishToken(J.bracketR);
            case 123:
              return ++this.pos, this.finishToken(J.braceL);
            case 125:
              return ++this.pos, this.finishToken(J.braceR);
            case 58:
              return ++this.pos, this.finishToken(J.colon);
            case 96:
              if (this.options.ecmaVersion < 6) break;
              return ++this.pos, this.finishToken(J.backQuote);
            case 48:
              var $ = this.input.charCodeAt(this.pos + 1);
              if ($ === 120 || $ === 88) return this.readRadixNumber(16);
              if (this.options.ecmaVersion >= 6) {
                if ($ === 111 || $ === 79) return this.readRadixNumber(8);
                if ($ === 98 || $ === 66) return this.readRadixNumber(2);
              }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return this.readNumber(false);
            case 34:
            case 39:
              return this.readString(g);
            case 47:
              return this.readToken_slash();
            case 37:
            case 42:
              return this.readToken_mult_modulo_exp(g);
            case 124:
            case 38:
              return this.readToken_pipe_amp(g);
            case 94:
              return this.readToken_caret();
            case 43:
            case 45:
              return this.readToken_plus_min(g);
            case 60:
            case 62:
              return this.readToken_lt_gt(g);
            case 61:
            case 33:
              return this.readToken_eq_excl(g);
            case 63:
              return this.readToken_question();
            case 126:
              return this.finishOp(J.prefix, 1);
            case 35:
              return this.readToken_numberSign();
          }
          this.raise(this.pos, "Unexpected character '" + $e(g) + "'");
        }, Bt.finishOp = function(g, $) {
          var se = this.input.slice(this.pos, this.pos + $);
          return this.pos += $, this.finishToken(g, se);
        }, Bt.readRegexp = function() {
          for (var g, $, se = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(se, "Unterminated regular expression");
            var ae = this.input.charAt(this.pos);
            if (Ee.test(ae) && this.raise(se, "Unterminated regular expression"), g) g = false;
            else {
              if (ae === "[") $ = true;
              else if (ae === "]" && $) $ = false;
              else if (ae === "/" && !$) break;
              g = ae === "\\";
            }
            ++this.pos;
          }
          var Se = this.input.slice(se, this.pos);
          ++this.pos;
          var Oe = this.pos, De = this.readWord1();
          this.containsEsc && this.unexpected(Oe);
          var We = this.regexpState || (this.regexpState = new Ct(this));
          We.reset(se, Se, De), this.validateRegExpFlags(We), this.validateRegExpPattern(We);
          var nt = null;
          try {
            nt = new RegExp(Se, De);
          } catch {
          }
          return this.finishToken(J.regexp, { pattern: Se, flags: De, value: nt });
        }, Bt.readInt = function(g, $, se) {
          for (var ae = this.options.ecmaVersion >= 12 && $ === void 0, Se = se && this.input.charCodeAt(this.pos) === 48, Oe = this.pos, De = 0, We = 0, nt = 0, ht = $ ?? 1 / 0; nt < ht; ++nt, ++this.pos) {
            var Ze = this.input.charCodeAt(this.pos), Pt = void 0;
            if (ae && Ze === 95) Se && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), We === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), nt === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), We = Ze;
            else {
              if ((Pt = Ze >= 97 ? Ze - 97 + 10 : Ze >= 65 ? Ze - 65 + 10 : Ze >= 48 && Ze <= 57 ? Ze - 48 : 1 / 0) >= g) break;
              We = Ze, De = De * g + Pt;
            }
          }
          return ae && We === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === Oe || $ != null && this.pos - Oe !== $ ? null : De;
        }, Bt.readRadixNumber = function(g) {
          var $ = this.pos;
          this.pos += 2;
          var se = this.readInt(g);
          return se == null && this.raise(this.start + 2, "Expected number in radix " + g), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (se = Vn(this.input.slice($, this.pos)), ++this.pos) : le(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(J.num, se);
        }, Bt.readNumber = function(g) {
          var $ = this.pos;
          g || this.readInt(10, void 0, true) !== null || this.raise($, "Invalid number");
          var se = this.pos - $ >= 2 && this.input.charCodeAt($) === 48;
          se && this.strict && this.raise($, "Invalid number");
          var ae = this.input.charCodeAt(this.pos);
          if (!se && !g && this.options.ecmaVersion >= 11 && ae === 110) {
            var Se = Vn(this.input.slice($, this.pos));
            return ++this.pos, le(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(J.num, Se);
          }
          se && /[89]/.test(this.input.slice($, this.pos)) && (se = false), ae !== 46 || se || (++this.pos, this.readInt(10), ae = this.input.charCodeAt(this.pos)), ae !== 69 && ae !== 101 || se || ((ae = this.input.charCodeAt(++this.pos)) !== 43 && ae !== 45 || ++this.pos, this.readInt(10) === null && this.raise($, "Invalid number")), le(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
          var Oe, De = (Oe = this.input.slice($, this.pos), se ? parseInt(Oe, 8) : parseFloat(Oe.replace(/_/g, "")));
          return this.finishToken(J.num, De);
        }, Bt.readCodePoint = function() {
          var g;
          if (this.input.charCodeAt(this.pos) === 123) {
            this.options.ecmaVersion < 6 && this.unexpected();
            var $ = ++this.pos;
            g = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, g > 1114111 && this.invalidStringToken($, "Code point out of bounds");
          } else g = this.readHexChar(4);
          return g;
        }, Bt.readString = function(g) {
          for (var $ = "", se = ++this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            var ae = this.input.charCodeAt(this.pos);
            if (ae === g) break;
            ae === 92 ? ($ += this.input.slice(se, this.pos), $ += this.readEscapedChar(false), se = this.pos) : ae === 8232 || ae === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (Ue(ae) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
          }
          return $ += this.input.slice(se, this.pos++), this.finishToken(J.string, $);
        };
        var pr = {};
        Bt.tryReadTemplateToken = function() {
          this.inTemplateElement = true;
          try {
            this.readTmplToken();
          } catch (g) {
            if (g !== pr) throw g;
            this.readInvalidTemplateToken();
          }
          this.inTemplateElement = false;
        }, Bt.invalidStringToken = function(g, $) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw pr;
          this.raise(g, $);
        }, Bt.readTmplToken = function() {
          for (var g = "", $ = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
            var se = this.input.charCodeAt(this.pos);
            if (se === 96 || se === 36 && this.input.charCodeAt(this.pos + 1) === 123) return this.pos !== this.start || this.type !== J.template && this.type !== J.invalidTemplate ? (g += this.input.slice($, this.pos), this.finishToken(J.template, g)) : se === 36 ? (this.pos += 2, this.finishToken(J.dollarBraceL)) : (++this.pos, this.finishToken(J.backQuote));
            if (se === 92) g += this.input.slice($, this.pos), g += this.readEscapedChar(true), $ = this.pos;
            else if (Ue(se)) {
              switch (g += this.input.slice($, this.pos), ++this.pos, se) {
                case 13:
                  this.input.charCodeAt(this.pos) === 10 && ++this.pos;
                case 10:
                  g += `
`;
                  break;
                default:
                  g += String.fromCharCode(se);
              }
              this.options.locations && (++this.curLine, this.lineStart = this.pos), $ = this.pos;
            } else ++this.pos;
          }
        }, Bt.readInvalidTemplateToken = function() {
          for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") break;
            case "`":
              return this.finishToken(J.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              this.input[this.pos + 1] === `
` && ++this.pos;
            case `
`:
            case "\u2028":
            case "\u2029":
              ++this.curLine, this.lineStart = this.pos + 1;
          }
          this.raise(this.start, "Unterminated template");
        }, Bt.readEscapedChar = function(g) {
          var $ = this.input.charCodeAt(++this.pos);
          switch (++this.pos, $) {
            case 110:
              return `
`;
            case 114:
              return "\r";
            case 120:
              return String.fromCharCode(this.readHexChar(2));
            case 117:
              return $e(this.readCodePoint());
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              this.input.charCodeAt(this.pos) === 10 && ++this.pos;
            case 10:
              return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
            case 56:
            case 57:
              if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), g) {
                var se = this.pos - 1;
                this.invalidStringToken(se, "Invalid escape sequence in template string");
              }
            default:
              if ($ >= 48 && $ <= 55) {
                var ae = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], Se = parseInt(ae, 8);
                return Se > 255 && (ae = ae.slice(0, -1), Se = parseInt(ae, 8)), this.pos += ae.length - 1, $ = this.input.charCodeAt(this.pos), ae === "0" && $ !== 56 && $ !== 57 || !this.strict && !g || this.invalidStringToken(this.pos - 1 - ae.length, g ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(Se);
              }
              return Ue($) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode($);
          }
        }, Bt.readHexChar = function(g) {
          var $ = this.pos, se = this.readInt(16, g);
          return se === null && this.invalidStringToken($, "Bad character escape sequence"), se;
        }, Bt.readWord1 = function() {
          this.containsEsc = false;
          for (var g = "", $ = true, se = this.pos, ae = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
            var Se = this.fullCharCodeAtPos();
            if (fe(Se, ae)) this.pos += Se <= 65535 ? 1 : 2;
            else {
              if (Se !== 92) break;
              this.containsEsc = true, g += this.input.slice(se, this.pos);
              var Oe = this.pos;
              this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
              var De = this.readCodePoint();
              ($ ? le : fe)(De, ae) || this.invalidStringToken(Oe, "Invalid Unicode escape"), g += $e(De), se = this.pos;
            }
            $ = false;
          }
          return g + this.input.slice(se, this.pos);
        }, Bt.readWord = function() {
          var g = this.readWord1(), $ = J.name;
          return this.keywords.test(g) && ($ = ye[g]), this.finishToken($, g);
        }, it.acorn = { Parser: it, version: "8.14.0", defaultOptions: ke, Position: Je, SourceLocation: st, getLineInfo: be, Node: Tn, TokenType: Pe, tokTypes: J, keywordTypes: ye, TokContext: Jt, tokContexts: Ft, isIdentifierChar: fe, isIdentifierStart: le, Token: Bn, isNewLine: Ue, lineBreak: Ee, lineBreakG: Me, nonASCIIwhitespace: He };
        const es = gt, Or = gt, Rs = /^\.?\//;
        function js(g = "", $) {
          return g.endsWith("/") ? g : g + "/";
        }
        function os(g) {
          return g && g !== "/";
        }
        function Wi(g, ...$) {
          let se = g || "";
          for (const ae of $.filter((Se) => os(Se))) if (se) {
            const Se = ae.replace(Rs, "");
            se = js(se) + Se;
          } else se = ae;
          return se;
        }
        const Dt = gt, Ur = gt, dr = gt, Ls = gt, de = gt, i = gt, v = new Set(es.builtinModules);
        function O(g) {
          return g.replace(/\\/g, "/");
        }
        const V = {}.hasOwnProperty, ne = /^([A-Z][a-z\d]*)+$/, ce = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), ve = {};
        function Ce(g, $ = "and") {
          return g.length < 3 ? g.join(` ${$} `) : `${g.slice(0, -1).join(", ")}, ${$} ${g[g.length - 1]}`;
        }
        const Le = /* @__PURE__ */ new Map();
        let Ke;
        function ut(g, $, se) {
          return Le.set(g, $), /* @__PURE__ */ function(ae, Se) {
            return Oe;
            function Oe(...De) {
              const We = Error.stackTraceLimit;
              At() && (Error.stackTraceLimit = 0);
              const nt = new ae();
              At() && (Error.stackTraceLimit = We);
              const ht = function(Ze, Pt, jt) {
                const rn = Le.get(Ze);
                if (Ur(rn !== void 0, "expected `message` to be found"), typeof rn == "function") return Ur(rn.length <= Pt.length, `Code: ${Ze}; The provided arguments length (${Pt.length}) does not match the required ones (${rn.length}).`), Reflect.apply(rn, jt, Pt);
                const vn = /%[dfijoOs]/g;
                let $n = 0;
                for (; vn.exec(rn) !== null; ) $n++;
                return Ur($n === Pt.length, `Code: ${Ze}; The provided arguments length (${Pt.length}) does not match the required ones (${$n}).`), Pt.length === 0 ? rn : (Pt.unshift(rn), Reflect.apply(i.format, null, Pt));
              }(Se, De, nt);
              return Object.defineProperties(nt, { message: { value: ht, enumerable: false, writable: true, configurable: true }, toString: { value() {
                return `${this.name} [${Se}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true } }), bt(nt), nt.code = Se, nt;
            }
          }(se, g);
        }
        function At() {
          try {
            if (de.startupSnapshot.isBuildingSnapshot()) return false;
          } catch {
          }
          const g = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return g === void 0 ? Object.isExtensible(Error) : V.call(g, "writable") && g.writable !== void 0 ? g.writable : g.set !== void 0;
        }
        ve.ERR_INVALID_ARG_TYPE = ut("ERR_INVALID_ARG_TYPE", (g, $, se) => {
          Ur(typeof g == "string", "'name' must be a string"), Array.isArray($) || ($ = [$]);
          let ae = "The ";
          if (g.endsWith(" argument")) ae += `${g} `;
          else {
            const We = g.includes(".") ? "property" : "argument";
            ae += `"${g}" ${We} `;
          }
          ae += "must be ";
          const Se = [], Oe = [], De = [];
          for (const We of $) Ur(typeof We == "string", "All expected entries have to be of type string"), ce.has(We) ? Se.push(We.toLowerCase()) : ne.exec(We) === null ? (Ur(We !== "object", 'The value "object" should be written as "Object"'), De.push(We)) : Oe.push(We);
          if (Oe.length > 0) {
            const We = Se.indexOf("object");
            We !== -1 && (Se.slice(We, 1), Oe.push("Object"));
          }
          return Se.length > 0 && (ae += `${Se.length > 1 ? "one of type" : "of type"} ${Ce(Se, "or")}`, (Oe.length > 0 || De.length > 0) && (ae += " or ")), Oe.length > 0 && (ae += `an instance of ${Ce(Oe, "or")}`, De.length > 0 && (ae += " or ")), De.length > 0 && (De.length > 1 ? ae += `one of ${Ce(De, "or")}` : (De[0].toLowerCase() !== De[0] && (ae += "an "), ae += `${De[0]}`)), ae += `. Received ${function(We) {
            if (We == null) return String(We);
            if (typeof We == "function" && We.name) return `function ${We.name}`;
            if (typeof We == "object") return We.constructor && We.constructor.name ? `an instance of ${We.constructor.name}` : `${(0, i.inspect)(We, { depth: -1 })}`;
            let nt = (0, i.inspect)(We, { colors: false });
            return nt.length > 28 && (nt = `${nt.slice(0, 25)}...`), `type ${typeof We} (${nt})`;
          }(se)}`, ae;
        }, TypeError), ve.ERR_INVALID_MODULE_SPECIFIER = ut("ERR_INVALID_MODULE_SPECIFIER", (g, $, se = void 0) => `Invalid module "${g}" ${$}${se ? ` imported from ${se}` : ""}`, TypeError), ve.ERR_INVALID_PACKAGE_CONFIG = ut("ERR_INVALID_PACKAGE_CONFIG", (g, $, se) => `Invalid package config ${g}${$ ? ` while importing ${$}` : ""}${se ? `. ${se}` : ""}`, Error), ve.ERR_INVALID_PACKAGE_TARGET = ut("ERR_INVALID_PACKAGE_TARGET", (g, $, se, ae = false, Se = void 0) => {
          const Oe = typeof se == "string" && !ae && se.length > 0 && !se.startsWith("./");
          return $ === "." ? (Ur(ae === false), `Invalid "exports" main target ${JSON.stringify(se)} defined in the package config ${g}package.json${Se ? ` imported from ${Se}` : ""}${Oe ? '; targets must start with "./"' : ""}`) : `Invalid "${ae ? "imports" : "exports"}" target ${JSON.stringify(se)} defined for '${$}' in the package config ${g}package.json${Se ? ` imported from ${Se}` : ""}${Oe ? '; targets must start with "./"' : ""}`;
        }, Error), ve.ERR_MODULE_NOT_FOUND = ut("ERR_MODULE_NOT_FOUND", (g, $, se = false) => `Cannot find ${se ? "module" : "package"} '${g}' imported from ${$}`, Error), ve.ERR_NETWORK_IMPORT_DISALLOWED = ut("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), ve.ERR_PACKAGE_IMPORT_NOT_DEFINED = ut("ERR_PACKAGE_IMPORT_NOT_DEFINED", (g, $, se) => `Package import specifier "${g}" is not defined${$ ? ` in package ${$}package.json` : ""} imported from ${se}`, TypeError), ve.ERR_PACKAGE_PATH_NOT_EXPORTED = ut("ERR_PACKAGE_PATH_NOT_EXPORTED", (g, $, se = void 0) => $ === "." ? `No "exports" main defined in ${g}package.json${se ? ` imported from ${se}` : ""}` : `Package subpath '${$}' is not defined by "exports" in ${g}package.json${se ? ` imported from ${se}` : ""}`, Error), ve.ERR_UNSUPPORTED_DIR_IMPORT = ut("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), ve.ERR_UNSUPPORTED_RESOLVE_REQUEST = ut("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError), ve.ERR_UNKNOWN_FILE_EXTENSION = ut("ERR_UNKNOWN_FILE_EXTENSION", (g, $) => `Unknown file extension "${g}" for ${$}`, TypeError), ve.ERR_INVALID_ARG_VALUE = ut("ERR_INVALID_ARG_VALUE", (g, $, se = "is invalid") => {
          let ae = (0, i.inspect)($);
          return ae.length > 128 && (ae = `${ae.slice(0, 128)}...`), `The ${g.includes(".") ? "property" : "argument"} '${g}' ${se}. Received ${ae}`;
        }, TypeError);
        const bt = function(g) {
          const $ = "__node_internal_" + g.name;
          return Object.defineProperty(g, "name", { value: $ }), g;
        }(function(g) {
          const $ = At();
          return $ && (Ke = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(g), $ && (Error.stackTraceLimit = Ke), g;
        }), Nt = {}.hasOwnProperty, { ERR_INVALID_PACKAGE_CONFIG: dn } = ve, kn = /* @__PURE__ */ new Map();
        function en(g, { base: $, specifier: se }) {
          const ae = kn.get(g);
          if (ae) return ae;
          let Se;
          try {
            Se = Or.readFileSync(Ls.toNamespacedPath(g), "utf8");
          } catch (De) {
            const We = De;
            if (We.code !== "ENOENT") throw We;
          }
          const Oe = { exists: false, pjsonPath: g, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          if (Se !== void 0) {
            let De;
            try {
              De = JSON.parse(Se);
            } catch (We) {
              const nt = We, ht = new dn(g, ($ ? `"${se}" from ` : "") + (0, Dt.fileURLToPath)($ || se), nt.message);
              throw ht.cause = nt, ht;
            }
            Oe.exists = true, Nt.call(De, "name") && typeof De.name == "string" && (Oe.name = De.name), Nt.call(De, "main") && typeof De.main == "string" && (Oe.main = De.main), Nt.call(De, "exports") && (Oe.exports = De.exports), Nt.call(De, "imports") && (Oe.imports = De.imports), !Nt.call(De, "type") || De.type !== "commonjs" && De.type !== "module" || (Oe.type = De.type);
          }
          return kn.set(g, Oe), Oe;
        }
        function wn(g) {
          let $ = new URL("package.json", g);
          for (; !$.pathname.endsWith("node_modules/package.json"); ) {
            const se = en((0, Dt.fileURLToPath)($), { specifier: g });
            if (se.exists) return se;
            const ae = $;
            if ($ = new URL("../package.json", $), $.pathname === ae.pathname) break;
          }
          return { pjsonPath: (0, Dt.fileURLToPath)($), exists: false, type: "none" };
        }
        function ls(g) {
          return wn(g).type;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: ti } = ve, wb = {}.hasOwnProperty, Pb = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" }, sp = { __proto__: null, "data:": function(g) {
          const { 1: $ } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(g.pathname) || [null, null, null];
          return function(se) {
            return se && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(se) ? "module" : se === "application/json" ? "json" : null;
          }($);
        }, "file:": function(g, $, se) {
          const ae = function(De) {
            const We = De.pathname;
            let nt = We.length;
            for (; nt--; ) {
              const ht = We.codePointAt(nt);
              if (ht === 47) return "";
              if (ht === 46) return We.codePointAt(nt - 1) === 47 ? "" : We.slice(nt);
            }
            return "";
          }(g);
          if (ae === ".js") {
            const De = ls(g);
            return De !== "none" ? De : "commonjs";
          }
          if (ae === "") {
            const De = ls(g);
            return De === "none" || De === "commonjs" ? "commonjs" : "module";
          }
          const Se = Pb[ae];
          if (Se) return Se;
          if (se) return;
          const Oe = (0, Dt.fileURLToPath)(g);
          throw new ti(ae, Oe);
        }, "http:": ip, "https:": ip, "node:": () => "builtin" };
        function ip() {
        }
        const Hi = RegExp.prototype[Symbol.replace], { ERR_INVALID_MODULE_SPECIFIER: Gi, ERR_INVALID_PACKAGE_CONFIG: ap, ERR_INVALID_PACKAGE_TARGET: xb, ERR_MODULE_NOT_FOUND: Po, ERR_PACKAGE_IMPORT_NOT_DEFINED: Ab, ERR_PACKAGE_PATH_NOT_EXPORTED: Cb, ERR_UNSUPPORTED_DIR_IMPORT: Ib, ERR_UNSUPPORTED_RESOLVE_REQUEST: op } = ve, lp = {}.hasOwnProperty, up = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, cp = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, kb = /^\.|%|\\/, zi = /\*/g, Ob = /%2f|%5c/i, pp = /* @__PURE__ */ new Set(), Db = /[/\\]{2}/;
        function dp(g, $, se, ae, Se, Oe, De) {
          if (dr.noDeprecation) return;
          const We = (0, Dt.fileURLToPath)(ae), nt = Db.exec(De ? g : $) !== null;
          dr.emitWarning(`Use of deprecated ${nt ? "double slash" : "leading or trailing slash matching"} resolving "${g}" for module request "${$}" ${$ === se ? "" : `matched to "${se}" `}in the "${Se ? "imports" : "exports"}" field module resolution of the package at ${We}${Oe ? ` imported from ${(0, Dt.fileURLToPath)(Oe)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function fp(g, $, se, ae) {
          if (dr.noDeprecation || function(nt, ht) {
            const Ze = nt.protocol;
            return wb.call(sp, Ze) && sp[Ze](nt, ht, true) || null;
          }(g, { parentURL: se.href }) !== "module") return;
          const Oe = (0, Dt.fileURLToPath)(g.href), De = (0, Dt.fileURLToPath)(new Dt.URL(".", $)), We = (0, Dt.fileURLToPath)(se);
          ae ? Ls.resolve(De, ae) !== Oe && dr.emitWarning(`Package ${De} has a "main" field set to "${ae}", excluding the full filename and extension to the resolved file at "${Oe.slice(De.length)}", imported from ${We}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : dr.emitWarning(`No "main" or "exports" field defined in the package.json for ${De} resolving the main entry point "${Oe.slice(De.length)}", imported from ${We}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function hp(g) {
          try {
            return (0, Or.statSync)(g);
          } catch {
          }
        }
        function xo(g) {
          const $ = (0, Or.statSync)(g, { throwIfNoEntry: false }), se = $ ? $.isFile() : void 0;
          return se != null && se;
        }
        function Nb(g, $, se) {
          let ae;
          if ($.main !== void 0) {
            if (ae = new Dt.URL($.main, g), xo(ae)) return ae;
            const De = [`./${$.main}.js`, `./${$.main}.json`, `./${$.main}.node`, `./${$.main}/index.js`, `./${$.main}/index.json`, `./${$.main}/index.node`];
            let We = -1;
            for (; ++We < De.length && (ae = new Dt.URL(De[We], g), !xo(ae)); ) ae = void 0;
            if (ae) return fp(ae, g, se, $.main), ae;
          }
          const Se = ["./index.js", "./index.json", "./index.node"];
          let Oe = -1;
          for (; ++Oe < Se.length && (ae = new Dt.URL(Se[Oe], g), !xo(ae)); ) ae = void 0;
          if (ae) return fp(ae, g, se, $.main), ae;
          throw new Po((0, Dt.fileURLToPath)(new Dt.URL(".", g)), (0, Dt.fileURLToPath)(se));
        }
        function Ao(g, $, se) {
          return new Cb((0, Dt.fileURLToPath)(new Dt.URL(".", $)), g, se && (0, Dt.fileURLToPath)(se));
        }
        function ni(g, $, se, ae, Se) {
          return $ = typeof $ == "object" && $ !== null ? JSON.stringify($, null, "") : `${$}`, new xb((0, Dt.fileURLToPath)(new Dt.URL(".", se)), g, $, ae, Se && (0, Dt.fileURLToPath)(Se));
        }
        function Rb(g, $, se, ae, Se, Oe, De, We, nt) {
          if ($ !== "" && !Oe && g[g.length - 1] !== "/") throw ni(se, g, ae, De, Se);
          if (!g.startsWith("./")) {
            if (De && !g.startsWith("../") && !g.startsWith("/")) {
              let jt = false;
              try {
                new Dt.URL(g), jt = true;
              } catch {
              }
              if (!jt) return bp(Oe ? Hi.call(zi, g, () => $) : g + $, ae, nt);
            }
            throw ni(se, g, ae, De, Se);
          }
          if (up.exec(g.slice(2)) !== null) {
            if (cp.exec(g.slice(2)) !== null) throw ni(se, g, ae, De, Se);
            if (!We) {
              const jt = Oe ? se.replace("*", () => $) : se + $;
              dp(Oe ? Hi.call(zi, g, () => $) : g, jt, se, ae, De, Se, true);
            }
          }
          const ht = new Dt.URL(g, ae), Ze = ht.pathname, Pt = new Dt.URL(".", ae).pathname;
          if (!Ze.startsWith(Pt)) throw ni(se, g, ae, De, Se);
          if ($ === "") return ht;
          if (up.exec($) !== null) {
            const jt = Oe ? se.replace("*", () => $) : se + $;
            cp.exec($) === null ? We || dp(Oe ? Hi.call(zi, g, () => $) : g, jt, se, ae, De, Se, false) : function(rn, vn, $n, Kn, Pn) {
              const Es = `request is not a valid match in pattern "${vn}" for the "${Kn ? "imports" : "exports"}" resolution of ${(0, Dt.fileURLToPath)($n)}`;
              throw new Gi(rn, Es, Pn && (0, Dt.fileURLToPath)(Pn));
            }(jt, se, ae, De, Se);
          }
          return Oe ? new Dt.URL(Hi.call(zi, ht.href, () => $)) : new Dt.URL($, ht);
        }
        function jb(g) {
          const $ = Number(g);
          return `${$}` === g && $ >= 0 && $ < 4294967295;
        }
        function Fs(g, $, se, ae, Se, Oe, De, We, nt) {
          if (typeof $ == "string") return Rb($, se, ae, g, Se, Oe, De, We, nt);
          if (Array.isArray($)) {
            const ht = $;
            if (ht.length === 0) return null;
            let Ze, Pt = -1;
            for (; ++Pt < ht.length; ) {
              const jt = ht[Pt];
              let rn;
              try {
                rn = Fs(g, jt, se, ae, Se, Oe, De, We, nt);
              } catch (vn) {
                if (Ze = vn, vn.code === "ERR_INVALID_PACKAGE_TARGET") continue;
                throw vn;
              }
              if (rn !== void 0) {
                if (rn !== null) return rn;
                Ze = null;
              }
            }
            if (Ze == null) return null;
            throw Ze;
          }
          if (typeof $ == "object" && $ !== null) {
            const ht = Object.getOwnPropertyNames($);
            let Ze = -1;
            for (; ++Ze < ht.length; ) if (jb(ht[Ze])) throw new ap((0, Dt.fileURLToPath)(g), Se, '"exports" cannot contain numeric property keys.');
            for (Ze = -1; ++Ze < ht.length; ) {
              const Pt = ht[Ze];
              if (Pt === "default" || nt && nt.has(Pt)) {
                const jt = Fs(g, $[Pt], se, ae, Se, Oe, De, We, nt);
                if (jt === void 0) continue;
                return jt;
              }
            }
            return null;
          }
          if ($ === null) return null;
          throw ni(ae, $, g, De, Se);
        }
        function Lb(g, $, se) {
          if (dr.noDeprecation) return;
          const ae = (0, Dt.fileURLToPath)($);
          pp.has(ae + "|" + g) || (pp.add(ae + "|" + g), dr.emitWarning(`Use of deprecated trailing slash pattern mapping "${g}" in the "exports" field module resolution of the package at ${ae}${se ? ` imported from ${(0, Dt.fileURLToPath)(se)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function mp(g, $, se, ae, Se) {
          let Oe = se.exports;
          if (function(Ze, Pt, jt) {
            if (typeof Ze == "string" || Array.isArray(Ze)) return true;
            if (typeof Ze != "object" || Ze === null) return false;
            const rn = Object.getOwnPropertyNames(Ze);
            let vn = false, $n = 0, Kn = -1;
            for (; ++Kn < rn.length; ) {
              const Pn = rn[Kn], Es = Pn === "" || Pn[0] !== ".";
              if ($n++ == 0) vn = Es;
              else if (vn !== Es) throw new ap((0, Dt.fileURLToPath)(Pt), jt, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return vn;
          }(Oe, g, ae) && (Oe = { ".": Oe }), lp.call(Oe, $) && !$.includes("*") && !$.endsWith("/")) {
            const Ze = Fs(g, Oe[$], "", $, ae, false, false, false, Se);
            if (Ze == null) throw Ao($, g, ae);
            return Ze;
          }
          let De = "", We = "";
          const nt = Object.getOwnPropertyNames(Oe);
          let ht = -1;
          for (; ++ht < nt.length; ) {
            const Ze = nt[ht], Pt = Ze.indexOf("*");
            if (Pt !== -1 && $.startsWith(Ze.slice(0, Pt))) {
              $.endsWith("/") && Lb($, g, ae);
              const jt = Ze.slice(Pt + 1);
              $.length >= Ze.length && $.endsWith(jt) && yp(De, Ze) === 1 && Ze.lastIndexOf("*") === Pt && (De = Ze, We = $.slice(Pt, $.length - jt.length));
            }
          }
          if (De) {
            const Ze = Fs(g, Oe[De], We, De, ae, true, false, $.endsWith("/"), Se);
            if (Ze == null) throw Ao($, g, ae);
            return Ze;
          }
          throw Ao($, g, ae);
        }
        function yp(g, $) {
          const se = g.indexOf("*"), ae = $.indexOf("*"), Se = se === -1 ? g.length : se + 1, Oe = ae === -1 ? $.length : ae + 1;
          return Se > Oe ? -1 : Oe > Se || se === -1 ? 1 : ae === -1 || g.length > $.length ? -1 : $.length > g.length ? 1 : 0;
        }
        function Fb(g, $, se) {
          if (g === "#" || g.startsWith("#/") || g.endsWith("/")) throw new Gi(g, "is not a valid internal imports specifier name", (0, Dt.fileURLToPath)($));
          let ae;
          const Se = wn($);
          if (Se.exists) {
            ae = (0, Dt.pathToFileURL)(Se.pjsonPath);
            const Oe = Se.imports;
            if (Oe) if (lp.call(Oe, g) && !g.includes("*")) {
              const De = Fs(ae, Oe[g], "", g, $, false, true, false, se);
              if (De != null) return De;
            } else {
              let De = "", We = "";
              const nt = Object.getOwnPropertyNames(Oe);
              let ht = -1;
              for (; ++ht < nt.length; ) {
                const Ze = nt[ht], Pt = Ze.indexOf("*");
                if (Pt !== -1 && g.startsWith(Ze.slice(0, -1))) {
                  const jt = Ze.slice(Pt + 1);
                  g.length >= Ze.length && g.endsWith(jt) && yp(De, Ze) === 1 && Ze.lastIndexOf("*") === Pt && (De = Ze, We = g.slice(Pt, g.length - jt.length));
                }
              }
              if (De) {
                const Ze = Fs(ae, Oe[De], We, De, $, true, true, false, se);
                if (Ze != null) return Ze;
              }
            }
          }
          throw function(Oe, De, We) {
            return new Ab(Oe, De && (0, Dt.fileURLToPath)(new Dt.URL(".", De)), (0, Dt.fileURLToPath)(We));
          }(g, ae, $);
        }
        function bp(g, $, se) {
          if (es.builtinModules.includes(g)) return new Dt.URL("node:" + g);
          const { packageName: ae, packageSubpath: Se, isScoped: Oe } = function(Ze, Pt) {
            let jt = Ze.indexOf("/"), rn = true, vn = false;
            Ze[0] === "@" && (vn = true, jt === -1 || Ze.length === 0 ? rn = false : jt = Ze.indexOf("/", jt + 1));
            const $n = jt === -1 ? Ze : Ze.slice(0, jt);
            if (kb.exec($n) !== null && (rn = false), !rn) throw new Gi(Ze, "is not a valid package name", (0, Dt.fileURLToPath)(Pt));
            return { packageName: $n, packageSubpath: "." + (jt === -1 ? "" : Ze.slice(jt)), isScoped: vn };
          }(g, $), De = wn($);
          if (De.exists) {
            const Ze = (0, Dt.pathToFileURL)(De.pjsonPath);
            if (De.name === ae && De.exports !== void 0 && De.exports !== null) return mp(Ze, Se, De, $, se);
          }
          let We, nt = new Dt.URL("./node_modules/" + ae + "/package.json", $), ht = (0, Dt.fileURLToPath)(nt);
          do {
            const Ze = hp(ht.slice(0, -13));
            if (!Ze || !Ze.isDirectory()) {
              We = ht, nt = new Dt.URL((Oe ? "../../../../node_modules/" : "../../../node_modules/") + ae + "/package.json", nt), ht = (0, Dt.fileURLToPath)(nt);
              continue;
            }
            const Pt = en(ht, { base: $, specifier: g });
            return Pt.exports !== void 0 && Pt.exports !== null ? mp(nt, Se, Pt, $, se) : Se === "." ? Nb(nt, Pt, $) : new Dt.URL(Se, nt);
          } while (ht.length !== We.length);
          throw new Po(ae, (0, Dt.fileURLToPath)($), false);
        }
        function Mb(g, $, se, ae) {
          const Se = $.protocol, Oe = Se === "data:" || Se === "http:" || Se === "https:";
          let De;
          if (function(We) {
            return We !== "" && (We[0] === "/" || function(nt) {
              return nt[0] === "." && (nt.length === 1 || nt[1] === "/" || nt[1] === "." && (nt.length === 2 || nt[2] === "/"));
            }(We));
          }(g)) try {
            De = new Dt.URL(g, $);
          } catch (We) {
            const nt = new op(g, $);
            throw nt.cause = We, nt;
          }
          else if (Se === "file:" && g[0] === "#") De = Fb(g, $, se);
          else try {
            De = new Dt.URL(g);
          } catch (We) {
            if (Oe && !es.builtinModules.includes(g)) {
              const nt = new op(g, $);
              throw nt.cause = We, nt;
            }
            De = bp(g, $, se);
          }
          return Ur(De !== void 0, "expected to be defined"), De.protocol !== "file:" ? De : function(We, nt, ht) {
            if (Ob.exec(We.pathname) !== null) throw new Gi(We.pathname, 'must not include encoded "/" or "\\" characters', (0, Dt.fileURLToPath)(nt));
            let Ze;
            try {
              Ze = (0, Dt.fileURLToPath)(We);
            } catch (jt) {
              const rn = jt;
              throw Object.defineProperty(rn, "input", { value: String(We) }), Object.defineProperty(rn, "module", { value: String(nt) }), rn;
            }
            const Pt = hp(Ze.endsWith("/") ? Ze.slice(-1) : Ze);
            if (Pt && Pt.isDirectory()) {
              const jt = new Ib(Ze, (0, Dt.fileURLToPath)(nt));
              throw jt.url = String(We), jt;
            }
            if (!Pt || !Pt.isFile()) {
              const jt = new Po(Ze || We.pathname, nt && (0, Dt.fileURLToPath)(nt), true);
              throw jt.url = String(We), jt;
            }
            {
              const jt = (0, Or.realpathSync)(Ze), { search: rn, hash: vn } = We;
              (We = (0, Dt.pathToFileURL)(jt + (Ze.endsWith(Ls.sep) ? "/" : ""))).search = rn, We.hash = vn;
            }
            return We;
          }(De, $);
        }
        function Ki(g) {
          return typeof g != "string" || g.startsWith("file://") ? O((0, Dt.fileURLToPath)(g)) : O(g);
        }
        function Co(g) {
          return (0, Dt.pathToFileURL)(Ki(g)).toString();
        }
        const Bb = /* @__PURE__ */ new Set(["node", "import"]), $b = [".mjs", ".cjs", ".js", ".json"], Ub = /* @__PURE__ */ new Set(["ERR_MODULE_NOT_FOUND", "ERR_UNSUPPORTED_DIR_IMPORT", "MODULE_NOT_FOUND", "ERR_PACKAGE_PATH_NOT_EXPORTED"]);
        function gp(g, $, se) {
          try {
            return Mb(g, $, se);
          } catch (ae) {
            if (!Ub.has(ae == null ? void 0 : ae.code)) throw ae;
          }
        }
        function Vb(g, $ = {}) {
          if (typeof g != "string") {
            if (!(g instanceof URL)) throw new TypeError("input must be a `string` or `URL`");
            g = Ki(g);
          }
          if (/(node|data|http|https):/.test(g)) return g;
          if (v.has(g)) return "node:" + g;
          if (g.startsWith("file://") && (g = Ki(g)), m(g)) try {
            if ((0, Or.statSync)(g).isFile()) return Co(g);
          } catch (De) {
            if ((De == null ? void 0 : De.code) !== "ENOENT") throw De;
          }
          const se = $.conditions ? new Set($.conditions) : Bb, ae = (Array.isArray($.url) ? $.url : [$.url]).filter(Boolean).map((De) => new URL(function(We) {
            return typeof We != "string" && (We = We.toString()), /(node|data|http|https|file):/.test(We) ? We : v.has(We) ? "node:" + We : "file://" + encodeURI(O(We));
          }(De.toString())));
          ae.length === 0 && ae.push(new URL(Co(process.cwd())));
          const Se = [...ae];
          for (const De of ae) De.protocol === "file:" && Se.push(new URL("./", De), new URL(Wi(De.pathname, "_index.js"), De), new URL("node_modules", De));
          let Oe;
          for (const De of Se) {
            if (Oe = gp(g, De, se), Oe) break;
            for (const We of ["", "/index"]) {
              for (const nt of $.extensions || $b) if (Oe = gp(Wi(g, We) + nt, De, se), Oe) break;
              if (Oe) break;
            }
            if (Oe) break;
          }
          if (!Oe) {
            const De = new Error(`Cannot find module ${g} imported from ${Se.join(", ")}`);
            throw De.code = "ERR_MODULE_NOT_FOUND", De;
          }
          return Co(Oe);
        }
        function Wb(g, $) {
          return Vb(g, $);
        }
        function Hb(g, $) {
          return Ki(Wb(g, $));
        }
        const Gb = /([\s;]|^)(import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m, zb = /\/\*.+?\*\/|\/\/.*(?=[nr])/g;
        function Kb(g, $ = {}) {
          return $.stripComments && (g = g.replace(zb, "")), Gb.test(g);
        }
        var qb = A("crypto");
        function vp(g, $ = 8) {
          return (0, qb.createHash)("md5").update(g).digest("hex").slice(0, $);
        }
        var Yb = function(g, $, se, ae) {
          return new (se || (se = Promise))(function(Se, Oe) {
            function De(ht) {
              try {
                nt(ae.next(ht));
              } catch (Ze) {
                Oe(Ze);
              }
            }
            function We(ht) {
              try {
                nt(ae.throw(ht));
              } catch (Ze) {
                Oe(Ze);
              }
            }
            function nt(ht) {
              var Ze;
              ht.done ? Se(ht.value) : (Ze = ht.value, Ze instanceof se ? Ze : new se(function(Pt) {
                Pt(Ze);
              })).then(De, We);
            }
            nt((ae = ae.apply(g, [])).next());
          });
        };
        const Xb = k(s.JITI_DEBUG), Ep = k(s.JITI_CACHE), Jb = k(s.JITI_ESM_RESOLVE), Sp = k(s.JITI_REQUIRE_CACHE), _p = k(s.JITI_SOURCE_MAPS), Qb = k(s.JITI_ALIAS), Zb = k(s.JITI_TRANSFORM_MODULES), eg = k(s.JITI_NATIVE_MODULES), Tp = k(s.JITI_EXPERIMENTAL_BUN), tg = (0, n.platform)() === "win32", ng = { debug: Xb, cache: Ep === void 0 || !!Ep, requireCache: Sp === void 0 || !!Sp, sourceMaps: _p !== void 0 && !!_p, interopDefault: false, esmResolve: Jb || false, cacheVersion: "7", legacy: (0, X.lt)(process.version || "0.0.0", "14.0.0"), extensions: [".js", ".mjs", ".cjs", ".ts", ".mts", ".cts", ".json"], alias: Qb, nativeModules: eg || [], transformModules: Zb || [], experimentalBun: Tp === void 0 ? !!process.versions.bun : !!Tp }, rg = /\.(c|m)?j(sx?)$/, sg = /\.(c|m)?t(sx?)$/;
        function wp(g, $ = {}, se, ae) {
          ($ = Object.assign(Object.assign({}, ng), $)).legacy && ($.cacheVersion += "-legacy"), $.transformOptions && ($.cacheVersion += "-" + Z()($.transformOptions));
          const Se = $.alias && Object.keys($.alias).length > 0 ? q($.alias || {}) : null, Oe = ["typescript", "jiti", ...$.nativeModules || []], De = [...$.transformModules || []], We = new RegExp(`node_modules/(${Oe.map((Tt) => N(Tt)).join("|")})/`), nt = new RegExp(`node_modules/(${De.map((Tt) => N(Tt)).join("|")})/`);
          function ht(...Tt) {
            $.debug && console.log("[jiti]", ...Tt);
          }
          if (g || (g = process.cwd()), function(Tt) {
            try {
              return (0, P.lstatSync)(Tt).isDirectory();
            } catch {
              return false;
            }
          }(g) && (g = p(g, "index.js")), $.cache === true && ($.cache = function() {
            let Tt = (0, n.tmpdir)();
            if (s.TMPDIR && Tt === process.cwd() && !s.JITI_RESPECT_TMPDIR_ENV) {
              const tn = s.TMPDIR;
              delete s.TMPDIR, Tt = (0, n.tmpdir)(), s.TMPDIR = tn;
            }
            return p(Tt, "node-jiti");
          }()), $.cache) try {
            if ((0, P.mkdirSync)($.cache, { recursive: true }), !function(Tt) {
              try {
                return (0, P.accessSync)(Tt, P.constants.W_OK), true;
              } catch {
                return false;
              }
            }($.cache)) throw new Error("directory is not writable");
          } catch (Tt) {
            ht("Error creating cache directory at ", $.cache, Tt), $.cache = false;
          }
          const Ze = W()(tg ? g.replace(/\//g, "\\") : g), Pt = (Tt, tn) => {
            try {
              return Ze.resolve(Tt, tn);
            } catch {
            }
          }, jt = (0, e.pathToFileURL)(g), rn = [...$.extensions].filter((Tt) => Tt !== ".js"), vn = (Tt, tn) => {
            let un, Ln;
            if (Se && (Tt = function(Ut, On) {
              const hn = f(Ut);
              On = q(On);
              for (const [ir, us] of Object.entries(On)) {
                if (!hn.startsWith(ir)) continue;
                const Ms = ee(ir) ? ir.slice(0, -1) : ir;
                if (ee(hn[Ms.length])) return p(us, hn.slice(ir.length));
              }
              return hn;
            }(Tt, Se)), $.esmResolve) {
              const Ut = [["node", "require"], ["node", "import"]];
              for (const On of Ut) {
                try {
                  un = Hb(Tt, { url: jt, conditions: On, extensions: $.extensions });
                } catch (hn) {
                  Ln = hn;
                }
                if (un) return un;
              }
            }
            try {
              return Ze.resolve(Tt, tn);
            } catch (Ut) {
              Ln = Ut;
            }
            for (const Ut of rn) if (un = Pt(Tt + Ut, tn) || Pt(Tt + "/index" + Ut, tn), un || sg.test((se == null ? void 0 : se.filename) || "") && (un = Pt(Tt.replace(rg, ".$1t$2"), tn), un)) return un;
            throw Ln;
          };
          function $n(Tt) {
            let tn = function(un, Ln, Ut) {
              if (!$.cache || !un) return Ut();
              const On = ` /* v${$.cacheVersion}-${vp(Ln, 16)} */`, hn = w(C(un)) + "-" + w(un), ir = p($.cache, hn + "." + vp(un) + ".js");
              if ((0, P.existsSync)(ir)) {
                const Ms = (0, P.readFileSync)(ir, "utf8");
                if (Ms.endsWith(On)) return ht("[cache hit]", un, "~>", ir), Ms;
              }
              ht("[cache miss]", un);
              const us = Ut();
              return us.includes("__JITI_ERROR__") || (0, P.writeFileSync)(ir, us + On, "utf8"), us;
            }(Tt.filename, Tt.source, () => {
              var un;
              const Ln = $.transform(Object.assign(Object.assign(Object.assign({ legacy: $.legacy }, $.transformOptions), { babel: Object.assign(Object.assign({}, $.sourceMaps ? { sourceFileName: Tt.filename, sourceMaps: "inline" } : {}), (un = $.transformOptions) === null || un === void 0 ? void 0 : un.babel) }), Tt));
              return Ln.error && $.debug && ht(Ln.error), Ln.code;
            });
            return tn.startsWith("#!") && (tn = "// " + tn), tn;
          }
          function Kn(Tt) {
            return $.interopDefault ? function(tn, un = {}) {
              if ((Ln = tn) === null || typeof Ln != "object" || !("default" in tn)) return tn;
              var Ln;
              const Ut = tn.default;
              if (Ut == null) return tn;
              const On = typeof Ut;
              if (On !== "object" && (On !== "function" || un.preferNamespace)) return un.preferNamespace ? tn : Ut;
              for (const hn in tn) try {
                hn in Ut || Object.defineProperty(Ut, hn, { enumerable: hn !== "default", configurable: hn !== "default", get: () => tn[hn] });
              } catch {
              }
              return Ut;
            }(Tt) : Tt;
          }
          function Pn(Tt, tn) {
            var un;
            const Ln = ae || {};
            if (Tt.startsWith("node:") ? Tt = Tt.slice(5) : Tt.startsWith("file:") && (Tt = (0, e.fileURLToPath)(Tt)), t.builtinModules.includes(Tt) || Tt === ".pnp.js") return Ze(Tt);
            if ($.experimentalBun && !$.transformOptions) try {
              ht(`[bun] [native] ${Tt}`);
              const hn = Ze(Tt);
              return $.requireCache === false && delete Ze.cache[Tt], Kn(hn);
            } catch (hn) {
              ht(`[bun] Using fallback for ${Tt} because of an error:`, hn);
            }
            const Ut = vn(Tt), On = _(Ut);
            if (On === ".json") {
              ht("[json]", Ut);
              const hn = Ze(Tt);
              return Object.defineProperty(hn, "default", { value: hn }), hn;
            }
            if (On && !$.extensions.includes(On)) return ht("[unknown]", Ut), Ze(Tt);
            if (We.test(Ut)) return ht("[native]", Ut), Ze(Tt);
            if (Ln[Ut] && (Ln[Ut].loaded === true || (se == null ? void 0 : se.loaded) === false)) return Kn((un = Ln[Ut]) === null || un === void 0 ? void 0 : un.exports);
            if ($.requireCache && Ze.cache[Ut]) {
              const hn = Ze.cache[Ut];
              if (hn == null ? void 0 : hn.loaded) return Kn(hn.exports);
            }
            return Es((0, P.readFileSync)(Ut, "utf8"), { id: Tt, filename: Ut, ext: On, cache: Ln });
          }
          function Es(Tt, tn = {}) {
            var un;
            const Ln = tn.id || (tn.filename ? w(tn.filename) : `_jitiEval.${tn.ext || ".js"}`), Ut = tn.filename || vn(Ln), On = tn.ext || _(Ut), hn = tn.cache || ae || {}, ir = On === ".ts" || On === ".mts" || On === ".cts", us = On === ".mjs" || On === ".js" && ((un = function(ar) {
              for (; ar && ar !== "." && ar !== "/"; ) {
                ar = p(ar, "..");
                try {
                  const qi = (0, P.readFileSync)(p(ar, "package.json"), "utf8");
                  try {
                    return JSON.parse(qi);
                  } catch {
                  }
                  break;
                } catch {
                }
              }
            }(Ut)) === null || un === void 0 ? void 0 : un.type) === "module", Ms = On !== ".cjs" && (ir || us || nt.test(Ut) || Kb(Tt) || $.legacy && Tt.match(/\?\.|\?\?/)), ig = l.performance.now();
            if (Ms) Tt = $n({ filename: Ut, source: Tt, ts: ir }), ht("[transpile]" + (us ? " [esm]" : ""), Ut, `(${Math.round(1e3 * (l.performance.now() - ig)) / 1e3}ms)`);
            else try {
              return ht("[native]", Ut), Kn(Ze(Ln));
            } catch (ar) {
              ht("Native require error:", ar), ht("[fallback]", Ut), Tt = $n({ filename: Ut, source: Tt, ts: ir });
            }
            const Rn = new t.Module(Ut);
            let Pp;
            Rn.filename = Ut, se && (Rn.parent = se, Array.isArray(se.children) && !se.children.includes(Rn) && se.children.push(Rn)), Rn.require = wp(Ut, $, Rn, hn), Rn.path = C(Ut), Rn.paths = t.Module._nodeModulePaths(Rn.path), hn[Ut] = Rn, $.requireCache && (Ze.cache[Ut] = Rn);
            try {
              Pp = c().runInThisContext(t.Module.wrap(Tt), { filename: Ut, lineOffset: 0, displayErrors: false });
            } catch (ar) {
              $.requireCache && delete Ze.cache[Ut], $.onError(ar);
            }
            try {
              Pp(Rn.exports, Rn.require, Rn, Rn.filename, C(Rn.filename));
            } catch (ar) {
              $.requireCache && delete Ze.cache[Ut], $.onError(ar);
            }
            if (Rn.exports && Rn.exports.__JITI_ERROR__) {
              const { filename: ar, line: qi, column: xp, code: ag, message: og } = Rn.exports.__JITI_ERROR__, Ap = new Error(`${ag}: ${og} 
 ${`${ar}:${qi}:${xp}`}`);
              Error.captureStackTrace(Ap, Pn), $.onError(Ap);
            }
            return Rn.loaded = true, Kn(Rn.exports);
          }
          return vn.paths = Ze.resolve.paths, Pn.resolve = vn, Pn.cache = $.requireCache ? Ze.cache : {}, Pn.extensions = Ze.extensions, Pn.main = Ze.main, Pn.transform = $n, Pn.register = function() {
            return (0, re.addHook)((Tt, tn) => Pn.transform({ source: Tt, filename: tn, ts: !!/\.[cm]?ts$/.test(tn) }), { exts: $.extensions });
          }, Pn.evalModule = Es, Pn.import = (Tt, tn) => Yb(this, void 0, void 0, function* () {
            return yield Pn(Tt);
          }), Pn;
        }
      })(), a3.exports = R.default;
    })();
  }(Jo)), Jo.exports;
}
var Qo = { exports: {} }, Nd;
function Vm() {
  return Nd || (Nd = 1, function(a3) {
    var s = {};
    (() => {
      var o = { "./node_modules/.pnpm/@ampproject+remapping@2.3.0/node_modules/@ampproject/remapping/dist/remapping.umd.js": function(P, t, l) {
        P.exports = function(n, u) {
          const c = r("", -1, -1, "", null, false), e = [];
          function r(C, w, I, D, j, L) {
            return { source: C, line: w, column: I, name: D, content: j, ignore: L };
          }
          function f(C, w, I, D, j) {
            return { map: C, sources: w, source: I, content: D, ignore: j };
          }
          function y(C, w) {
            return f(C, w, "", null, false);
          }
          function S(C, w, I) {
            return f(null, e, C, w, I);
          }
          function T(C) {
            const w = new u.GenMapping({ file: C.map.file }), { sources: I, map: D } = C, j = D.names, L = n.decodedMappings(D);
            for (let k = 0; k < L.length; k++) {
              const N = L[k];
              for (let F = 0; F < N.length; F++) {
                const W = N[F], X = W[0];
                let H = c;
                if (W.length !== 1 && (H = d(I[W[1]], W[2], W[3], W.length === 5 ? j[W[4]] : ""), H == null)) continue;
                const { column: U, line: q, name: ee, content: re, source: Y, ignore: Z } = H;
                u.maybeAddSegment(w, k, X, Y, q, U, ee), Y && re != null && u.setSourceContent(w, Y, re), Z && u.setIgnore(w, Y, true);
              }
            }
            return w;
          }
          function d(C, w, I, D) {
            if (!C.map) return r(C.source, w, I, D, C.content, C.ignore);
            const j = n.traceSegment(C.map, w, I);
            return j == null ? null : j.length === 1 ? c : d(C.sources[j[1]], j[2], j[3], j.length === 5 ? C.map.names[j[4]] : D);
          }
          function p(C) {
            return Array.isArray(C) ? C : [C];
          }
          function h(C, w) {
            const I = p(C).map((L) => new n.TraceMap(L, "")), D = I.pop();
            for (let L = 0; L < I.length; L++) if (I[L].sources.length > 1) throw new Error(`Transformation map ${L} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
            let j = m(D, w, "", 0);
            for (let L = I.length - 1; L >= 0; L--) j = y(I[L], [j]);
            return j;
          }
          function m(C, w, I, D) {
            const { resolvedSources: j, sourcesContent: L, ignoreList: k } = C, N = D + 1;
            return y(C, j.map((F, W) => {
              const X = { importer: I, depth: N, source: F || "", content: void 0, ignore: void 0 }, H = w(X.source, X), { source: U, content: q, ignore: ee } = X;
              return H ? m(new n.TraceMap(H, U), w, U, N) : S(U, q !== void 0 ? q : L ? L[W] : null, ee !== void 0 ? ee : !!k && k.includes(W));
            }));
          }
          class E {
            constructor(w, I) {
              const D = I.decodedMappings ? u.toDecodedMap(w) : u.toEncodedMap(w);
              this.version = D.version, this.file = D.file, this.mappings = D.mappings, this.names = D.names, this.ignoreList = D.ignoreList, this.sourceRoot = D.sourceRoot, this.sources = D.sources, I.excludeContent || (this.sourcesContent = D.sourcesContent);
            }
            toString() {
              return JSON.stringify(this);
            }
          }
          function _(C, w, I) {
            const D = typeof I == "object" ? I : { excludeContent: !!I, decodedMappings: false }, j = h(C, w);
            return new E(T(j), D);
          }
          return _;
        }(l("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"), l("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.8/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"));
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files lazy recursive": (P) => {
        function t(l) {
          return Promise.resolve().then(() => {
            var n = new Error("Cannot find module '" + l + "'");
            throw n.code = "MODULE_NOT_FOUND", n;
          });
        }
        t.keys = () => [], t.resolve = t, t.id = "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files lazy recursive", P.exports = t;
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive": (P) => {
        function t(l) {
          var n = new Error("Cannot find module '" + l + "'");
          throw n.code = "MODULE_NOT_FOUND", n;
        }
        t.keys = () => [], t.resolve = t, t.id = "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive", P.exports = t;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-class-properties/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = (0, l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((u) => (u.assertVersion(7), { name: "syntax-class-properties", manipulateOptions(c, e) {
          e.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
        } }));
        t.default = n;
      }, "./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.8/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js": function(P, t, l) {
        (function(n, u, c, e) {
          class p {
            constructor({ file: Z, sourceRoot: G } = {}) {
              this._names = new u.SetArray(), this._sources = new u.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = Z, this.sourceRoot = G, this._ignoreList = new u.SetArray();
            }
          }
          function h(Y) {
            return Y;
          }
          function m(Y, Z, G, B, z, M, K, Q) {
            return N(false, Y, Z, G, B, z, M, K, Q);
          }
          function E(Y, Z) {
            return re(false, Y, Z);
          }
          const _ = (Y, Z, G, B, z, M, K, Q) => N(true, Y, Z, G, B, z, M, K, Q), C = (Y, Z) => re(true, Y, Z);
          function w(Y, Z, G) {
            const { _sources: B, _sourcesContent: z } = Y;
            z[u.put(B, Z)] = G;
          }
          function I(Y, Z, G = true) {
            const { _sources: B, _sourcesContent: z, _ignoreList: M } = Y, K = u.put(B, Z);
            K === z.length && (z[K] = null), G ? u.put(M, K) : u.remove(M, K);
          }
          function D(Y) {
            const { _mappings: Z, _sources: G, _sourcesContent: B, _names: z, _ignoreList: M } = Y;
            return H(Z), { version: 3, file: Y.file || void 0, names: z.array, sourceRoot: Y.sourceRoot || void 0, sources: G.array, sourcesContent: B, mappings: Z, ignoreList: M.array };
          }
          function j(Y) {
            const Z = D(Y);
            return Object.assign(Object.assign({}, Z), { mappings: c.encode(Z.mappings) });
          }
          function L(Y) {
            const Z = new e.TraceMap(Y), G = new p({ file: Z.file, sourceRoot: Z.sourceRoot });
            return U(G._names, Z.names), U(G._sources, Z.sources), G._sourcesContent = Z.sourcesContent || Z.sources.map(() => null), G._mappings = e.decodedMappings(Z), Z.ignoreList && U(G._ignoreList, Z.ignoreList), G;
          }
          function k(Y) {
            const Z = [], { _mappings: G, _sources: B, _names: z } = Y;
            for (let M = 0; M < G.length; M++) {
              const K = G[M];
              for (let Q = 0; Q < K.length; Q++) {
                const ie = K[Q], ue = { line: M + 1, column: ie[0] };
                let ge, Te, le;
                ie.length !== 1 && (ge = B.array[ie[1]], Te = { line: ie[2] + 1, column: ie[3] }, ie.length === 5 && (le = z.array[ie[4]])), Z.push({ generated: ue, source: ge, original: Te, name: le });
              }
            }
            return Z;
          }
          function N(Y, Z, G, B, z, M, K, Q, ie) {
            const { _mappings: ue, _sources: ge, _sourcesContent: Te, _names: le } = Z, fe = F(ue, G), Pe = W(fe, B);
            if (!z) return Y && q(fe, Pe) ? void 0 : X(fe, Pe, [B]);
            const xe = u.put(ge, z), we = Q ? u.put(le, Q) : -1;
            if (xe === Te.length && (Te[xe] = ie ?? null), !Y || !ee(fe, Pe, xe, M, K, we)) return X(fe, Pe, Q ? [B, xe, M, K, we] : [B, xe, M, K]);
          }
          function F(Y, Z) {
            for (let G = Y.length; G <= Z; G++) Y[G] = [];
            return Y[Z];
          }
          function W(Y, Z) {
            let G = Y.length;
            for (let B = G - 1; B >= 0 && !(Z >= Y[B][0]); G = B--) ;
            return G;
          }
          function X(Y, Z, G) {
            for (let B = Y.length; B > Z; B--) Y[B] = Y[B - 1];
            Y[Z] = G;
          }
          function H(Y) {
            const { length: Z } = Y;
            let G = Z;
            for (let B = G - 1; B >= 0 && !(Y[B].length > 0); G = B, B--) ;
            G < Z && (Y.length = G);
          }
          function U(Y, Z) {
            for (let G = 0; G < Z.length; G++) u.put(Y, Z[G]);
          }
          function q(Y, Z) {
            return Z === 0 || Y[Z - 1].length === 1;
          }
          function ee(Y, Z, G, B, z, M) {
            if (Z === 0) return false;
            const K = Y[Z - 1];
            return K.length !== 1 && G === K[1] && B === K[2] && z === K[3] && M === (K.length === 5 ? K[4] : -1);
          }
          function re(Y, Z, G) {
            const { generated: B, source: z, original: M, name: K, content: Q } = G;
            return z ? N(Y, Z, B.line - 1, B.column, z, M.line - 1, M.column, K, Q) : N(Y, Z, B.line - 1, B.column, null, null, null, null, null);
          }
          n.GenMapping = p, n.addMapping = E, n.addSegment = m, n.allMappings = k, n.fromMap = L, n.maybeAddMapping = C, n.maybeAddSegment = _, n.setIgnore = I, n.setSourceContent = w, n.toDecodedMap = D, n.toEncodedMap = j, Object.defineProperty(n, "__esModule", { value: true });
        })(t, l("./node_modules/.pnpm/@jridgewell+set-array@1.2.1/node_modules/@jridgewell/set-array/dist/set-array.umd.js"), l("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"), l("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"));
      }, "./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js": function(P) {
        P.exports = /* @__PURE__ */ function() {
          const t = /^[\w+.-]+:\/\//, l = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, n = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
          function u(_) {
            return t.test(_);
          }
          function c(_) {
            return _.startsWith("//");
          }
          function e(_) {
            return _.startsWith("/");
          }
          function r(_) {
            return _.startsWith("file:");
          }
          function f(_) {
            return /^[.?#]/.test(_);
          }
          function y(_) {
            const C = l.exec(_);
            return T(C[1], C[2] || "", C[3], C[4] || "", C[5] || "/", C[6] || "", C[7] || "");
          }
          function S(_) {
            const C = n.exec(_), w = C[2];
            return T("file:", "", C[1] || "", "", e(w) ? w : "/" + w, C[3] || "", C[4] || "");
          }
          function T(_, C, w, I, D, j, L) {
            return { scheme: _, user: C, host: w, port: I, path: D, query: j, hash: L, type: 7 };
          }
          function d(_) {
            if (c(_)) {
              const w = y("http:" + _);
              return w.scheme = "", w.type = 6, w;
            }
            if (e(_)) {
              const w = y("http://foo.com" + _);
              return w.scheme = "", w.host = "", w.type = 5, w;
            }
            if (r(_)) return S(_);
            if (u(_)) return y(_);
            const C = y("http://foo.com/" + _);
            return C.scheme = "", C.host = "", C.type = _ ? _.startsWith("?") ? 3 : _.startsWith("#") ? 2 : 4 : 1, C;
          }
          function p(_) {
            if (_.endsWith("/..")) return _;
            const C = _.lastIndexOf("/");
            return _.slice(0, C + 1);
          }
          function h(_, C) {
            m(C, C.type), _.path === "/" ? _.path = C.path : _.path = p(C.path) + _.path;
          }
          function m(_, C) {
            const w = C <= 4, I = _.path.split("/");
            let D = 1, j = 0, L = false;
            for (let N = 1; N < I.length; N++) {
              const F = I[N];
              F ? (L = false, F !== "." && (F !== ".." ? (I[D++] = F, j++) : j ? (L = true, j--, D--) : w && (I[D++] = F))) : L = true;
            }
            let k = "";
            for (let N = 1; N < D; N++) k += "/" + I[N];
            (!k || L && !k.endsWith("/..")) && (k += "/"), _.path = k;
          }
          function E(_, C) {
            if (!_ && !C) return "";
            const w = d(_);
            let I = w.type;
            if (C && I !== 7) {
              const j = d(C), L = j.type;
              switch (I) {
                case 1:
                  w.hash = j.hash;
                case 2:
                  w.query = j.query;
                case 3:
                case 4:
                  h(w, j);
                case 5:
                  w.user = j.user, w.host = j.host, w.port = j.port;
                case 6:
                  w.scheme = j.scheme;
              }
              L > I && (I = L);
            }
            m(w, I);
            const D = w.query + w.hash;
            switch (I) {
              case 2:
              case 3:
                return D;
              case 4: {
                const j = w.path.slice(1);
                return j ? f(C || _) && !f(j) ? "./" + j + D : j + D : D || ".";
              }
              case 5:
                return w.path + D;
              default:
                return w.scheme + "//" + w.user + w.host + w.port + w.path + D;
            }
          }
          return E;
        }();
      }, "./node_modules/.pnpm/@jridgewell+set-array@1.2.1/node_modules/@jridgewell/set-array/dist/set-array.umd.js": function(P, t) {
        (function(l) {
          class n {
            constructor() {
              this._indexes = { __proto__: null }, this.array = [];
            }
          }
          function u(y) {
            return y;
          }
          function c(y, S) {
            return y._indexes[S];
          }
          function e(y, S) {
            const T = c(y, S);
            if (T !== void 0) return T;
            const { array: d, _indexes: p } = y, h = d.push(S);
            return p[S] = h - 1;
          }
          function r(y) {
            const { array: S, _indexes: T } = y;
            S.length !== 0 && (T[S.pop()] = void 0);
          }
          function f(y, S) {
            const T = c(y, S);
            if (T === void 0) return;
            const { array: d, _indexes: p } = y;
            for (let h = T + 1; h < d.length; h++) {
              const m = d[h];
              d[h - 1] = m, p[m]--;
            }
            p[S] = void 0, d.pop();
          }
          l.SetArray = n, l.get = c, l.pop = r, l.put = e, l.remove = f, Object.defineProperty(l, "__esModule", { value: true });
        })(t);
      }, "./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js": function(P, t) {
        (function(l) {
          const c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = new Uint8Array(64), r = new Uint8Array(128);
          for (let W = 0; W < c.length; W++) {
            const X = c.charCodeAt(W);
            e[W] = X, r[X] = W;
          }
          function f(W, X) {
            let H = 0, U = 0, q = 0;
            do {
              const re = W.next();
              q = r[re], H |= (31 & q) << U, U += 5;
            } while (32 & q);
            const ee = 1 & H;
            return H >>>= 1, ee && (H = -2147483648 | -H), X + H;
          }
          function y(W, X, H) {
            let U = X - H;
            U = U < 0 ? -U << 1 | 1 : U << 1;
            do {
              let q = 31 & U;
              U >>>= 5, U > 0 && (q |= 32), W.write(e[q]);
            } while (U > 0);
            return X;
          }
          function S(W, X) {
            return !(W.pos >= X) && W.peek() !== 44;
          }
          const T = 16384, d = typeof TextDecoder < "u" ? new TextDecoder() : typeof Buffer < "u" ? { decode: (W) => Buffer.from(W.buffer, W.byteOffset, W.byteLength).toString() } : { decode(W) {
            let X = "";
            for (let H = 0; H < W.length; H++) X += String.fromCharCode(W[H]);
            return X;
          } };
          class p {
            constructor() {
              this.pos = 0, this.out = "", this.buffer = new Uint8Array(T);
            }
            write(X) {
              const { buffer: H } = this;
              H[this.pos++] = X, this.pos === T && (this.out += d.decode(H), this.pos = 0);
            }
            flush() {
              const { buffer: X, out: H, pos: U } = this;
              return U > 0 ? H + d.decode(X.subarray(0, U)) : H;
            }
          }
          class h {
            constructor(X) {
              this.pos = 0, this.buffer = X;
            }
            next() {
              return this.buffer.charCodeAt(this.pos++);
            }
            peek() {
              return this.buffer.charCodeAt(this.pos);
            }
            indexOf(X) {
              const { buffer: H, pos: U } = this, q = H.indexOf(X, U);
              return q === -1 ? H.length : q;
            }
          }
          const m = [];
          function E(W) {
            const { length: X } = W, H = new h(W), U = [], q = [];
            let ee = 0;
            for (; H.pos < X; H.pos++) {
              ee = f(H, ee);
              const re = f(H, 0);
              if (!S(H, X)) {
                const B = q.pop();
                B[2] = ee, B[3] = re;
                continue;
              }
              const Y = f(H, 0), Z = 1 & f(H, 0) ? [ee, re, 0, 0, Y, f(H, 0)] : [ee, re, 0, 0, Y];
              let G = m;
              if (S(H, X)) {
                G = [];
                do {
                  const B = f(H, 0);
                  G.push(B);
                } while (S(H, X));
              }
              Z.vars = G, U.push(Z), q.push(Z);
            }
            return U;
          }
          function _(W) {
            const X = new p();
            for (let H = 0; H < W.length; ) H = C(W, H, X, [0]);
            return X.flush();
          }
          function C(W, X, H, U) {
            const q = W[X], { 0: ee, 1: re, 2: Y, 3: Z, 4: G, vars: B } = q;
            X > 0 && H.write(44), U[0] = y(H, ee, U[0]), y(H, re, 0), y(H, G, 0), y(H, q.length === 6 ? 1 : 0, 0), q.length === 6 && y(H, q[5], 0);
            for (const z of B) y(H, z, 0);
            for (X++; X < W.length; ) {
              const z = W[X], { 0: M, 1: K } = z;
              if (M > Y || M === Y && K >= Z) break;
              X = C(W, X, H, U);
            }
            return H.write(44), U[0] = y(H, Y, U[0]), y(H, Z, 0), X;
          }
          function w(W) {
            const { length: X } = W, H = new h(W), U = [], q = [];
            let ee = 0, re = 0, Y = 0, Z = 0, G = 0, B = 0, z = 0, M = 0;
            do {
              const K = H.indexOf(";");
              let Q = 0;
              for (; H.pos < K; H.pos++) {
                if (Q = f(H, Q), !S(H, K)) {
                  const Pe = q.pop();
                  Pe[2] = ee, Pe[3] = Q;
                  continue;
                }
                const ie = f(H, 0), ue = 2 & ie, ge = 4 & ie;
                let Te, le = null, fe = m;
                if (1 & ie) {
                  const Pe = f(H, re);
                  Y = f(H, re === Pe ? Y : 0), re = Pe, Te = [ee, Q, 0, 0, Pe, Y];
                } else Te = [ee, Q, 0, 0];
                if (Te.isScope = !!ge, ue) {
                  const Pe = Z, xe = G;
                  Z = f(H, Z);
                  const we = Pe === Z;
                  G = f(H, we ? G : 0), B = f(H, we && xe === G ? B : 0), le = [Z, G, B];
                }
                if (Te.callsite = le, S(H, K)) {
                  fe = [];
                  do {
                    z = ee, M = Q;
                    const Pe = f(H, 0);
                    let xe;
                    if (Pe < -1) {
                      xe = [[f(H, 0)]];
                      for (let we = -1; we > Pe; we--) {
                        const me = z;
                        z = f(H, z), M = f(H, z === me ? M : 0);
                        const ye = f(H, 0);
                        xe.push([ye, z, M]);
                      }
                    } else xe = [[Pe]];
                    fe.push(xe);
                  } while (S(H, K));
                }
                Te.bindings = fe, U.push(Te), q.push(Te);
              }
              ee++, H.pos = K + 1;
            } while (H.pos < X);
            return U;
          }
          function I(W) {
            if (W.length === 0) return "";
            const X = new p();
            for (let H = 0; H < W.length; ) H = D(W, H, X, [0, 0, 0, 0, 0, 0, 0]);
            return X.flush();
          }
          function D(W, X, H, U) {
            const q = W[X], { 0: ee, 1: re, 2: Y, 3: Z, isScope: G, callsite: B, bindings: z } = q;
            if (U[0] < ee ? (j(H, U[0], ee), U[0] = ee, U[1] = 0) : X > 0 && H.write(44), U[1] = y(H, q[1], U[1]), y(H, (q.length === 6 ? 1 : 0) | (B ? 2 : 0) | (G ? 4 : 0), 0), q.length === 6) {
              const { 4: M, 5: K } = q;
              M !== U[2] && (U[3] = 0), U[2] = y(H, M, U[2]), U[3] = y(H, K, U[3]);
            }
            if (B) {
              const { 0: M, 1: K, 2: Q } = q.callsite;
              M !== U[4] ? (U[5] = 0, U[6] = 0) : K !== U[5] && (U[6] = 0), U[4] = y(H, M, U[4]), U[5] = y(H, K, U[5]), U[6] = y(H, Q, U[6]);
            }
            if (z) for (const M of z) {
              M.length > 1 && y(H, -M.length, 0), y(H, M[0][0], 0);
              let K = ee, Q = re;
              for (let ie = 1; ie < M.length; ie++) {
                const ue = M[ie];
                K = y(H, ue[1], K), Q = y(H, ue[2], Q), y(H, ue[0], 0);
              }
            }
            for (X++; X < W.length; ) {
              const M = W[X], { 0: K, 1: Q } = M;
              if (K > Y || K === Y && Q >= Z) break;
              X = D(W, X, H, U);
            }
            return U[0] < Y ? (j(H, U[0], Y), U[0] = Y, U[1] = 0) : H.write(44), U[1] = y(H, Z, U[1]), X;
          }
          function j(W, X, H) {
            do
              W.write(59);
            while (++X < H);
          }
          function L(W) {
            const { length: X } = W, H = new h(W), U = [];
            let q = 0, ee = 0, re = 0, Y = 0, Z = 0;
            do {
              const G = H.indexOf(";"), B = [];
              let z = true, M = 0;
              for (q = 0; H.pos < G; ) {
                let K;
                q = f(H, q), q < M && (z = false), M = q, S(H, G) ? (ee = f(H, ee), re = f(H, re), Y = f(H, Y), S(H, G) ? (Z = f(H, Z), K = [q, ee, re, Y, Z]) : K = [q, ee, re, Y]) : K = [q], B.push(K), H.pos++;
              }
              z || k(B), U.push(B), H.pos = G + 1;
            } while (H.pos <= X);
            return U;
          }
          function k(W) {
            W.sort(N);
          }
          function N(W, X) {
            return W[0] - X[0];
          }
          function F(W) {
            const X = new p();
            let H = 0, U = 0, q = 0, ee = 0;
            for (let re = 0; re < W.length; re++) {
              const Y = W[re];
              if (re > 0 && X.write(59), Y.length === 0) continue;
              let Z = 0;
              for (let G = 0; G < Y.length; G++) {
                const B = Y[G];
                G > 0 && X.write(44), Z = y(X, B[0], Z), B.length !== 1 && (H = y(X, B[1], H), U = y(X, B[2], U), q = y(X, B[3], q), B.length !== 4 && (ee = y(X, B[4], ee)));
              }
            }
            return X.flush();
          }
          l.decode = L, l.decodeGeneratedRanges = w, l.decodeOriginalScopes = E, l.encode = F, l.encodeGeneratedRanges = I, l.encodeOriginalScopes = _, Object.defineProperty(l, "__esModule", { value: true });
        })(t);
      }, "./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js": function(P, t, l) {
        (function(n, u, c) {
          function e(Ie, Re) {
            return Re && !Re.endsWith("/") && (Re += "/"), c(Ie, Re);
          }
          function r(Ie) {
            if (!Ie) return "";
            const Re = Ie.lastIndexOf("/");
            return Ie.slice(0, Re + 1);
          }
          const f = 0, y = 1, S = 2, T = 3, d = 4, p = 1, h = 2;
          function m(Ie, Re) {
            const Be = E(Ie, 0);
            if (Be === Ie.length) return Ie;
            Re || (Ie = Ie.slice());
            for (let je = Be; je < Ie.length; je = E(Ie, je + 1)) Ie[je] = C(Ie[je], Re);
            return Ie;
          }
          function E(Ie, Re) {
            for (let Be = Re; Be < Ie.length; Be++) if (!_(Ie[Be])) return Be;
            return Ie.length;
          }
          function _(Ie) {
            for (let Re = 1; Re < Ie.length; Re++) if (Ie[Re][f] < Ie[Re - 1][f]) return false;
            return true;
          }
          function C(Ie, Re) {
            return Re || (Ie = Ie.slice()), Ie.sort(w);
          }
          function w(Ie, Re) {
            return Ie[f] - Re[f];
          }
          let I = false;
          function D(Ie, Re, Be, je) {
            for (; Be <= je; ) {
              const he = Be + (je - Be >> 1), oe = Ie[he][f] - Re;
              if (oe === 0) return I = true, he;
              oe < 0 ? Be = he + 1 : je = he - 1;
            }
            return I = false, Be - 1;
          }
          function j(Ie, Re, Be) {
            for (let je = Be + 1; je < Ie.length && Ie[je][f] === Re; Be = je++) ;
            return Be;
          }
          function L(Ie, Re, Be) {
            for (let je = Be - 1; je >= 0 && Ie[je][f] === Re; Be = je--) ;
            return Be;
          }
          function k() {
            return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
          }
          function N(Ie, Re, Be, je) {
            const { lastKey: he, lastNeedle: oe, lastIndex: _e } = Be;
            let Ne = 0, $e = Ie.length - 1;
            if (je === he) {
              if (Re === oe) return I = _e !== -1 && Ie[_e][f] === Re, _e;
              Re >= oe ? Ne = _e === -1 ? 0 : _e : $e = _e;
            }
            return Be.lastKey = je, Be.lastNeedle = Re, Be.lastIndex = D(Ie, Re, Ne, $e);
          }
          function F(Ie, Re) {
            const Be = Re.map(X);
            for (let je = 0; je < Ie.length; je++) {
              const he = Ie[je];
              for (let oe = 0; oe < he.length; oe++) {
                const _e = he[oe];
                if (_e.length === 1) continue;
                const Ne = _e[y], $e = _e[S], Xe = _e[T], Je = Be[Ne], st = Je[$e] || (Je[$e] = []), be = Re[Ne];
                let ke = j(st, Xe, N(st, Xe, be, $e));
                be.lastIndex = ++ke, W(st, ke, [Xe, je, _e[f]]);
              }
            }
            return Be;
          }
          function W(Ie, Re, Be) {
            for (let je = Ie.length; je > Re; je--) Ie[je] = Ie[je - 1];
            Ie[Re] = Be;
          }
          function X() {
            return { __proto__: null };
          }
          const H = function(Ie, Re) {
            const Be = U(Ie);
            if (!("sections" in Be)) return new M(Be, Re);
            const je = [], he = [], oe = [], _e = [], Ne = [];
            return q(Be, Re, je, he, oe, _e, Ne, 0, 0, 1 / 0, 1 / 0), me({ version: 3, file: Be.file, names: _e, sources: he, sourcesContent: oe, mappings: je, ignoreList: Ne });
          };
          function U(Ie) {
            return typeof Ie == "string" ? JSON.parse(Ie) : Ie;
          }
          function q(Ie, Re, Be, je, he, oe, _e, Ne, $e, Xe, Je) {
            const { sections: st } = Ie;
            for (let be = 0; be < st.length; be++) {
              const { map: ke, offset: Ve } = st[be];
              let ze = Xe, rt = Je;
              if (be + 1 < st.length) {
                const it = st[be + 1].offset;
                ze = Math.min(Xe, Ne + it.line), ze === Xe ? rt = Math.min(Je, $e + it.column) : ze < Xe && (rt = $e + it.column);
              }
              ee(ke, Re, Be, je, he, oe, _e, Ne + Ve.line, $e + Ve.column, ze, rt);
            }
          }
          function ee(Ie, Re, Be, je, he, oe, _e, Ne, $e, Xe, Je) {
            const st = U(Ie);
            if ("sections" in st) return q(...arguments);
            const be = new M(st, Re), ke = je.length, Ve = oe.length, ze = ie(be), { resolvedSources: rt, sourcesContent: it, ignoreList: Ye } = be;
            if (re(je, rt), re(oe, be.names), it) re(he, it);
            else for (let tt = 0; tt < rt.length; tt++) he.push(null);
            if (Ye) for (let tt = 0; tt < Ye.length; tt++) _e.push(Ye[tt] + ke);
            for (let tt = 0; tt < ze.length; tt++) {
              const pt = Ne + tt;
              if (pt > Xe) return;
              const Et = Y(Be, pt), Qe = tt === 0 ? $e : 0, yt = ze[tt];
              for (let vt = 0; vt < yt.length; vt++) {
                const kt = yt[vt], qt = Qe + kt[f];
                if (pt === Xe && qt >= Je) return;
                if (kt.length === 1) {
                  Et.push([qt]);
                  continue;
                }
                const sn = ke + kt[y], _n = kt[S], bn = kt[T];
                Et.push(kt.length === 4 ? [qt, sn, _n, bn] : [qt, sn, _n, bn, Ve + kt[d]]);
              }
            }
          }
          function re(Ie, Re) {
            for (let Be = 0; Be < Re.length; Be++) Ie.push(Re[Be]);
          }
          function Y(Ie, Re) {
            for (let Be = Ie.length; Be <= Re; Be++) Ie[Be] = [];
            return Ie[Re];
          }
          const Z = "`line` must be greater than 0 (lines start at line 1)", G = "`column` must be greater than or equal to 0 (columns start at column 0)", B = -1, z = 1;
          class M {
            constructor(Re, Be) {
              const je = typeof Re == "string";
              if (!je && Re._decodedMemo) return Re;
              const he = je ? JSON.parse(Re) : Re, { version: oe, file: _e, names: Ne, sourceRoot: $e, sources: Xe, sourcesContent: Je } = he;
              this.version = oe, this.file = _e, this.names = Ne || [], this.sourceRoot = $e, this.sources = Xe, this.sourcesContent = Je, this.ignoreList = he.ignoreList || he.x_google_ignoreList || void 0;
              const st = e($e || "", r(Be));
              this.resolvedSources = Xe.map((ke) => e(ke || "", st));
              const { mappings: be } = he;
              typeof be == "string" ? (this._encoded = be, this._decoded = void 0) : (this._encoded = void 0, this._decoded = m(be, je)), this._decodedMemo = k(), this._bySources = void 0, this._bySourceMemos = void 0;
            }
          }
          function K(Ie) {
            return Ie;
          }
          function Q(Ie) {
            var Re, Be;
            return (Re = (Be = Ie)._encoded) !== null && Re !== void 0 ? Re : Be._encoded = u.encode(Ie._decoded);
          }
          function ie(Ie) {
            var Re;
            return (Re = Ie)._decoded || (Re._decoded = u.decode(Ie._encoded));
          }
          function ue(Ie, Re, Be) {
            const je = ie(Ie);
            if (Re >= je.length) return null;
            const he = je[Re], oe = Ue(he, Ie._decodedMemo, Re, Be, z);
            return oe === -1 ? null : he[oe];
          }
          function ge(Ie, Re) {
            let { line: Be, column: je, bias: he } = Re;
            if (Be--, Be < 0) throw new Error(Z);
            if (je < 0) throw new Error(G);
            const oe = ie(Ie);
            if (Be >= oe.length) return Ee(null, null, null, null);
            const _e = oe[Be], Ne = Ue(_e, Ie._decodedMemo, Be, je, he || z);
            if (Ne === -1) return Ee(null, null, null, null);
            const $e = _e[Ne];
            if ($e.length === 1) return Ee(null, null, null, null);
            const { names: Xe, resolvedSources: Je } = Ie;
            return Ee(Je[$e[y]], $e[S] + 1, $e[T], $e.length === 5 ? Xe[$e[d]] : null);
          }
          function Te(Ie, Re) {
            const { source: Be, line: je, column: he, bias: oe } = Re;
            return He(Ie, Be, je, he, oe || z, false);
          }
          function le(Ie, Re) {
            const { source: Be, line: je, column: he, bias: oe } = Re;
            return He(Ie, Be, je, he, oe || B, true);
          }
          function fe(Ie, Re) {
            const Be = ie(Ie), { names: je, resolvedSources: he } = Ie;
            for (let oe = 0; oe < Be.length; oe++) {
              const _e = Be[oe];
              for (let Ne = 0; Ne < _e.length; Ne++) {
                const $e = _e[Ne], Xe = oe + 1, Je = $e[0];
                let st = null, be = null, ke = null, Ve = null;
                $e.length !== 1 && (st = he[$e[1]], be = $e[2] + 1, ke = $e[3]), $e.length === 5 && (Ve = je[$e[4]]), Re({ generatedLine: Xe, generatedColumn: Je, source: st, originalLine: be, originalColumn: ke, name: Ve });
              }
            }
          }
          function Pe(Ie, Re) {
            const { sources: Be, resolvedSources: je } = Ie;
            let he = Be.indexOf(Re);
            return he === -1 && (he = je.indexOf(Re)), he;
          }
          function xe(Ie, Re) {
            const { sourcesContent: Be } = Ie;
            if (Be == null) return null;
            const je = Pe(Ie, Re);
            return je === -1 ? null : Be[je];
          }
          function we(Ie, Re) {
            const { ignoreList: Be } = Ie;
            if (Be == null) return false;
            const je = Pe(Ie, Re);
            return je !== -1 && Be.includes(je);
          }
          function me(Ie, Re) {
            const Be = new M(J(Ie, []), Re);
            return Be._decoded = Ie.mappings, Be;
          }
          function ye(Ie) {
            return J(Ie, ie(Ie));
          }
          function pe(Ie) {
            return J(Ie, Q(Ie));
          }
          function J(Ie, Re) {
            return { version: Ie.version, file: Ie.file, names: Ie.names, sourceRoot: Ie.sourceRoot, sources: Ie.sources, sourcesContent: Ie.sourcesContent, mappings: Re, ignoreList: Ie.ignoreList || Ie.x_google_ignoreList };
          }
          function Ee(Ie, Re, Be, je) {
            return { source: Ie, line: Re, column: Be, name: je };
          }
          function Me(Ie, Re) {
            return { line: Ie, column: Re };
          }
          function Ue(Ie, Re, Be, je, he) {
            let oe = N(Ie, je, Re, Be);
            return I ? oe = (he === B ? j : L)(Ie, je, oe) : he === B && oe++, oe === -1 || oe === Ie.length ? -1 : oe;
          }
          function qe(Ie, Re, Be, je, he) {
            let oe = Ue(Ie, Re, Be, je, z);
            if (I || he !== B || oe++, oe === -1 || oe === Ie.length) return [];
            const _e = I ? je : Ie[oe][f];
            I || (oe = L(Ie, _e, oe));
            const Ne = j(Ie, _e, oe), $e = [];
            for (; oe <= Ne; oe++) {
              const Xe = Ie[oe];
              $e.push(Me(Xe[p] + 1, Xe[h]));
            }
            return $e;
          }
          function He(Ie, Re, Be, je, he, oe) {
            var _e;
            if (--Be < 0) throw new Error(Z);
            if (je < 0) throw new Error(G);
            const { sources: Ne, resolvedSources: $e } = Ie;
            let Xe = Ne.indexOf(Re);
            if (Xe === -1 && (Xe = $e.indexOf(Re)), Xe === -1) return oe ? [] : Me(null, null);
            const Je = ((_e = Ie)._bySources || (_e._bySources = F(ie(Ie), Ie._bySourceMemos = Ne.map(k))))[Xe][Be];
            if (Je == null) return oe ? [] : Me(null, null);
            const st = Ie._bySourceMemos[Xe];
            if (oe) return qe(Je, st, Be, je, he);
            const be = Ue(Je, st, Be, je, he);
            if (be === -1) return Me(null, null);
            const ke = Je[be];
            return Me(ke[p] + 1, ke[h]);
          }
          n.AnyMap = H, n.GREATEST_LOWER_BOUND = z, n.LEAST_UPPER_BOUND = B, n.TraceMap = M, n.allGeneratedPositionsFor = le, n.decodedMap = ye, n.decodedMappings = ie, n.eachMapping = fe, n.encodedMap = pe, n.encodedMappings = Q, n.generatedPositionFor = Te, n.isIgnored = we, n.originalPositionFor = ge, n.presortedDecodedMap = me, n.sourceContentFor = xe, n.traceSegment = ue;
        })(t, l("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.0/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"), l("./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"));
      }, "./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          var c = (0, n.createDynamicImportTransform)(u);
          return { manipulateOptions: function(e, r) {
            r.plugins.push("dynamicImport");
          }, visitor: { Import: function(e) {
            c(this, e);
          } } };
        };
        var n = l("./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/utils.js");
        P.exports = t.default;
      }, "./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/utils.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true });
        var l = function(u, c) {
          if (Array.isArray(u)) return u;
          if (Symbol.iterator in Object(u)) return function(e, r) {
            var f = [], y = true, S = false, T = void 0;
            try {
              for (var d, p = e[Symbol.iterator](); !(y = (d = p.next()).done) && (f.push(d.value), !r || f.length !== r); y = true) ;
            } catch (h) {
              S = true, T = h;
            } finally {
              try {
                !y && p.return && p.return();
              } finally {
                if (S) throw T;
              }
            }
            return f;
          }(u, c);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
        function n(u, c) {
          var e = c.arguments, r = l(e, 1)[0];
          return u.isStringLiteral(r) || u.isTemplateLiteral(r) ? (u.removeComments(r), r) : u.templateLiteral([u.templateElement({ raw: "", cooked: "" }), u.templateElement({ raw: "", cooked: "" }, true)], e);
        }
        t.getImportSource = n, t.createDynamicImportTransform = function(u) {
          var c = u.template, e = u.types, r = { static: { interop: c("Promise.resolve().then(() => INTEROP(require(SOURCE)))"), noInterop: c("Promise.resolve().then(() => require(SOURCE))") }, dynamic: { interop: c("Promise.resolve(SOURCE).then(s => INTEROP(require(s)))"), noInterop: c("Promise.resolve(SOURCE).then(s => require(s))") } }, f = typeof WeakSet == "function" && /* @__PURE__ */ new WeakSet();
          return function(y, S) {
            if (f) {
              if (f.has(S)) return;
              f.add(S);
            }
            var T, d = n(e, S.parent), p = (T = d, e.isStringLiteral(T) || e.isTemplateLiteral(T) && T.expressions.length === 0 ? r.static : r.dynamic), h = y.opts.noInterop ? p.noInterop({ SOURCE: d }) : p.interop({ SOURCE: d, INTEROP: y.addHelper("interopRequireWildcard") });
            S.parentPath.replaceWith(h);
          };
        };
      }, "./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js": (P, t, l) => {
        var n = l("path");
        function u(c) {
          switch (c.parent.type) {
            case "TSTypeReference":
            case "TSQualifiedName":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return true;
            default:
              return false;
          }
        }
        P.exports = function(c) {
          var e = c.types, r = function(y, S) {
            return function(T) {
              var d = e.callExpression(y.expression, [e.Identifier(T), e.Identifier("undefined"), e.NumericLiteral(S.key)]), p = e.logicalExpression("||", d, e.Identifier(T)), h = e.assignmentExpression("=", e.Identifier(T), p);
              return e.expressionStatement(h);
            };
          }, f = function(y, S) {
            return function(T, d) {
              var p = e.callExpression(y.expression, [e.Identifier("".concat(T, ".prototype")), e.StringLiteral(d), e.NumericLiteral(S.key)]);
              return e.expressionStatement(p);
            };
          };
          return { visitor: { Program: function(y, S) {
            var T = (0, n.extname)(S.file.opts.filename);
            T !== ".ts" && T !== ".tsx" || function() {
              var d = /* @__PURE__ */ Object.create(null);
              y.node.body.filter(function(N) {
                var F = N.type, W = N.declaration;
                switch (F) {
                  case "ClassDeclaration":
                    return true;
                  case "ExportNamedDeclaration":
                  case "ExportDefaultDeclaration":
                    return W && W.type === "ClassDeclaration";
                  default:
                    return false;
                }
              }).map(function(N) {
                return N.type === "ClassDeclaration" ? N : N.declaration;
              }).forEach(function(N) {
                N.body.body.forEach(function(F) {
                  (F.params || []).forEach(function(W) {
                    (W.decorators || []).forEach(function(X) {
                      X.expression.callee ? d[X.expression.callee.name] = X : d[X.expression.name] = X;
                    });
                  });
                });
              });
              var p = true, h = false, m = void 0;
              try {
                for (var E, _ = y.get("body")[Symbol.iterator](); !(p = (E = _.next()).done); p = true) {
                  var C = E.value;
                  if (C.node.type === "ImportDeclaration") {
                    if (C.node.specifiers.length === 0) continue;
                    var w = true, I = false, D = void 0;
                    try {
                      for (var j, L = function() {
                        var N = j.value, F = C.scope.getBinding(N.local.name);
                        F.referencePaths.length ? F.referencePaths.reduce(function(W, X) {
                          return W || u(X);
                        }, false) && Object.keys(d).forEach(function(W) {
                          var X = d[W];
                          (X.expression.arguments || []).forEach(function(H) {
                            H.name === N.local.name && F.referencePaths.push({ parent: X.expression });
                          });
                        }) : d[N.local.name] && F.referencePaths.push({ parent: d[N.local.name] });
                      }, k = C.node.specifiers[Symbol.iterator](); !(w = (j = k.next()).done); w = true) L();
                    } catch (N) {
                      I = true, D = N;
                    } finally {
                      try {
                        w || k.return == null || k.return();
                      } finally {
                        if (I) throw D;
                      }
                    }
                  }
                }
              } catch (N) {
                h = true, m = N;
              } finally {
                try {
                  p || _.return == null || _.return();
                } finally {
                  if (h) throw m;
                }
              }
            }();
          }, Function: function(y) {
            var S = "";
            y.node.id ? S = y.node.id.name : y.node.key && (S = y.node.key.name), (y.get("params") || []).slice().forEach(function(T) {
              var d = T.node.decorators || [], p = d.length;
              if (d.slice().forEach(function(m) {
                if (y.type === "ClassMethod") {
                  var E, _ = y.parentPath.parentPath, C = y.findParent(function(N) {
                    return N.type === "ClassDeclaration";
                  });
                  if (C ? E = C.node.id.name : (_.insertAfter(null), E = function(N) {
                    var F = N.findParent(function(W) {
                      return W.node.type === "AssignmentExpression";
                    });
                    return F.node.right.type === "SequenceExpression" ? F.node.right.expressions[1].name : F.node.right.type === "ClassExpression" ? F.node.left.name : null;
                  }(y)), S === "constructor") {
                    var w = r(m, T)(E);
                    _.insertAfter(w);
                  } else {
                    var I = f(m, T)(E, S);
                    _.insertAfter(I);
                  }
                } else {
                  var D = y.findParent(function(N) {
                    return N.node.type === "VariableDeclarator";
                  }).node.id.name;
                  if (S === D) {
                    var j = r(m, T)(D);
                    y.parentKey === "body" ? y.insertAfter(j) : y.findParent(function(N) {
                      return N.parentKey === "body";
                    }).insertAfter(j);
                  } else {
                    var L = y.findParent(function(N) {
                      return N.node.type === "CallExpression";
                    }), k = f(m, T)(D, S);
                    L.insertAfter(k);
                  }
                }
              }), p) {
                var h = function(m) {
                  switch (m.node.type) {
                    case "ObjectPattern":
                      return e.ObjectPattern(m.node.properties);
                    case "AssignmentPattern":
                      return e.AssignmentPattern(m.node.left, m.node.right);
                    case "TSParameterProperty":
                      return e.Identifier(m.node.parameter.name);
                    default:
                      return e.Identifier(m.node.name);
                  }
                }(T);
                T.replaceWith(h);
              }
            });
          } } };
        };
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.26.0_@babel+traverse@7.26.4/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/metadataVisitor.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.metadataVisitor = function(e, r) {
          const f = r.node, y = e.node;
          switch (f.type) {
            case "ClassMethod":
              const S = f.kind === "constructor" ? y.decorators : f.decorators;
              if (!S || S.length === 0) return;
              S.push(c("design:type", n.types.identifier("Function"))), S.push(c("design:paramtypes", n.types.arrayExpression(f.params.map((T) => (0, u.serializeType)(e, T)))));
              break;
            case "ClassProperty":
              if (!f.decorators || f.decorators.length === 0 || !f.typeAnnotation || f.typeAnnotation.type !== "TSTypeAnnotation") return;
              f.decorators.push(c("design:type", (0, u.serializeType)(e, f)));
          }
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.26.0_@babel+traverse@7.26.4/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/serializeType.js");
        function c(e, r) {
          return n.types.decorator(n.types.callExpression(n.types.memberExpression(n.types.identifier("Reflect"), n.types.identifier("metadata")), [n.types.stringLiteral(e), r]));
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.26.0_@babel+traverse@7.26.4/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/serializeType.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.serializeType = function(T, d) {
          const p = c(d);
          if (p == null || !p.typeAnnotation || p.typeAnnotation.type !== "TSTypeAnnotation") return u();
          const h = p.typeAnnotation.typeAnnotation;
          return y(T.node.id ? T.node.id.name : "", h);
        }, t.isClassType = r;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");
        function u() {
          return n.types.unaryExpression("void", n.types.numericLiteral(0));
        }
        function c(T) {
          return T == null ? null : T.type === "ClassProperty" || T.type === "Identifier" || T.type === "ObjectPattern" ? T : T.type === "AssignmentPattern" && T.left.type === "Identifier" ? T.left : T.type === "TSParameterProperty" ? c(T.parameter) : null;
        }
        function e(T, d) {
          const p = f(d.typeName);
          return r(T, p) ? n.types.identifier("Object") : n.types.conditionalExpression(n.types.binaryExpression("===", n.types.unaryExpression("typeof", p), n.types.stringLiteral("undefined")), n.types.identifier("Object"), n.types.cloneDeep(p));
        }
        function r(T, d) {
          switch (d.type) {
            case "Identifier":
              return d.name === T;
            case "MemberExpression":
              return r(T, d.object);
            default:
              throw new Error(`The property expression at ${d.start} is not valid as a Type to be used in Reflect.metadata`);
          }
        }
        function f(T) {
          return T.type === "Identifier" ? n.types.identifier(T.name) : n.types.memberExpression(f(T.left), T.right);
        }
        function y(T, d) {
          if (d === void 0) return n.types.identifier("Object");
          switch (d.type) {
            case "TSVoidKeyword":
            case "TSUndefinedKeyword":
            case "TSNullKeyword":
            case "TSNeverKeyword":
              return u();
            case "TSParenthesizedType":
              return y(T, d.typeAnnotation);
            case "TSFunctionType":
            case "TSConstructorType":
              return n.types.identifier("Function");
            case "TSArrayType":
            case "TSTupleType":
              return n.types.identifier("Array");
            case "TSTypePredicate":
            case "TSBooleanKeyword":
              return n.types.identifier("Boolean");
            case "TSStringKeyword":
              return n.types.identifier("String");
            case "TSObjectKeyword":
              return n.types.identifier("Object");
            case "TSLiteralType":
              switch (d.literal.type) {
                case "StringLiteral":
                  return n.types.identifier("String");
                case "NumericLiteral":
                  return n.types.identifier("Number");
                case "BooleanLiteral":
                  return n.types.identifier("Boolean");
                default:
                  throw new Error("Bad type for decorator" + d.literal);
              }
            case "TSNumberKeyword":
            case "TSBigIntKeyword":
              return n.types.identifier("Number");
            case "TSSymbolKeyword":
              return n.types.identifier("Symbol");
            case "TSTypeReference":
              return e(T, d);
            case "TSIntersectionType":
            case "TSUnionType":
              return S(T, d.types);
            case "TSConditionalType":
              return S(T, [d.trueType, d.falseType]);
            case "TSTypeQuery":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSTypeLiteral":
            case "TSAnyKeyword":
            case "TSUnknownKeyword":
            case "TSThisType":
              break;
            default:
              throw new Error("Bad type for decorator");
          }
          return n.types.identifier("Object");
        }
        function S(T, d) {
          let p;
          for (let h of d) {
            for (; h.type === "TSParenthesizedType"; ) h = h.typeAnnotation;
            if (h.type === "TSNeverKeyword" || h.type === "TSNullKeyword" || h.type === "TSUndefinedKeyword") continue;
            const m = y(T, h);
            if (n.types.isIdentifier(m) && m.name === "Object") return m;
            if (p) {
              if (!n.types.isIdentifier(p) || !n.types.isIdentifier(m) || p.name !== m.name) return n.types.identifier("Object");
            } else p = m;
          }
          return p || u();
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.26.0_@babel+traverse@7.26.4/node_modules/babel-plugin-transform-typescript-metadata/lib/parameter/parameterVisitor.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.parameterVisitor = function(c, e) {
          if (e.type !== "ClassMethod" || e.node.type !== "ClassMethod" || e.node.key.type !== "Identifier") return;
          const r = e;
          (r.get("params") || []).slice().forEach(function(f) {
            let y;
            (f.node.type === "Identifier" || f.node.type === "ObjectPattern" ? f.node : f.node.type === "TSParameterProperty" && f.node.parameter.type === "Identifier" ? f.node.parameter : null) != null && ((f.node.decorators || []).slice().forEach(function(S) {
              r.node.kind === "constructor" ? (y = u(f.key, S.expression, true), c.node.decorators || (c.node.decorators = []), c.node.decorators.push(y)) : (y = u(f.key, S.expression, false), r.node.decorators || (r.node.decorators = []), r.node.decorators.push(y));
            }), y && (f.node.decorators = null));
          });
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");
        function u(c, e, r = false) {
          return n.types.decorator(n.types.functionExpression(null, [n.types.identifier("target"), n.types.identifier("key")], n.types.blockStatement([n.types.returnStatement(n.types.callExpression(e, [n.types.identifier("target"), n.types.identifier(r ? "undefined" : "key"), n.types.numericLiteral(c)]))])));
        }
      }, "./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.26.0_@babel+traverse@7.26.4/node_modules/babel-plugin-transform-typescript-metadata/lib/plugin.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"), u = l("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.26.0_@babel+traverse@7.26.4/node_modules/babel-plugin-transform-typescript-metadata/lib/parameter/parameterVisitor.js"), c = l("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.26.0_@babel+traverse@7.26.4/node_modules/babel-plugin-transform-typescript-metadata/lib/metadata/metadataVisitor.js"), e = (0, n.declare)((r) => (r.assertVersion(7), { visitor: { Program(f) {
          f.traverse({ ClassDeclaration(y) {
            for (const S of y.get("body").get("body")) S.type !== "ClassMethod" && S.type !== "ClassProperty" || ((0, u.parameterVisitor)(y, S), (0, c.metadataVisitor)(y, S));
            y.parentPath.scope.crawl();
          } });
        } } }));
        t.default = e;
      }, "./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js": (P, t) => {
        var l;
        function n(c, e) {
          (e = e || {}).hasComment && (c = function(r) {
            return r.split(",").pop();
          }(c)), e.encoding === "base64" ? c = l(c) : e.encoding === "uri" && (c = decodeURIComponent(c)), (e.isJSON || e.encoding) && (c = JSON.parse(c)), this.sourcemap = c;
        }
        function u(c) {
          return new n(c, { isJSON: true });
        }
        Object.defineProperty(t, "commentRegex", { get: function() {
          return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/gm;
        } }), Object.defineProperty(t, "mapFileCommentRegex", { get: function() {
          return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/gm;
        } }), l = typeof Buffer < "u" ? typeof Buffer.from == "function" ? function(c) {
          return Buffer.from(c, "base64").toString();
        } : function(c) {
          if (typeof value == "number") throw new TypeError("The value to decode must not be of type number.");
          return new Buffer(c, "base64").toString();
        } : function(c) {
          return decodeURIComponent(escape(atob(c)));
        }, n.prototype.toJSON = function(c) {
          return JSON.stringify(this.sourcemap, null, c);
        }, typeof Buffer < "u" ? typeof Buffer.from == "function" ? n.prototype.toBase64 = function() {
          var c = this.toJSON();
          return Buffer.from(c, "utf8").toString("base64");
        } : n.prototype.toBase64 = function() {
          var c = this.toJSON();
          if (typeof c == "number") throw new TypeError("The json to encode must not be of type number.");
          return new Buffer(c, "utf8").toString("base64");
        } : n.prototype.toBase64 = function() {
          var c = this.toJSON();
          return btoa(unescape(encodeURIComponent(c)));
        }, n.prototype.toURI = function() {
          var c = this.toJSON();
          return encodeURIComponent(c);
        }, n.prototype.toComment = function(c) {
          var e, r, f;
          return c != null && c.encoding === "uri" ? (e = "", r = this.toURI()) : (e = ";base64", r = this.toBase64()), f = "sourceMappingURL=data:application/json;charset=utf-8" + e + "," + r, c != null && c.multiline ? "/*# " + f + " */" : "//# " + f;
        }, n.prototype.toObject = function() {
          return JSON.parse(this.toJSON());
        }, n.prototype.addProperty = function(c, e) {
          if (this.sourcemap.hasOwnProperty(c)) throw new Error('property "' + c + '" already exists on the sourcemap, use set property instead');
          return this.setProperty(c, e);
        }, n.prototype.setProperty = function(c, e) {
          return this.sourcemap[c] = e, this;
        }, n.prototype.getProperty = function(c) {
          return this.sourcemap[c];
        }, t.fromObject = function(c) {
          return new n(c);
        }, t.fromJSON = function(c) {
          return new n(c, { isJSON: true });
        }, t.fromURI = function(c) {
          return new n(c, { encoding: "uri" });
        }, t.fromBase64 = function(c) {
          return new n(c, { encoding: "base64" });
        }, t.fromComment = function(c) {
          var e;
          return new n(c = c.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), { encoding: (e = t.commentRegex.exec(c)) && e[4] || "uri", hasComment: true });
        }, t.fromMapFileComment = function(c, e) {
          if (typeof e == "string") throw new Error("String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
          var r = function(f, y) {
            var S = t.mapFileCommentRegex.exec(f), T = S[1] || S[2];
            try {
              return (f = y(T)) != null && typeof f.catch == "function" ? f.catch(d) : f;
            } catch (p) {
              d(p);
            }
            function d(p) {
              throw new Error("An error occurred while trying to read the map file at " + T + `
` + p.stack);
            }
          }(c, e);
          return r != null && typeof r.then == "function" ? r.then(u) : u(r);
        }, t.fromSource = function(c) {
          var e = c.match(t.commentRegex);
          return e ? t.fromComment(e.pop()) : null;
        }, t.fromMapFileSource = function(c, e) {
          if (typeof e == "string") throw new Error("String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
          var r = c.match(t.mapFileCommentRegex);
          return r ? t.fromMapFileComment(r.pop(), e) : null;
        }, t.removeComments = function(c) {
          return c.replace(t.commentRegex, "");
        }, t.removeMapFileComments = function(c) {
          return c.replace(t.mapFileCommentRegex, "");
        }, t.generateMapFileComment = function(c, e) {
          var r = "sourceMappingURL=" + c;
          return e && e.multiline ? "/*# " + r + " */" : "//# " + r;
        };
      }, "./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js": (P, t, l) => {
        t.formatArgs = function(u) {
          if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + P.exports.humanize(this.diff), !this.useColors) return;
          const c = "color: " + this.color;
          u.splice(1, 0, c, "color: inherit");
          let e = 0, r = 0;
          u[0].replace(/%[a-zA-Z%]/g, (f) => {
            f !== "%%" && (e++, f === "%c" && (r = e));
          }), u.splice(r, 0, c);
        }, t.save = function(u) {
          try {
            u ? t.storage.setItem("debug", u) : t.storage.removeItem("debug");
          } catch {
          }
        }, t.load = function() {
          let u;
          try {
            u = t.storage.getItem("debug");
          } catch {
          }
          return !u && typeof process < "u" && "env" in process && (u = s.DEBUG), u;
        }, t.useColors = function() {
          if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
          if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
          let u;
          return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (u = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(u[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }, t.storage = function() {
          try {
            return localStorage;
          } catch {
          }
        }(), t.destroy = /* @__PURE__ */ (() => {
          let u = false;
          return () => {
            u || (u = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => {
        }), P.exports = l("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js")(t);
        const { formatters: n } = P.exports;
        n.j = function(u) {
          try {
            return JSON.stringify(u);
          } catch (c) {
            return "[UnexpectedJSONParseError]: " + c.message;
          }
        };
      }, "./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js": (P, t, l) => {
        P.exports = function(n) {
          function u(r) {
            let f, y, S, T = null;
            function d(...p) {
              if (!d.enabled) return;
              const h = d, m = Number(/* @__PURE__ */ new Date()), E = m - (f || m);
              h.diff = E, h.prev = f, h.curr = m, f = m, p[0] = u.coerce(p[0]), typeof p[0] != "string" && p.unshift("%O");
              let _ = 0;
              p[0] = p[0].replace(/%([a-zA-Z%])/g, (C, w) => {
                if (C === "%%") return "%";
                _++;
                const I = u.formatters[w];
                if (typeof I == "function") {
                  const D = p[_];
                  C = I.call(h, D), p.splice(_, 1), _--;
                }
                return C;
              }), u.formatArgs.call(h, p), (h.log || u.log).apply(h, p);
            }
            return d.namespace = r, d.useColors = u.useColors(), d.color = u.selectColor(r), d.extend = c, d.destroy = u.destroy, Object.defineProperty(d, "enabled", { enumerable: true, configurable: false, get: () => T !== null ? T : (y !== u.namespaces && (y = u.namespaces, S = u.enabled(r)), S), set: (p) => {
              T = p;
            } }), typeof u.init == "function" && u.init(d), d;
          }
          function c(r, f) {
            const y = u(this.namespace + (f === void 0 ? ":" : f) + r);
            return y.log = this.log, y;
          }
          function e(r, f) {
            let y = 0, S = 0, T = -1, d = 0;
            for (; y < r.length; ) if (S < f.length && (f[S] === r[y] || f[S] === "*")) f[S] === "*" ? (T = S, d = y, S++) : (y++, S++);
            else {
              if (T === -1) return false;
              S = T + 1, d++, y = d;
            }
            for (; S < f.length && f[S] === "*"; ) S++;
            return S === f.length;
          }
          return u.debug = u, u.default = u, u.coerce = function(r) {
            return r instanceof Error ? r.stack || r.message : r;
          }, u.disable = function() {
            const r = [...u.names, ...u.skips.map((f) => "-" + f)].join(",");
            return u.enable(""), r;
          }, u.enable = function(r) {
            u.save(r), u.namespaces = r, u.names = [], u.skips = [];
            const f = (typeof r == "string" ? r : "").trim().replace(" ", ",").split(",").filter(Boolean);
            for (const y of f) y[0] === "-" ? u.skips.push(y.slice(1)) : u.names.push(y);
          }, u.enabled = function(r) {
            for (const f of u.skips) if (e(r, f)) return false;
            for (const f of u.names) if (e(r, f)) return true;
            return false;
          }, u.humanize = l("./node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"), u.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(n).forEach((r) => {
            u[r] = n[r];
          }), u.names = [], u.skips = [], u.formatters = {}, u.selectColor = function(r) {
            let f = 0;
            for (let y = 0; y < r.length; y++) f = (f << 5) - f + r.charCodeAt(y), f |= 0;
            return u.colors[Math.abs(f) % u.colors.length];
          }, u.enable(u.load()), u;
        };
      }, "./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js": (P, t, l) => {
        typeof process > "u" || process.type === "renderer" || process.browser === true || process.__nwjs ? P.exports = l("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/browser.js") : P.exports = l("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js");
      }, "./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/node.js": (P, t, l) => {
        const n = l("tty"), u = l("util");
        t.init = function(e) {
          e.inspectOpts = {};
          const r = Object.keys(t.inspectOpts);
          for (let f = 0; f < r.length; f++) e.inspectOpts[r[f]] = t.inspectOpts[r[f]];
        }, t.log = function(...e) {
          return process.stderr.write(u.formatWithOptions(t.inspectOpts, ...e) + `
`);
        }, t.formatArgs = function(e) {
          const { namespace: r, useColors: f } = this;
          if (f) {
            const y = this.color, S = "\x1B[3" + (y < 8 ? y : "8;5;" + y), T = `  ${S};1m${r} \x1B[0m`;
            e[0] = T + e[0].split(`
`).join(`
` + T), e.push(S + "m+" + P.exports.humanize(this.diff) + "\x1B[0m");
          } else e[0] = function() {
            return t.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
          }() + r + " " + e[0];
        }, t.save = function(e) {
          e ? s.DEBUG = e : delete s.DEBUG;
        }, t.load = function() {
          return s.DEBUG;
        }, t.useColors = function() {
          return "colors" in t.inspectOpts ? !!t.inspectOpts.colors : n.isatty(process.stderr.fd);
        }, t.destroy = u.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), t.colors = [6, 2, 3, 4, 5, 1];
        try {
          const e = l("./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js");
          e && (e.stderr || e).level >= 2 && (t.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
        } catch {
        }
        t.inspectOpts = Object.keys(s).filter((e) => /^debug_/i.test(e)).reduce((e, r) => {
          const f = r.substring(6).toLowerCase().replace(/_([a-z])/g, (S, T) => T.toUpperCase());
          let y = s[r];
          return y = !!/^(yes|on|true|enabled)$/i.test(y) || !/^(no|off|false|disabled)$/i.test(y) && (y === "null" ? null : Number(y)), e[f] = y, e;
        }, {}), P.exports = l("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/common.js")(t);
        const { formatters: c } = P.exports;
        c.o = function(e) {
          return this.inspectOpts.colors = this.useColors, u.inspect(e, this.inspectOpts).split(`
`).map((r) => r.trim()).join(" ");
        }, c.O = function(e) {
          return this.inspectOpts.colors = this.useColors, u.inspect(e, this.inspectOpts);
        };
      }, "./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js": (P) => {
        const t = Symbol.for("gensync:v1:start"), l = Symbol.for("gensync:v1:suspend");
        function n(d, p, h, m) {
          if (typeof h === d || m && h === void 0) return;
          let E;
          throw E = m ? `Expected opts.${p} to be either a ${d}, or undefined.` : `Expected opts.${p} to be a ${d}.`, u(E, "GENSYNC_OPTIONS_ERROR");
        }
        function u(d, p) {
          return Object.assign(new Error(d), { code: p });
        }
        function c({ name: d, arity: p, sync: h, async: m }) {
          return T(d, p, function* (...E) {
            const _ = yield t;
            if (!_) return h.call(this, E);
            let C;
            try {
              m.call(this, E, (w) => {
                C || (C = { value: w }, _());
              }, (w) => {
                C || (C = { err: w }, _());
              });
            } catch (w) {
              C = { err: w }, _();
            }
            if (yield l, C.hasOwnProperty("err")) throw C.err;
            return C.value;
          });
        }
        function e(d) {
          let p;
          for (; !({ value: p } = d.next()).done; ) f(p, d);
          return p;
        }
        function r(d, p, h) {
          (function m() {
            try {
              let E;
              for (; !({ value: E } = d.next()).done; ) {
                f(E, d);
                let _ = true, C = false;
                const w = d.next(() => {
                  _ ? C = true : m();
                });
                if (_ = false, y(w, d), !C) return;
              }
              return p(E);
            } catch (E) {
              return h(E);
            }
          })();
        }
        function f(d, p) {
          d !== t && S(p, u(`Got unexpected yielded value in gensync generator: ${JSON.stringify(d)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, "GENSYNC_EXPECTED_START"));
        }
        function y({ value: d, done: p }, h) {
          (p || d !== l) && S(h, u(p ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(d)}. If you get this, it is probably a gensync bug.`, "GENSYNC_EXPECTED_SUSPEND"));
        }
        function S(d, p) {
          throw d.throw && d.throw(p), p;
        }
        function T(d, p, h) {
          if (typeof d == "string") {
            const m = Object.getOwnPropertyDescriptor(h, "name");
            m && !m.configurable || Object.defineProperty(h, "name", Object.assign(m || {}, { configurable: true, value: d }));
          }
          if (typeof p == "number") {
            const m = Object.getOwnPropertyDescriptor(h, "length");
            m && !m.configurable || Object.defineProperty(h, "length", Object.assign(m || {}, { configurable: true, value: p }));
          }
          return h;
        }
        P.exports = Object.assign(function(d) {
          let p = d;
          return p = typeof d != "function" ? function({ name: h, arity: m, sync: E, async: _, errback: C }) {
            if (n("string", "name", h, true), n("number", "arity", m, true), n("function", "sync", E), n("function", "async", _, true), n("function", "errback", C, true), _ && C) throw u("Expected one of either opts.async or opts.errback, but got _both_.", "GENSYNC_OPTIONS_ERROR");
            if (typeof h != "string") {
              let w;
              C && C.name && C.name !== "errback" && (w = C.name), _ && _.name && _.name !== "async" && (w = _.name.replace(/Async$/, "")), E && E.name && E.name !== "sync" && (w = E.name.replace(/Sync$/, "")), typeof w == "string" && (h = w);
            }
            return typeof m != "number" && (m = E.length), c({ name: h, arity: m, sync: function(w) {
              return E.apply(this, w);
            }, async: function(w, I, D) {
              _ ? _.apply(this, w).then(I, D) : C ? C.call(this, ...w, (j, L) => {
                j == null ? I(L) : D(j);
              }) : I(E.apply(this, w));
            } });
          }(d) : function(h) {
            return T(h.name, h.length, function(...m) {
              return h.apply(this, m);
            });
          }(d), Object.assign(p, /* @__PURE__ */ function(h) {
            return { sync: function(...E) {
              return e(h.apply(this, E));
            }, async: function(...E) {
              return new Promise((_, C) => {
                r(h.apply(this, E), _, C);
              });
            }, errback: function(...E) {
              const _ = E.pop();
              if (typeof _ != "function") throw u("Asynchronous function called without callback", "GENSYNC_ERRBACK_NO_CALLBACK");
              let C;
              try {
                C = h.apply(this, E);
              } catch (w) {
                return void _(w);
              }
              r(C, (w) => _(void 0, w), (w) => _(w));
            } };
          }(p));
        }, { all: c({ name: "all", arity: 1, sync: function(d) {
          return Array.from(d[0]).map((p) => e(p));
        }, async: function(d, p, h) {
          const m = Array.from(d[0]);
          if (m.length === 0) return void Promise.resolve().then(() => p([]));
          let E = 0;
          const _ = m.map(() => {
          });
          m.forEach((C, w) => {
            r(C, (I) => {
              _[w] = I, E += 1, E === _.length && p(_);
            }, h);
          });
        } }), race: c({ name: "race", arity: 1, sync: function(d) {
          const p = Array.from(d[0]);
          if (p.length === 0) throw u("Must race at least 1 item", "GENSYNC_RACE_NONEMPTY");
          return e(p[0]);
        }, async: function(d, p, h) {
          const m = Array.from(d[0]);
          if (m.length === 0) throw u("Must race at least 1 item", "GENSYNC_RACE_NONEMPTY");
          for (const E of m) r(E, p, h);
        } }) });
      }, "./node_modules/.pnpm/globals@11.12.0/node_modules/globals/index.js": (P, t, l) => {
        P.exports = l("./node_modules/.pnpm/globals@11.12.0/node_modules/globals/globals.json");
      }, "./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js": (P) => {
        P.exports = (t, l = process.argv) => {
          const n = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", u = l.indexOf(n + t), c = l.indexOf("--");
          return u !== -1 && (c === -1 || u < c);
        };
      }, "./node_modules/.pnpm/jsesc@3.1.0/node_modules/jsesc/jsesc.js": (P) => {
        const t = {}, l = t.hasOwnProperty, n = (E, _) => {
          for (const C in E) l.call(E, C) && _(C, E[C]);
        }, u = (E) => "\\u" + ("0000" + E).slice(-4), c = (E, _) => {
          let C = E.toString(16);
          return _ ? C : C.toUpperCase();
        }, e = t.toString, r = Array.isArray, f = (E) => typeof E == "bigint", y = { "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" }, S = /[\\\b\f\n\r\t]/, T = /[0-9]/, d = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, p = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g, h = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, m = (E, _) => {
          const C = () => {
            W = F, ++_.indentLevel, F = _.indent.repeat(_.indentLevel);
          }, w = { escapeEverything: false, minimal: false, isScriptContext: false, quotes: "single", wrap: false, es6: false, json: false, compact: true, lowercaseHex: false, numbers: "decimal", indent: "	", indentLevel: 0, __inline1__: false, __inline2__: false }, I = _ && _.json;
          var D, j;
          I && (w.quotes = "double", w.wrap = true), D = w, (_ = ((j = _) && n(j, (z, M) => {
            D[z] = M;
          }), D)).quotes != "single" && _.quotes != "double" && _.quotes != "backtick" && (_.quotes = "single");
          const L = _.quotes == "double" ? '"' : _.quotes == "backtick" ? "`" : "'", k = _.compact, N = _.lowercaseHex;
          let F = _.indent.repeat(_.indentLevel), W = "";
          const X = _.__inline1__, H = _.__inline2__, U = k ? "" : `
`;
          let q, ee = true;
          const re = _.numbers == "binary", Y = _.numbers == "octal", Z = _.numbers == "decimal", G = _.numbers == "hexadecimal";
          if (I && E && /* @__PURE__ */ ((z) => typeof z == "function")(E.toJSON) && (E = E.toJSON()), !((z) => typeof z == "string" || e.call(z) == "[object String]")(E)) {
            if (((z) => e.call(z) == "[object Map]")(E)) return E.size == 0 ? "new Map()" : (k || (_.__inline1__ = true, _.__inline2__ = false), "new Map(" + m(Array.from(E), _) + ")");
            if (((z) => e.call(z) == "[object Set]")(E)) return E.size == 0 ? "new Set()" : "new Set(" + m(Array.from(E), _) + ")";
            if (((z) => typeof Buffer == "function" && Buffer.isBuffer(z))(E)) return E.length == 0 ? "Buffer.from([])" : "Buffer.from(" + m(Array.from(E), _) + ")";
            if (r(E)) return q = [], _.wrap = true, X && (_.__inline1__ = false, _.__inline2__ = true), H || C(), ((z, M) => {
              const K = z.length;
              let Q = -1;
              for (; ++Q < K; ) M(z[Q]);
            })(E, (z) => {
              ee = false, H && (_.__inline2__ = false), q.push((k || H ? "" : F) + m(z, _));
            }), ee ? "[]" : H ? "[" + q.join(", ") + "]" : "[" + U + q.join("," + U) + U + (k ? "" : W) + "]";
            if (((z) => typeof z == "number" || e.call(z) == "[object Number]")(E) || f(E)) {
              if (I) return JSON.stringify(Number(E));
              let z;
              if (Z) z = String(E);
              else if (G) {
                let M = E.toString(16);
                N || (M = M.toUpperCase()), z = "0x" + M;
              } else re ? z = "0b" + E.toString(2) : Y && (z = "0o" + E.toString(8));
              return f(E) ? z + "n" : z;
            }
            return f(E) ? I ? JSON.stringify(Number(E)) : E + "n" : ((z) => e.call(z) == "[object Object]")(E) ? (q = [], _.wrap = true, C(), n(E, (z, M) => {
              ee = false, q.push((k ? "" : F) + m(z, _) + ":" + (k ? "" : " ") + m(M, _));
            }), ee ? "{}" : "{" + U + q.join("," + U) + U + (k ? "" : W) + "}") : I ? JSON.stringify(E) || "null" : String(E);
          }
          const B = _.escapeEverything ? p : h;
          return q = E.replace(B, (z, M, K, Q, ie, ue) => {
            if (M) {
              if (_.minimal) return M;
              const Te = M.charCodeAt(0), le = M.charCodeAt(1);
              return _.es6 ? "\\u{" + c(1024 * (Te - 55296) + le - 56320 + 65536, N) + "}" : u(c(Te, N)) + u(c(le, N));
            }
            if (K) return u(c(K.charCodeAt(0), N));
            if (z == "\0" && !I && !T.test(ue.charAt(ie + 1))) return "\\0";
            if (Q) return Q == L || _.escapeEverything ? "\\" + Q : Q;
            if (S.test(z)) return y[z];
            if (_.minimal && !d.test(z)) return z;
            const ge = c(z.charCodeAt(0), N);
            return I || ge.length > 2 ? u(ge) : "\\x" + ("00" + ge).slice(-2);
          }), L == "`" && (q = q.replace(/\$\{/g, "\\${")), _.isScriptContext && (q = q.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, I ? "\\u003C!--" : "\\x3C!--")), _.wrap && (q = L + q + L), q;
        };
        m.version = "3.0.2", P.exports = m;
      }, "./node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js": (P) => {
        var t = 1e3, l = 60 * t, n = 60 * l, u = 24 * n, c = 7 * u, e = 365.25 * u;
        function r(f, y, S, T) {
          var d = y >= 1.5 * S;
          return Math.round(f / S) + " " + T + (d ? "s" : "");
        }
        P.exports = function(f, y) {
          y = y || {};
          var S = typeof f;
          if (S === "string" && f.length > 0) return function(T) {
            if (!((T = String(T)).length > 100)) {
              var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(T);
              if (d) {
                var p = parseFloat(d[1]);
                switch ((d[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return p * e;
                  case "weeks":
                  case "week":
                  case "w":
                    return p * c;
                  case "days":
                  case "day":
                  case "d":
                    return p * u;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return p * n;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return p * l;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return p * t;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return p;
                  default:
                    return;
                }
              }
            }
          }(f);
          if (S === "number" && isFinite(f)) return y.long ? function(T) {
            var d = Math.abs(T);
            return d >= u ? r(T, d, u, "day") : d >= n ? r(T, d, n, "hour") : d >= l ? r(T, d, l, "minute") : d >= t ? r(T, d, t, "second") : T + " ms";
          }(f) : function(T) {
            var d = Math.abs(T);
            return d >= u ? Math.round(T / u) + "d" : d >= n ? Math.round(T / n) + "h" : d >= l ? Math.round(T / l) + "m" : d >= t ? Math.round(T / t) + "s" : T + "ms";
          }(f);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(f));
        };
      }, "./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js": (P, t) => {
        var l;
        t = P.exports = E, l = typeof process == "object" && s && s.NODE_DEBUG && /\bsemver\b/i.test(s.NODE_DEBUG) ? function() {
          var G = Array.prototype.slice.call(arguments, 0);
          G.unshift("SEMVER"), console.log.apply(console, G);
        } : function() {
        }, t.SEMVER_SPEC_VERSION = "2.0.0";
        var n = 256, u = Number.MAX_SAFE_INTEGER || 9007199254740991, c = n - 6, e = t.re = [], r = t.safeRe = [], f = t.src = [], y = t.tokens = {}, S = 0;
        function T(G) {
          y[G] = S++;
        }
        var d = [["\\s", 1], ["\\d", n], ["[a-zA-Z0-9-]", c]];
        function p(G) {
          for (var B = 0; B < d.length; B++) {
            var z = d[B][0], M = d[B][1];
            G = G.split(z + "*").join(z + "{0," + M + "}").split(z + "+").join(z + "{1," + M + "}");
          }
          return G;
        }
        T("NUMERICIDENTIFIER"), f[y.NUMERICIDENTIFIER] = "0|[1-9]\\d*", T("NUMERICIDENTIFIERLOOSE"), f[y.NUMERICIDENTIFIERLOOSE] = "\\d+", T("NONNUMERICIDENTIFIER"), f[y.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*", T("MAINVERSION"), f[y.MAINVERSION] = "(" + f[y.NUMERICIDENTIFIER] + ")\\.(" + f[y.NUMERICIDENTIFIER] + ")\\.(" + f[y.NUMERICIDENTIFIER] + ")", T("MAINVERSIONLOOSE"), f[y.MAINVERSIONLOOSE] = "(" + f[y.NUMERICIDENTIFIERLOOSE] + ")\\.(" + f[y.NUMERICIDENTIFIERLOOSE] + ")\\.(" + f[y.NUMERICIDENTIFIERLOOSE] + ")", T("PRERELEASEIDENTIFIER"), f[y.PRERELEASEIDENTIFIER] = "(?:" + f[y.NUMERICIDENTIFIER] + "|" + f[y.NONNUMERICIDENTIFIER] + ")", T("PRERELEASEIDENTIFIERLOOSE"), f[y.PRERELEASEIDENTIFIERLOOSE] = "(?:" + f[y.NUMERICIDENTIFIERLOOSE] + "|" + f[y.NONNUMERICIDENTIFIER] + ")", T("PRERELEASE"), f[y.PRERELEASE] = "(?:-(" + f[y.PRERELEASEIDENTIFIER] + "(?:\\." + f[y.PRERELEASEIDENTIFIER] + ")*))", T("PRERELEASELOOSE"), f[y.PRERELEASELOOSE] = "(?:-?(" + f[y.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + f[y.PRERELEASEIDENTIFIERLOOSE] + ")*))", T("BUILDIDENTIFIER"), f[y.BUILDIDENTIFIER] = "[a-zA-Z0-9-]+", T("BUILD"), f[y.BUILD] = "(?:\\+(" + f[y.BUILDIDENTIFIER] + "(?:\\." + f[y.BUILDIDENTIFIER] + ")*))", T("FULL"), T("FULLPLAIN"), f[y.FULLPLAIN] = "v?" + f[y.MAINVERSION] + f[y.PRERELEASE] + "?" + f[y.BUILD] + "?", f[y.FULL] = "^" + f[y.FULLPLAIN] + "$", T("LOOSEPLAIN"), f[y.LOOSEPLAIN] = "[v=\\s]*" + f[y.MAINVERSIONLOOSE] + f[y.PRERELEASELOOSE] + "?" + f[y.BUILD] + "?", T("LOOSE"), f[y.LOOSE] = "^" + f[y.LOOSEPLAIN] + "$", T("GTLT"), f[y.GTLT] = "((?:<|>)?=?)", T("XRANGEIDENTIFIERLOOSE"), f[y.XRANGEIDENTIFIERLOOSE] = f[y.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*", T("XRANGEIDENTIFIER"), f[y.XRANGEIDENTIFIER] = f[y.NUMERICIDENTIFIER] + "|x|X|\\*", T("XRANGEPLAIN"), f[y.XRANGEPLAIN] = "[v=\\s]*(" + f[y.XRANGEIDENTIFIER] + ")(?:\\.(" + f[y.XRANGEIDENTIFIER] + ")(?:\\.(" + f[y.XRANGEIDENTIFIER] + ")(?:" + f[y.PRERELEASE] + ")?" + f[y.BUILD] + "?)?)?", T("XRANGEPLAINLOOSE"), f[y.XRANGEPLAINLOOSE] = "[v=\\s]*(" + f[y.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + f[y.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + f[y.XRANGEIDENTIFIERLOOSE] + ")(?:" + f[y.PRERELEASELOOSE] + ")?" + f[y.BUILD] + "?)?)?", T("XRANGE"), f[y.XRANGE] = "^" + f[y.GTLT] + "\\s*" + f[y.XRANGEPLAIN] + "$", T("XRANGELOOSE"), f[y.XRANGELOOSE] = "^" + f[y.GTLT] + "\\s*" + f[y.XRANGEPLAINLOOSE] + "$", T("COERCE"), f[y.COERCE] = "(^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])", T("COERCERTL"), e[y.COERCERTL] = new RegExp(f[y.COERCE], "g"), r[y.COERCERTL] = new RegExp(p(f[y.COERCE]), "g"), T("LONETILDE"), f[y.LONETILDE] = "(?:~>?)", T("TILDETRIM"), f[y.TILDETRIM] = "(\\s*)" + f[y.LONETILDE] + "\\s+", e[y.TILDETRIM] = new RegExp(f[y.TILDETRIM], "g"), r[y.TILDETRIM] = new RegExp(p(f[y.TILDETRIM]), "g"), T("TILDE"), f[y.TILDE] = "^" + f[y.LONETILDE] + f[y.XRANGEPLAIN] + "$", T("TILDELOOSE"), f[y.TILDELOOSE] = "^" + f[y.LONETILDE] + f[y.XRANGEPLAINLOOSE] + "$", T("LONECARET"), f[y.LONECARET] = "(?:\\^)", T("CARETTRIM"), f[y.CARETTRIM] = "(\\s*)" + f[y.LONECARET] + "\\s+", e[y.CARETTRIM] = new RegExp(f[y.CARETTRIM], "g"), r[y.CARETTRIM] = new RegExp(p(f[y.CARETTRIM]), "g"), T("CARET"), f[y.CARET] = "^" + f[y.LONECARET] + f[y.XRANGEPLAIN] + "$", T("CARETLOOSE"), f[y.CARETLOOSE] = "^" + f[y.LONECARET] + f[y.XRANGEPLAINLOOSE] + "$", T("COMPARATORLOOSE"), f[y.COMPARATORLOOSE] = "^" + f[y.GTLT] + "\\s*(" + f[y.LOOSEPLAIN] + ")$|^$", T("COMPARATOR"), f[y.COMPARATOR] = "^" + f[y.GTLT] + "\\s*(" + f[y.FULLPLAIN] + ")$|^$", T("COMPARATORTRIM"), f[y.COMPARATORTRIM] = "(\\s*)" + f[y.GTLT] + "\\s*(" + f[y.LOOSEPLAIN] + "|" + f[y.XRANGEPLAIN] + ")", e[y.COMPARATORTRIM] = new RegExp(f[y.COMPARATORTRIM], "g"), r[y.COMPARATORTRIM] = new RegExp(p(f[y.COMPARATORTRIM]), "g"), T("HYPHENRANGE"), f[y.HYPHENRANGE] = "^\\s*(" + f[y.XRANGEPLAIN] + ")\\s+-\\s+(" + f[y.XRANGEPLAIN] + ")\\s*$", T("HYPHENRANGELOOSE"), f[y.HYPHENRANGELOOSE] = "^\\s*(" + f[y.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + f[y.XRANGEPLAINLOOSE] + ")\\s*$", T("STAR"), f[y.STAR] = "(<|>)?=?\\s*\\*";
        for (var h = 0; h < S; h++) l(h, f[h]), e[h] || (e[h] = new RegExp(f[h]), r[h] = new RegExp(p(f[h])));
        function m(G, B) {
          if (B && typeof B == "object" || (B = { loose: !!B, includePrerelease: false }), G instanceof E) return G;
          if (typeof G != "string" || G.length > n || !(B.loose ? r[y.LOOSE] : r[y.FULL]).test(G)) return null;
          try {
            return new E(G, B);
          } catch {
            return null;
          }
        }
        function E(G, B) {
          if (B && typeof B == "object" || (B = { loose: !!B, includePrerelease: false }), G instanceof E) {
            if (G.loose === B.loose) return G;
            G = G.version;
          } else if (typeof G != "string") throw new TypeError("Invalid Version: " + G);
          if (G.length > n) throw new TypeError("version is longer than " + n + " characters");
          if (!(this instanceof E)) return new E(G, B);
          l("SemVer", G, B), this.options = B, this.loose = !!B.loose;
          var z = G.trim().match(B.loose ? r[y.LOOSE] : r[y.FULL]);
          if (!z) throw new TypeError("Invalid Version: " + G);
          if (this.raw = G, this.major = +z[1], this.minor = +z[2], this.patch = +z[3], this.major > u || this.major < 0) throw new TypeError("Invalid major version");
          if (this.minor > u || this.minor < 0) throw new TypeError("Invalid minor version");
          if (this.patch > u || this.patch < 0) throw new TypeError("Invalid patch version");
          z[4] ? this.prerelease = z[4].split(".").map(function(M) {
            if (/^[0-9]+$/.test(M)) {
              var K = +M;
              if (K >= 0 && K < u) return K;
            }
            return M;
          }) : this.prerelease = [], this.build = z[5] ? z[5].split(".") : [], this.format();
        }
        t.parse = m, t.valid = function(G, B) {
          var z = m(G, B);
          return z ? z.version : null;
        }, t.clean = function(G, B) {
          var z = m(G.trim().replace(/^[=v]+/, ""), B);
          return z ? z.version : null;
        }, t.SemVer = E, E.prototype.format = function() {
          return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
        }, E.prototype.toString = function() {
          return this.version;
        }, E.prototype.compare = function(G) {
          return l("SemVer.compare", this.version, this.options, G), G instanceof E || (G = new E(G, this.options)), this.compareMain(G) || this.comparePre(G);
        }, E.prototype.compareMain = function(G) {
          return G instanceof E || (G = new E(G, this.options)), C(this.major, G.major) || C(this.minor, G.minor) || C(this.patch, G.patch);
        }, E.prototype.comparePre = function(G) {
          if (G instanceof E || (G = new E(G, this.options)), this.prerelease.length && !G.prerelease.length) return -1;
          if (!this.prerelease.length && G.prerelease.length) return 1;
          if (!this.prerelease.length && !G.prerelease.length) return 0;
          var B = 0;
          do {
            var z = this.prerelease[B], M = G.prerelease[B];
            if (l("prerelease compare", B, z, M), z === void 0 && M === void 0) return 0;
            if (M === void 0) return 1;
            if (z === void 0) return -1;
            if (z !== M) return C(z, M);
          } while (++B);
        }, E.prototype.compareBuild = function(G) {
          G instanceof E || (G = new E(G, this.options));
          var B = 0;
          do {
            var z = this.build[B], M = G.build[B];
            if (l("prerelease compare", B, z, M), z === void 0 && M === void 0) return 0;
            if (M === void 0) return 1;
            if (z === void 0) return -1;
            if (z !== M) return C(z, M);
          } while (++B);
        }, E.prototype.inc = function(G, B) {
          switch (G) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", B);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", B);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", B), this.inc("pre", B);
              break;
            case "prerelease":
              this.prerelease.length === 0 && this.inc("patch", B), this.inc("pre", B);
              break;
            case "major":
              this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              this.prerelease.length === 0 && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0) this.prerelease = [0];
              else {
                for (var z = this.prerelease.length; --z >= 0; ) typeof this.prerelease[z] == "number" && (this.prerelease[z]++, z = -2);
                z === -1 && this.prerelease.push(0);
              }
              B && (this.prerelease[0] === B ? isNaN(this.prerelease[1]) && (this.prerelease = [B, 0]) : this.prerelease = [B, 0]);
              break;
            default:
              throw new Error("invalid increment argument: " + G);
          }
          return this.format(), this.raw = this.version, this;
        }, t.inc = function(G, B, z, M) {
          typeof z == "string" && (M = z, z = void 0);
          try {
            return new E(G, z).inc(B, M).version;
          } catch {
            return null;
          }
        }, t.diff = function(G, B) {
          if (j(G, B)) return null;
          var z = m(G), M = m(B), K = "";
          if (z.prerelease.length || M.prerelease.length) {
            K = "pre";
            var Q = "prerelease";
          }
          for (var ie in z) if ((ie === "major" || ie === "minor" || ie === "patch") && z[ie] !== M[ie]) return K + ie;
          return Q;
        }, t.compareIdentifiers = C;
        var _ = /^[0-9]+$/;
        function C(G, B) {
          var z = _.test(G), M = _.test(B);
          return z && M && (G = +G, B = +B), G === B ? 0 : z && !M ? -1 : M && !z ? 1 : G < B ? -1 : 1;
        }
        function w(G, B, z) {
          return new E(G, z).compare(new E(B, z));
        }
        function I(G, B, z) {
          return w(G, B, z) > 0;
        }
        function D(G, B, z) {
          return w(G, B, z) < 0;
        }
        function j(G, B, z) {
          return w(G, B, z) === 0;
        }
        function L(G, B, z) {
          return w(G, B, z) !== 0;
        }
        function k(G, B, z) {
          return w(G, B, z) >= 0;
        }
        function N(G, B, z) {
          return w(G, B, z) <= 0;
        }
        function F(G, B, z, M) {
          switch (B) {
            case "===":
              return typeof G == "object" && (G = G.version), typeof z == "object" && (z = z.version), G === z;
            case "!==":
              return typeof G == "object" && (G = G.version), typeof z == "object" && (z = z.version), G !== z;
            case "":
            case "=":
            case "==":
              return j(G, z, M);
            case "!=":
              return L(G, z, M);
            case ">":
              return I(G, z, M);
            case ">=":
              return k(G, z, M);
            case "<":
              return D(G, z, M);
            case "<=":
              return N(G, z, M);
            default:
              throw new TypeError("Invalid operator: " + B);
          }
        }
        function W(G, B) {
          if (B && typeof B == "object" || (B = { loose: !!B, includePrerelease: false }), G instanceof W) {
            if (G.loose === !!B.loose) return G;
            G = G.value;
          }
          if (!(this instanceof W)) return new W(G, B);
          G = G.trim().split(/\s+/).join(" "), l("comparator", G, B), this.options = B, this.loose = !!B.loose, this.parse(G), this.semver === X ? this.value = "" : this.value = this.operator + this.semver.version, l("comp", this);
        }
        t.rcompareIdentifiers = function(G, B) {
          return C(B, G);
        }, t.major = function(G, B) {
          return new E(G, B).major;
        }, t.minor = function(G, B) {
          return new E(G, B).minor;
        }, t.patch = function(G, B) {
          return new E(G, B).patch;
        }, t.compare = w, t.compareLoose = function(G, B) {
          return w(G, B, true);
        }, t.compareBuild = function(G, B, z) {
          var M = new E(G, z), K = new E(B, z);
          return M.compare(K) || M.compareBuild(K);
        }, t.rcompare = function(G, B, z) {
          return w(B, G, z);
        }, t.sort = function(G, B) {
          return G.sort(function(z, M) {
            return t.compareBuild(z, M, B);
          });
        }, t.rsort = function(G, B) {
          return G.sort(function(z, M) {
            return t.compareBuild(M, z, B);
          });
        }, t.gt = I, t.lt = D, t.eq = j, t.neq = L, t.gte = k, t.lte = N, t.cmp = F, t.Comparator = W;
        var X = {};
        function H(G, B) {
          if (B && typeof B == "object" || (B = { loose: !!B, includePrerelease: false }), G instanceof H) return G.loose === !!B.loose && G.includePrerelease === !!B.includePrerelease ? G : new H(G.raw, B);
          if (G instanceof W) return new H(G.value, B);
          if (!(this instanceof H)) return new H(G, B);
          if (this.options = B, this.loose = !!B.loose, this.includePrerelease = !!B.includePrerelease, this.raw = G.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(function(z) {
            return this.parseRange(z.trim());
          }, this).filter(function(z) {
            return z.length;
          }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + this.raw);
          this.format();
        }
        function U(G, B) {
          for (var z = true, M = G.slice(), K = M.pop(); z && M.length; ) z = M.every(function(Q) {
            return K.intersects(Q, B);
          }), K = M.pop();
          return z;
        }
        function q(G) {
          return !G || G.toLowerCase() === "x" || G === "*";
        }
        function ee(G, B, z, M, K, Q, ie, ue, ge, Te, le, fe, Pe) {
          return ((B = q(z) ? "" : q(M) ? ">=" + z + ".0.0" : q(K) ? ">=" + z + "." + M + ".0" : ">=" + B) + " " + (ue = q(ge) ? "" : q(Te) ? "<" + (+ge + 1) + ".0.0" : q(le) ? "<" + ge + "." + (+Te + 1) + ".0" : fe ? "<=" + ge + "." + Te + "." + le + "-" + fe : "<=" + ue)).trim();
        }
        function re(G, B, z) {
          for (var M = 0; M < G.length; M++) if (!G[M].test(B)) return false;
          if (B.prerelease.length && !z.includePrerelease) {
            for (M = 0; M < G.length; M++) if (l(G[M].semver), G[M].semver !== X && G[M].semver.prerelease.length > 0) {
              var K = G[M].semver;
              if (K.major === B.major && K.minor === B.minor && K.patch === B.patch) return true;
            }
            return false;
          }
          return true;
        }
        function Y(G, B, z) {
          try {
            B = new H(B, z);
          } catch {
            return false;
          }
          return B.test(G);
        }
        function Z(G, B, z, M) {
          var K, Q, ie, ue, ge;
          switch (G = new E(G, M), B = new H(B, M), z) {
            case ">":
              K = I, Q = N, ie = D, ue = ">", ge = ">=";
              break;
            case "<":
              K = D, Q = k, ie = I, ue = "<", ge = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (Y(G, B, M)) return false;
          for (var Te = 0; Te < B.set.length; ++Te) {
            var le = B.set[Te], fe = null, Pe = null;
            if (le.forEach(function(xe) {
              xe.semver === X && (xe = new W(">=0.0.0")), fe = fe || xe, Pe = Pe || xe, K(xe.semver, fe.semver, M) ? fe = xe : ie(xe.semver, Pe.semver, M) && (Pe = xe);
            }), fe.operator === ue || fe.operator === ge || (!Pe.operator || Pe.operator === ue) && Q(G, Pe.semver) || Pe.operator === ge && ie(G, Pe.semver)) return false;
          }
          return true;
        }
        W.prototype.parse = function(G) {
          var B = this.options.loose ? r[y.COMPARATORLOOSE] : r[y.COMPARATOR], z = G.match(B);
          if (!z) throw new TypeError("Invalid comparator: " + G);
          this.operator = z[1] !== void 0 ? z[1] : "", this.operator === "=" && (this.operator = ""), z[2] ? this.semver = new E(z[2], this.options.loose) : this.semver = X;
        }, W.prototype.toString = function() {
          return this.value;
        }, W.prototype.test = function(G) {
          if (l("Comparator.test", G, this.options.loose), this.semver === X || G === X) return true;
          if (typeof G == "string") try {
            G = new E(G, this.options);
          } catch {
            return false;
          }
          return F(G, this.operator, this.semver, this.options);
        }, W.prototype.intersects = function(G, B) {
          if (!(G instanceof W)) throw new TypeError("a Comparator is required");
          var z;
          if (B && typeof B == "object" || (B = { loose: !!B, includePrerelease: false }), this.operator === "") return this.value === "" || (z = new H(G.value, B), Y(this.value, z, B));
          if (G.operator === "") return G.value === "" || (z = new H(this.value, B), Y(G.semver, z, B));
          var M = !(this.operator !== ">=" && this.operator !== ">" || G.operator !== ">=" && G.operator !== ">"), K = !(this.operator !== "<=" && this.operator !== "<" || G.operator !== "<=" && G.operator !== "<"), Q = this.semver.version === G.semver.version, ie = !(this.operator !== ">=" && this.operator !== "<=" || G.operator !== ">=" && G.operator !== "<="), ue = F(this.semver, "<", G.semver, B) && (this.operator === ">=" || this.operator === ">") && (G.operator === "<=" || G.operator === "<"), ge = F(this.semver, ">", G.semver, B) && (this.operator === "<=" || this.operator === "<") && (G.operator === ">=" || G.operator === ">");
          return M || K || Q && ie || ue || ge;
        }, t.Range = H, H.prototype.format = function() {
          return this.range = this.set.map(function(G) {
            return G.join(" ").trim();
          }).join("||").trim(), this.range;
        }, H.prototype.toString = function() {
          return this.range;
        }, H.prototype.parseRange = function(G) {
          var B = this.options.loose, z = B ? r[y.HYPHENRANGELOOSE] : r[y.HYPHENRANGE];
          G = G.replace(z, ee), l("hyphen replace", G), G = G.replace(r[y.COMPARATORTRIM], "$1$2$3"), l("comparator trim", G, r[y.COMPARATORTRIM]), G = (G = (G = G.replace(r[y.TILDETRIM], "$1~")).replace(r[y.CARETTRIM], "$1^")).split(/\s+/).join(" ");
          var M = B ? r[y.COMPARATORLOOSE] : r[y.COMPARATOR], K = G.split(" ").map(function(Q) {
            return function(ie, ue) {
              return l("comp", ie, ue), ie = function(ge, Te) {
                return ge.trim().split(/\s+/).map(function(le) {
                  return function(fe, Pe) {
                    l("caret", fe, Pe);
                    var xe = Pe.loose ? r[y.CARETLOOSE] : r[y.CARET];
                    return fe.replace(xe, function(we, me, ye, pe, J) {
                      var Ee;
                      return l("caret", fe, we, me, ye, pe, J), q(me) ? Ee = "" : q(ye) ? Ee = ">=" + me + ".0.0 <" + (+me + 1) + ".0.0" : q(pe) ? Ee = me === "0" ? ">=" + me + "." + ye + ".0 <" + me + "." + (+ye + 1) + ".0" : ">=" + me + "." + ye + ".0 <" + (+me + 1) + ".0.0" : J ? (l("replaceCaret pr", J), Ee = me === "0" ? ye === "0" ? ">=" + me + "." + ye + "." + pe + "-" + J + " <" + me + "." + ye + "." + (+pe + 1) : ">=" + me + "." + ye + "." + pe + "-" + J + " <" + me + "." + (+ye + 1) + ".0" : ">=" + me + "." + ye + "." + pe + "-" + J + " <" + (+me + 1) + ".0.0") : (l("no pr"), Ee = me === "0" ? ye === "0" ? ">=" + me + "." + ye + "." + pe + " <" + me + "." + ye + "." + (+pe + 1) : ">=" + me + "." + ye + "." + pe + " <" + me + "." + (+ye + 1) + ".0" : ">=" + me + "." + ye + "." + pe + " <" + (+me + 1) + ".0.0"), l("caret return", Ee), Ee;
                    });
                  }(le, Te);
                }).join(" ");
              }(ie, ue), l("caret", ie), ie = function(ge, Te) {
                return ge.trim().split(/\s+/).map(function(le) {
                  return function(fe, Pe) {
                    var xe = Pe.loose ? r[y.TILDELOOSE] : r[y.TILDE];
                    return fe.replace(xe, function(we, me, ye, pe, J) {
                      var Ee;
                      return l("tilde", fe, we, me, ye, pe, J), q(me) ? Ee = "" : q(ye) ? Ee = ">=" + me + ".0.0 <" + (+me + 1) + ".0.0" : q(pe) ? Ee = ">=" + me + "." + ye + ".0 <" + me + "." + (+ye + 1) + ".0" : J ? (l("replaceTilde pr", J), Ee = ">=" + me + "." + ye + "." + pe + "-" + J + " <" + me + "." + (+ye + 1) + ".0") : Ee = ">=" + me + "." + ye + "." + pe + " <" + me + "." + (+ye + 1) + ".0", l("tilde return", Ee), Ee;
                    });
                  }(le, Te);
                }).join(" ");
              }(ie, ue), l("tildes", ie), ie = function(ge, Te) {
                return l("replaceXRanges", ge, Te), ge.split(/\s+/).map(function(le) {
                  return function(fe, Pe) {
                    fe = fe.trim();
                    var xe = Pe.loose ? r[y.XRANGELOOSE] : r[y.XRANGE];
                    return fe.replace(xe, function(we, me, ye, pe, J, Ee) {
                      l("xRange", fe, we, me, ye, pe, J, Ee);
                      var Me = q(ye), Ue = Me || q(pe), qe = Ue || q(J), He = qe;
                      return me === "=" && He && (me = ""), Ee = Pe.includePrerelease ? "-0" : "", Me ? we = me === ">" || me === "<" ? "<0.0.0-0" : "*" : me && He ? (Ue && (pe = 0), J = 0, me === ">" ? (me = ">=", Ue ? (ye = +ye + 1, pe = 0, J = 0) : (pe = +pe + 1, J = 0)) : me === "<=" && (me = "<", Ue ? ye = +ye + 1 : pe = +pe + 1), we = me + ye + "." + pe + "." + J + Ee) : Ue ? we = ">=" + ye + ".0.0" + Ee + " <" + (+ye + 1) + ".0.0" + Ee : qe && (we = ">=" + ye + "." + pe + ".0" + Ee + " <" + ye + "." + (+pe + 1) + ".0" + Ee), l("xRange return", we), we;
                    });
                  }(le, Te);
                }).join(" ");
              }(ie, ue), l("xrange", ie), ie = function(ge, Te) {
                return l("replaceStars", ge, Te), ge.trim().replace(r[y.STAR], "");
              }(ie, ue), l("stars", ie), ie;
            }(Q, this.options);
          }, this).join(" ").split(/\s+/);
          return this.options.loose && (K = K.filter(function(Q) {
            return !!Q.match(M);
          })), K = K.map(function(Q) {
            return new W(Q, this.options);
          }, this);
        }, H.prototype.intersects = function(G, B) {
          if (!(G instanceof H)) throw new TypeError("a Range is required");
          return this.set.some(function(z) {
            return U(z, B) && G.set.some(function(M) {
              return U(M, B) && z.every(function(K) {
                return M.every(function(Q) {
                  return K.intersects(Q, B);
                });
              });
            });
          });
        }, t.toComparators = function(G, B) {
          return new H(G, B).set.map(function(z) {
            return z.map(function(M) {
              return M.value;
            }).join(" ").trim().split(" ");
          });
        }, H.prototype.test = function(G) {
          if (!G) return false;
          if (typeof G == "string") try {
            G = new E(G, this.options);
          } catch {
            return false;
          }
          for (var B = 0; B < this.set.length; B++) if (re(this.set[B], G, this.options)) return true;
          return false;
        }, t.satisfies = Y, t.maxSatisfying = function(G, B, z) {
          var M = null, K = null;
          try {
            var Q = new H(B, z);
          } catch {
            return null;
          }
          return G.forEach(function(ie) {
            Q.test(ie) && (M && K.compare(ie) !== -1 || (K = new E(M = ie, z)));
          }), M;
        }, t.minSatisfying = function(G, B, z) {
          var M = null, K = null;
          try {
            var Q = new H(B, z);
          } catch {
            return null;
          }
          return G.forEach(function(ie) {
            Q.test(ie) && (M && K.compare(ie) !== 1 || (K = new E(M = ie, z)));
          }), M;
        }, t.minVersion = function(G, B) {
          G = new H(G, B);
          var z = new E("0.0.0");
          if (G.test(z) || (z = new E("0.0.0-0"), G.test(z))) return z;
          z = null;
          for (var M = 0; M < G.set.length; ++M) G.set[M].forEach(function(K) {
            var Q = new E(K.semver.version);
            switch (K.operator) {
              case ">":
                Q.prerelease.length === 0 ? Q.patch++ : Q.prerelease.push(0), Q.raw = Q.format();
              case "":
              case ">=":
                z && !I(z, Q) || (z = Q);
                break;
              case "<":
              case "<=":
                break;
              default:
                throw new Error("Unexpected operation: " + K.operator);
            }
          });
          return z && G.test(z) ? z : null;
        }, t.validRange = function(G, B) {
          try {
            return new H(G, B).range || "*";
          } catch {
            return null;
          }
        }, t.ltr = function(G, B, z) {
          return Z(G, B, "<", z);
        }, t.gtr = function(G, B, z) {
          return Z(G, B, ">", z);
        }, t.outside = Z, t.prerelease = function(G, B) {
          var z = m(G, B);
          return z && z.prerelease.length ? z.prerelease : null;
        }, t.intersects = function(G, B, z) {
          return G = new H(G, z), B = new H(B, z), G.intersects(B);
        }, t.coerce = function(G, B) {
          if (G instanceof E) return G;
          if (typeof G == "number" && (G = String(G)), typeof G != "string") return null;
          var z = null;
          if ((B = B || {}).rtl) {
            for (var M; (M = r[y.COERCERTL].exec(G)) && (!z || z.index + z[0].length !== G.length); ) z && M.index + M[0].length === z.index + z[0].length || (z = M), r[y.COERCERTL].lastIndex = M.index + M[1].length + M[2].length;
            r[y.COERCERTL].lastIndex = -1;
          } else z = G.match(r[y.COERCE]);
          return z === null ? null : m(z[2] + "." + (z[3] || "0") + "." + (z[4] || "0"), B);
        };
      }, "./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js": (P, t, l) => {
        const n = l("os"), u = l("tty"), c = l("./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"), { env: e } = process;
        let r;
        function f(S) {
          return S !== 0 && { level: S, hasBasic: true, has256: S >= 2, has16m: S >= 3 };
        }
        function y(S, T) {
          if (r === 0) return 0;
          if (c("color=16m") || c("color=full") || c("color=truecolor")) return 3;
          if (c("color=256")) return 2;
          if (S && !T && r === void 0) return 0;
          const d = r || 0;
          if (e.TERM === "dumb") return d;
          if (process.platform === "win32") {
            const p = n.release().split(".");
            return Number(p[0]) >= 10 && Number(p[2]) >= 10586 ? Number(p[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in e) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((p) => p in e) || e.CI_NAME === "codeship" ? 1 : d;
          if ("TEAMCITY_VERSION" in e) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(e.TEAMCITY_VERSION) ? 1 : 0;
          if (e.COLORTERM === "truecolor") return 3;
          if ("TERM_PROGRAM" in e) {
            const p = parseInt((e.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (e.TERM_PROGRAM) {
              case "iTerm.app":
                return p >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(e.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(e.TERM) || "COLORTERM" in e ? 1 : d;
        }
        c("no-color") || c("no-colors") || c("color=false") || c("color=never") ? r = 0 : (c("color") || c("colors") || c("color=true") || c("color=always")) && (r = 1), "FORCE_COLOR" in e && (r = e.FORCE_COLOR === "true" ? 1 : e.FORCE_COLOR === "false" ? 0 : e.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(e.FORCE_COLOR, 10), 3)), P.exports = { supportsColor: function(S) {
          return f(y(S, S && S.isTTY));
        }, stdout: f(y(true, u.isatty(1))), stderr: f(y(true, u.isatty(2))) };
      }, "./stubs/babel-codeframe.js": (P, t, l) => {
        function n() {
          return "";
        }
        l.r(t), l.d(t, { codeFrameColumns: () => n });
      }, "./stubs/helper-compilation-targets.js": (P, t, l) => {
        function n() {
          return {};
        }
        l.r(t), l.d(t, { default: () => n });
      }, assert: (P) => {
        P.exports = gt;
      }, fs: (P) => {
        P.exports = gt;
      }, module: (P) => {
        P.exports = gt;
      }, os: (P) => {
        P.exports = gt;
      }, path: (P) => {
        P.exports = gt;
      }, process: (P) => {
        P.exports = gt;
      }, tty: (P) => {
        P.exports = gt;
      }, url: (P) => {
        P.exports = gt;
      }, util: (P) => {
        P.exports = gt;
      }, v8: (P) => {
        P.exports = gt;
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js": (P, t, l) => {
        function n() {
          const E = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return n = function() {
            return E;
          }, E;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.assertSimpleType = h, t.makeStrongCache = y, t.makeStrongCacheSync = function(E) {
          return e(y(E));
        }, t.makeWeakCache = f, t.makeWeakCacheSync = function(E) {
          return e(f(E));
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/util.js");
        const e = (E) => n()(E).sync;
        function* r() {
          return true;
        }
        function f(E) {
          return S(WeakMap, E);
        }
        function y(E) {
          return S(Map, E);
        }
        function S(E, _) {
          const C = new E(), w = new E(), I = new E();
          return function* (D, j) {
            const L = yield* (0, u.isAsync)(), k = L ? w : C, N = yield* function* (U, q, ee, re, Y) {
              const Z = yield* T(q, re, Y);
              if (Z.valid) return Z;
              if (U) {
                const G = yield* T(ee, re, Y);
                if (G.valid) return { valid: true, value: yield* (0, u.waitFor)(G.value.promise) };
              }
              return { valid: false, value: null };
            }(L, k, I, D, j);
            if (N.valid) return N.value;
            const F = new p(j), W = _(D, F);
            let X, H;
            return H = (0, c.isIterableIterator)(W) ? yield* (0, u.onFirstPause)(W, () => {
              X = function(U, q, ee) {
                const re = new m();
                return d(q, U, ee, re), re;
              }(F, I, D);
            }) : W, d(k, F, D, H), X && (I.delete(D), X.release(H)), H;
          };
        }
        function* T(E, _, C) {
          const w = E.get(_);
          if (w) {
            for (const { value: I, valid: D } of w) if (yield* D(C)) return { valid: true, value: I };
          }
          return { valid: false, value: null };
        }
        function d(E, _, C, w) {
          _.configured() || _.forever();
          let I = E.get(C);
          switch (_.deactivate(), _.mode()) {
            case "forever":
              I = [{ value: w, valid: r }], E.set(C, I);
              break;
            case "invalidate":
              I = [{ value: w, valid: _.validator() }], E.set(C, I);
              break;
            case "valid":
              I ? I.push({ value: w, valid: _.validator() }) : (I = [{ value: w, valid: _.validator() }], E.set(C, I));
          }
        }
        class p {
          constructor(_) {
            this._active = true, this._never = false, this._forever = false, this._invalidate = false, this._configured = false, this._pairs = [], this._data = void 0, this._data = _;
          }
          simple() {
            return function(_) {
              function C(w) {
                if (typeof w != "boolean") return _.using(() => h(w()));
                w ? _.forever() : _.never();
              }
              return C.forever = () => _.forever(), C.never = () => _.never(), C.using = (w) => _.using(() => h(w())), C.invalidate = (w) => _.invalidate(() => h(w())), C;
            }(this);
          }
          mode() {
            return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
          }
          forever() {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never) throw new Error("Caching has already been configured with .never()");
            this._forever = true, this._configured = true;
          }
          never() {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._forever) throw new Error("Caching has already been configured with .forever()");
            this._never = true, this._configured = true;
          }
          using(_) {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never || this._forever) throw new Error("Caching has already been configured with .never or .forever()");
            this._configured = true;
            const C = _(this._data), w = (0, u.maybeAsync)(_, "You appear to be using an async cache handler, but Babel has been called synchronously");
            return (0, u.isThenable)(C) ? C.then((I) => (this._pairs.push([I, w]), I)) : (this._pairs.push([C, w]), C);
          }
          invalidate(_) {
            return this._invalidate = true, this.using(_);
          }
          validator() {
            const _ = this._pairs;
            return function* (C) {
              for (const [w, I] of _) if (w !== (yield* I(C))) return false;
              return true;
            };
          }
          deactivate() {
            this._active = false;
          }
          configured() {
            return this._configured;
          }
        }
        function h(E) {
          if ((0, u.isThenable)(E)) throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
          if (E != null && typeof E != "string" && typeof E != "boolean" && typeof E != "number") throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
          return E;
        }
        class m {
          constructor() {
            this.released = false, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((_) => {
              this._resolve = _;
            });
          }
          release(_) {
            this.released = true, this._resolve(_);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-chain.js": (P, t, l) => {
        function n() {
          const le = l("path");
          return n = function() {
            return le;
          }, le;
        }
        function u() {
          const le = l("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js");
          return u = function() {
            return le;
          }, le;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.buildPresetChain = function* (le, fe) {
          const Pe = yield* h(le, fe);
          return Pe ? { plugins: M(Pe.plugins), presets: M(Pe.presets), options: Pe.options.map((xe) => z(xe)), files: /* @__PURE__ */ new Set() } : null;
        }, t.buildPresetChainWalker = void 0, t.buildRootChain = function* (le, fe) {
          let Pe, xe;
          const we = new r.ConfigPrinter(), me = yield* j({ options: le, dirname: fe.cwd }, fe, void 0, we);
          if (!me) return null;
          const ye = yield* we.output();
          let pe;
          typeof le.configFile == "string" ? pe = yield* (0, S.loadConfig)(le.configFile, fe.cwd, fe.envName, fe.caller) : le.configFile !== false && (pe = yield* (0, S.findRootConfig)(fe.root, fe.envName, fe.caller));
          let { babelrc: J, babelrcRoots: Ee } = le, Me = fe.cwd;
          const Ue = B(), qe = new r.ConfigPrinter();
          if (pe) {
            const he = w(pe), oe = yield* k(he, fe, void 0, qe);
            if (!oe) return null;
            Pe = yield* qe.output(), J === void 0 && (J = he.options.babelrc), Ee === void 0 && (Me = he.dirname, Ee = he.options.babelrcRoots), Z(Ue, oe);
          }
          let He, Ie, Re = false;
          const Be = B();
          if ((J === true || J === void 0) && typeof fe.filename == "string") {
            const he = yield* (0, S.findPackageData)(fe.filename);
            if (he && function(oe, _e, Ne, $e) {
              if (typeof Ne == "boolean") return Ne;
              const Xe = oe.root;
              if (Ne === void 0) return _e.directories.includes(Xe);
              let Je = Ne;
              return Array.isArray(Je) || (Je = [Je]), Je = Je.map((st) => typeof st == "string" ? n().resolve($e, st) : st), Je.length === 1 && Je[0] === Xe ? _e.directories.includes(Xe) : Je.some((st) => (typeof st == "string" && (st = (0, e.default)(st, $e)), _e.directories.some((be) => Te(st, $e, be, oe))));
            }(fe, he, Ee, Me)) {
              if ({ ignore: He, config: Ie } = yield* (0, S.findRelativeConfig)(he, fe.envName, fe.caller), He && Be.files.add(He.filepath), He && ue(fe, He.ignore, null, He.dirname) && (Re = true), Ie && !Re) {
                const oe = I(Ie), _e = new r.ConfigPrinter(), Ne = yield* k(oe, fe, void 0, _e);
                Ne ? (xe = yield* _e.output(), Z(Be, Ne)) : Re = true;
              }
              Ie && Re && Be.files.add(Ie.filepath);
            }
          }
          fe.showConfig && console.log(`Babel configs on "${fe.filename}" (ascending priority):
` + [Pe, xe, ye].filter((he) => !!he).join(`

`) + `
-----End Babel configs-----`);
          const je = Z(Z(Z(B(), Ue), Be), me);
          return { plugins: Re ? [] : M(je.plugins), presets: Re ? [] : M(je.presets), options: Re ? [] : je.options.map((he) => z(he)), fileHandling: Re ? "ignored" : "transpile", ignore: He || void 0, babelrc: Ie || void 0, config: pe || void 0, files: je.files };
        };
        var c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/options.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/pattern-to-regex.js"), r = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/printer.js"), f = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), y = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js"), S = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/index.js"), T = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js"), d = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-descriptors.js");
        const p = u()("babel:config:config-chain"), h = t.buildPresetChainWalker = re({ root: (le) => m(le), env: (le, fe) => E(le)(fe), overrides: (le, fe) => _(le)(fe), overridesEnv: (le, fe, Pe) => C(le)(fe)(Pe), createLogger: () => () => {
        } }), m = (0, T.makeWeakCacheSync)((le) => H(le, le.alias, d.createUncachedDescriptors)), E = (0, T.makeWeakCacheSync)((le) => (0, T.makeStrongCacheSync)((fe) => U(le, le.alias, d.createUncachedDescriptors, fe))), _ = (0, T.makeWeakCacheSync)((le) => (0, T.makeStrongCacheSync)((fe) => q(le, le.alias, d.createUncachedDescriptors, fe))), C = (0, T.makeWeakCacheSync)((le) => (0, T.makeStrongCacheSync)((fe) => (0, T.makeStrongCacheSync)((Pe) => ee(le, le.alias, d.createUncachedDescriptors, fe, Pe)))), w = (0, T.makeWeakCacheSync)((le) => ({ filepath: le.filepath, dirname: le.dirname, options: (0, c.validate)("configfile", le.options, le.filepath) })), I = (0, T.makeWeakCacheSync)((le) => ({ filepath: le.filepath, dirname: le.dirname, options: (0, c.validate)("babelrcfile", le.options, le.filepath) })), D = (0, T.makeWeakCacheSync)((le) => ({ filepath: le.filepath, dirname: le.dirname, options: (0, c.validate)("extendsfile", le.options, le.filepath) })), j = re({ root: (le) => H(le, "base", d.createCachedDescriptors), env: (le, fe) => U(le, "base", d.createCachedDescriptors, fe), overrides: (le, fe) => q(le, "base", d.createCachedDescriptors, fe), overridesEnv: (le, fe, Pe) => ee(le, "base", d.createCachedDescriptors, fe, Pe), createLogger: (le, fe, Pe) => function(xe, we, me) {
          var ye;
          return me ? me.configure(we.showConfig, r.ChainFormatter.Programmatic, { callerName: (ye = we.caller) == null ? void 0 : ye.name }) : () => {
          };
        }(0, fe, Pe) }), L = re({ root: (le) => N(le), env: (le, fe) => F(le)(fe), overrides: (le, fe) => W(le)(fe), overridesEnv: (le, fe, Pe) => X(le)(fe)(Pe), createLogger: (le, fe, Pe) => function(xe, we, me) {
          return me ? me.configure(we.showConfig, r.ChainFormatter.Config, { filepath: xe }) : () => {
          };
        }(le.filepath, fe, Pe) });
        function* k(le, fe, Pe, xe) {
          const we = yield* L(le, fe, Pe, xe);
          return we == null ? void 0 : we.files.add(le.filepath), we;
        }
        const N = (0, T.makeWeakCacheSync)((le) => H(le, le.filepath, d.createUncachedDescriptors)), F = (0, T.makeWeakCacheSync)((le) => (0, T.makeStrongCacheSync)((fe) => U(le, le.filepath, d.createUncachedDescriptors, fe))), W = (0, T.makeWeakCacheSync)((le) => (0, T.makeStrongCacheSync)((fe) => q(le, le.filepath, d.createUncachedDescriptors, fe))), X = (0, T.makeWeakCacheSync)((le) => (0, T.makeStrongCacheSync)((fe) => (0, T.makeStrongCacheSync)((Pe) => ee(le, le.filepath, d.createUncachedDescriptors, fe, Pe))));
        function H({ dirname: le, options: fe }, Pe, xe) {
          return xe(le, fe, Pe);
        }
        function U({ dirname: le, options: fe }, Pe, xe, we) {
          var me;
          const ye = (me = fe.env) == null ? void 0 : me[we];
          return ye ? xe(le, ye, `${Pe}.env["${we}"]`) : null;
        }
        function q({ dirname: le, options: fe }, Pe, xe, we) {
          var me;
          const ye = (me = fe.overrides) == null ? void 0 : me[we];
          if (!ye) throw new Error("Assertion failure - missing override");
          return xe(le, ye, `${Pe}.overrides[${we}]`);
        }
        function ee({ dirname: le, options: fe }, Pe, xe, we, me) {
          var ye, pe;
          const J = (ye = fe.overrides) == null ? void 0 : ye[we];
          if (!J) throw new Error("Assertion failure - missing override");
          const Ee = (pe = J.env) == null ? void 0 : pe[me];
          return Ee ? xe(le, Ee, `${Pe}.overrides[${we}].env["${me}"]`) : null;
        }
        function re({ root: le, env: fe, overrides: Pe, overridesEnv: xe, createLogger: we }) {
          return function* (me, ye, pe = /* @__PURE__ */ new Set(), J) {
            const { dirname: Ee } = me, Me = [], Ue = le(me);
            if (K(Ue, Ee, ye, me.filepath)) {
              Me.push({ config: Ue, envName: void 0, index: void 0 });
              const Ie = fe(me, ye.envName);
              Ie && K(Ie, Ee, ye, me.filepath) && Me.push({ config: Ie, envName: ye.envName, index: void 0 }), (Ue.options.overrides || []).forEach((Re, Be) => {
                const je = Pe(me, Be);
                if (K(je, Ee, ye, me.filepath)) {
                  Me.push({ config: je, index: Be, envName: void 0 });
                  const he = xe(me, Be, ye.envName);
                  he && K(he, Ee, ye, me.filepath) && Me.push({ config: he, index: Be, envName: ye.envName });
                }
              });
            }
            if (Me.some(({ config: { options: { ignore: Ie, only: Re } } }) => ue(ye, Ie, Re, Ee))) return null;
            const qe = B(), He = we(me, ye, J);
            for (const { config: Ie, index: Re, envName: Be } of Me) {
              if (!(yield* Y(qe, Ie.options, Ee, ye, pe, J))) return null;
              He(Ie, Re, Be), yield* G(qe, Ie);
            }
            return qe;
          };
        }
        function* Y(le, fe, Pe, xe, we, me) {
          if (fe.extends === void 0) return true;
          const ye = yield* (0, S.loadConfig)(fe.extends, Pe, xe.envName, xe.caller);
          if (we.has(ye)) throw new Error(`Configuration cycle detected loading ${ye.filepath}.
File already loaded following the config chain:
` + Array.from(we, (J) => ` - ${J.filepath}`).join(`
`));
          we.add(ye);
          const pe = yield* k(D(ye), xe, we, me);
          return we.delete(ye), !!pe && (Z(le, pe), true);
        }
        function Z(le, fe) {
          le.options.push(...fe.options), le.plugins.push(...fe.plugins), le.presets.push(...fe.presets);
          for (const Pe of fe.files) le.files.add(Pe);
          return le;
        }
        function* G(le, { options: fe, plugins: Pe, presets: xe }) {
          return le.options.push(fe), le.plugins.push(...yield* Pe()), le.presets.push(...yield* xe()), le;
        }
        function B() {
          return { options: [], presets: [], plugins: [], files: /* @__PURE__ */ new Set() };
        }
        function z(le) {
          const fe = Object.assign({}, le);
          return delete fe.extends, delete fe.env, delete fe.overrides, delete fe.plugins, delete fe.presets, delete fe.passPerPreset, delete fe.ignore, delete fe.only, delete fe.test, delete fe.include, delete fe.exclude, hasOwnProperty.call(fe, "sourceMap") && (fe.sourceMaps = fe.sourceMap, delete fe.sourceMap), fe;
        }
        function M(le) {
          const fe = /* @__PURE__ */ new Map(), Pe = [];
          for (const xe of le) if (typeof xe.value == "function") {
            const we = xe.value;
            let me = fe.get(we);
            me || (me = /* @__PURE__ */ new Map(), fe.set(we, me));
            let ye = me.get(xe.name);
            ye ? ye.value = xe : (ye = { value: xe }, Pe.push(ye), xe.ownPass || me.set(xe.name, ye));
          } else Pe.push({ value: xe });
          return Pe.reduce((xe, we) => (xe.push(we.value), xe), []);
        }
        function K({ options: le }, fe, Pe, xe) {
          return (le.test === void 0 || Q(Pe, le.test, fe, xe)) && (le.include === void 0 || Q(Pe, le.include, fe, xe)) && (le.exclude === void 0 || !Q(Pe, le.exclude, fe, xe));
        }
        function Q(le, fe, Pe, xe) {
          return ge(le, Array.isArray(fe) ? fe : [fe], Pe, xe);
        }
        function ie(le, fe) {
          return fe instanceof RegExp ? String(fe) : fe;
        }
        function ue(le, fe, Pe, xe) {
          if (fe && ge(le, fe, xe)) {
            var we;
            const ye = `No config is applied to "${(we = le.filename) != null ? we : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(fe, ie)}\` from "${xe}"`;
            return p(ye), le.showConfig && console.log(ye), true;
          }
          if (Pe && !ge(le, Pe, xe)) {
            var me;
            const ye = `No config is applied to "${(me = le.filename) != null ? me : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(Pe, ie)}\` from "${xe}"`;
            return p(ye), le.showConfig && console.log(ye), true;
          }
          return false;
        }
        function ge(le, fe, Pe, xe) {
          return fe.some((we) => Te(we, Pe, le.filename, le, xe));
        }
        function Te(le, fe, Pe, xe, we) {
          if (typeof le == "function") return !!(0, f.endHiddenCallStack)(le)(Pe, { dirname: fe, envName: xe.envName, caller: xe.caller });
          if (typeof Pe != "string") throw new y.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", we);
          return typeof le == "string" && (le = (0, e.default)(le, fe)), le.test(Pe);
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-descriptors.js": (P, t, l) => {
        function n() {
          const D = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return n = function() {
            return D;
          }, D;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.createCachedDescriptors = function(D, j, L) {
          const { plugins: k, presets: N, passPerPreset: F } = j;
          return { options: S(j, D), plugins: k ? () => h(k, D)(L) : () => y([]), presets: N ? () => d(N, D)(L)(!!F) : () => y([]) };
        }, t.createDescriptor = I, t.createUncachedDescriptors = function(D, j, L) {
          return { options: S(j, D), plugins: (0, u.once)(() => C(j.plugins || [], D, L)), presets: (0, u.once)(() => _(j.presets || [], D, L, !!j.passPerPreset)) };
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/functional.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/index.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/item.js"), r = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js"), f = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/resolve-targets.js");
        function* y(D) {
          return D;
        }
        function S(D, j) {
          return typeof D.browserslistConfigFile == "string" && (D.browserslistConfigFile = (0, f.resolveBrowserslistConfigFile)(D.browserslistConfigFile, j)), D;
        }
        const T = /* @__PURE__ */ new WeakMap(), d = (0, r.makeWeakCacheSync)((D, j) => {
          const L = j.using((k) => k);
          return (0, r.makeStrongCacheSync)((k) => (0, r.makeStrongCache)(function* (N) {
            return (yield* _(D, L, k, N)).map((F) => E(T, F));
          }));
        }), p = /* @__PURE__ */ new WeakMap(), h = (0, r.makeWeakCacheSync)((D, j) => {
          const L = j.using((k) => k);
          return (0, r.makeStrongCache)(function* (k) {
            return (yield* C(D, L, k)).map((N) => E(p, N));
          });
        }), m = {};
        function E(D, j) {
          const { value: L, options: k = m } = j;
          if (k === false) return j;
          let N = D.get(L);
          N || (N = /* @__PURE__ */ new WeakMap(), D.set(L, N));
          let F = N.get(k);
          if (F || (F = [], N.set(k, F)), !F.includes(j)) {
            const W = F.filter((X) => {
              return U = j, (H = X).name === U.name && H.value === U.value && H.options === U.options && H.dirname === U.dirname && H.alias === U.alias && H.ownPass === U.ownPass && ((q = H.file) == null ? void 0 : q.request) === ((ee = U.file) == null ? void 0 : ee.request) && ((re = H.file) == null ? void 0 : re.resolved) === ((Y = U.file) == null ? void 0 : Y.resolved);
              var H, U, q, ee, re, Y;
            });
            if (W.length > 0) return W[0];
            F.push(j);
          }
          return j;
        }
        function* _(D, j, L, k) {
          return yield* w("preset", D, j, L, k);
        }
        function* C(D, j, L) {
          return yield* w("plugin", D, j, L);
        }
        function* w(D, j, L, k, N) {
          const F = yield* n().all(j.map((W, X) => I(W, L, { type: D, alias: `${k}$${X}`, ownPass: !!N })));
          return function(W) {
            const X = /* @__PURE__ */ new Map();
            for (const H of W) {
              if (typeof H.value != "function") continue;
              let U = X.get(H.value);
              if (U || (U = /* @__PURE__ */ new Set(), X.set(H.value, U)), U.has(H.name)) {
                const q = W.filter((ee) => ee.value === H.value);
                throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(q, null, 2)}`].join(`
`));
              }
              U.add(H.name);
            }
          }(F), F;
        }
        function* I(D, j, { type: L, alias: k, ownPass: N }) {
          const F = (0, e.getItemDescriptor)(D);
          if (F) return F;
          let W, X, H, U = D;
          Array.isArray(U) && (U.length === 3 ? [U, X, W] = U : [U, X] = U);
          let q = null;
          if (typeof U == "string") {
            if (typeof L != "string") throw new Error("To resolve a string-based item, the type of item must be given");
            const ee = L === "plugin" ? c.loadPlugin : c.loadPreset, re = U;
            ({ filepath: q, value: U } = yield* ee(U, j)), H = { request: re, resolved: q };
          }
          if (!U) throw new Error(`Unexpected falsy value: ${String(U)}`);
          if (typeof U == "object" && U.__esModule) {
            if (!U.default) throw new Error("Must export a default export when using ES6 modules.");
            U = U.default;
          }
          if (typeof U != "object" && typeof U != "function") throw new Error(`Unsupported format: ${typeof U}. Expected an object or a function.`);
          if (q !== null && typeof U == "object" && U) throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${q}`);
          return { name: W, alias: q || k, value: U, options: X, dirname: j, ownPass: N, file: H };
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/configuration.js": (P, t, l) => {
        function n() {
          const H = l("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js");
          return n = function() {
            return H;
          }, H;
        }
        function u() {
          const H = l("fs");
          return u = function() {
            return H;
          }, H;
        }
        function c() {
          const H = l("path");
          return c = function() {
            return H;
          }, H;
        }
        function e() {
          const H = l("./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs");
          return e = function() {
            return H;
          }, H;
        }
        function r() {
          const H = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return r = function() {
            return H;
          }, H;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.ROOT_CONFIG_FILENAMES = void 0, t.findConfigUpwards = function(H) {
          let U = H;
          for (; ; ) {
            for (const ee of C) if (u().existsSync(c().join(U, ee))) return U;
            const q = c().dirname(U);
            if (U === q) break;
            U = q;
          }
          return null;
        }, t.findRelativeConfig = function* (H, U, q) {
          let ee = null, re = null;
          const Y = c().dirname(H.filepath);
          for (const G of H.directories) {
            var Z;
            if (ee || (ee = yield* W(w, G, U, q, ((Z = H.pkg) == null ? void 0 : Z.dirname) === G ? k(H.pkg) : null)), !re) {
              const B = c().join(G, I);
              re = yield* F(B), re && _("Found ignore %o from %o.", re.filepath, Y);
            }
          }
          return { config: ee, ignore: re };
        }, t.findRootConfig = function(H, U, q) {
          return W(C, H, U, q);
        }, t.loadConfig = function* (H, U, q, ee) {
          const re = (Z = process.versions.node, G = "8.9", Z = Z.split("."), G = G.split("."), +Z[0] > +G[0] || Z[0] == G[0] && +Z[1] >= +G[1] ? l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").resolve : (B, { paths: [z] }, M = l("module")) => {
            let K = M._findPath(B, M._nodeModulePaths(z).concat(z));
            if (K) return K;
            throw K = new Error(`Cannot resolve module '${B}'`), K.code = "MODULE_NOT_FOUND", K;
          })(H, { paths: [U] }), Y = yield* X(re, q, ee);
          var Z, G;
          if (!Y) throw new p.default("Config file contains no configuration data", re);
          return _("Loaded config %o from %o.", H, U), Y;
        }, t.resolveShowConfigPath = function* (H) {
          const U = s.BABEL_SHOW_CONFIG_FOR;
          if (U != null) {
            const q = c().resolve(H, U);
            if (!(yield* h.stat(q)).isFile()) throw new Error(`${q}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
            return q;
          }
          return null;
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js"), y = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/config-api.js"), S = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/utils.js"), T = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/module-types.js"), d = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/pattern-to-regex.js"), p = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js"), h = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/fs.js"), m = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), E = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js");
        const _ = n()("babel:config:loading:files:configuration"), C = t.ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts"], w = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"], I = ".babelignore", D = (0, f.makeWeakCache)(function* (H, U) {
          return yield* [], { options: (0, m.endHiddenCallStack)(H)((0, y.makeConfigAPI)(U)), cacheNeedsConfiguration: !U.configured() };
        });
        function* j(H, U) {
          if (!u().existsSync(H)) return null;
          let q = yield* (0, T.default)(H, (yield* (0, E.isAsync)()) ? "auto" : "require", "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously or when using the Node.js `--experimental-require-module` flag.", "You appear to be using a configuration file that contains top-level await, which is only supported when running Babel asynchronously."), ee = false;
          if (typeof q == "function" && ({ options: q, cacheNeedsConfiguration: ee } = yield* D(q, U)), !q || typeof q != "object" || Array.isArray(q)) throw new p.default("Configuration should be an exported JavaScript object.", H);
          if (typeof q.then == "function") throw q.catch == null || q.catch(() => {
          }), new p.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.", H);
          return ee && function(re) {
            throw new p.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, re);
          }(H), function(re, Y) {
            let Z = L.get(re);
            Z || L.set(re, Z = /* @__PURE__ */ new Map());
            let G = Z.get(Y);
            return G || (G = { filepath: Y, dirname: c().dirname(Y), options: re }, Z.set(Y, G)), G;
          }(q, H);
        }
        const L = /* @__PURE__ */ new WeakMap(), k = (0, f.makeWeakCacheSync)((H) => {
          const U = H.options.babel;
          if (U === void 0) return null;
          if (typeof U != "object" || Array.isArray(U) || U === null) throw new p.default(".babel property must be an object", H.filepath);
          return { filepath: H.filepath, dirname: H.dirname, options: U };
        }), N = (0, S.makeStaticFileCache)((H, U) => {
          let q;
          try {
            q = e().parse(U);
          } catch (ee) {
            throw new p.default(`Error while parsing config - ${ee.message}`, H);
          }
          if (!q) throw new p.default("No config detected", H);
          if (typeof q != "object") throw new p.default("Config returned typeof " + typeof q, H);
          if (Array.isArray(q)) throw new p.default("Expected config object but found array", H);
          return delete q.$schema, { filepath: H, dirname: c().dirname(H), options: q };
        }), F = (0, S.makeStaticFileCache)((H, U) => {
          const q = c().dirname(H), ee = U.split(`
`).map((re) => re.replace(/#.*$/, "").trim()).filter(Boolean);
          for (const re of ee) if (re[0] === "!") throw new p.default("Negation of file paths is not supported.", H);
          return { filepath: H, dirname: c().dirname(H), ignore: ee.map((re) => (0, d.default)(re, q)) };
        });
        function* W(H, U, q, ee, re = null) {
          const Y = (yield* r().all(H.map((Z) => X(c().join(U, Z), q, ee)))).reduce((Z, G) => {
            if (G && Z) throw new p.default(`Multiple configuration files found. Please remove one:
 - ${c().basename(Z.filepath)}
 - ${G.filepath}
from ${U}`);
            return G || Z;
          }, re);
          return Y && _("Found configuration %o from %o.", Y.filepath, U), Y;
        }
        function X(H, U, q) {
          switch (c().extname(H)) {
            case ".js":
            case ".cjs":
            case ".mjs":
            case ".cts":
              return j(H, { envName: U, caller: q });
            default:
              return N(H);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/import.cjs": (P, t, l) => {
        P.exports = function(n) {
          return l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files lazy recursive")(n);
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), Object.defineProperty(t, "ROOT_CONFIG_FILENAMES", { enumerable: true, get: function() {
          return u.ROOT_CONFIG_FILENAMES;
        } }), Object.defineProperty(t, "findConfigUpwards", { enumerable: true, get: function() {
          return u.findConfigUpwards;
        } }), Object.defineProperty(t, "findPackageData", { enumerable: true, get: function() {
          return n.findPackageData;
        } }), Object.defineProperty(t, "findRelativeConfig", { enumerable: true, get: function() {
          return u.findRelativeConfig;
        } }), Object.defineProperty(t, "findRootConfig", { enumerable: true, get: function() {
          return u.findRootConfig;
        } }), Object.defineProperty(t, "loadConfig", { enumerable: true, get: function() {
          return u.loadConfig;
        } }), Object.defineProperty(t, "loadPlugin", { enumerable: true, get: function() {
          return c.loadPlugin;
        } }), Object.defineProperty(t, "loadPreset", { enumerable: true, get: function() {
          return c.loadPreset;
        } }), Object.defineProperty(t, "resolvePlugin", { enumerable: true, get: function() {
          return c.resolvePlugin;
        } }), Object.defineProperty(t, "resolvePreset", { enumerable: true, get: function() {
          return c.resolvePreset;
        } }), Object.defineProperty(t, "resolveShowConfigPath", { enumerable: true, get: function() {
          return u.resolveShowConfigPath;
        } });
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/package.js"), u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/configuration.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/plugins.js");
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/module-types.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function* (j, L, k, N) {
          var F;
          let W, X = u().extname(j);
          switch (w.has(X) || (X = ".js"), `${L} ${X}`) {
            case "require .cjs":
            case "auto .cjs":
              return m(j, arguments[2]);
            case "require .cts":
            case "auto .cts":
              return function(U) {
                const q = ".cts", ee = !!(l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[".ts"] || l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[".cts"] || l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[".mts"]);
                let re;
                if (!ee) {
                  const Y = { babelrc: false, configFile: false, sourceType: "unambiguous", sourceMaps: "inline", sourceFileName: u().basename(U), presets: [[D(U), Object.assign({ onlyRemoveTypeImports: true, optimizeConstEnums: true }, { allowDeclareFields: true })]] };
                  re = function(Z, G) {
                    if (re && G.endsWith(q)) try {
                      return Z._compile((0, S.transformFileSync)(G, Object.assign({}, Y, { filename: G })).code, G);
                    } catch (B) {
                      if (!ee) {
                        const z = l("./node_modules/.pnpm/@babel+preset-typescript@7.26.0_@babel+core@7.26.0/node_modules/@babel/preset-typescript/package.json");
                        e().lt(z.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");
                      }
                      throw B;
                    }
                    return l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[".js"](Z, G);
                  }, l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[q] = re;
                }
                try {
                  return m(U);
                } finally {
                  ee || (l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[q] === re && delete l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").extensions[q], re = void 0);
                }
              }(j);
            case "auto .js":
            case "require .js":
            case "require .mjs":
              try {
                return m(j, arguments[2]);
              } catch (U) {
                var H;
                if (U.code === "ERR_REQUIRE_ASYNC_MODULE" || U.code === "ERR_REQUIRE_CYCLE_MODULE" && I.has(j)) {
                  if (I.add(j), !((H = W) != null ? H : W = yield* (0, n.isAsync)())) throw new y.default(N, j);
                } else if (U.code !== "ERR_REQUIRE_ESM" && X !== ".mjs") throw U;
              }
            case "auto .mjs":
              if ((F = W) != null ? F : W = yield* (0, n.isAsync)()) return (yield* (0, n.waitFor)(E(j))).default;
              throw new y.default(k, j);
            default:
              throw new Error("Internal Babel error: unreachable code.");
          }
        }, t.supportsESM = void 0;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js");
        function u() {
          const j = l("path");
          return u = function() {
            return j;
          }, j;
        }
        function c() {
          const j = l("url");
          return c = function() {
            return j;
          }, j;
        }
        function e() {
          const j = l("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return e = function() {
            return j;
          }, j;
        }
        function r() {
          const j = l("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js");
          return r = function() {
            return j;
          }, j;
        }
        var f = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), y = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js"), S = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform-file.js");
        function T(j, L, k, N, F, W, X) {
          try {
            var H = j[W](X), U = H.value;
          } catch (q) {
            return void k(q);
          }
          H.done ? L(U) : Promise.resolve(U).then(N, F);
        }
        const d = r()("babel:config:loading:files:module-types");
        try {
          var p = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/import.cjs");
        } catch {
        }
        t.supportsESM = e().satisfies(process.versions.node, "^12.17 || >=13.2");
        const h = /* @__PURE__ */ new Set();
        function m(j) {
          if (h.has(j)) return d("Auto-ignoring usage of config %o.", j), {};
          let L;
          try {
            h.add(j), L = (0, f.endHiddenCallStack)(l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive"))(j);
          } finally {
            h.delete(j);
          }
          return L == null || !L.__esModule && L[Symbol.toStringTag] !== "Module" ? L : L.default || (arguments[1] ? L : void 0);
        }
        const E = (0, f.endHiddenCallStack)((_ = function* (j) {
          const L = (0, c().pathToFileURL)(j).toString() + "?import";
          if (!p) throw new y.default(`Internal error: Native ECMAScript modules aren't supported by this platform.
`, j);
          return yield p(L);
        }, C = function() {
          var j = this, L = arguments;
          return new Promise(function(k, N) {
            var F = _.apply(j, L);
            function W(H) {
              T(F, k, N, W, X, "next", H);
            }
            function X(H) {
              T(F, k, N, W, X, "throw", H);
            }
            W(void 0);
          });
        }, function(j) {
          return C.apply(this, arguments);
        }));
        var _, C;
        const w = /* @__PURE__ */ new Set([".js", ".mjs", ".cjs", ".cts"]), I = /* @__PURE__ */ new Set();
        function D(j) {
          try {
            return l("./node_modules/.pnpm/@babel+preset-typescript@7.26.0_@babel+core@7.26.0/node_modules/@babel/preset-typescript/lib/index.js");
          } catch (L) {
            if (L.code !== "MODULE_NOT_FOUND") throw L;
            let k = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
            throw process.versions.pnp && (k += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new y.default(k, j);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/package.js": (P, t, l) => {
        function n() {
          const f = l("path");
          return n = function() {
            return f;
          }, f;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.findPackageData = function* (f) {
          let y = null;
          const S = [];
          let T = true, d = n().dirname(f);
          for (; !y && n().basename(d) !== "node_modules"; ) {
            S.push(d), y = yield* r(n().join(d, e));
            const p = n().dirname(d);
            if (d === p) {
              T = false;
              break;
            }
            d = p;
          }
          return { filepath: f, directories: S, pkg: y, isPackage: T };
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/utils.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js");
        const e = "package.json", r = (0, u.makeStaticFileCache)((f, y) => {
          let S;
          try {
            S = JSON.parse(y);
          } catch (T) {
            throw new c.default(`Error while parsing JSON - ${T.message}`, f);
          }
          if (!S) throw new Error(`${f}: No config detected`);
          if (typeof S != "object") throw new c.default("Config returned typeof " + typeof S, f);
          if (Array.isArray(S)) throw new c.default("Expected config object but found array", f);
          return { filepath: f, dirname: n().dirname(f), options: S };
        });
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/plugins.js": (P, t, l) => {
        function n() {
          const H = l("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js");
          return n = function() {
            return H;
          }, H;
        }
        function u() {
          const H = l("path");
          return u = function() {
            return H;
          }, H;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.loadPlugin = function* (H, U) {
          const { filepath: q, loader: ee } = w(H, U, yield* (0, c.isAsync)()), re = yield* X("plugin", ee, q);
          return S("Loaded plugin %o from %o.", H, U), { filepath: q, value: re };
        }, t.loadPreset = function* (H, U) {
          const { filepath: q, loader: ee } = I(H, U, yield* (0, c.isAsync)()), re = yield* X("preset", ee, q);
          return S("Loaded preset %o from %o.", H, U), { filepath: q, value: re };
        }, t.resolvePreset = t.resolvePlugin = void 0;
        var c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/module-types.js");
        function r() {
          const H = l("url");
          return r = function() {
            return H;
          }, H;
        }
        var f = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/vendor/import-meta-resolve.js");
        function y() {
          const H = l("fs");
          return y = function() {
            return H;
          }, H;
        }
        const S = n()("babel:config:loading:files:plugins"), T = /^module:/, d = /^(?!@|module:|[^/]+\/|babel-plugin-)/, p = /^(?!@|module:|[^/]+\/|babel-preset-)/, h = /^(@babel\/)(?!plugin-|[^/]+\/)/, m = /^(@babel\/)(?!preset-|[^/]+\/)/, E = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/, _ = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, C = /^(@(?!babel$)[^/]+)$/, w = t.resolvePlugin = F.bind(null, "plugin"), I = t.resolvePreset = F.bind(null, "preset");
        function D(H, U) {
          if (u().isAbsolute(U)) return U;
          const q = H === "preset";
          return U.replace(q ? p : d, `babel-${H}-`).replace(q ? m : h, `$1${H}-`).replace(q ? _ : E, `$1babel-${H}-`).replace(C, `$1/babel-${H}`).replace(T, "");
        }
        function* j(H, U) {
          const q = D(H, U), { error: ee, value: re } = yield q;
          if (!ee) return re;
          if (ee.code !== "MODULE_NOT_FOUND") throw ee;
          q === U || (yield U).error || (ee.message += `
- If you want to resolve "${U}", use "module:${U}"`), (yield D(H, "@babel/" + U)).error || (ee.message += `
- Did you mean "@babel/${U}"?`);
          const Y = H === "preset" ? "plugin" : "preset";
          if ((yield D(Y, U)).error || (ee.message += `
- Did you accidentally pass a ${Y} as a ${H}?`), H === "plugin") {
            const Z = q.replace("-proposal-", "-transform-");
            Z === q || (yield Z).error || (ee.message += `
- Did you mean "${Z}"?`);
          }
          throw ee.message += `

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`, ee;
        }
        function L(H, U) {
          try {
            return U ? { error: null, value: (q = process.versions.node, ee = "8.9", q = q.split("."), ee = ee.split("."), +q[0] > +ee[0] || q[0] == ee[0] && +q[1] >= +ee[1] ? l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").resolve : (re, { paths: [Y] }, Z = l("module")) => {
              let G = Z._findPath(re, Z._nodeModulePaths(Y).concat(Y));
              if (G) return G;
              throw G = new Error(`Cannot resolve module '${re}'`), G.code = "MODULE_NOT_FOUND", G;
            })(H, { paths: [U] }) } : { error: null, value: l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files sync recursive").resolve(H) };
          } catch (re) {
            return { error: re, value: null };
          }
          var q, ee;
        }
        function k(H, U) {
          try {
            return { error: null, value: (0, f.resolve)(H, U) };
          } catch (q) {
            return { error: q, value: null };
          }
        }
        function N(H, U, q) {
          const ee = j(H, U);
          let re = ee.next();
          for (; !re.done; ) re = ee.next(L(re.value, q));
          return { loader: "require", filepath: re.value };
        }
        function F(H, U, q, ee) {
          if (!e.supportsESM || !ee) return N(H, U, q);
          try {
            const re = function(Y, Z, G) {
              const B = (0, r().pathToFileURL)(u().join(G, "./babel-virtual-resolve-base.js")).href, z = j(Y, Z);
              let M = z.next();
              for (; !M.done; ) M = z.next(k(M.value, B));
              return { loader: "auto", filepath: (0, r().fileURLToPath)(M.value) };
            }(H, U, q);
            if (!(0, y().existsSync)(re.filepath)) throw Object.assign(new Error(`Could not resolve "${U}" in file ${q}.`), { type: "MODULE_NOT_FOUND" });
            return re;
          } catch (re) {
            try {
              return N(H, U, q);
            } catch (Y) {
              throw re.type === "MODULE_NOT_FOUND" ? re : Y.type === "MODULE_NOT_FOUND" ? Y : re;
            }
          }
        }
        var W = /* @__PURE__ */ new Set();
        function* X(H, U, q) {
          if (!(yield* (0, c.isAsync)()) && W.has(q)) throw new Error(`Reentrant ${H} detected trying to load "${q}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
          try {
            return W.add(q), yield* (0, e.default)(q, U, `You appear to be using a native ECMAScript module ${H}, which is only supported when running Babel asynchronously or when using the Node.js \`--experimental-require-module\` flag.`, `You appear to be using a ${H} that contains top-level await, which is only supported when running Babel asynchronously.`, true);
          } catch (ee) {
            throw ee.message = `[BABEL]: ${ee.message} (While processing: ${q})`, ee;
          } finally {
            W.delete(q);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/utils.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.makeStaticFileCache = function(e) {
          return (0, n.makeStrongCache)(function* (r, f) {
            return f.invalidate(() => function(S) {
              if (!c().existsSync(S)) return null;
              try {
                return +c().statSync(S).mtime;
              } catch (T) {
                if (T.code !== "ENOENT" && T.code !== "ENOTDIR") throw T;
              }
              return null;
            }(r)) === null ? null : e(r, yield* u.readFile(r, "utf8"));
          });
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js"), u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/fs.js");
        function c() {
          const e = l("fs");
          return c = function() {
            return e;
          }, e;
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/full.js": (P, t, l) => {
        function n() {
          const U = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return n = function() {
            return U;
          }, U;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/util.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), r = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/plugin.js"), f = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/item.js"), y = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-chain.js"), S = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        function T() {
          const U = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");
          return T = function() {
            return U;
          }, U;
        }
        var d = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js"), p = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/options.js"), h = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/plugins.js"), m = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/config-api.js"), E = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/partial.js"), _ = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js");
        t.default = n()(function* (U) {
          var q;
          const ee = yield* (0, E.default)(U);
          if (!ee) return null;
          const { options: re, context: Y, fileHandling: Z } = ee;
          if (Z === "ignored") return null;
          const G = {}, { plugins: B, presets: z } = re;
          if (!B || !z) throw new Error("Assertion failure - plugins and presets exist");
          const M = Object.assign({}, Y, { targets: re.targets }), K = (xe) => {
            const we = (0, f.getItemDescriptor)(xe);
            if (!we) throw new Error("Assertion failure - must be config item");
            return we;
          }, Q = z.map(K), ie = B.map(K), ue = [[]], ge = [], Te = [];
          if (yield* C(Y, function* xe(we, me) {
            const ye = [];
            for (let J = 0; J < we.length; J++) {
              const Ee = we[J];
              if (Ee.options !== false) {
                try {
                  var pe = yield* X(Ee, M);
                } catch (Me) {
                  throw Me.code === "BABEL_UNKNOWN_OPTION" && (0, p.checkNoUnwrappedItemOptionPairs)(we, J, "preset", Me), Me;
                }
                Te.push(pe.externalDependencies), Ee.ownPass ? ye.push({ preset: pe.chain, pass: [] }) : ye.unshift({ preset: pe.chain, pass: me });
              }
            }
            if (ye.length > 0) {
              ue.splice(1, 0, ...ye.map((J) => J.pass).filter((J) => J !== me));
              for (const { preset: J, pass: Ee } of ye) {
                if (!J || (Ee.push(...J.plugins), yield* xe(J.presets, Ee))) return true;
                J.options.forEach((Me) => {
                  (0, c.mergeOptions)(G, Me);
                });
              }
            }
          })(Q, ue[0])) return null;
          const fe = G;
          (0, c.mergeOptions)(fe, re);
          const Pe = Object.assign({}, M, { assumptions: (q = fe.assumptions) != null ? q : {} });
          return yield* C(Y, function* () {
            ue[0].unshift(...ie);
            for (const we of ue) {
              const me = [];
              ge.push(me);
              for (let ye = 0; ye < we.length; ye++) {
                const pe = we[ye];
                if (pe.options !== false) {
                  try {
                    var xe = yield* L(pe, Pe);
                  } catch (J) {
                    throw J.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, p.checkNoUnwrappedItemOptionPairs)(we, ye, "plugin", J), J;
                  }
                  me.push(xe), Te.push(xe.externalDependencies);
                }
              }
            }
          })(), fe.plugins = ge[0], fe.presets = ge.slice(1).filter((xe) => xe.length > 0).map((xe) => ({ plugins: xe })), fe.passPerPreset = fe.presets.length > 0, { options: fe, passes: ge, externalDependencies: (0, S.finalize)(Te) };
        });
        function C(U, q) {
          return function* (ee, re) {
            try {
              return yield* q(ee, re);
            } catch (Z) {
              var Y;
              throw /^\[BABEL\]/.test(Z.message) || (Z.message = `[BABEL] ${(Y = U.filename) != null ? Y : "unknown file"}: ${Z.message}`), Z;
            }
          };
        }
        const w = (U) => (0, d.makeWeakCache)(function* ({ value: q, options: ee, dirname: re, alias: Y }, Z) {
          if (ee === false) throw new Error("Assertion failure");
          ee = ee || {};
          const G = [];
          let B = q;
          if (typeof q == "function") {
            const z = (0, u.maybeAsync)(q, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), M = Object.assign({}, e, U(Z, G));
            try {
              B = yield* z(M, ee, re);
            } catch (K) {
              throw Y && (K.message += ` (While processing: ${JSON.stringify(Y)})`), K;
            }
          }
          if (!B || typeof B != "object") throw new Error("Plugin/Preset did not return an object.");
          if ((0, u.isThenable)(B)) throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(Y)})`);
          if (G.length > 0 && (!Z.configured() || Z.mode() === "forever")) {
            let z = `A plugin/preset has external untracked dependencies (${G[0]}), but the cache `;
            throw Z.configured() ? z += " has been configured to never be invalidated. " : z += "has not been configured to be invalidated when the external dependencies change. ", z += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(Y)})`, new Error(z);
          }
          return { value: B, options: ee, dirname: re, alias: Y, externalDependencies: (0, S.finalize)(G) };
        }), I = w(m.makePluginAPI), D = w(m.makePresetAPI), j = (0, d.makeWeakCache)(function* ({ value: U, options: q, dirname: ee, alias: re, externalDependencies: Y }, Z) {
          const G = (0, h.validatePluginObject)(U), B = Object.assign({}, G);
          if (B.visitor && (B.visitor = T().default.explode(Object.assign({}, B.visitor))), B.inherits) {
            const z = { name: void 0, alias: `${re}$inherits`, value: B.inherits, options: q, dirname: ee }, M = yield* (0, u.forwardAsync)(L, (K) => Z.invalidate((Q) => K(z, Q)));
            B.pre = H(M.pre, B.pre), B.post = H(M.post, B.post), B.manipulateOptions = H(M.manipulateOptions, B.manipulateOptions), B.visitor = T().default.visitors.merge([M.visitor || {}, B.visitor || {}]), M.externalDependencies.length > 0 && (Y = Y.length === 0 ? M.externalDependencies : (0, S.finalize)([Y, M.externalDependencies]));
          }
          return new r.default(B, q, re, Y);
        });
        function* L(U, q) {
          if (U.value instanceof r.default) {
            if (U.options) throw new Error("Passed options to an existing Plugin instance will not work.");
            return U.value;
          }
          return yield* j(yield* I(U, q), q);
        }
        const k = (U) => U && typeof U != "function", N = (U, q) => {
          if (k(U.test) || k(U.include) || k(U.exclude)) {
            const ee = q.name ? `"${q.name}"` : "/* your preset */";
            throw new _.default([`Preset ${ee} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, { filename: 'file.ts', presets: [${ee}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
          }
        }, F = (U, q, ee) => {
          if (!q.filename) {
            var re;
            const { options: Y } = U;
            N(Y, ee), (re = Y.overrides) == null || re.forEach((Z) => N(Z, ee));
          }
        }, W = (0, d.makeWeakCacheSync)(({ value: U, dirname: q, alias: ee, externalDependencies: re }) => ({ options: (0, p.validate)("preset", U), alias: ee, dirname: q, externalDependencies: re }));
        function* X(U, q) {
          const ee = W(yield* D(U, q));
          return F(ee, q, U), { chain: yield* (0, y.buildPresetChain)(ee, q), externalDependencies: ee.externalDependencies };
        }
        function H(U, q) {
          return U ? q ? function(...ee) {
            const re = U.apply(this, ee);
            return re && typeof re.then == "function" ? re.then(() => q.apply(this, ee)) : q.apply(this, ee);
          } : U : q;
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/config-api.js": (P, t, l) => {
        function n() {
          const y = l("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return n = function() {
            return y;
          }, y;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.makeConfigAPI = e, t.makePluginAPI = function(y, S) {
          return Object.assign({}, r(y, S), { assumption: (T) => y.using((d) => d.assumptions[T]) });
        }, t.makePresetAPI = r;
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/caching.js");
        function e(y) {
          return { version: u.version, cache: y.simple(), env: (S) => y.using((T) => S === void 0 ? T.envName : typeof S == "function" ? (0, c.assertSimpleType)(S(T.envName)) : (Array.isArray(S) ? S : [S]).some((d) => {
            if (typeof d != "string") throw new Error("Unexpected non-string value");
            return d === T.envName;
          })), async: () => false, caller: (S) => y.using((T) => (0, c.assertSimpleType)(S(T.caller))), assertVersion: f };
        }
        function r(y, S) {
          return Object.assign({}, e(y), { targets: () => JSON.parse(y.using((T) => JSON.stringify(T.targets))), addExternalDependency: (T) => {
            S.push(T);
          } });
        }
        function f(y) {
          if (typeof y == "number") {
            if (!Number.isInteger(y)) throw new Error("Expected string or integer value.");
            y = `^${y}.0.0-0`;
          }
          if (typeof y != "string") throw new Error("Expected string or integer value.");
          if (y === "*" || n().satisfies(u.version, y)) return;
          const S = Error.stackTraceLimit;
          typeof S == "number" && S < 25 && (Error.stackTraceLimit = 25);
          const T = new Error(`Requires Babel "${y}", but was loaded with "${u.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
          throw typeof S == "number" && (Error.stackTraceLimit = S), Object.assign(T, { code: "BABEL_VERSION_UNSUPPORTED", version: u.version, range: y });
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/deep-array.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.finalize = function(l) {
          return Object.freeze(l);
        }, t.flattenToSet = function(l) {
          const n = /* @__PURE__ */ new Set(), u = [l];
          for (; u.length > 0; ) for (const c of u.pop()) Array.isArray(c) ? u.push(c) : n.add(c);
          return n;
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/environment.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.getEnv = function(l = "development") {
          return s.BABEL_ENV || "production";
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js": (P, t, l) => {
        function n() {
          const h = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return n = function() {
            return h;
          }, h;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.createConfigItem = function(h, m, E) {
          if (E !== void 0) (0, r.beginHiddenCallStack)(d.errback)(h, m, E);
          else {
            if (typeof m != "function") return p(h, m);
            (0, r.beginHiddenCallStack)(d.errback)(h, void 0, E);
          }
        }, t.createConfigItemAsync = function(...h) {
          return (0, r.beginHiddenCallStack)(d.async)(...h);
        }, t.createConfigItemSync = p, Object.defineProperty(t, "default", { enumerable: true, get: function() {
          return u.default;
        } }), t.loadOptions = function(h, m) {
          if (m !== void 0) (0, r.beginHiddenCallStack)(S.errback)(h, m);
          else {
            if (typeof h != "function") return T(h);
            (0, r.beginHiddenCallStack)(S.errback)(void 0, h);
          }
        }, t.loadOptionsAsync = function(...h) {
          return (0, r.beginHiddenCallStack)(S.async)(...h);
        }, t.loadOptionsSync = T, t.loadPartialConfig = function(h, m) {
          if (m !== void 0) (0, r.beginHiddenCallStack)(f.errback)(h, m);
          else {
            if (typeof h != "function") return y(h);
            (0, r.beginHiddenCallStack)(f.errback)(void 0, h);
          }
        }, t.loadPartialConfigAsync = function(...h) {
          return (0, r.beginHiddenCallStack)(f.async)(...h);
        }, t.loadPartialConfigSync = y;
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/full.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/partial.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/item.js"), r = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const f = n()(c.loadPartialConfig);
        function y(...h) {
          return (0, r.beginHiddenCallStack)(f.sync)(...h);
        }
        const S = n()(function* (h) {
          var m;
          const E = yield* (0, u.default)(h);
          return (m = E == null ? void 0 : E.options) != null ? m : null;
        });
        function T(...h) {
          return (0, r.beginHiddenCallStack)(S.sync)(...h);
        }
        const d = n()(e.createConfigItem);
        function p(...h) {
          return (0, r.beginHiddenCallStack)(d.sync)(...h);
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/item.js": (P, t, l) => {
        function n() {
          const f = l("path");
          return n = function() {
            return f;
          }, f;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.createConfigItem = function* (f, { dirname: y = ".", type: S } = {}) {
          return c(yield* (0, u.createDescriptor)(f, n().resolve(y), { type: S, alias: "programmatic item" }));
        }, t.createItemFromDescriptor = c, t.getItemDescriptor = function(f) {
          if (f != null && f[e]) return f._descriptor;
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-descriptors.js");
        function c(f) {
          return new r(f);
        }
        const e = Symbol.for("@babel/core@7 - ConfigItem");
        class r {
          constructor(y) {
            this._descriptor = void 0, this[e] = true, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = y, Object.defineProperty(this, "_descriptor", { enumerable: false }), Object.defineProperty(this, e, { enumerable: false }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? { request: this._descriptor.file.request, resolved: this._descriptor.file.resolved } : void 0, Object.freeze(this);
          }
        }
        Object.freeze(r.prototype);
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/partial.js": (P, t, l) => {
        function n() {
          const m = l("path");
          return n = function() {
            return m;
          }, m;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = p, t.loadPartialConfig = function* (m) {
          let E = false;
          if (typeof m == "object" && m !== null && !Array.isArray(m)) {
            var _ = m;
            ({ showIgnoredFiles: E } = _), m = function(N, F) {
              if (N == null) return {};
              var W = {};
              for (var X in N) if ({}.hasOwnProperty.call(N, X)) {
                if (F.includes(X)) continue;
                W[X] = N[X];
              }
              return W;
            }(_, d);
          }
          const C = yield* p(m);
          if (!C) return null;
          const { options: w, babelrc: I, ignore: D, config: j, fileHandling: L, files: k } = C;
          return L === "ignored" && !E ? null : ((w.plugins || []).forEach((N) => {
            if (N.value instanceof u.default) throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
          }), new h(w, I ? I.filepath : void 0, D ? D.filepath : void 0, j ? j.filepath : void 0, L, k));
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/plugin.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/util.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/item.js"), r = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/config-chain.js"), f = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/environment.js"), y = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/options.js"), S = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/index.js"), T = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/resolve-targets.js");
        const d = ["showIgnoredFiles"];
        function* p(m) {
          if (m != null && (typeof m != "object" || Array.isArray(m))) throw new Error("Babel options must be an object, null, or undefined");
          const E = m ? (0, y.validate)("arguments", m) : {}, { envName: _ = (0, f.getEnv)(), cwd: C = ".", root: w = ".", rootMode: I = "root", caller: D, cloneInputAst: j = true } = E, L = n().resolve(C), k = function(H, U) {
            switch (U) {
              case "root":
                return H;
              case "upward-optional": {
                const q = (0, S.findConfigUpwards)(H);
                return q === null ? H : q;
              }
              case "upward": {
                const q = (0, S.findConfigUpwards)(H);
                if (q !== null) return q;
                throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${H}".
One of the following config files must be in the directory tree: "${S.ROOT_CONFIG_FILENAMES.join(", ")}".`), { code: "BABEL_ROOT_NOT_FOUND", dirname: H });
              }
              default:
                throw new Error("Assertion failure - unknown rootMode value.");
            }
          }(n().resolve(L, w), I), N = typeof E.filename == "string" ? n().resolve(C, E.filename) : void 0, F = { filename: N, cwd: L, root: k, envName: _, caller: D, showConfig: (yield* (0, S.resolveShowConfigPath)(L)) === N }, W = yield* (0, r.buildRootChain)(E, F);
          if (!W) return null;
          const X = { assumptions: {} };
          return W.options.forEach((H) => {
            (0, c.mergeOptions)(X, H);
          }), { options: Object.assign({}, X, { targets: (0, T.resolveTargets)(X, k), cloneInputAst: j, babelrc: false, configFile: false, browserslistConfigFile: false, passPerPreset: false, envName: F.envName, cwd: F.cwd, root: F.root, rootMode: "root", filename: typeof F.filename == "string" ? F.filename : void 0, plugins: W.plugins.map((H) => (0, e.createItemFromDescriptor)(H)), presets: W.presets.map((H) => (0, e.createItemFromDescriptor)(H)) }), context: F, fileHandling: W.fileHandling, ignore: W.ignore, babelrc: W.babelrc, config: W.config, files: W.files };
        }
        class h {
          constructor(E, _, C, w, I, D) {
            this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = E, this.babelignore = C, this.babelrc = _, this.config = w, this.fileHandling = I, this.files = D, Object.freeze(this);
          }
          hasFilesystemConfig() {
            return this.babelrc !== void 0 || this.config !== void 0;
          }
        }
        Object.freeze(h.prototype);
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/pattern-to-regex.js": (P, t, l) => {
        function n() {
          const d = l("path");
          return n = function() {
            return d;
          }, d;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(d, p) {
          const h = n().resolve(p, d).split(n().sep);
          return new RegExp(["^", ...h.map((m, E) => {
            const _ = E === h.length - 1;
            return m === "**" ? _ ? S : y : m === "*" ? _ ? f : r : m.indexOf("*.") === 0 ? e + T(m.slice(1)) + (_ ? c : u) : T(m) + (_ ? c : u);
          })].join(""));
        };
        const u = `\\${n().sep}`, c = `(?:${u}|$)`, e = `[^${u}]+`, r = `(?:${e}${u})`, f = `(?:${e}${c})`, y = `${r}*?`, S = `${r}*?${f}?`;
        function T(d) {
          return d.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/plugin.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        t.default = class {
          constructor(u, c, e, r = (0, n.finalize)([])) {
            this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = u.name || e, this.manipulateOptions = u.manipulateOptions, this.post = u.post, this.pre = u.pre, this.visitor = u.visitor || {}, this.parserOverride = u.parserOverride, this.generatorOverride = u.generatorOverride, this.options = c, this.externalDependencies = r;
          }
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/printer.js": (P, t, l) => {
        function n() {
          const f = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return n = function() {
            return f;
          }, f;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.ConfigPrinter = t.ChainFormatter = void 0;
        const u = t.ChainFormatter = { Programmatic: 0, Config: 1 }, c = { title(f, y, S) {
          let T = "";
          return f === u.Programmatic ? (T = "programmatic options", y && (T += " from " + y)) : T = "config " + S, T;
        }, loc(f, y) {
          let S = "";
          return f != null && (S += `.overrides[${f}]`), y != null && (S += `.env["${y}"]`), S;
        }, *optionsAndDescriptors(f) {
          const y = Object.assign({}, f.options);
          delete y.overrides, delete y.env;
          const S = [...yield* f.plugins()];
          S.length && (y.plugins = S.map((d) => e(d)));
          const T = [...yield* f.presets()];
          return T.length && (y.presets = [...T].map((d) => e(d))), JSON.stringify(y, void 0, 2);
        } };
        function e(f) {
          var y;
          let S = (y = f.file) == null ? void 0 : y.request;
          return S == null && (typeof f.value == "object" ? S = f.value : typeof f.value == "function" && (S = `[Function: ${f.value.toString().slice(0, 50)} ... ]`)), S == null && (S = "[Unknown]"), f.options === void 0 ? S : f.name == null ? [S, f.options] : [S, f.options, f.name];
        }
        class r {
          constructor() {
            this._stack = [];
          }
          configure(y, S, { callerName: T, filepath: d }) {
            return y ? (p, h, m) => {
              this._stack.push({ type: S, callerName: T, filepath: d, content: p, index: h, envName: m });
            } : () => {
            };
          }
          static *format(y) {
            let S = c.title(y.type, y.callerName, y.filepath);
            const T = c.loc(y.index, y.envName);
            return T && (S += ` ${T}`), `${S}
${yield* c.optionsAndDescriptors(y.content)}`;
          }
          *output() {
            return this._stack.length === 0 ? "" : (yield* n().all(this._stack.map((y) => r.format(y)))).join(`

`);
          }
        }
        t.ConfigPrinter = r;
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/resolve-targets.js": (P, t, l) => {
        function n() {
          const c = l("path");
          return n = function() {
            return c;
          }, c;
        }
        function u() {
          const c = l("./stubs/helper-compilation-targets.js");
          return u = function() {
            return c;
          }, c;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.resolveBrowserslistConfigFile = function(c, e) {
          return n().resolve(e, c);
        }, t.resolveTargets = function(c, e) {
          const r = c.targets;
          let f;
          typeof r == "string" || Array.isArray(r) ? f = { browsers: r } : r && (f = "esmodules" in r ? Object.assign({}, r, { esmodules: "intersect" }) : r);
          const { browserslistConfigFile: y } = c;
          let S, T = false;
          return typeof y == "string" ? S = y : T = y === false, (0, u().default)(f, { ignoreBrowserslistConfig: T, configFile: S, configPath: e, browserslistEnv: c.browserslistEnv });
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/util.js": (P, t) => {
        function l(n, u) {
          for (const c of Object.keys(u)) {
            const e = u[c];
            e !== void 0 && (n[c] = e);
          }
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.isIterableIterator = function(n) {
          return !!n && typeof n.next == "function" && typeof n[Symbol.iterator] == "function";
        }, t.mergeOptions = function(n, u) {
          for (const c of Object.keys(u)) if (c !== "parserOpts" && c !== "generatorOpts" && c !== "assumptions" || !u[c]) {
            const e = u[c];
            e !== void 0 && (n[c] = e);
          } else {
            const e = u[c];
            l(n[c] || (n[c] = {}), e);
          }
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/option-assertions.js": (P, t, l) => {
        function n() {
          const h = l("./stubs/helper-compilation-targets.js");
          return n = function() {
            return h;
          }, h;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.access = e, t.assertArray = y, t.assertAssumptions = function(h, m) {
          if (m === void 0) return;
          if (typeof m != "object" || m === null) throw new Error(`${c(h)} must be an object or undefined.`);
          let E = h;
          do
            E = E.parent;
          while (E.type !== "root");
          const _ = E.source === "preset";
          for (const C of Object.keys(m)) {
            const w = e(h, C);
            if (!u.assumptionsNames.has(C)) throw new Error(`${c(w)} is not a supported assumption.`);
            if (typeof m[C] != "boolean") throw new Error(`${c(w)} must be a boolean.`);
            if (_ && m[C] === false) throw new Error(`${c(w)} cannot be set to 'false' inside presets.`);
          }
          return m;
        }, t.assertBabelrcSearch = function(h, m) {
          if (m === void 0 || typeof m == "boolean") return m;
          if (Array.isArray(m)) m.forEach((E, _) => {
            if (!S(E)) throw new Error(`${c(e(h, _))} must be a string/Function/RegExp.`);
          });
          else if (!S(m)) throw new Error(`${c(h)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(m)}`);
          return m;
        }, t.assertBoolean = r, t.assertCallerMetadata = function(h, m) {
          const E = f(h, m);
          if (E) {
            if (typeof E.name != "string") throw new Error(`${c(h)} set but does not contain "name" property string`);
            for (const _ of Object.keys(E)) {
              const C = e(h, _), w = E[_];
              if (w != null && typeof w != "boolean" && typeof w != "string" && typeof w != "number") throw new Error(`${c(C)} must be null, undefined, a boolean, a string, or a number.`);
            }
          }
          return m;
        }, t.assertCompact = function(h, m) {
          if (m !== void 0 && typeof m != "boolean" && m !== "auto") throw new Error(`${c(h)} must be a boolean, "auto", or undefined`);
          return m;
        }, t.assertConfigApplicableTest = function(h, m) {
          if (m === void 0) return m;
          if (Array.isArray(m)) m.forEach((E, _) => {
            if (!S(E)) throw new Error(`${c(e(h, _))} must be a string/Function/RegExp.`);
          });
          else if (!S(m)) throw new Error(`${c(h)} must be a string/Function/RegExp, or an array of those`);
          return m;
        }, t.assertConfigFileSearch = function(h, m) {
          if (m !== void 0 && typeof m != "boolean" && typeof m != "string") throw new Error(`${c(h)} must be a undefined, a boolean, a string, got ${JSON.stringify(m)}`);
          return m;
        }, t.assertFunction = function(h, m) {
          if (m !== void 0 && typeof m != "function") throw new Error(`${c(h)} must be a function, or undefined`);
          return m;
        }, t.assertIgnoreList = function(h, m) {
          const E = y(h, m);
          return E == null ? void 0 : E.forEach((_, C) => function(w, I) {
            if (typeof I != "string" && typeof I != "function" && !(I instanceof RegExp)) throw new Error(`${c(w)} must be an array of string/Function/RegExp values, or undefined`);
            return I;
          }(e(h, C), _)), E;
        }, t.assertInputSourceMap = function(h, m) {
          if (m !== void 0 && typeof m != "boolean" && (typeof m != "object" || !m)) throw new Error(`${c(h)} must be a boolean, object, or undefined`);
          return m;
        }, t.assertObject = f, t.assertPluginList = function(h, m) {
          const E = y(h, m);
          return E && E.forEach((_, C) => function(w, I) {
            if (Array.isArray(I)) {
              if (I.length === 0) throw new Error(`${c(w)} must include an object`);
              if (I.length > 3) throw new Error(`${c(w)} may only be a two-tuple or three-tuple`);
              if (T(e(w, 0), I[0]), I.length > 1) {
                const D = I[1];
                if (D !== void 0 && D !== false && (typeof D != "object" || Array.isArray(D) || D === null)) throw new Error(`${c(e(w, 1))} must be an object, false, or undefined`);
              }
              if (I.length === 3) {
                const D = I[2];
                if (D !== void 0 && typeof D != "string") throw new Error(`${c(e(w, 2))} must be a string, or undefined`);
              }
            } else T(w, I);
            return I;
          }(e(h, C), _)), E;
        }, t.assertRootMode = function(h, m) {
          if (m !== void 0 && m !== "root" && m !== "upward" && m !== "upward-optional") throw new Error(`${c(h)} must be a "root", "upward", "upward-optional" or undefined`);
          return m;
        }, t.assertSourceMaps = function(h, m) {
          if (m !== void 0 && typeof m != "boolean" && m !== "inline" && m !== "both") throw new Error(`${c(h)} must be a boolean, "inline", "both", or undefined`);
          return m;
        }, t.assertSourceType = function(h, m) {
          if (m !== void 0 && m !== "module" && m !== "script" && m !== "unambiguous") throw new Error(`${c(h)} must be "module", "script", "unambiguous", or undefined`);
          return m;
        }, t.assertString = function(h, m) {
          if (m !== void 0 && typeof m != "string") throw new Error(`${c(h)} must be a string, or undefined`);
          return m;
        }, t.assertTargets = function(h, m) {
          if ((0, n().isBrowsersQueryValid)(m)) return m;
          if (typeof m != "object" || !m || Array.isArray(m)) throw new Error(`${c(h)} must be a string, an array of strings or an object`);
          const E = e(h, "browsers"), _ = e(h, "esmodules");
          d(E, m.browsers), r(_, m.esmodules);
          for (const C of Object.keys(m)) {
            const w = m[C], I = e(h, C);
            if (C === "esmodules") r(I, w);
            else if (C === "browsers") d(I, w);
            else {
              if (!hasOwnProperty.call(n().TargetNames, C)) {
                const D = Object.keys(n().TargetNames).join(", ");
                throw new Error(`${c(I)} is not a valid target. Supported targets are ${D}`);
              }
              p(I, w);
            }
          }
          return m;
        }, t.msg = c;
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/options.js");
        function c(h) {
          switch (h.type) {
            case "root":
              return "";
            case "env":
              return `${c(h.parent)}.env["${h.name}"]`;
            case "overrides":
              return `${c(h.parent)}.overrides[${h.index}]`;
            case "option":
              return `${c(h.parent)}.${h.name}`;
            case "access":
              return `${c(h.parent)}[${JSON.stringify(h.name)}]`;
            default:
              throw new Error(`Assertion failure: Unknown type ${h.type}`);
          }
        }
        function e(h, m) {
          return { type: "access", name: m, parent: h };
        }
        function r(h, m) {
          if (m !== void 0 && typeof m != "boolean") throw new Error(`${c(h)} must be a boolean, or undefined`);
          return m;
        }
        function f(h, m) {
          if (m !== void 0 && (typeof m != "object" || Array.isArray(m) || !m)) throw new Error(`${c(h)} must be an object, or undefined`);
          return m;
        }
        function y(h, m) {
          if (m != null && !Array.isArray(m)) throw new Error(`${c(h)} must be an array, or undefined`);
          return m;
        }
        function S(h) {
          return typeof h == "string" || typeof h == "function" || h instanceof RegExp;
        }
        function T(h, m) {
          if ((typeof m != "object" || !m) && typeof m != "string" && typeof m != "function") throw new Error(`${c(h)} must be a string, object, function`);
          return m;
        }
        function d(h, m) {
          if (m !== void 0 && !(0, n().isBrowsersQueryValid)(m)) throw new Error(`${c(h)} must be undefined, a string or an array of strings`);
        }
        function p(h, m) {
          if ((typeof m != "number" || Math.round(m) !== m) && typeof m != "string") throw new Error(`${c(h)} must be a string or an integer number`);
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/options.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.assumptionsNames = void 0, t.checkNoUnwrappedItemOptionPairs = function(p, h, m, E) {
          if (h === 0) return;
          const _ = p[h - 1], C = p[h];
          _.file && _.options === void 0 && typeof C.value == "object" && (E.message += `
- Maybe you meant to use
"${m}s": [
  ["${_.file.request}", ${JSON.stringify(C.value, void 0, 2)}]
]
To be a valid ${m}, its name and options should be wrapped in a pair of brackets`);
        }, t.validate = function(p, h, m) {
          try {
            return T({ type: "root", source: p }, h);
          } catch (E) {
            const _ = new c.default(E.message, m);
            throw E.code && (_.code = E.code), _;
          }
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/removed.js"), u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/option-assertions.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js");
        const e = { cwd: u.assertString, root: u.assertString, rootMode: u.assertRootMode, configFile: u.assertConfigFileSearch, caller: u.assertCallerMetadata, filename: u.assertString, filenameRelative: u.assertString, code: u.assertBoolean, ast: u.assertBoolean, cloneInputAst: u.assertBoolean, envName: u.assertString }, r = { babelrc: u.assertBoolean, babelrcRoots: u.assertBabelrcSearch }, f = { extends: u.assertString, ignore: u.assertIgnoreList, only: u.assertIgnoreList, targets: u.assertTargets, browserslistConfigFile: u.assertConfigFileSearch, browserslistEnv: u.assertString }, y = { inputSourceMap: u.assertInputSourceMap, presets: u.assertPluginList, plugins: u.assertPluginList, passPerPreset: u.assertBoolean, assumptions: u.assertAssumptions, env: function(p, h) {
          if (p.parent.type === "env") throw new Error(`${(0, u.msg)(p)} is not allowed inside of another .env block`);
          const m = p.parent, E = (0, u.assertObject)(p, h);
          if (E) for (const _ of Object.keys(E)) {
            const C = (0, u.assertObject)((0, u.access)(p, _), E[_]);
            C && T({ type: "env", name: _, parent: m }, C);
          }
          return E;
        }, overrides: function(p, h) {
          if (p.parent.type === "env") throw new Error(`${(0, u.msg)(p)} is not allowed inside an .env block`);
          if (p.parent.type === "overrides") throw new Error(`${(0, u.msg)(p)} is not allowed inside an .overrides block`);
          const m = p.parent, E = (0, u.assertArray)(p, h);
          if (E) for (const [_, C] of E.entries()) {
            const w = (0, u.access)(p, _), I = (0, u.assertObject)(w, C);
            if (!I) throw new Error(`${(0, u.msg)(w)} must be an object`);
            T({ type: "overrides", index: _, parent: m }, I);
          }
          return E;
        }, test: u.assertConfigApplicableTest, include: u.assertConfigApplicableTest, exclude: u.assertConfigApplicableTest, retainLines: u.assertBoolean, comments: u.assertBoolean, shouldPrintComment: u.assertFunction, compact: u.assertCompact, minified: u.assertBoolean, auxiliaryCommentBefore: u.assertString, auxiliaryCommentAfter: u.assertString, sourceType: u.assertSourceType, wrapPluginVisitorMethod: u.assertFunction, highlightCode: u.assertBoolean, sourceMaps: u.assertSourceMaps, sourceMap: u.assertSourceMaps, sourceFileName: u.assertString, sourceRoot: u.assertString, parserOpts: u.assertObject, generatorOpts: u.assertObject };
        Object.assign(y, { getModuleId: u.assertFunction, moduleRoot: u.assertString, moduleIds: u.assertBoolean, moduleId: u.assertString }), t.assumptionsNames = /* @__PURE__ */ new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUninitializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);
        function S(p) {
          return p.type === "root" ? p.source : S(p.parent);
        }
        function T(p, h) {
          const m = S(p);
          return function(E) {
            if (hasOwnProperty.call(E, "sourceMap") && hasOwnProperty.call(E, "sourceMaps")) throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
          }(h), Object.keys(h).forEach((E) => {
            const _ = { type: "option", name: E, parent: p };
            if (m === "preset" && f[E]) throw new Error(`${(0, u.msg)(_)} is not allowed in preset options`);
            if (m !== "arguments" && e[E]) throw new Error(`${(0, u.msg)(_)} is only allowed in root programmatic options`);
            if (m !== "arguments" && m !== "configfile" && r[E]) throw m === "babelrcfile" || m === "extendsfile" ? new Error(`${(0, u.msg)(_)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, u.msg)(_)} is only allowed in root programmatic options, or babel.config.js/config file options`);
            (y[E] || f[E] || r[E] || e[E] || d)(_, h[E]);
          }), h;
        }
        function d(p) {
          const h = p.name;
          if (n.default[h]) {
            const { message: m, version: E = 5 } = n.default[h];
            throw new Error(`Using removed Babel ${E} option: ${(0, u.msg)(p)} - ${m}`);
          }
          {
            const m = new Error(`Unknown option: ${(0, u.msg)(p)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
            throw m.code = "BABEL_UNKNOWN_OPTION", m;
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/plugins.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.validatePluginObject = function(c) {
          const e = { type: "root", source: "plugin" };
          return Object.keys(c).forEach((r) => {
            const f = u[r];
            if (!f) {
              const y = new Error(`.${r} is not a valid Plugin property`);
              throw y.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", y;
            }
            f({ type: "option", name: r, parent: e }, c[r]);
          }), c;
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/option-assertions.js");
        const u = { name: n.assertString, manipulateOptions: n.assertFunction, pre: n.assertFunction, post: n.assertFunction, inherits: n.assertFunction, visitor: function(c, e) {
          const r = (0, n.assertObject)(c, e);
          if (r && (Object.keys(r).forEach((f) => {
            f !== "_exploded" && f !== "_verified" && function(y, S) {
              if (S && typeof S == "object") Object.keys(S).forEach((T) => {
                if (T !== "enter" && T !== "exit") throw new Error(`.visitor["${y}"] may only have .enter and/or .exit handlers.`);
              });
              else if (typeof S != "function") throw new Error(`.visitor["${y}"] must be a function`);
            }(f, r[f]);
          }), r.enter || r.exit)) throw new Error(`${(0, n.msg)(c)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
          return r;
        }, parserOverride: n.assertFunction, generatorOverride: n.assertFunction };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/validation/removed.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0, t.default = { auxiliaryComment: { message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" }, blacklist: { message: "Put the specific transforms you want in the `plugins` option" }, breakConfig: { message: "This is not a necessary option in Babel 6" }, experimental: { message: "Put the specific transforms you want in the `plugins` option" }, externalHelpers: { message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/" }, extra: { message: "" }, jsxPragma: { message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/" }, loose: { message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option." }, metadataUsedHelpers: { message: "Not required anymore as this is enabled by default" }, modules: { message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules" }, nonStandard: { message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/" }, optional: { message: "Put the specific transforms you want in the `plugins` option" }, sourceMapName: { message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." }, stage: { message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" }, whitelist: { message: "Put the specific transforms you want in the `plugins` option" }, resolveModuleSource: { version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options" }, metadata: { version: 6, message: "Generated plugin metadata is always included in the output result" }, sourceMapTarget: { version: 6, message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." } };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/config-error.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        class u extends Error {
          constructor(e, r) {
            super(e), (0, n.expectedError)(this), r && (0, n.injectVirtualStackFrame)(this, r);
          }
        }
        t.default = u;
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js": (P, t) => {
        var l;
        Object.defineProperty(t, "__esModule", { value: true }), t.beginHiddenCallStack = function(T) {
          return u ? Object.defineProperty(function(...d) {
            return y(), T(...d);
          }, "name", { value: e }) : T;
        }, t.endHiddenCallStack = function(T) {
          return u ? Object.defineProperty(function(...d) {
            return T(...d);
          }, "name", { value: c }) : T;
        }, t.expectedError = function(T) {
          if (u) return r.add(T), T;
        }, t.injectVirtualStackFrame = function(T, d) {
          if (!u) return;
          let p = f.get(T);
          return p || f.set(T, p = []), p.push(/* @__PURE__ */ function(h) {
            return /* @__PURE__ */ Object.create({ isNative: () => false, isConstructor: () => false, isToplevel: () => true, getFileName: () => h, getLineNumber: () => {
            }, getColumnNumber: () => {
            }, getFunctionName: () => {
            }, getMethodName: () => {
            }, getTypeName: () => {
            }, toString: () => h });
          }(d)), T;
        };
        const n = Function.call.bind(Error.prototype.toString), u = !!Error.captureStackTrace && ((l = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? void 0 : l.writable) === true, c = "startHiding - secret - don't use this - v1", e = "stopHiding - secret - don't use this - v1", r = /* @__PURE__ */ new WeakSet(), f = /* @__PURE__ */ new WeakMap();
        function y() {
          y = () => {
          };
          const { prepareStackTrace: T = S } = Error;
          Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, 50)), Error.prepareStackTrace = function(d, p) {
            let h = [], m = r.has(d) ? "hiding" : "unknown";
            for (let E = 0; E < p.length; E++) {
              const _ = p[E].getFunctionName();
              if (_ === c) m = "hiding";
              else if (_ === e) {
                if (m === "hiding") m = "showing", f.has(d) && h.unshift(...f.get(d));
                else if (m === "unknown") {
                  h = p;
                  break;
                }
              } else m !== "hiding" && h.push(p[E]);
            }
            return T(d, h);
          };
        }
        function S(T, d) {
          return d.length === 0 ? n(T) : `${n(T)}
    at ${d.join(`
    at `)}`;
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js": (P, t, l) => {
        function n() {
          const T = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return n = function() {
            return T;
          }, T;
        }
        function u(T, d, p, h, m, E, _) {
          try {
            var C = T[E](_), w = C.value;
          } catch (I) {
            return void p(I);
          }
          C.done ? d(w) : Promise.resolve(w).then(h, m);
        }
        function c(T) {
          return function() {
            var d = this, p = arguments;
            return new Promise(function(h, m) {
              var E = T.apply(d, p);
              function _(w) {
                u(E, h, m, _, C, "next", w);
              }
              function C(w) {
                u(E, h, m, _, C, "throw", w);
              }
              _(void 0);
            });
          };
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.forwardAsync = function(T, d) {
          const p = n()(T);
          return r((h) => {
            const m = p[h];
            return d(m);
          });
        }, t.isAsync = void 0, t.isThenable = S, t.maybeAsync = function(T, d) {
          return n()({ sync(...p) {
            const h = T.apply(this, p);
            if (S(h)) throw new Error(d);
            return h;
          }, async(...p) {
            return Promise.resolve(T.apply(this, p));
          } });
        }, t.waitFor = t.onFirstPause = void 0;
        const e = n()(function* (T) {
          return yield* T;
        });
        t.isAsync = n()({ sync: () => false, errback: (T) => T(null, true) });
        const r = n()({ sync: (T) => T("sync"), async: (f = c(function* (T) {
          return T("async");
        }), function(T) {
          return f.apply(this, arguments);
        }) });
        var f;
        t.onFirstPause = n()({ name: "onFirstPause", arity: 2, sync: function(T) {
          return e.sync(T);
        }, errback: function(T, d, p) {
          let h = false;
          e.errback(T, (m, E) => {
            h = true, p(m, E);
          }), h || d();
        } }), t.waitFor = n()({ sync: (T) => T, async: (y = c(function* (T) {
          return T;
        }), function(T) {
          return y.apply(this, arguments);
        }) });
        var y;
        function S(T) {
          return !(!T || typeof T != "object" && typeof T != "function" || !T.then || typeof T.then != "function");
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/fs.js": (P, t, l) => {
        function n() {
          const c = l("fs");
          return n = function() {
            return c;
          }, c;
        }
        function u() {
          const c = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return u = function() {
            return c;
          }, c;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.stat = t.readFile = void 0, t.readFile = u()({ sync: n().readFileSync, errback: n().readFile }), t.stat = u()({ sync: n().statSync, errback: n().stat });
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/functional.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.once = function(u) {
          let c, e, r = false;
          return function* () {
            if (!c) {
              if (e) return r = true, yield* (0, n.waitFor)(e);
              if (yield* (0, n.isAsync)()) {
                let f, y;
                e = new Promise((S, T) => {
                  f = S, y = T;
                });
                try {
                  c = { ok: true, value: yield* u() }, e = null, r && f(c.value);
                } catch (S) {
                  c = { ok: false, value: S }, e = null, r && y(S);
                }
              } else try {
                c = { ok: true, value: yield* u() };
              } catch (f) {
                c = { ok: false, value: f };
              }
            }
            if (c.ok) return c.value;
            throw c.value;
          };
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js");
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.DEFAULT_EXTENSIONS = void 0, Object.defineProperty(t, "File", { enumerable: true, get: function() {
          return n.default;
        } }), Object.defineProperty(t, "buildExternalHelpers", { enumerable: true, get: function() {
          return u.default;
        } }), Object.defineProperty(t, "createConfigItem", { enumerable: true, get: function() {
          return T.createConfigItem;
        } }), Object.defineProperty(t, "createConfigItemAsync", { enumerable: true, get: function() {
          return T.createConfigItemAsync;
        } }), Object.defineProperty(t, "createConfigItemSync", { enumerable: true, get: function() {
          return T.createConfigItemSync;
        } }), Object.defineProperty(t, "getEnv", { enumerable: true, get: function() {
          return e.getEnv;
        } }), Object.defineProperty(t, "loadOptions", { enumerable: true, get: function() {
          return T.loadOptions;
        } }), Object.defineProperty(t, "loadOptionsAsync", { enumerable: true, get: function() {
          return T.loadOptionsAsync;
        } }), Object.defineProperty(t, "loadOptionsSync", { enumerable: true, get: function() {
          return T.loadOptionsSync;
        } }), Object.defineProperty(t, "loadPartialConfig", { enumerable: true, get: function() {
          return T.loadPartialConfig;
        } }), Object.defineProperty(t, "loadPartialConfigAsync", { enumerable: true, get: function() {
          return T.loadPartialConfigAsync;
        } }), Object.defineProperty(t, "loadPartialConfigSync", { enumerable: true, get: function() {
          return T.loadPartialConfigSync;
        } }), Object.defineProperty(t, "parse", { enumerable: true, get: function() {
          return m.parse;
        } }), Object.defineProperty(t, "parseAsync", { enumerable: true, get: function() {
          return m.parseAsync;
        } }), Object.defineProperty(t, "parseSync", { enumerable: true, get: function() {
          return m.parseSync;
        } }), t.resolvePreset = t.resolvePlugin = void 0, Object.defineProperty(t, "template", { enumerable: true, get: function() {
          return S().default;
        } }), Object.defineProperty(t, "tokTypes", { enumerable: true, get: function() {
          return f().tokTypes;
        } }), Object.defineProperty(t, "transform", { enumerable: true, get: function() {
          return d.transform;
        } }), Object.defineProperty(t, "transformAsync", { enumerable: true, get: function() {
          return d.transformAsync;
        } }), Object.defineProperty(t, "transformFile", { enumerable: true, get: function() {
          return p.transformFile;
        } }), Object.defineProperty(t, "transformFileAsync", { enumerable: true, get: function() {
          return p.transformFileAsync;
        } }), Object.defineProperty(t, "transformFileSync", { enumerable: true, get: function() {
          return p.transformFileSync;
        } }), Object.defineProperty(t, "transformFromAst", { enumerable: true, get: function() {
          return h.transformFromAst;
        } }), Object.defineProperty(t, "transformFromAstAsync", { enumerable: true, get: function() {
          return h.transformFromAstAsync;
        } }), Object.defineProperty(t, "transformFromAstSync", { enumerable: true, get: function() {
          return h.transformFromAstSync;
        } }), Object.defineProperty(t, "transformSync", { enumerable: true, get: function() {
          return d.transformSync;
        } }), Object.defineProperty(t, "traverse", { enumerable: true, get: function() {
          return y().default;
        } }), t.version = t.types = void 0;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/file.js"), u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/tools/build-external-helpers.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/files/index.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/environment.js");
        function r() {
          const E = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
          return r = function() {
            return E;
          }, E;
        }
        function f() {
          const E = l("./node_modules/.pnpm/@babel+parser@7.26.3/node_modules/@babel/parser/lib/index.js");
          return f = function() {
            return E;
          }, E;
        }
        function y() {
          const E = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");
          return y = function() {
            return E;
          }, E;
        }
        function S() {
          const E = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js");
          return S = function() {
            return E;
          }, E;
        }
        Object.defineProperty(t, "types", { enumerable: true, get: function() {
          return r();
        } });
        var T = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js"), d = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform.js"), p = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform-file.js"), h = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform-ast.js"), m = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parse.js");
        l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), t.version = "7.26.0", t.resolvePlugin = (E, _) => c.resolvePlugin(E, _, false).filepath, t.resolvePreset = (E, _) => c.resolvePreset(E, _, false).filepath, t.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]), t.OptionManager = class {
          init(E) {
            return (0, T.loadOptionsSync)(E);
          }
        }, t.Plugin = function(E) {
          throw new Error(`The (${E}) Babel 5 plugin is being run with an unsupported Babel version.`);
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parse.js": (P, t, l) => {
        function n() {
          const y = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return n = function() {
            return y;
          }, y;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.parse = void 0, t.parseAsync = function(...y) {
          return (0, r.beginHiddenCallStack)(f.async)(...y);
        }, t.parseSync = function(...y) {
          return (0, r.beginHiddenCallStack)(f.sync)(...y);
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parser/index.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/normalize-opts.js"), r = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const f = n()(function* (y, S) {
          const T = yield* (0, u.default)(S);
          return T === null ? null : yield* (0, c.default)(T.passes, (0, e.default)(T), y);
        });
        t.parse = function(y, S, T) {
          if (typeof S == "function" && (T = S, S = void 0), T === void 0) return (0, r.beginHiddenCallStack)(f.sync)(y, S);
          (0, r.beginHiddenCallStack)(f.errback)(y, S, T);
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parser/index.js": (P, t, l) => {
        function n() {
          const e = l("./node_modules/.pnpm/@babel+parser@7.26.3/node_modules/@babel/parser/lib/index.js");
          return n = function() {
            return e;
          }, e;
        }
        function u() {
          const e = l("./stubs/babel-codeframe.js");
          return u = function() {
            return e;
          }, e;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function* (e, { parserOpts: r, highlightCode: f = true, filename: y = "unknown" }, S) {
          try {
            const T = [];
            for (const d of e) for (const p of d) {
              const { parserOverride: h } = p;
              if (h) {
                const m = h(S, r, n().parse);
                m !== void 0 && T.push(m);
              }
            }
            if (T.length === 0) return (0, n().parse)(S, r);
            if (T.length === 1) {
              if (yield* [], typeof T[0].then == "function") throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
              return T[0];
            }
            throw new Error("More than one plugin attempted to override parsing.");
          } catch (T) {
            T.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (T.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
            const { loc: d, missingPlugin: p } = T;
            if (d) {
              const h = (0, u().codeFrameColumns)(S, { start: { line: d.line, column: d.column + 1 } }, { highlightCode: f });
              T.message = p ? `${y}: ` + (0, c.default)(p[0], d, h, y) : `${y}: ${T.message}

` + h, T.code = "BABEL_PARSE_ERROR";
            }
            throw T;
          }
        };
        var c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js");
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c, e, r) {
          let f = `Support for the experimental syntax '${u}' isn't currently enabled (${c.line}:${c.column + 1}):

` + e;
          const y = l[u];
          if (y) {
            const { syntax: S, transform: T } = y;
            if (S) {
              const d = n(S);
              T ? f += `

Add ${n(T)} to the '${T.name.startsWith("@babel/plugin") ? "plugins" : "presets"}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${d} to the 'plugins' section to enable parsing.` : f += `

Add ${d} to the 'plugins' section of your Babel config to enable parsing.`;
            }
          }
          return f += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${r === "unknown" ? "<name of the input file>" : r} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`, f;
        };
        const l = { asyncDoExpressions: { syntax: { name: "@babel/plugin-syntax-async-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions" } }, decimal: { syntax: { name: "@babel/plugin-syntax-decimal", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal" } }, decorators: { syntax: { name: "@babel/plugin-syntax-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators" }, transform: { name: "@babel/plugin-proposal-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators" } }, doExpressions: { syntax: { name: "@babel/plugin-syntax-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions" }, transform: { name: "@babel/plugin-proposal-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions" } }, exportDefaultFrom: { syntax: { name: "@babel/plugin-syntax-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from" }, transform: { name: "@babel/plugin-proposal-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from" } }, flow: { syntax: { name: "@babel/plugin-syntax-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow" }, transform: { name: "@babel/preset-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow" } }, functionBind: { syntax: { name: "@babel/plugin-syntax-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind" }, transform: { name: "@babel/plugin-proposal-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind" } }, functionSent: { syntax: { name: "@babel/plugin-syntax-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent" }, transform: { name: "@babel/plugin-proposal-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent" } }, jsx: { syntax: { name: "@babel/plugin-syntax-jsx", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx" }, transform: { name: "@babel/preset-react", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react" } }, pipelineOperator: { syntax: { name: "@babel/plugin-syntax-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator" }, transform: { name: "@babel/plugin-proposal-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator" } }, recordAndTuple: { syntax: { name: "@babel/plugin-syntax-record-and-tuple", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple" } }, throwExpressions: { syntax: { name: "@babel/plugin-syntax-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions" }, transform: { name: "@babel/plugin-proposal-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions" } }, typescript: { syntax: { name: "@babel/plugin-syntax-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript" }, transform: { name: "@babel/preset-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript" } } };
        Object.assign(l, { asyncGenerators: { syntax: { name: "@babel/plugin-syntax-async-generators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators" }, transform: { name: "@babel/plugin-transform-async-generator-functions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions" } }, classProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateMethods: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-private-methods", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods" } }, classStaticBlock: { syntax: { name: "@babel/plugin-syntax-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block" }, transform: { name: "@babel/plugin-transform-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block" } }, dynamicImport: { syntax: { name: "@babel/plugin-syntax-dynamic-import", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import" } }, exportNamespaceFrom: { syntax: { name: "@babel/plugin-syntax-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from" }, transform: { name: "@babel/plugin-transform-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from" } }, importAssertions: { syntax: { name: "@babel/plugin-syntax-import-assertions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions" } }, importAttributes: { syntax: { name: "@babel/plugin-syntax-import-attributes", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes" } }, importMeta: { syntax: { name: "@babel/plugin-syntax-import-meta", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta" } }, logicalAssignment: { syntax: { name: "@babel/plugin-syntax-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators" }, transform: { name: "@babel/plugin-transform-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators" } }, moduleStringNames: { syntax: { name: "@babel/plugin-syntax-module-string-names", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names" } }, numericSeparator: { syntax: { name: "@babel/plugin-syntax-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator" }, transform: { name: "@babel/plugin-transform-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator" } }, nullishCoalescingOperator: { syntax: { name: "@babel/plugin-syntax-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator" }, transform: { name: "@babel/plugin-transform-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator" } }, objectRestSpread: { syntax: { name: "@babel/plugin-syntax-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread" }, transform: { name: "@babel/plugin-transform-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread" } }, optionalCatchBinding: { syntax: { name: "@babel/plugin-syntax-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding" }, transform: { name: "@babel/plugin-transform-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding" } }, optionalChaining: { syntax: { name: "@babel/plugin-syntax-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining" }, transform: { name: "@babel/plugin-transform-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining" } }, privateIn: { syntax: { name: "@babel/plugin-syntax-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object" }, transform: { name: "@babel/plugin-transform-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object" } }, regexpUnicodeSets: { syntax: { name: "@babel/plugin-syntax-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md" }, transform: { name: "@babel/plugin-transform-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md" } } });
        const n = ({ name: u, url: c }) => `${u} (${c})`;
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/tools/build-external-helpers.js": (P, t, l) => {
        function n() {
          const ee = l("./node_modules/.pnpm/@babel+helpers@7.26.0/node_modules/@babel/helpers/lib/index.js");
          return n = function() {
            return ee;
          }, ee;
        }
        function u() {
          const ee = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/index.js");
          return u = function() {
            return ee;
          }, ee;
        }
        function c() {
          const ee = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js");
          return c = function() {
            return ee;
          }, ee;
        }
        function e() {
          const ee = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
          return e = function() {
            return ee;
          }, ee;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(ee, re = "global") {
          let Y;
          const Z = { global: W, module: X, umd: H, var: U }[re];
          if (!Z) throw new Error(`Unsupported output type ${re}`);
          return Y = Z(ee), (0, u().default)(Y).code;
        };
        const { arrayExpression: r, assignmentExpression: f, binaryExpression: y, blockStatement: S, callExpression: T, cloneNode: d, conditionalExpression: p, exportNamedDeclaration: h, exportSpecifier: m, expressionStatement: E, functionExpression: _, identifier: C, memberExpression: w, objectExpression: I, program: D, stringLiteral: j, unaryExpression: L, variableDeclaration: k, variableDeclarator: N } = e(), F = (ee) => c().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(ee);
        function W(ee) {
          const re = C("babelHelpers"), Y = [], Z = _(null, [C("global")], S(Y)), G = D([E(T(Z, [p(y("===", L("typeof", C("global")), j("undefined")), C("self"), C("global"))]))]);
          return Y.push(k("var", [N(re, f("=", w(C("global"), re), I([])))])), q(Y, re, ee), G;
        }
        function X(ee) {
          const re = [], Y = q(re, null, ee);
          return re.unshift(h(null, Object.keys(Y).map((Z) => m(d(Y[Z]), C(Z))))), D(re, [], "module");
        }
        function H(ee) {
          const re = C("babelHelpers"), Y = [];
          return Y.push(k("var", [N(re, C("global"))])), q(Y, re, ee), D([F({ FACTORY_PARAMETERS: C("global"), BROWSER_ARGUMENTS: f("=", w(C("root"), re), I([])), COMMON_ARGUMENTS: C("exports"), AMD_ARGUMENTS: r([j("exports")]), FACTORY_BODY: Y, UMD_ROOT: C("this") })]);
        }
        function U(ee) {
          const re = C("babelHelpers"), Y = [];
          Y.push(k("var", [N(re, I([]))]));
          const Z = D(Y);
          return q(Y, re, ee), Y.push(E(re)), Z;
        }
        function q(ee, re, Y) {
          const Z = (B) => re ? w(re, C(B)) : C(`_${B}`), G = {};
          return n().list.forEach(function(B) {
            if (Y && !Y.includes(B)) return;
            const z = G[B] = Z(B), { nodes: M } = n().get(B, Z, re ? null : `_${B}`, [], re ? (K, Q, ie) => {
              ie((ue) => f("=", z, ue)), K.body.push(E(f("=", z, C(Q))));
            } : null);
            ee.push(...M);
          }), G;
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform-ast.js": (P, t, l) => {
        function n() {
          const f = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return n = function() {
            return f;
          }, f;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.transformFromAst = void 0, t.transformFromAstAsync = function(...f) {
          return (0, e.beginHiddenCallStack)(r.async)(...f);
        }, t.transformFromAstSync = function(...f) {
          return (0, e.beginHiddenCallStack)(r.sync)(...f);
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/index.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const r = n()(function* (f, y, S) {
          const T = yield* (0, u.default)(S);
          if (T === null) return null;
          if (!f) throw new Error("No AST given");
          return yield* (0, c.run)(T, y, f);
        });
        t.transformFromAst = function(f, y, S, T) {
          let d, p;
          if (typeof S == "function" ? (p = S, d = void 0) : (d = S, p = T), p === void 0) return (0, e.beginHiddenCallStack)(r.sync)(f, y, d);
          (0, e.beginHiddenCallStack)(r.errback)(f, y, d, p);
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform-file.js": (P, t, l) => {
        function n() {
          const f = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return n = function() {
            return f;
          }, f;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.transformFile = function(...f) {
          r.errback(...f);
        }, t.transformFileAsync = function(...f) {
          return r.async(...f);
        }, t.transformFileSync = function(...f) {
          return r.sync(...f);
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/index.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/fs.js");
        const r = n()(function* (f, y) {
          const S = Object.assign({}, y, { filename: f }), T = yield* (0, u.default)(S);
          if (T === null) return null;
          const d = yield* e.readFile(f, "utf8");
          return yield* (0, c.run)(T, d);
        });
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transform.js": (P, t, l) => {
        function n() {
          const f = l("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return n = function() {
            return f;
          }, f;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.transform = void 0, t.transformAsync = function(...f) {
          return (0, e.beginHiddenCallStack)(r.async)(...f);
        }, t.transformSync = function(...f) {
          return (0, e.beginHiddenCallStack)(r.sync)(...f);
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/index.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/index.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const r = n()(function* (f, y) {
          const S = yield* (0, u.default)(y);
          return S === null ? null : yield* (0, c.run)(S, f);
        });
        t.transform = function(f, y, S) {
          let T, d;
          if (typeof y == "function" ? (d = y, T = void 0) : (T = y, d = S), d === void 0) return (0, e.beginHiddenCallStack)(r.sync)(f, T);
          (0, e.beginHiddenCallStack)(r.errback)(f, T, d);
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js": (P, t, l) => {
        function n() {
          const y = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");
          return n = function() {
            return y;
          }, y;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function() {
          return c || (c = new u.default(Object.assign({}, e, { visitor: n().default.explode(e.visitor) }), {})), c;
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/plugin.js");
        let c;
        const e = { name: "internal.blockHoist", visitor: { Block: { exit({ node: y }) {
          y.body = r(y.body);
        } }, SwitchCase: { exit({ node: y }) {
          y.consequent = r(y.consequent);
        } } } };
        function r(y) {
          let S = Math.pow(2, 30) - 1, T = false;
          for (let d = 0; d < y.length; d++) {
            const p = f(y[d]);
            if (p > S) {
              T = true;
              break;
            }
            S = p;
          }
          return T ? function(d) {
            const p = /* @__PURE__ */ Object.create(null);
            for (let E = 0; E < d.length; E++) {
              const _ = d[E], C = f(_);
              (p[C] || (p[C] = [])).push(_);
            }
            const h = Object.keys(p).map((E) => +E).sort((E, _) => _ - E);
            let m = 0;
            for (const E of h) {
              const _ = p[E];
              for (const C of _) d[m++] = C;
            }
            return d;
          }(y.slice()) : y;
        }
        function f(y) {
          const S = y == null ? void 0 : y._blockHoist;
          return S == null ? 1 : S === true ? 2 : S;
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs": (P, t, l) => {
        t.getModuleName = () => l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js").getModuleName;
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/file.js": (P, t, l) => {
        function n() {
          const h = l("./node_modules/.pnpm/@babel+helpers@7.26.0/node_modules/@babel/helpers/lib/index.js");
          return n = function() {
            return h;
          }, h;
        }
        function u() {
          const h = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");
          return u = function() {
            return h;
          }, h;
        }
        function c() {
          const h = l("./stubs/babel-codeframe.js");
          return c = function() {
            return h;
          }, h;
        }
        function e() {
          const h = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
          return e = function() {
            return h;
          }, h;
        }
        function r() {
          const h = l("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return r = function() {
            return h;
          }, h;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var f = function(h, m) {
          if (h === null || typeof h != "object" && typeof h != "function") return { default: h };
          var E = y(m);
          if (E && E.has(h)) return E.get(h);
          var _ = { __proto__: null }, C = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var w in h) if (w !== "default" && {}.hasOwnProperty.call(h, w)) {
            var I = C ? Object.getOwnPropertyDescriptor(h, w) : null;
            I && (I.get || I.set) ? Object.defineProperty(_, w, I) : _[w] = h[w];
          }
          return _.default = h, E && E.set(h, _), _;
        }(l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs"), true);
        function y(h) {
          if (typeof WeakMap != "function") return null;
          var m = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap();
          return (y = function(_) {
            return _ ? E : m;
          })(h);
        }
        const { cloneNode: S, interpreterDirective: T } = e(), d = { enter(h, m) {
          const E = h.node.loc;
          E && (m.loc = E, h.stop());
        } };
        class p {
          constructor(m, { code: E, ast: _, inputMap: C }) {
            this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = { file: this, getCode: () => this.code, getScope: () => this.scope, addHelper: this.addHelper.bind(this), buildError: this.buildCodeFrameError.bind(this) }, this.opts = m, this.code = E, this.ast = _, this.inputMap = C, this.path = u().NodePath.get({ hub: this.hub, parentPath: null, parent: this.ast, container: this.ast, key: "program" }).setContext(), this.scope = this.path.scope;
          }
          get shebang() {
            const { interpreter: m } = this.path.node;
            return m ? m.value : "";
          }
          set shebang(m) {
            m ? this.path.get("interpreter").replaceWith(T(m)) : this.path.get("interpreter").remove();
          }
          set(m, E) {
            if (m === "helpersNamespace") throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
            this._map.set(m, E);
          }
          get(m) {
            return this._map.get(m);
          }
          has(m) {
            return this._map.has(m);
          }
          availableHelper(m, E) {
            let _;
            try {
              _ = n().minVersion(m);
            } catch (C) {
              if (C.code !== "BABEL_HELPER_UNKNOWN") throw C;
              return false;
            }
            return typeof E != "string" || (r().valid(E) && (E = `^${E}`), !r().intersects(`<${_}`, E) && !r().intersects(">=8.0.0", E));
          }
          addHelper(m) {
            const E = this.declarations[m];
            if (E) return S(E);
            const _ = this.get("helperGenerator");
            if (_) {
              const L = _(m);
              if (L) return L;
            }
            n().minVersion(m);
            const C = this.declarations[m] = this.scope.generateUidIdentifier(m), w = {};
            for (const L of n().getDependencies(m)) w[L] = this.addHelper(L);
            const { nodes: I, globals: D } = n().get(m, (L) => w[L], C.name, Object.keys(this.scope.getAllBindings()));
            D.forEach((L) => {
              this.path.scope.hasBinding(L, true) && this.path.scope.rename(L);
            }), I.forEach((L) => {
              L._compact = true;
            });
            const j = this.path.unshiftContainer("body", I);
            for (const L of j) L.isVariableDeclaration() && this.scope.registerDeclaration(L);
            return C;
          }
          buildCodeFrameError(m, E, _ = SyntaxError) {
            let C = m == null ? void 0 : m.loc;
            if (!C && m) {
              const w = { loc: null };
              (0, u().default)(m, d, this.scope, w), C = w.loc;
              let I = "This is an error on an internal node. Probably an internal error.";
              C && (I += " Location has been estimated."), E += ` (${I})`;
            }
            if (C) {
              const { highlightCode: w = true } = this.opts;
              E += `
` + (0, c().codeFrameColumns)(this.code, { start: { line: C.start.line, column: C.start.column + 1 }, end: C.end && C.start.line === C.end.line ? { line: C.end.line, column: C.end.column + 1 } : void 0 }, { highlightCode: w });
            }
            return new _(E);
          }
        }
        t.default = p, p.prototype.addImport = function() {
          throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
        }, p.prototype.addTemplateObject = function() {
          throw new Error("This function has been moved into the template literal transform itself.");
        }, p.prototype.getModuleName = function() {
          return f.getModuleName()(this.opts, this.opts);
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/generate.js": (P, t, l) => {
        function n() {
          const e = l("./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js");
          return n = function() {
            return e;
          }, e;
        }
        function u() {
          const e = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/index.js");
          return u = function() {
            return e;
          }, e;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(e, r) {
          const { opts: f, ast: y, code: S, inputMap: T } = r, { generatorOpts: d } = f;
          d.inputSourceMap = T == null ? void 0 : T.toObject();
          const p = [];
          for (const _ of e) for (const C of _) {
            const { generatorOverride: w } = C;
            if (w) {
              const I = w(y, d, S, u().default);
              I !== void 0 && p.push(I);
            }
          }
          let h;
          if (p.length === 0) h = (0, u().default)(y, d, S);
          else {
            if (p.length !== 1) throw new Error("More than one plugin attempted to override codegen.");
            if (h = p[0], typeof h.then == "function") throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          }
          let { code: m, decodedMap: E = h.map } = h;
          return h.__mergedMap ? E = Object.assign({}, h.map) : E && (E = T ? (0, c.default)(T.toObject(), E, d.sourceFileName) : h.map), f.sourceMaps !== "inline" && f.sourceMaps !== "both" || (m += `
` + n().fromObject(E).toComment()), f.sourceMaps === "inline" && (E = null), { outputCode: m, outputMap: E };
        };
        var c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/merge-map.js");
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/merge-map.js": (P, t, l) => {
        function n() {
          const c = l("./node_modules/.pnpm/@ampproject+remapping@2.3.0/node_modules/@ampproject/remapping/dist/remapping.umd.js");
          return n = function() {
            return c;
          }, c;
        }
        function u(c) {
          return Object.assign({}, c, { sourceRoot: null });
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c, e, r) {
          const f = r.replace(/\\/g, "/");
          let y = false;
          const S = n()(u(e), (T, d) => T !== f || y ? null : (y = true, d.source = "", u(c)));
          return typeof c.sourceRoot == "string" && (S.sourceRoot = c.sourceRoot), Object.assign({}, S);
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/index.js": (P, t, l) => {
        function n() {
          const T = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");
          return n = function() {
            return T;
          }, T;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.run = function* (T, d, p) {
          const h = yield* (0, r.default)(T.passes, (0, e.default)(T), d, p), m = h.opts;
          try {
            yield* function* (I, D) {
              const j = yield* (0, S.isAsync)();
              for (const L of D) {
                const k = [], N = [], F = [];
                for (const X of L.concat([(0, c.default)()])) {
                  const H = new u.default(I, X.key, X.options, j);
                  k.push([X, H]), N.push(H), F.push(X.visitor);
                }
                for (const [X, H] of k) X.pre && (yield* (0, S.maybeAsync)(X.pre, "You appear to be using an async plugin/preset, but Babel has been called synchronously").call(H, I));
                const W = n().default.visitors.merge(F, N, I.opts.wrapPluginVisitorMethod);
                (0, n().default)(I.ast, W, I.scope);
                for (const [X, H] of k) X.post && (yield* (0, S.maybeAsync)(X.post, "You appear to be using an async plugin/preset, but Babel has been called synchronously").call(H, I));
              }
            }(h, T.passes);
          } catch (I) {
            var E;
            throw I.message = `${(E = m.filename) != null ? E : "unknown file"}: ${I.message}`, I.code || (I.code = "BABEL_TRANSFORM_ERROR"), I;
          }
          let _, C;
          try {
            m.code !== false && ({ outputCode: _, outputMap: C } = (0, f.default)(T.passes, h));
          } catch (I) {
            var w;
            throw I.message = `${(w = m.filename) != null ? w : "unknown file"}: ${I.message}`, I.code || (I.code = "BABEL_GENERATE_ERROR"), I;
          }
          return { metadata: h.metadata, options: m, ast: m.ast === true ? h.ast : null, code: _ === void 0 ? null : _, map: C === void 0 ? null : C, sourceType: h.ast.program.sourceType, externalDependencies: (0, y.flattenToSet)(T.externalDependencies) };
        };
        var u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/plugin-pass.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"), e = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/normalize-opts.js"), r = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/normalize-file.js"), f = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/generate.js"), y = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/config/helpers/deep-array.js"), S = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/gensync-utils/async.js");
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/normalize-file.js": (P, t, l) => {
        function n() {
          const C = l("fs");
          return n = function() {
            return C;
          }, C;
        }
        function u() {
          const C = l("path");
          return u = function() {
            return C;
          }, C;
        }
        function c() {
          const C = l("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js");
          return c = function() {
            return C;
          }, C;
        }
        function e() {
          const C = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
          return e = function() {
            return C;
          }, C;
        }
        function r() {
          const C = l("./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js");
          return r = function() {
            return C;
          }, C;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function* (C, w, I, D) {
          if (I = `${I || ""}`, D) {
            if (D.type === "Program") D = T(D, [], []);
            else if (D.type !== "File") throw new Error("AST root must be a Program or File node");
            w.cloneInputAst && (D = (0, S.default)(D));
          } else D = yield* (0, y.default)(C, w, I);
          let j = null;
          if (w.inputSourceMap !== false) {
            if (typeof w.inputSourceMap == "object" && (j = r().fromObject(w.inputSourceMap)), !j) {
              const L = _(h, D);
              if (L) try {
                j = r().fromComment("//" + L);
              } catch {
                p("discarding unknown inline input sourcemap");
              }
            }
            if (!j) {
              const L = _(m, D);
              if (typeof w.filename == "string" && L) try {
                const k = m.exec(L), N = n().readFileSync(u().resolve(u().dirname(w.filename), k[1]), "utf8");
                j = r().fromJSON(N);
              } catch (k) {
                p("discarding unknown file input sourcemap", k);
              }
              else L && p("discarding un-loadable file input sourcemap");
            }
          }
          return new f.default(w, { code: I, ast: D, inputMap: j });
        };
        var f = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/file/file.js"), y = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/parser/index.js"), S = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/util/clone-deep.js");
        const { file: T, traverseFast: d } = e(), p = c()("babel:transform:file"), h = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/, m = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
        function E(C, w, I) {
          return w && (w = w.filter(({ value: D }) => !C.test(D) || (I = D, false))), [w, I];
        }
        function _(C, w) {
          let I = null;
          return d(w, (D) => {
            [D.leadingComments, I] = E(C, D.leadingComments, I), [D.innerComments, I] = E(C, D.innerComments, I), [D.trailingComments, I] = E(C, D.trailingComments, I);
          }), I;
        }
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/normalize-opts.js": (P, t, l) => {
        function n() {
          const u = l("path");
          return n = function() {
            return u;
          }, u;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          const { filename: c, cwd: e, filenameRelative: r = typeof c == "string" ? n().relative(e, c) : "unknown", sourceType: f = "module", inputSourceMap: y, sourceMaps: S = !!y, sourceRoot: T = u.options.moduleRoot, sourceFileName: d = n().basename(r), comments: p = true, compact: h = "auto" } = u.options, m = u.options, E = Object.assign({}, m, { parserOpts: Object.assign({ sourceType: n().extname(r) === ".mjs" ? "module" : f, sourceFileName: c, plugins: [] }, m.parserOpts), generatorOpts: Object.assign({ filename: c, auxiliaryCommentBefore: m.auxiliaryCommentBefore, auxiliaryCommentAfter: m.auxiliaryCommentAfter, retainLines: m.retainLines, comments: p, shouldPrintComment: m.shouldPrintComment, compact: h, minified: m.minified, sourceMaps: S, sourceRoot: T, sourceFileName: d }, m.generatorOpts) });
          for (const _ of u.passes) for (const C of _) C.manipulateOptions && C.manipulateOptions(E, E.parserOpts);
          return E;
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/plugin-pass.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        class l {
          constructor(u, c, e, r) {
            this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.isAsync = void 0, this.key = c, this.file = u, this.opts = e || {}, this.cwd = u.opts.cwd, this.filename = u.opts.filename, this.isAsync = r;
          }
          set(u, c) {
            this._map.set(u, c);
          }
          get(u) {
            return this._map.get(u);
          }
          availableHelper(u, c) {
            return this.file.availableHelper(u, c);
          }
          addHelper(u) {
            return this.file.addHelper(u);
          }
          buildCodeFrameError(u, c, e) {
            return this.file.buildCodeFrameError(u, c, e);
          }
        }
        t.default = l, l.prototype.getModuleName = function() {
          return this.file.getModuleName();
        }, l.prototype.addImport = function() {
          this.file.addImport();
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/transformation/util/clone-deep.js": (P, t) => {
        function l(n, u) {
          if (n !== null) {
            if (u.has(n)) return u.get(n);
            let c;
            if (Array.isArray(n)) {
              c = new Array(n.length), u.set(n, c);
              for (let e = 0; e < n.length; e++) c[e] = typeof n[e] != "object" ? n[e] : l(n[e], u);
            } else {
              c = {}, u.set(n, c);
              const e = Object.keys(n);
              for (let r = 0; r < e.length; r++) {
                const f = e[r];
                c[f] = typeof n[f] != "object" ? n[f] : l(n[f], u);
              }
            }
            return c;
          }
          return n;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(n) {
          return typeof n != "object" ? n : l(n, /* @__PURE__ */ new Map());
        };
      }, "./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/vendor/import-meta-resolve.js": (P, t, l) => {
        function n() {
          const be = l("assert");
          return n = function() {
            return be;
          }, be;
        }
        function u() {
          const be = function(ke, Ve) {
            if (ke === null || typeof ke != "object" && typeof ke != "function") return { default: ke };
            var ze = T(Ve);
            if (ze && ze.has(ke)) return ze.get(ke);
            var rt = { __proto__: null }, it = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var Ye in ke) if (Ye !== "default" && {}.hasOwnProperty.call(ke, Ye)) {
              var tt = it ? Object.getOwnPropertyDescriptor(ke, Ye) : null;
              tt && (tt.get || tt.set) ? Object.defineProperty(rt, Ye, tt) : rt[Ye] = ke[Ye];
            }
            return rt.default = ke, ze && ze.set(ke, rt), rt;
          }(l("fs"), true);
          return u = function() {
            return be;
          }, be;
        }
        function c() {
          const be = l("process");
          return c = function() {
            return be;
          }, be;
        }
        function e() {
          const be = l("url");
          return e = function() {
            return be;
          }, be;
        }
        function r() {
          const be = l("path");
          return r = function() {
            return be;
          }, be;
        }
        function f() {
          const be = l("module");
          return f = function() {
            return be;
          }, be;
        }
        function y() {
          const be = l("v8");
          return y = function() {
            return be;
          }, be;
        }
        function S() {
          const be = l("util");
          return S = function() {
            return be;
          }, be;
        }
        function T(be) {
          if (typeof WeakMap != "function") return null;
          var ke = /* @__PURE__ */ new WeakMap(), Ve = /* @__PURE__ */ new WeakMap();
          return (T = function(ze) {
            return ze ? Ve : ke;
          })(be);
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.moduleResolve = st, t.resolve = function(be, ke) {
          if (!ke) throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
          try {
            return function(Ve, ze = {}) {
              const { parentURL: rt } = ze;
              let it, Ye, tt;
              if (n()(rt !== void 0, "expected `parentURL` to be defined"), function(yt) {
                if (yt !== void 0) {
                  if (typeof yt != "string" && (vt = yt, !(vt && typeof vt == "object" && "href" in vt && typeof vt.href == "string" && "protocol" in vt && typeof vt.protocol == "string" && vt.href && vt.protocol))) throw new m.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], yt);
                  var vt;
                }
              }(rt), rt) try {
                it = new (e()).URL(rt);
              } catch {
              }
              try {
                if (Ye = Je(Ve) ? new (e()).URL(Ve, it) : new (e()).URL(Ve), tt = Ye.protocol, tt === "data:") return { url: Ye.href, format: null };
              } catch {
              }
              const pt = function(yt, vt, kt) {
                if (kt) {
                  const qt = kt.protocol;
                  if (qt === "http:" || qt === "https:") {
                    if (Je(yt)) {
                      const sn = vt == null ? void 0 : vt.protocol;
                      if (sn && sn !== "https:" && sn !== "http:") throw new z(yt, kt, "remote imports cannot import from a local location.");
                      return { url: (vt == null ? void 0 : vt.href) || "" };
                    }
                    throw f().builtinModules.includes(yt) ? new z(yt, kt, "remote imports cannot import from a local location.") : new z(yt, kt, "only relative and absolute specifiers are supported.");
                  }
                }
              }(Ve, Ye, it);
              if (pt) return pt;
              if (tt === void 0 && Ye && (tt = Ye.protocol), tt === "node:") return { url: Ve };
              if (Ye && Ye.protocol === "node:") return { url: Ve };
              const Et = function(yt) {
                if (yt !== void 0 && yt !== Z) {
                  if (!Array.isArray(yt)) throw new Y("conditions", yt, "expected an array");
                  return new Set(yt);
                }
                return G;
              }(ze.conditions), Qe = st(Ve, new (e()).URL(rt), Et, false);
              return { url: Qe.href, format: re(Qe, { parentURL: rt }) };
            }(be, { parentURL: ke }).url;
          } catch (Ve) {
            const ze = Ve;
            if ((ze.code === "ERR_UNSUPPORTED_DIR_IMPORT" || ze.code === "ERR_MODULE_NOT_FOUND") && typeof ze.url == "string") return ze.url;
            throw Ve;
          }
        };
        const d = {}.hasOwnProperty, p = /^([A-Z][a-z\d]*)+$/, h = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), m = {};
        function E(be, ke = "and") {
          return be.length < 3 ? be.join(` ${ke} `) : `${be.slice(0, -1).join(", ")}, ${ke} ${be[be.length - 1]}`;
        }
        const _ = /* @__PURE__ */ new Map();
        let C;
        function w(be, ke, Ve) {
          return _.set(be, ke), /* @__PURE__ */ function(ze, rt) {
            return it;
            function it(...Ye) {
              const tt = Error.stackTraceLimit;
              I() && (Error.stackTraceLimit = 0);
              const pt = new ze();
              I() && (Error.stackTraceLimit = tt);
              const Et = function(Qe, yt, vt) {
                const kt = _.get(Qe);
                if (n()(kt !== void 0, "expected `message` to be found"), typeof kt == "function") return n()(kt.length <= yt.length, `Code: ${Qe}; The provided arguments length (${yt.length}) does not match the required ones (${kt.length}).`), Reflect.apply(kt, vt, yt);
                const qt = /%[dfijoOs]/g;
                let sn = 0;
                for (; qt.exec(kt) !== null; ) sn++;
                return n()(sn === yt.length, `Code: ${Qe}; The provided arguments length (${yt.length}) does not match the required ones (${sn}).`), yt.length === 0 ? kt : (yt.unshift(kt), Reflect.apply(S().format, null, yt));
              }(rt, Ye, pt);
              return Object.defineProperties(pt, { message: { value: Et, enumerable: false, writable: true, configurable: true }, toString: { value() {
                return `${this.name} [${rt}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true } }), D(pt), pt.code = rt, pt;
            }
          }(Ve, be);
        }
        function I() {
          try {
            if (y().startupSnapshot.isBuildingSnapshot()) return false;
          } catch {
          }
          const be = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return be === void 0 ? Object.isExtensible(Error) : d.call(be, "writable") && be.writable !== void 0 ? be.writable : be.set !== void 0;
        }
        m.ERR_INVALID_ARG_TYPE = w("ERR_INVALID_ARG_TYPE", (be, ke, Ve) => {
          n()(typeof be == "string", "'name' must be a string"), Array.isArray(ke) || (ke = [ke]);
          let ze = "The ";
          if (be.endsWith(" argument")) ze += `${be} `;
          else {
            const tt = be.includes(".") ? "property" : "argument";
            ze += `"${be}" ${tt} `;
          }
          ze += "must be ";
          const rt = [], it = [], Ye = [];
          for (const tt of ke) n()(typeof tt == "string", "All expected entries have to be of type string"), h.has(tt) ? rt.push(tt.toLowerCase()) : p.exec(tt) === null ? (n()(tt !== "object", 'The value "object" should be written as "Object"'), Ye.push(tt)) : it.push(tt);
          if (it.length > 0) {
            const tt = rt.indexOf("object");
            tt !== -1 && (rt.slice(tt, 1), it.push("Object"));
          }
          return rt.length > 0 && (ze += `${rt.length > 1 ? "one of type" : "of type"} ${E(rt, "or")}`, (it.length > 0 || Ye.length > 0) && (ze += " or ")), it.length > 0 && (ze += `an instance of ${E(it, "or")}`, Ye.length > 0 && (ze += " or ")), Ye.length > 0 && (Ye.length > 1 ? ze += `one of ${E(Ye, "or")}` : (Ye[0].toLowerCase() !== Ye[0] && (ze += "an "), ze += `${Ye[0]}`)), ze += `. Received ${function(tt) {
            if (tt == null) return String(tt);
            if (typeof tt == "function" && tt.name) return `function ${tt.name}`;
            if (typeof tt == "object") return tt.constructor && tt.constructor.name ? `an instance of ${tt.constructor.name}` : `${(0, S().inspect)(tt, { depth: -1 })}`;
            let pt = (0, S().inspect)(tt, { colors: false });
            return pt.length > 28 && (pt = `${pt.slice(0, 25)}...`), `type ${typeof tt} (${pt})`;
          }(Ve)}`, ze;
        }, TypeError), m.ERR_INVALID_MODULE_SPECIFIER = w("ERR_INVALID_MODULE_SPECIFIER", (be, ke, Ve = void 0) => `Invalid module "${be}" ${ke}${Ve ? ` imported from ${Ve}` : ""}`, TypeError), m.ERR_INVALID_PACKAGE_CONFIG = w("ERR_INVALID_PACKAGE_CONFIG", (be, ke, Ve) => `Invalid package config ${be}${ke ? ` while importing ${ke}` : ""}${Ve ? `. ${Ve}` : ""}`, Error), m.ERR_INVALID_PACKAGE_TARGET = w("ERR_INVALID_PACKAGE_TARGET", (be, ke, Ve, ze = false, rt = void 0) => {
          const it = typeof Ve == "string" && !ze && Ve.length > 0 && !Ve.startsWith("./");
          return ke === "." ? (n()(ze === false), `Invalid "exports" main target ${JSON.stringify(Ve)} defined in the package config ${be}package.json${rt ? ` imported from ${rt}` : ""}${it ? '; targets must start with "./"' : ""}`) : `Invalid "${ze ? "imports" : "exports"}" target ${JSON.stringify(Ve)} defined for '${ke}' in the package config ${be}package.json${rt ? ` imported from ${rt}` : ""}${it ? '; targets must start with "./"' : ""}`;
        }, Error), m.ERR_MODULE_NOT_FOUND = w("ERR_MODULE_NOT_FOUND", (be, ke, Ve = false) => `Cannot find ${Ve ? "module" : "package"} '${be}' imported from ${ke}`, Error), m.ERR_NETWORK_IMPORT_DISALLOWED = w("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), m.ERR_PACKAGE_IMPORT_NOT_DEFINED = w("ERR_PACKAGE_IMPORT_NOT_DEFINED", (be, ke, Ve) => `Package import specifier "${be}" is not defined${ke ? ` in package ${ke}package.json` : ""} imported from ${Ve}`, TypeError), m.ERR_PACKAGE_PATH_NOT_EXPORTED = w("ERR_PACKAGE_PATH_NOT_EXPORTED", (be, ke, Ve = void 0) => ke === "." ? `No "exports" main defined in ${be}package.json${Ve ? ` imported from ${Ve}` : ""}` : `Package subpath '${ke}' is not defined by "exports" in ${be}package.json${Ve ? ` imported from ${Ve}` : ""}`, Error), m.ERR_UNSUPPORTED_DIR_IMPORT = w("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), m.ERR_UNSUPPORTED_RESOLVE_REQUEST = w("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError), m.ERR_UNKNOWN_FILE_EXTENSION = w("ERR_UNKNOWN_FILE_EXTENSION", (be, ke) => `Unknown file extension "${be}" for ${ke}`, TypeError), m.ERR_INVALID_ARG_VALUE = w("ERR_INVALID_ARG_VALUE", (be, ke, Ve = "is invalid") => {
          let ze = (0, S().inspect)(ke);
          return ze.length > 128 && (ze = `${ze.slice(0, 128)}...`), `The ${be.includes(".") ? "property" : "argument"} '${be}' ${Ve}. Received ${ze}`;
        }, TypeError);
        const D = function(be) {
          const ke = "__node_internal_" + be.name;
          return Object.defineProperty(be, "name", { value: ke }), be;
        }(function(be) {
          const ke = I();
          return ke && (C = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(be), ke && (Error.stackTraceLimit = C), be;
        }), j = {}.hasOwnProperty, { ERR_INVALID_PACKAGE_CONFIG: L } = m, k = /* @__PURE__ */ new Map();
        function N(be, { base: ke, specifier: Ve }) {
          const ze = k.get(be);
          if (ze) return ze;
          let rt;
          try {
            rt = u().default.readFileSync(r().toNamespacedPath(be), "utf8");
          } catch (Ye) {
            const tt = Ye;
            if (tt.code !== "ENOENT") throw tt;
          }
          const it = { exists: false, pjsonPath: be, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          if (rt !== void 0) {
            let Ye;
            try {
              Ye = JSON.parse(rt);
            } catch (tt) {
              const pt = tt, Et = new L(be, (ke ? `"${Ve}" from ` : "") + (0, e().fileURLToPath)(ke || Ve), pt.message);
              throw Et.cause = pt, Et;
            }
            it.exists = true, j.call(Ye, "name") && typeof Ye.name == "string" && (it.name = Ye.name), j.call(Ye, "main") && typeof Ye.main == "string" && (it.main = Ye.main), j.call(Ye, "exports") && (it.exports = Ye.exports), j.call(Ye, "imports") && (it.imports = Ye.imports), !j.call(Ye, "type") || Ye.type !== "commonjs" && Ye.type !== "module" || (it.type = Ye.type);
          }
          return k.set(be, it), it;
        }
        function F(be) {
          let ke = new URL("package.json", be);
          for (; !ke.pathname.endsWith("node_modules/package.json"); ) {
            const Ve = N((0, e().fileURLToPath)(ke), { specifier: be });
            if (Ve.exists) return Ve;
            const ze = ke;
            if (ke = new URL("../package.json", ke), ke.pathname === ze.pathname) break;
          }
          return { pjsonPath: (0, e().fileURLToPath)(ke), exists: false, type: "none" };
        }
        function W(be) {
          return F(be).type;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: X } = m, H = {}.hasOwnProperty, U = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" }, q = { __proto__: null, "data:": function(be) {
          const { 1: ke } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(be.pathname) || [null, null, null];
          return function(Ve) {
            return Ve && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(Ve) ? "module" : Ve === "application/json" ? "json" : null;
          }(ke);
        }, "file:": function(be, ke, Ve) {
          const ze = function(Ye) {
            const tt = Ye.pathname;
            let pt = tt.length;
            for (; pt--; ) {
              const Et = tt.codePointAt(pt);
              if (Et === 47) return "";
              if (Et === 46) return tt.codePointAt(pt - 1) === 47 ? "" : tt.slice(pt);
            }
            return "";
          }(be);
          if (ze === ".js") {
            const Ye = W(be);
            return Ye !== "none" ? Ye : "commonjs";
          }
          if (ze === "") {
            const Ye = W(be);
            return Ye === "none" || Ye === "commonjs" ? "commonjs" : "module";
          }
          const rt = U[ze];
          if (rt) return rt;
          if (Ve) return;
          const it = (0, e().fileURLToPath)(be);
          throw new X(ze, it);
        }, "http:": ee, "https:": ee, "node:": () => "builtin" };
        function ee() {
        }
        function re(be, ke) {
          const Ve = be.protocol;
          return H.call(q, Ve) && q[Ve](be, ke, true) || null;
        }
        const { ERR_INVALID_ARG_VALUE: Y } = m, Z = Object.freeze(["node", "import"]), G = new Set(Z), B = RegExp.prototype[Symbol.replace], { ERR_NETWORK_IMPORT_DISALLOWED: z, ERR_INVALID_MODULE_SPECIFIER: M, ERR_INVALID_PACKAGE_CONFIG: K, ERR_INVALID_PACKAGE_TARGET: Q, ERR_MODULE_NOT_FOUND: ie, ERR_PACKAGE_IMPORT_NOT_DEFINED: ue, ERR_PACKAGE_PATH_NOT_EXPORTED: ge, ERR_UNSUPPORTED_DIR_IMPORT: Te, ERR_UNSUPPORTED_RESOLVE_REQUEST: le } = m, fe = {}.hasOwnProperty, Pe = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, xe = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, we = /^\.|%|\\/, me = /\*/g, ye = /%2f|%5c/i, pe = /* @__PURE__ */ new Set(), J = /[/\\]{2}/;
        function Ee(be, ke, Ve, ze, rt, it, Ye) {
          if (c().noDeprecation) return;
          const tt = (0, e().fileURLToPath)(ze), pt = J.exec(Ye ? be : ke) !== null;
          c().emitWarning(`Use of deprecated ${pt ? "double slash" : "leading or trailing slash matching"} resolving "${be}" for module request "${ke}" ${ke === Ve ? "" : `matched to "${Ve}" `}in the "${rt ? "imports" : "exports"}" field module resolution of the package at ${tt}${it ? ` imported from ${(0, e().fileURLToPath)(it)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function Me(be, ke, Ve, ze) {
          if (c().noDeprecation || re(be, { parentURL: Ve.href }) !== "module") return;
          const rt = (0, e().fileURLToPath)(be.href), it = (0, e().fileURLToPath)(new (e()).URL(".", ke)), Ye = (0, e().fileURLToPath)(Ve);
          ze ? r().resolve(it, ze) !== rt && c().emitWarning(`Package ${it} has a "main" field set to "${ze}", excluding the full filename and extension to the resolved file at "${rt.slice(it.length)}", imported from ${Ye}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : c().emitWarning(`No "main" or "exports" field defined in the package.json for ${it} resolving the main entry point "${rt.slice(it.length)}", imported from ${Ye}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function Ue(be) {
          try {
            return (0, u().statSync)(be);
          } catch {
          }
        }
        function qe(be) {
          const ke = (0, u().statSync)(be, { throwIfNoEntry: false }), Ve = ke ? ke.isFile() : void 0;
          return Ve != null && Ve;
        }
        function He(be, ke, Ve) {
          let ze;
          if (ke.main !== void 0) {
            if (ze = new (e()).URL(ke.main, be), qe(ze)) return ze;
            const Ye = [`./${ke.main}.js`, `./${ke.main}.json`, `./${ke.main}.node`, `./${ke.main}/index.js`, `./${ke.main}/index.json`, `./${ke.main}/index.node`];
            let tt = -1;
            for (; ++tt < Ye.length && (ze = new (e()).URL(Ye[tt], be), !qe(ze)); ) ze = void 0;
            if (ze) return Me(ze, be, Ve, ke.main), ze;
          }
          const rt = ["./index.js", "./index.json", "./index.node"];
          let it = -1;
          for (; ++it < rt.length && (ze = new (e()).URL(rt[it], be), !qe(ze)); ) ze = void 0;
          if (ze) return Me(ze, be, Ve, ke.main), ze;
          throw new ie((0, e().fileURLToPath)(new (e()).URL(".", be)), (0, e().fileURLToPath)(Ve));
        }
        function Ie(be, ke, Ve) {
          return new ge((0, e().fileURLToPath)(new (e()).URL(".", ke)), be, Ve && (0, e().fileURLToPath)(Ve));
        }
        function Re(be, ke, Ve, ze, rt) {
          return ke = typeof ke == "object" && ke !== null ? JSON.stringify(ke, null, "") : `${ke}`, new Q((0, e().fileURLToPath)(new (e()).URL(".", Ve)), be, ke, ze, rt && (0, e().fileURLToPath)(rt));
        }
        function Be(be, ke, Ve, ze, rt, it, Ye, tt, pt) {
          if (ke !== "" && !it && be[be.length - 1] !== "/") throw Re(Ve, be, ze, Ye, rt);
          if (!be.startsWith("./")) {
            if (Ye && !be.startsWith("../") && !be.startsWith("/")) {
              let vt = false;
              try {
                new (e()).URL(be), vt = true;
              } catch {
              }
              if (!vt) return Xe(it ? B.call(me, be, () => ke) : be + ke, ze, pt);
            }
            throw Re(Ve, be, ze, Ye, rt);
          }
          if (Pe.exec(be.slice(2)) !== null) {
            if (xe.exec(be.slice(2)) !== null) throw Re(Ve, be, ze, Ye, rt);
            if (!tt) {
              const vt = it ? Ve.replace("*", () => ke) : Ve + ke;
              Ee(it ? B.call(me, be, () => ke) : be, vt, Ve, ze, Ye, rt, true);
            }
          }
          const Et = new (e()).URL(be, ze), Qe = Et.pathname, yt = new (e()).URL(".", ze).pathname;
          if (!Qe.startsWith(yt)) throw Re(Ve, be, ze, Ye, rt);
          if (ke === "") return Et;
          if (Pe.exec(ke) !== null) {
            const vt = it ? Ve.replace("*", () => ke) : Ve + ke;
            xe.exec(ke) === null ? tt || Ee(it ? B.call(me, be, () => ke) : be, vt, Ve, ze, Ye, rt, false) : function(kt, qt, sn, _n, bn) {
              const Kt = `request is not a valid match in pattern "${qt}" for the "${_n ? "imports" : "exports"}" resolution of ${(0, e().fileURLToPath)(sn)}`;
              throw new M(kt, Kt, bn && (0, e().fileURLToPath)(bn));
            }(vt, Ve, ze, Ye, rt);
          }
          return it ? new (e()).URL(B.call(me, Et.href, () => ke)) : new (e()).URL(ke, Et);
        }
        function je(be) {
          const ke = Number(be);
          return `${ke}` === be && ke >= 0 && ke < 4294967295;
        }
        function he(be, ke, Ve, ze, rt, it, Ye, tt, pt) {
          if (typeof ke == "string") return Be(ke, Ve, ze, be, rt, it, Ye, tt, pt);
          if (Array.isArray(ke)) {
            const Et = ke;
            if (Et.length === 0) return null;
            let Qe, yt = -1;
            for (; ++yt < Et.length; ) {
              const vt = Et[yt];
              let kt;
              try {
                kt = he(be, vt, Ve, ze, rt, it, Ye, tt, pt);
              } catch (qt) {
                if (Qe = qt, qt.code === "ERR_INVALID_PACKAGE_TARGET") continue;
                throw qt;
              }
              if (kt !== void 0) {
                if (kt !== null) return kt;
                Qe = null;
              }
            }
            if (Qe == null) return null;
            throw Qe;
          }
          if (typeof ke == "object" && ke !== null) {
            const Et = Object.getOwnPropertyNames(ke);
            let Qe = -1;
            for (; ++Qe < Et.length; ) if (je(Et[Qe])) throw new K((0, e().fileURLToPath)(be), rt, '"exports" cannot contain numeric property keys.');
            for (Qe = -1; ++Qe < Et.length; ) {
              const yt = Et[Qe];
              if (yt === "default" || pt && pt.has(yt)) {
                const vt = he(be, ke[yt], Ve, ze, rt, it, Ye, tt, pt);
                if (vt === void 0) continue;
                return vt;
              }
            }
            return null;
          }
          if (ke === null) return null;
          throw Re(ze, ke, be, Ye, rt);
        }
        function oe(be, ke, Ve) {
          if (c().noDeprecation) return;
          const ze = (0, e().fileURLToPath)(ke);
          pe.has(ze + "|" + be) || (pe.add(ze + "|" + be), c().emitWarning(`Use of deprecated trailing slash pattern mapping "${be}" in the "exports" field module resolution of the package at ${ze}${Ve ? ` imported from ${(0, e().fileURLToPath)(Ve)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function _e(be, ke, Ve, ze, rt) {
          let it = Ve.exports;
          if (function(Qe, yt, vt) {
            if (typeof Qe == "string" || Array.isArray(Qe)) return true;
            if (typeof Qe != "object" || Qe === null) return false;
            const kt = Object.getOwnPropertyNames(Qe);
            let qt = false, sn = 0, _n = -1;
            for (; ++_n < kt.length; ) {
              const bn = kt[_n], Kt = bn === "" || bn[0] !== ".";
              if (sn++ == 0) qt = Kt;
              else if (qt !== Kt) throw new K((0, e().fileURLToPath)(yt), vt, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return qt;
          }(it, be, ze) && (it = { ".": it }), fe.call(it, ke) && !ke.includes("*") && !ke.endsWith("/")) {
            const Qe = he(be, it[ke], "", ke, ze, false, false, false, rt);
            if (Qe == null) throw Ie(ke, be, ze);
            return Qe;
          }
          let Ye = "", tt = "";
          const pt = Object.getOwnPropertyNames(it);
          let Et = -1;
          for (; ++Et < pt.length; ) {
            const Qe = pt[Et], yt = Qe.indexOf("*");
            if (yt !== -1 && ke.startsWith(Qe.slice(0, yt))) {
              ke.endsWith("/") && oe(ke, be, ze);
              const vt = Qe.slice(yt + 1);
              ke.length >= Qe.length && ke.endsWith(vt) && Ne(Ye, Qe) === 1 && Qe.lastIndexOf("*") === yt && (Ye = Qe, tt = ke.slice(yt, ke.length - vt.length));
            }
          }
          if (Ye) {
            const Qe = he(be, it[Ye], tt, Ye, ze, true, false, ke.endsWith("/"), rt);
            if (Qe == null) throw Ie(ke, be, ze);
            return Qe;
          }
          throw Ie(ke, be, ze);
        }
        function Ne(be, ke) {
          const Ve = be.indexOf("*"), ze = ke.indexOf("*"), rt = Ve === -1 ? be.length : Ve + 1, it = ze === -1 ? ke.length : ze + 1;
          return rt > it ? -1 : it > rt || Ve === -1 ? 1 : ze === -1 || be.length > ke.length ? -1 : ke.length > be.length ? 1 : 0;
        }
        function $e(be, ke, Ve) {
          if (be === "#" || be.startsWith("#/") || be.endsWith("/")) throw new M(be, "is not a valid internal imports specifier name", (0, e().fileURLToPath)(ke));
          let ze;
          const rt = F(ke);
          if (rt.exists) {
            ze = (0, e().pathToFileURL)(rt.pjsonPath);
            const it = rt.imports;
            if (it) if (fe.call(it, be) && !be.includes("*")) {
              const Ye = he(ze, it[be], "", be, ke, false, true, false, Ve);
              if (Ye != null) return Ye;
            } else {
              let Ye = "", tt = "";
              const pt = Object.getOwnPropertyNames(it);
              let Et = -1;
              for (; ++Et < pt.length; ) {
                const Qe = pt[Et], yt = Qe.indexOf("*");
                if (yt !== -1 && be.startsWith(Qe.slice(0, -1))) {
                  const vt = Qe.slice(yt + 1);
                  be.length >= Qe.length && be.endsWith(vt) && Ne(Ye, Qe) === 1 && Qe.lastIndexOf("*") === yt && (Ye = Qe, tt = be.slice(yt, be.length - vt.length));
                }
              }
              if (Ye) {
                const Qe = he(ze, it[Ye], tt, Ye, ke, true, true, false, Ve);
                if (Qe != null) return Qe;
              }
            }
          }
          throw function(it, Ye, tt) {
            return new ue(it, Ye && (0, e().fileURLToPath)(new (e()).URL(".", Ye)), (0, e().fileURLToPath)(tt));
          }(be, ze, ke);
        }
        function Xe(be, ke, Ve) {
          if (f().builtinModules.includes(be)) return new (e()).URL("node:" + be);
          const { packageName: ze, packageSubpath: rt, isScoped: it } = function(Qe, yt) {
            let vt = Qe.indexOf("/"), kt = true, qt = false;
            Qe[0] === "@" && (qt = true, vt === -1 || Qe.length === 0 ? kt = false : vt = Qe.indexOf("/", vt + 1));
            const sn = vt === -1 ? Qe : Qe.slice(0, vt);
            if (we.exec(sn) !== null && (kt = false), !kt) throw new M(Qe, "is not a valid package name", (0, e().fileURLToPath)(yt));
            return { packageName: sn, packageSubpath: "." + (vt === -1 ? "" : Qe.slice(vt)), isScoped: qt };
          }(be, ke), Ye = F(ke);
          if (Ye.exists) {
            const Qe = (0, e().pathToFileURL)(Ye.pjsonPath);
            if (Ye.name === ze && Ye.exports !== void 0 && Ye.exports !== null) return _e(Qe, rt, Ye, ke, Ve);
          }
          let tt, pt = new (e()).URL("./node_modules/" + ze + "/package.json", ke), Et = (0, e().fileURLToPath)(pt);
          do {
            const Qe = Ue(Et.slice(0, -13));
            if (!Qe || !Qe.isDirectory()) {
              tt = Et, pt = new (e()).URL((it ? "../../../../node_modules/" : "../../../node_modules/") + ze + "/package.json", pt), Et = (0, e().fileURLToPath)(pt);
              continue;
            }
            const yt = N(Et, { base: ke, specifier: be });
            return yt.exports !== void 0 && yt.exports !== null ? _e(pt, rt, yt, ke, Ve) : rt === "." ? He(pt, yt, ke) : new (e()).URL(rt, pt);
          } while (Et.length !== tt.length);
          throw new ie(ze, (0, e().fileURLToPath)(ke), false);
        }
        function Je(be) {
          return be !== "" && (be[0] === "/" || function(ke) {
            return ke[0] === "." && (ke.length === 1 || ke[1] === "/" || ke[1] === "." && (ke.length === 2 || ke[2] === "/"));
          }(be));
        }
        function st(be, ke, Ve, ze) {
          const rt = ke.protocol, it = rt === "data:" || rt === "http:" || rt === "https:";
          let Ye;
          if (Je(be)) try {
            Ye = new (e()).URL(be, ke);
          } catch (tt) {
            const pt = new le(be, ke);
            throw pt.cause = tt, pt;
          }
          else if (rt === "file:" && be[0] === "#") Ye = $e(be, ke, Ve);
          else try {
            Ye = new (e()).URL(be);
          } catch (tt) {
            if (it && !f().builtinModules.includes(be)) {
              const pt = new le(be, ke);
              throw pt.cause = tt, pt;
            }
            Ye = Xe(be, ke, Ve);
          }
          return n()(Ye !== void 0, "expected to be defined"), Ye.protocol !== "file:" ? Ye : function(tt, pt, Et) {
            if (ye.exec(tt.pathname) !== null) throw new M(tt.pathname, 'must not include encoded "/" or "\\" characters', (0, e().fileURLToPath)(pt));
            let Qe;
            try {
              Qe = (0, e().fileURLToPath)(tt);
            } catch (vt) {
              const kt = vt;
              throw Object.defineProperty(kt, "input", { value: String(tt) }), Object.defineProperty(kt, "module", { value: String(pt) }), kt;
            }
            const yt = Ue(Qe.endsWith("/") ? Qe.slice(-1) : Qe);
            if (yt && yt.isDirectory()) {
              const vt = new Te(Qe, (0, e().fileURLToPath)(pt));
              throw vt.url = String(tt), vt;
            }
            if (!yt || !yt.isFile()) {
              const vt = new ie(Qe || tt.pathname, pt && (0, e().fileURLToPath)(pt), true);
              throw vt.url = String(tt), vt;
            }
            if (!Et) {
              const vt = (0, u().realpathSync)(Qe), { search: kt, hash: qt } = tt;
              (tt = (0, e().pathToFileURL)(vt + (Qe.endsWith(r().sep) ? "/" : ""))).search = kt, tt.hash = qt;
            }
            return tt;
          }(Ye, ke, ze);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/buffer.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0, t.default = class {
          constructor(l, n) {
            this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = true, this._indentChar = "", this._fastIndentations = [], this._position = { line: 1, column: 0 }, this._sourcePosition = { identifierName: void 0, identifierNamePos: void 0, line: void 0, column: void 0, filename: void 0 }, this._map = l, this._indentChar = n;
            for (let u = 0; u < 64; u++) this._fastIndentations.push(n.repeat(u));
            this._allocQueue();
          }
          _allocQueue() {
            const l = this._queue;
            for (let n = 0; n < 16; n++) l.push({ char: 0, repeat: 1, line: void 0, column: void 0, identifierName: void 0, identifierNamePos: void 0, filename: "" });
          }
          _pushQueue(l, n, u, c, e) {
            const r = this._queueCursor;
            r === this._queue.length && this._allocQueue();
            const f = this._queue[r];
            f.char = l, f.repeat = n, f.line = u, f.column = c, f.filename = e, this._queueCursor++;
          }
          _popQueue() {
            if (this._queueCursor === 0) throw new Error("Cannot pop from empty queue");
            return this._queue[--this._queueCursor];
          }
          get() {
            this._flush();
            const l = this._map, n = { code: (this._buf + this._str).trimRight(), decodedMap: l == null ? void 0 : l.getDecoded(), get __mergedMap() {
              return this.map;
            }, get map() {
              const u = l ? l.get() : null;
              return n.map = u, u;
            }, set map(u) {
              Object.defineProperty(n, "map", { value: u, writable: true });
            }, get rawMappings() {
              const u = l == null ? void 0 : l.getRawMappings();
              return n.rawMappings = u, u;
            }, set rawMappings(u) {
              Object.defineProperty(n, "rawMappings", { value: u, writable: true });
            } };
            return n;
          }
          append(l, n) {
            this._flush(), this._append(l, this._sourcePosition, n);
          }
          appendChar(l) {
            this._flush(), this._appendChar(l, 1, this._sourcePosition);
          }
          queue(l) {
            if (l === 10) for (; this._queueCursor !== 0; ) {
              const u = this._queue[this._queueCursor - 1].char;
              if (u !== 32 && u !== 9) break;
              this._queueCursor--;
            }
            const n = this._sourcePosition;
            this._pushQueue(l, 1, n.line, n.column, n.filename);
          }
          queueIndentation(l) {
            l !== 0 && this._pushQueue(-1, l, void 0, void 0, void 0);
          }
          _flush() {
            const l = this._queueCursor, n = this._queue;
            for (let u = 0; u < l; u++) {
              const c = n[u];
              this._appendChar(c.char, c.repeat, c);
            }
            this._queueCursor = 0;
          }
          _appendChar(l, n, u) {
            if (this._last = l, l === -1) {
              const c = this._fastIndentations[n];
              this._str += c !== void 0 ? c : n > 1 ? this._indentChar.repeat(n) : this._indentChar;
            } else this._str += n > 1 ? String.fromCharCode(l).repeat(n) : String.fromCharCode(l);
            l !== 10 ? (this._mark(u.line, u.column, u.identifierName, u.identifierNamePos, u.filename), this._position.column += n) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (u.identifierName = void 0, u.identifierNamePos = void 0);
          }
          _append(l, n, u) {
            const c = l.length, e = this._position;
            if (this._last = l.charCodeAt(c - 1), ++this._appendCount > 4096 ? (this._str, this._buf += this._str, this._str = l, this._appendCount = 0) : this._str += l, !u && !this._map) return void (e.column += c);
            const { column: r, identifierName: f, identifierNamePos: y, filename: S } = n;
            let T = n.line;
            f == null && y == null || !this._canMarkIdName || (n.identifierName = void 0, n.identifierNamePos = void 0);
            let d = l.indexOf(`
`), p = 0;
            for (d !== 0 && this._mark(T, r, f, y, S); d !== -1; ) e.line++, e.column = 0, p = d + 1, p < c && T !== void 0 && this._mark(++T, 0, null, null, S), d = l.indexOf(`
`, p);
            e.column += c - p;
          }
          _mark(l, n, u, c, e) {
            var r;
            (r = this._map) == null || r.mark(this._position, l, n, u, c, e);
          }
          removeTrailingNewline() {
            const l = this._queueCursor;
            l !== 0 && this._queue[l - 1].char === 10 && this._queueCursor--;
          }
          removeLastSemicolon() {
            const l = this._queueCursor;
            l !== 0 && this._queue[l - 1].char === 59 && this._queueCursor--;
          }
          getLastChar() {
            const l = this._queueCursor;
            return l !== 0 ? this._queue[l - 1].char : this._last;
          }
          getNewlineCount() {
            const l = this._queueCursor;
            let n = 0;
            if (l === 0) return this._last === 10 ? 1 : 0;
            for (let u = l - 1; u >= 0 && this._queue[u].char === 10; u--) n++;
            return n === l && this._last === 10 ? n + 1 : n;
          }
          endsWithCharAndNewline() {
            const l = this._queue, n = this._queueCursor;
            if (n !== 0) return l[n - 1].char !== 10 ? void 0 : n > 1 ? l[n - 2].char : this._last;
          }
          hasContent() {
            return this._queueCursor !== 0 || !!this._last;
          }
          exactSource(l, n) {
            if (!this._map) return void n();
            this.source("start", l);
            const u = l.identifierName, c = this._sourcePosition;
            u && (this._canMarkIdName = false, c.identifierName = u), n(), u && (this._canMarkIdName = true, c.identifierName = void 0, c.identifierNamePos = void 0), this.source("end", l);
          }
          source(l, n) {
            this._map && this._normalizePosition(l, n, 0);
          }
          sourceWithOffset(l, n, u) {
            this._map && this._normalizePosition(l, n, u);
          }
          _normalizePosition(l, n, u) {
            const c = n[l], e = this._sourcePosition;
            c && (e.line = c.line, e.column = Math.max(c.column + u, 0), e.filename = n.filename);
          }
          getCurrentColumn() {
            const l = this._queue, n = this._queueCursor;
            let u = -1, c = 0;
            for (let e = 0; e < n; e++) {
              const r = l[e];
              r.char === 10 && (u = c), c += r.repeat;
            }
            return u === -1 ? this._position.column + c : c - 1 - u;
          }
          getCurrentLine() {
            let l = 0;
            const n = this._queue;
            for (let u = 0; u < this._queueCursor; u++) n[u].char === 10 && l++;
            return this._position.line + l;
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/base.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.BlockStatement = function(u) {
          var c;
          this.tokenChar(123);
          const e = this.enterDelimited(), r = (c = u.directives) == null ? void 0 : c.length;
          if (r) {
            var f;
            const y = u.body.length ? 2 : 1;
            this.printSequence(u.directives, true, y), (f = u.directives[r - 1].trailingComments) != null && f.length || this.newline(y);
          }
          this.printSequence(u.body, true), e(), this.rightBrace(u);
        }, t.Directive = function(u) {
          this.print(u.value), this.semicolon();
        }, t.DirectiveLiteral = function(u) {
          const c = this.getPossibleRaw(u);
          if (!this.format.minified && c !== void 0) return void this.token(c);
          const { value: e } = u;
          if (n.test(e)) {
            if (l.test(e)) throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
            this.token(`'${e}'`);
          } else this.token(`"${e}"`);
        }, t.File = function(u) {
          u.program && this.print(u.program.interpreter), this.print(u.program);
        }, t.InterpreterDirective = function(u) {
          this.token(`#!${u.value}`), this.newline(1, true);
        }, t.Placeholder = function(u) {
          this.token("%%"), this.print(u.name), this.token("%%"), u.expectedNode === "Statement" && this.semicolon();
        }, t.Program = function(u) {
          var c;
          this.noIndentInnerCommentsHere(), this.printInnerComments();
          const e = (c = u.directives) == null ? void 0 : c.length;
          if (e) {
            var r;
            const f = u.body.length ? 2 : 1;
            this.printSequence(u.directives, void 0, f), (r = u.directives[e - 1].trailingComments) != null && r.length || this.newline(f);
          }
          this.printSequence(u.body);
        };
        const l = /(?:^|[^\\])(?:\\\\)*'/, n = /(?:^|[^\\])(?:\\\\)*"/;
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/classes.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.ClassAccessorProperty = function(e) {
          var r;
          this.printJoin(e.decorators);
          const f = (r = e.key.loc) == null || (r = r.end) == null ? void 0 : r.line;
          f && this.catchUp(f), this.tsPrintClassMemberModifiers(e), this.word("accessor", true), this.space(), e.computed ? (this.tokenChar(91), this.print(e.key), this.tokenChar(93)) : (this._variance(e), this.print(e.key)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
        }, t.ClassBody = function(e) {
          if (this.tokenChar(123), e.body.length === 0) this.tokenChar(125);
          else {
            this.newline();
            const r = function(y, S) {
              if (!y.tokenMap || S.start == null || S.end == null) return null;
              const T = y.tokenMap.getIndexes(S);
              if (!T) return null;
              let d = 1, p = 0, h = 0;
              const m = () => {
                for (; h < S.body.length && S.body[h].start == null; ) h++;
              };
              return m(), (E) => {
                h <= E && (h = E + 1, m());
                const _ = h === S.body.length ? S.end : S.body[h].start;
                let C;
                for (; d < T.length && y.tokenMap.matchesOriginal(C = y._tokens[T[d]], ";") && C.start < _; ) y.token(";", void 0, p++), d++;
              };
            }(this, e);
            r == null ? void 0 : r(-1);
            const f = this.enterDelimited();
            this.printJoin(e.body, true, true, r, true), f(), this.endsWith(10) || this.newline(), this.rightBrace(e);
          }
        }, t.ClassExpression = t.ClassDeclaration = function(e, r) {
          (u(r) || c(r)) && this._shouldPrintDecoratorsBeforeExport(r) || this.printJoin(e.decorators), e.declare && (this.word("declare"), this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id)), this.print(e.typeParameters), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass), this.print(e.superTypeParameters)), e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements)), this.space(), this.print(e.body);
        }, t.ClassMethod = function(e) {
          this._classMethodHead(e), this.space(), this.print(e.body);
        }, t.ClassPrivateMethod = function(e) {
          this._classMethodHead(e), this.space(), this.print(e.body);
        }, t.ClassPrivateProperty = function(e) {
          this.printJoin(e.decorators), e.static && (this.word("static"), this.space()), this.print(e.key), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
        }, t.ClassProperty = function(e) {
          if (this.printJoin(e.decorators), !e.static && !this.format.preserveFormat) {
            var r;
            const f = (r = e.key.loc) == null || (r = r.end) == null ? void 0 : r.line;
            f && this.catchUp(f);
          }
          this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key), this.tokenChar(93)) : (this._variance(e), this.print(e.key)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
        }, t.StaticBlock = function(e) {
          this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, true), this.rightBrace(e));
        }, t._classMethodHead = function(e) {
          if (this.printJoin(e.decorators), !this.format.preserveFormat) {
            var r;
            const f = (r = e.key.loc) == null || (r = r.end) == null ? void 0 : r.line;
            f && this.catchUp(f);
          }
          this.tsPrintClassMemberModifiers(e), this._methodHead(e);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { isExportDefaultDeclaration: u, isExportNamedDeclaration: c } = n;
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/expressions.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.LogicalExpression = t.BinaryExpression = t.AssignmentExpression = function(S) {
          this.print(S.left), this.space(), S.operator === "in" || S.operator === "instanceof" ? this.word(S.operator) : (this.token(S.operator), this._endsWithDiv = S.operator === "/"), this.space(), this.print(S.right);
        }, t.AssignmentPattern = function(S) {
          this.print(S.left), (S.left.type === "Identifier" || y(S.left)) && (S.left.optional && this.tokenChar(63), this.print(S.left.typeAnnotation)), this.space(), this.tokenChar(61), this.space(), this.print(S.right);
        }, t.AwaitExpression = function(S) {
          this.word("await"), S.argument && (this.space(), this.printTerminatorless(S.argument));
        }, t.BindExpression = function(S) {
          this.print(S.object), this.token("::"), this.print(S.callee);
        }, t.CallExpression = function(S) {
          this.print(S.callee), this.print(S.typeArguments), this.print(S.typeParameters), this.tokenChar(40);
          const T = this.enterDelimited();
          this.printList(S.arguments, this.shouldPrintTrailingComma(")")), T(), this.rightParens(S);
        }, t.ConditionalExpression = function(S) {
          this.print(S.test), this.space(), this.tokenChar(63), this.space(), this.print(S.consequent), this.space(), this.tokenChar(58), this.space(), this.print(S.alternate);
        }, t.Decorator = function(S) {
          this.tokenChar(64), this.print(S.expression), this.newline();
        }, t.DoExpression = function(S) {
          S.async && (this.word("async", true), this.space()), this.word("do"), this.space(), this.print(S.body);
        }, t.EmptyStatement = function() {
          this.semicolon(true);
        }, t.ExpressionStatement = function(S) {
          this.tokenContext |= u.TokenContext.expressionStatement, this.print(S.expression), this.semicolon();
        }, t.Import = function() {
          this.word("import");
        }, t.MemberExpression = function(S) {
          if (this.print(S.object), !S.computed && r(S.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
          let T = S.computed;
          if (e(S.property) && typeof S.property.value == "number" && (T = true), T) {
            const d = this.enterDelimited();
            this.tokenChar(91), this.print(S.property), this.tokenChar(93), d();
          } else this.tokenChar(46), this.print(S.property);
        }, t.MetaProperty = function(S) {
          this.print(S.meta), this.tokenChar(46), this.print(S.property);
        }, t.ModuleExpression = function(S) {
          this.word("module", true), this.space(), this.tokenChar(123), this.indent();
          const { body: T } = S;
          (T.body.length || T.directives.length) && this.newline(), this.print(T), this.dedent(), this.rightBrace(S);
        }, t.NewExpression = function(S, T) {
          if (this.word("new"), this.space(), this.print(S.callee), this.format.minified && S.arguments.length === 0 && !S.optional && !c(T, { callee: S }) && !r(T) && !f(T) || (this.print(S.typeArguments), this.print(S.typeParameters), S.optional && this.token("?."), S.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(S, ")"))) return;
          this.tokenChar(40);
          const d = this.enterDelimited();
          this.printList(S.arguments, this.shouldPrintTrailingComma(")")), d(), this.rightParens(S);
        }, t.OptionalCallExpression = function(S) {
          this.print(S.callee), this.print(S.typeParameters), S.optional && this.token("?."), this.print(S.typeArguments), this.tokenChar(40);
          const T = this.enterDelimited();
          this.printList(S.arguments), T(), this.rightParens(S);
        }, t.OptionalMemberExpression = function(S) {
          let { computed: T } = S;
          const { optional: d, property: p } = S;
          if (this.print(S.object), !T && r(p)) throw new TypeError("Got a MemberExpression for MemberExpression property");
          e(p) && typeof p.value == "number" && (T = true), d && this.token("?."), T ? (this.tokenChar(91), this.print(p), this.tokenChar(93)) : (d || this.tokenChar(46), this.print(p));
        }, t.ParenthesizedExpression = function(S) {
          this.tokenChar(40);
          const T = this.enterDelimited();
          this.print(S.expression), T(), this.rightParens(S);
        }, t.PrivateName = function(S) {
          this.tokenChar(35), this.print(S.id);
        }, t.SequenceExpression = function(S) {
          this.printList(S.expressions);
        }, t.Super = function() {
          this.word("super");
        }, t.ThisExpression = function() {
          this.word("this");
        }, t.UnaryExpression = function(S) {
          const { operator: T } = S;
          T === "void" || T === "delete" || T === "typeof" || T === "throw" ? (this.word(T), this.space()) : this.token(T), this.print(S.argument);
        }, t.UpdateExpression = function(S) {
          S.prefix ? (this.token(S.operator), this.print(S.argument)) : (this.print(S.argument, true), this.token(S.operator));
        }, t.V8IntrinsicIdentifier = function(S) {
          this.tokenChar(37), this.word(S.name);
        }, t.YieldExpression = function(S) {
          this.word("yield", true), S.delegate ? (this.tokenChar(42), S.argument && (this.space(), this.print(S.argument))) : S.argument && (this.space(), this.printTerminatorless(S.argument));
        }, t._shouldPrintDecoratorsBeforeExport = function(S) {
          return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof S.start == "number" && S.start === S.declaration.start;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js");
        const { isCallExpression: c, isLiteral: e, isMemberExpression: r, isNewExpression: f, isPattern: y } = n;
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/flow.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.AnyTypeAnnotation = function() {
          this.word("any");
        }, t.ArrayTypeAnnotation = function(m) {
          this.print(m.elementType, true), this.tokenChar(91), this.tokenChar(93);
        }, t.BooleanLiteralTypeAnnotation = function(m) {
          this.word(m.value ? "true" : "false");
        }, t.BooleanTypeAnnotation = function() {
          this.word("boolean");
        }, t.DeclareClass = function(m, E) {
          r(E) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(m);
        }, t.DeclareExportAllDeclaration = function(m) {
          this.word("declare"), this.space(), u.ExportAllDeclaration.call(this, m);
        }, t.DeclareExportDeclaration = function(m) {
          this.word("declare"), this.space(), this.word("export"), this.space(), m.default && (this.word("default"), this.space()), d.call(this, m);
        }, t.DeclareFunction = function(m, E) {
          r(E) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(m.id), this.print(m.id.typeAnnotation.typeAnnotation), m.predicate && (this.space(), this.print(m.predicate)), this.semicolon();
        }, t.DeclareInterface = function(m) {
          this.word("declare"), this.space(), this.InterfaceDeclaration(m);
        }, t.DeclareModule = function(m) {
          this.word("declare"), this.space(), this.word("module"), this.space(), this.print(m.id), this.space(), this.print(m.body);
        }, t.DeclareModuleExports = function(m) {
          this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(m.typeAnnotation);
        }, t.DeclareOpaqueType = function(m, E) {
          r(E) || (this.word("declare"), this.space()), this.OpaqueType(m);
        }, t.DeclareTypeAlias = function(m) {
          this.word("declare"), this.space(), this.TypeAlias(m);
        }, t.DeclareVariable = function(m, E) {
          r(E) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(m.id), this.print(m.id.typeAnnotation), this.semicolon();
        }, t.DeclaredPredicate = function(m) {
          this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(m.value), this.tokenChar(41);
        }, t.EmptyTypeAnnotation = function() {
          this.word("empty");
        }, t.EnumBooleanBody = function(m) {
          const { explicitType: E } = m;
          y(this, "boolean", E), S(this, m);
        }, t.EnumBooleanMember = function(m) {
          T(this, m);
        }, t.EnumDeclaration = function(m) {
          const { id: E, body: _ } = m;
          this.word("enum"), this.space(), this.print(E), this.print(_);
        }, t.EnumDefaultedMember = function(m) {
          const { id: E } = m;
          this.print(E), this.tokenChar(44);
        }, t.EnumNumberBody = function(m) {
          const { explicitType: E } = m;
          y(this, "number", E), S(this, m);
        }, t.EnumNumberMember = function(m) {
          T(this, m);
        }, t.EnumStringBody = function(m) {
          const { explicitType: E } = m;
          y(this, "string", E), S(this, m);
        }, t.EnumStringMember = function(m) {
          T(this, m);
        }, t.EnumSymbolBody = function(m) {
          y(this, "symbol", true), S(this, m);
        }, t.ExistsTypeAnnotation = function() {
          this.tokenChar(42);
        }, t.FunctionTypeAnnotation = function(m, E) {
          this.print(m.typeParameters), this.tokenChar(40), m.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(m.this.typeAnnotation), (m.params.length || m.rest) && (this.tokenChar(44), this.space())), this.printList(m.params), m.rest && (m.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(m.rest)), this.tokenChar(41);
          const _ = E == null ? void 0 : E.type;
          _ != null && (_ === "ObjectTypeCallProperty" || _ === "ObjectTypeInternalSlot" || _ === "DeclareFunction" || _ === "ObjectTypeProperty" && E.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(m.returnType);
        }, t.FunctionTypeParam = function(m) {
          this.print(m.name), m.optional && this.tokenChar(63), m.name && (this.tokenChar(58), this.space()), this.print(m.typeAnnotation);
        }, t.IndexedAccessType = function(m) {
          this.print(m.objectType, true), this.tokenChar(91), this.print(m.indexType), this.tokenChar(93);
        }, t.InferredPredicate = function() {
          this.tokenChar(37), this.word("checks");
        }, t.InterfaceDeclaration = function(m) {
          this.word("interface"), this.space(), this._interfaceish(m);
        }, t.GenericTypeAnnotation = t.ClassImplements = t.InterfaceExtends = function(m) {
          this.print(m.id), this.print(m.typeParameters, true);
        }, t.InterfaceTypeAnnotation = function(m) {
          var E;
          this.word("interface"), (E = m.extends) != null && E.length && (this.space(), this.word("extends"), this.space(), this.printList(m.extends)), this.space(), this.print(m.body);
        }, t.IntersectionTypeAnnotation = function(m) {
          this.printJoin(m.types, void 0, void 0, p);
        }, t.MixedTypeAnnotation = function() {
          this.word("mixed");
        }, t.NullLiteralTypeAnnotation = function() {
          this.word("null");
        }, t.NullableTypeAnnotation = function(m) {
          this.tokenChar(63), this.print(m.typeAnnotation);
        }, Object.defineProperty(t, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
          return e.NumericLiteral;
        } }), t.NumberTypeAnnotation = function() {
          this.word("number");
        }, t.ObjectTypeAnnotation = function(m) {
          m.exact ? this.token("{|") : this.tokenChar(123);
          const E = [...m.properties, ...m.callProperties || [], ...m.indexers || [], ...m.internalSlots || []];
          E.length && (this.newline(), this.space(), this.printJoin(E, true, true, void 0, void 0, function(_) {
            if (_ && !E[0]) return 1;
          }, () => {
            (E.length !== 1 || m.inexact) && (this.tokenChar(44), this.space());
          }), this.space()), m.inexact && (this.indent(), this.token("..."), E.length && this.newline(), this.dedent()), m.exact ? this.token("|}") : this.tokenChar(125);
        }, t.ObjectTypeCallProperty = function(m) {
          m.static && (this.word("static"), this.space()), this.print(m.value);
        }, t.ObjectTypeIndexer = function(m) {
          m.static && (this.word("static"), this.space()), this._variance(m), this.tokenChar(91), m.id && (this.print(m.id), this.tokenChar(58), this.space()), this.print(m.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(m.value);
        }, t.ObjectTypeInternalSlot = function(m) {
          m.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(m.id), this.tokenChar(93), this.tokenChar(93), m.optional && this.tokenChar(63), m.method || (this.tokenChar(58), this.space()), this.print(m.value);
        }, t.ObjectTypeProperty = function(m) {
          m.proto && (this.word("proto"), this.space()), m.static && (this.word("static"), this.space()), m.kind !== "get" && m.kind !== "set" || (this.word(m.kind), this.space()), this._variance(m), this.print(m.key), m.optional && this.tokenChar(63), m.method || (this.tokenChar(58), this.space()), this.print(m.value);
        }, t.ObjectTypeSpreadProperty = function(m) {
          this.token("..."), this.print(m.argument);
        }, t.OpaqueType = function(m) {
          this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(m.id), this.print(m.typeParameters), m.supertype && (this.tokenChar(58), this.space(), this.print(m.supertype)), m.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(m.impltype)), this.semicolon();
        }, t.OptionalIndexedAccessType = function(m) {
          this.print(m.objectType), m.optional && this.token("?."), this.tokenChar(91), this.print(m.indexType), this.tokenChar(93);
        }, t.QualifiedTypeIdentifier = function(m) {
          this.print(m.qualification), this.tokenChar(46), this.print(m.id);
        }, Object.defineProperty(t, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
          return e.StringLiteral;
        } }), t.StringTypeAnnotation = function() {
          this.word("string");
        }, t.SymbolTypeAnnotation = function() {
          this.word("symbol");
        }, t.ThisTypeAnnotation = function() {
          this.word("this");
        }, t.TupleTypeAnnotation = function(m) {
          this.tokenChar(91), this.printList(m.types), this.tokenChar(93);
        }, t.TypeAlias = function(m) {
          this.word("type"), this.space(), this.print(m.id), this.print(m.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(m.right), this.semicolon();
        }, t.TypeAnnotation = function(m, E) {
          this.tokenChar(58), this.space(), E.type === "ArrowFunctionExpression" ? this.tokenContext |= c.TokenContext.arrowFlowReturnType : m.optional && this.tokenChar(63), this.print(m.typeAnnotation);
        }, t.TypeCastExpression = function(m) {
          this.tokenChar(40), this.print(m.expression), this.print(m.typeAnnotation), this.tokenChar(41);
        }, t.TypeParameter = function(m) {
          this._variance(m), this.word(m.name), m.bound && this.print(m.bound), m.default && (this.space(), this.tokenChar(61), this.space(), this.print(m.default));
        }, t.TypeParameterDeclaration = t.TypeParameterInstantiation = function(m) {
          this.tokenChar(60), this.printList(m.params), this.tokenChar(62);
        }, t.TypeofTypeAnnotation = function(m) {
          this.word("typeof"), this.space(), this.print(m.argument);
        }, t.UnionTypeAnnotation = function(m) {
          this.printJoin(m.types, void 0, void 0, h);
        }, t.Variance = function(m) {
          m.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
        }, t.VoidTypeAnnotation = function() {
          this.word("void");
        }, t._interfaceish = function(m) {
          var E;
          if (this.print(m.id), this.print(m.typeParameters), (E = m.extends) != null && E.length && (this.space(), this.word("extends"), this.space(), this.printList(m.extends)), m.type === "DeclareClass") {
            var _, C;
            (_ = m.mixins) != null && _.length && (this.space(), this.word("mixins"), this.space(), this.printList(m.mixins)), (C = m.implements) != null && C.length && (this.space(), this.word("implements"), this.space(), this.printList(m.implements));
          }
          this.space(), this.print(m.body);
        }, t._variance = function(m) {
          var E;
          const _ = (E = m.variance) == null ? void 0 : E.kind;
          _ != null && (_ === "plus" ? this.tokenChar(43) : _ === "minus" && this.tokenChar(45));
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/modules.js"), c = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js"), e = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/types.js");
        const { isDeclareExportDeclaration: r, isStatement: f } = n;
        function y(m, E, _) {
          _ && (m.space(), m.word("of"), m.space(), m.word(E)), m.space();
        }
        function S(m, E) {
          const { members: _ } = E;
          m.token("{"), m.indent(), m.newline();
          for (const C of _) m.print(C), m.newline();
          E.hasUnknownMembers && (m.token("..."), m.newline()), m.dedent(), m.token("}");
        }
        function T(m, E) {
          m.print(E.id), m.space(), m.token("="), m.space(), m.print(E.init), m.token(",");
        }
        function d(m) {
          if (m.declaration) {
            const E = m.declaration;
            this.print(E), f(E) || this.semicolon();
          } else this.tokenChar(123), m.specifiers.length && (this.space(), this.printList(m.specifiers), this.space()), this.tokenChar(125), m.source && (this.space(), this.word("from"), this.space(), this.print(m.source)), this.semicolon();
        }
        function p(m) {
          this.space(), this.token("&", false, m), this.space();
        }
        function h(m) {
          this.space(), this.token("|", false, m), this.space();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true });
        var n = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/template-literals.js");
        Object.keys(n).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === n[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return n[h];
          } }));
        });
        var u = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/expressions.js");
        Object.keys(u).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === u[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return u[h];
          } }));
        });
        var c = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/statements.js");
        Object.keys(c).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === c[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return c[h];
          } }));
        });
        var e = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/classes.js");
        Object.keys(e).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === e[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return e[h];
          } }));
        });
        var r = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/methods.js");
        Object.keys(r).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === r[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return r[h];
          } }));
        });
        var f = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/modules.js");
        Object.keys(f).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === f[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return f[h];
          } }));
        });
        var y = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/types.js");
        Object.keys(y).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === y[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return y[h];
          } }));
        });
        var S = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/flow.js");
        Object.keys(S).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === S[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return S[h];
          } }));
        });
        var T = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/base.js");
        Object.keys(T).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === T[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return T[h];
          } }));
        });
        var d = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/jsx.js");
        Object.keys(d).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === d[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return d[h];
          } }));
        });
        var p = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/typescript.js");
        Object.keys(p).forEach(function(h) {
          h !== "default" && h !== "__esModule" && (h in t && t[h] === p[h] || Object.defineProperty(t, h, { enumerable: true, get: function() {
            return p[h];
          } }));
        });
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/jsx.js": (P, t) => {
        function l() {
          this.space();
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.JSXAttribute = function(n) {
          this.print(n.name), n.value && (this.tokenChar(61), this.print(n.value));
        }, t.JSXClosingElement = function(n) {
          this.tokenChar(60), this.tokenChar(47), this.print(n.name), this.tokenChar(62);
        }, t.JSXClosingFragment = function() {
          this.token("</"), this.tokenChar(62);
        }, t.JSXElement = function(n) {
          const u = n.openingElement;
          if (this.print(u), !u.selfClosing) {
            this.indent();
            for (const c of n.children) this.print(c);
            this.dedent(), this.print(n.closingElement);
          }
        }, t.JSXEmptyExpression = function() {
          this.printInnerComments();
        }, t.JSXExpressionContainer = function(n) {
          this.tokenChar(123), this.print(n.expression), this.rightBrace(n);
        }, t.JSXFragment = function(n) {
          this.print(n.openingFragment), this.indent();
          for (const u of n.children) this.print(u);
          this.dedent(), this.print(n.closingFragment);
        }, t.JSXIdentifier = function(n) {
          this.word(n.name);
        }, t.JSXMemberExpression = function(n) {
          this.print(n.object), this.tokenChar(46), this.print(n.property);
        }, t.JSXNamespacedName = function(n) {
          this.print(n.namespace), this.tokenChar(58), this.print(n.name);
        }, t.JSXOpeningElement = function(n) {
          this.tokenChar(60), this.print(n.name), this.print(n.typeParameters), n.attributes.length > 0 && (this.space(), this.printJoin(n.attributes, void 0, void 0, l)), n.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(62);
        }, t.JSXOpeningFragment = function() {
          this.tokenChar(60), this.tokenChar(62);
        }, t.JSXSpreadAttribute = function(n) {
          this.tokenChar(123), this.token("..."), this.print(n.argument), this.rightBrace(n);
        }, t.JSXSpreadChild = function(n) {
          this.tokenChar(123), this.token("..."), this.print(n.expression), this.rightBrace(n);
        }, t.JSXText = function(n) {
          const u = this.getPossibleRaw(n);
          u !== void 0 ? this.token(u, true) : this.token(n.value, true);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/methods.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.ArrowFunctionExpression = function(r, f) {
          r.async && (this.word("async", true), this.space()), this._shouldPrintArrowParamsParens(r) ? this._params(r, void 0, f) : this.print(r.params[0], true), this._predicate(r, true), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= u.TokenContext.arrowBody, this.print(r.body);
        }, t.FunctionDeclaration = t.FunctionExpression = function(r, f) {
          this._functionHead(r, f), this.space(), this.print(r.body);
        }, t._functionHead = function(r, f) {
          r.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = false), this.space()), this.word("function"), r.generator && (this.format.preserveFormat || (this._endsWithInnerRaw = false), this.tokenChar(42)), this.space(), r.id && this.print(r.id), this._params(r, r.id, f), r.type !== "TSDeclareFunction" && this._predicate(r);
        }, t._methodHead = function(r) {
          const f = r.kind, y = r.key;
          f !== "get" && f !== "set" || (this.word(f), this.space()), r.async && (this.word("async", true), this.space()), f !== "method" && f !== "init" || r.generator && this.tokenChar(42), r.computed ? (this.tokenChar(91), this.print(y), this.tokenChar(93)) : this.print(y), r.optional && this.tokenChar(63), this._params(r, r.computed && r.key.type !== "StringLiteral" ? void 0 : r.key, void 0);
        }, t._param = function(r) {
          this.printJoin(r.decorators), this.print(r), r.optional && this.tokenChar(63), this.print(r.typeAnnotation);
        }, t._parameters = function(r, f) {
          const y = this.enterDelimited(), S = this.shouldPrintTrailingComma(f), T = r.length;
          for (let d = 0; d < T; d++) this._param(r[d]), (S || d < T - 1) && (this.token(",", null, d), this.space());
          this.token(f), y();
        }, t._params = function(r, f, y) {
          this.print(r.typeParameters);
          const S = e.call(this, f, y);
          S && this.sourceIdentifierName(S.name, S.pos), this.tokenChar(40), this._parameters(r.params, ")");
          const T = r.type === "ArrowFunctionExpression";
          this.print(r.returnType, T), this._noLineTerminator = T;
        }, t._predicate = function(r, f) {
          r.predicate && (r.returnType || this.tokenChar(58), this.space(), this.print(r.predicate, f));
        }, t._shouldPrintArrowParamsParens = function(r) {
          var f, y;
          if (r.params.length !== 1 || r.typeParameters || r.returnType || r.predicate) return true;
          const S = r.params[0];
          if (!c(S) || S.typeAnnotation || S.optional || (f = S.leadingComments) != null && f.length || (y = S.trailingComments) != null && y.length) return true;
          if (this.tokenMap) {
            if (r.loc == null || this.tokenMap.findMatching(r, "(") !== null) return true;
            const T = this.tokenMap.findMatching(r, "=>");
            return (T == null ? void 0 : T.loc) == null || T.loc.start.line !== r.loc.start.line;
          }
          return !!this.format.retainLines;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js");
        const { isIdentifier: c } = n;
        function e(r, f) {
          let y, S = r;
          if (!S && f) {
            const m = f.type;
            m === "VariableDeclarator" ? S = f.id : m === "AssignmentExpression" || m === "AssignmentPattern" ? S = f.left : m === "ObjectProperty" || m === "ClassProperty" ? f.computed && f.key.type !== "StringLiteral" || (S = f.key) : m !== "ClassPrivateProperty" && m !== "ClassAccessorProperty" || (S = f.key);
          }
          if (S) {
            var T, d;
            if (S.type === "Identifier") y = { pos: (T = S.loc) == null ? void 0 : T.start, name: ((d = S.loc) == null ? void 0 : d.identifierName) || S.name };
            else if (S.type === "PrivateName") {
              var p;
              y = { pos: (p = S.loc) == null ? void 0 : p.start, name: "#" + S.id.name };
            } else if (S.type === "StringLiteral") {
              var h;
              y = { pos: (h = S.loc) == null ? void 0 : h.start, name: S.value };
            }
            return y;
          }
        }
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/modules.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.ExportAllDeclaration = function(p) {
          var h, m;
          this.word("export"), this.space(), p.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), (h = p.attributes) != null && h.length || (m = p.assertions) != null && m.length ? (this.print(p.source, true), this.space(), this._printAttributes(p, false)) : this.print(p.source), this.semicolon();
        }, t.ExportDefaultDeclaration = function(p) {
          d(this, p), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |= u.TokenContext.exportDefault;
          const h = p.declaration;
          this.print(h), S(h) || this.semicolon();
        }, t.ExportDefaultSpecifier = function(p) {
          this.print(p.exported);
        }, t.ExportNamedDeclaration = function(p) {
          if (d(this, p), this.word("export"), this.space(), p.declaration) {
            const E = p.declaration;
            this.print(E), S(E) || this.semicolon();
          } else {
            p.exportKind === "type" && (this.word("type"), this.space());
            const E = p.specifiers.slice(0);
            let _ = false;
            for (; ; ) {
              const w = E[0];
              if (!e(w) && !r(w)) break;
              _ = true, this.print(E.shift()), E.length && (this.tokenChar(44), this.space());
            }
            let C = false;
            var h, m;
            (E.length || !E.length && !_) && (C = true, this.tokenChar(123), E.length && (this.space(), this.printList(E, this.shouldPrintTrailingComma("}")), this.space()), this.tokenChar(125)), p.source && (this.space(), this.word("from"), this.space(), (h = p.attributes) != null && h.length || (m = p.assertions) != null && m.length ? (this.print(p.source, true), this.space(), this._printAttributes(p, C)) : this.print(p.source)), this.semicolon();
          }
        }, t.ExportNamespaceSpecifier = function(p) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(p.exported);
        }, t.ExportSpecifier = function(p) {
          p.exportKind === "type" && (this.word("type"), this.space()), this.print(p.local), p.exported && p.local.name !== p.exported.name && (this.space(), this.word("as"), this.space(), this.print(p.exported));
        }, t.ImportAttribute = function(p) {
          this.print(p.key), this.tokenChar(58), this.space(), this.print(p.value);
        }, t.ImportDeclaration = function(p) {
          var h, m;
          this.word("import"), this.space();
          const E = p.importKind === "type" || p.importKind === "typeof";
          E ? (this.noIndentInnerCommentsHere(), this.word(p.importKind), this.space()) : p.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : p.phase && (this.noIndentInnerCommentsHere(), this.word(p.phase), this.space());
          const _ = p.specifiers.slice(0), C = !!_.length;
          for (; C; ) {
            const I = _[0];
            if (!f(I) && !y(I)) break;
            this.print(_.shift()), _.length && (this.tokenChar(44), this.space());
          }
          let w = false;
          _.length ? (w = true, this.tokenChar(123), this.space(), this.printList(_, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(125)) : E && !C && (w = true, this.tokenChar(123), this.tokenChar(125)), (C || E) && (this.space(), this.word("from"), this.space()), (h = p.attributes) != null && h.length || (m = p.assertions) != null && m.length ? (this.print(p.source, true), this.space(), this._printAttributes(p, w)) : this.print(p.source), this.semicolon();
        }, t.ImportDefaultSpecifier = function(p) {
          this.print(p.local);
        }, t.ImportExpression = function(p) {
          this.word("import"), p.phase && (this.tokenChar(46), this.word(p.phase)), this.tokenChar(40), this.print(p.source), p.options != null && (this.tokenChar(44), this.space(), this.print(p.options)), this.tokenChar(41);
        }, t.ImportNamespaceSpecifier = function(p) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(p.local);
        }, t.ImportSpecifier = function(p) {
          p.importKind !== "type" && p.importKind !== "typeof" || (this.word(p.importKind), this.space()), this.print(p.imported), p.local && p.local.name !== p.imported.name && (this.space(), this.word("as"), this.space(), this.print(p.local));
        }, t._printAttributes = function(p, h) {
          const { importAttributesKeyword: m } = this.format, { attributes: E, assertions: _ } = p;
          !E || m || T || (T = true, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
          const C = m === "assert" || !m && _;
          if (this.word(C ? "assert" : "with"), this.space(), !C && m !== "with") return void this.printList(E || _);
          const w = h ? 1 : 0;
          this.token("{", null, w), this.space(), this.printList(E || _, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", null, w);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js");
        const { isClassDeclaration: c, isExportDefaultSpecifier: e, isExportNamespaceSpecifier: r, isImportDefaultSpecifier: f, isImportNamespaceSpecifier: y, isStatement: S } = n;
        let T = false;
        function d(p, h) {
          c(h.declaration) && p._shouldPrintDecoratorsBeforeExport(h) && p.printJoin(h.declaration.decorators);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/statements.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.BreakStatement = function(d) {
          this.word("break"), T(this, d.label);
        }, t.CatchClause = function(d) {
          this.word("catch"), this.space(), d.param && (this.tokenChar(40), this.print(d.param), this.print(d.param.typeAnnotation), this.tokenChar(41), this.space()), this.print(d.body);
        }, t.ContinueStatement = function(d) {
          this.word("continue"), T(this, d.label);
        }, t.DebuggerStatement = function() {
          this.word("debugger"), this.semicolon();
        }, t.DoWhileStatement = function(d) {
          this.word("do"), this.space(), this.print(d.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(d.test), this.tokenChar(41), this.semicolon();
        }, t.ForOfStatement = t.ForInStatement = void 0, t.ForStatement = function(d) {
          this.word("for"), this.space(), this.tokenChar(40);
          {
            const p = this.enterForStatementInit();
            this.tokenContext |= u.TokenContext.forHead, this.print(d.init), p();
          }
          this.tokenChar(59), d.test && (this.space(), this.print(d.test)), this.token(";", false, 1), d.update && (this.space(), this.print(d.update)), this.tokenChar(41), this.printBlock(d);
        }, t.IfStatement = function(d) {
          this.word("if"), this.space(), this.tokenChar(40), this.print(d.test), this.tokenChar(41), this.space();
          const p = d.alternate && r(y(d.consequent));
          p && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(d.consequent), p && (this.dedent(), this.newline(), this.tokenChar(125)), d.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(d.alternate));
        }, t.LabeledStatement = function(d) {
          this.print(d.label), this.tokenChar(58), this.space(), this.print(d.body);
        }, t.ReturnStatement = function(d) {
          this.word("return"), T(this, d.argument);
        }, t.SwitchCase = function(d) {
          d.test ? (this.word("case"), this.space(), this.print(d.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), d.consequent.length && (this.newline(), this.printSequence(d.consequent, true));
        }, t.SwitchStatement = function(d) {
          this.word("switch"), this.space(), this.tokenChar(40), this.print(d.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(d.cases, true, void 0, function(p, h) {
            if (!p && d.cases[d.cases.length - 1] === h) return -1;
          }), this.rightBrace(d);
        }, t.ThrowStatement = function(d) {
          this.word("throw"), T(this, d.argument);
        }, t.TryStatement = function(d) {
          this.word("try"), this.space(), this.print(d.block), this.space(), d.handlers ? this.print(d.handlers[0]) : this.print(d.handler), d.finalizer && (this.space(), this.word("finally"), this.space(), this.print(d.finalizer));
        }, t.VariableDeclaration = function(d, p) {
          d.declare && (this.word("declare"), this.space());
          const { kind: h } = d;
          h === "await using" ? (this.word("await"), this.space(), this.word("using", true)) : this.word(h, h === "using"), this.space();
          let m = false;
          if (!c(p)) for (const E of d.declarations) E.init && (m = true);
          if (this.printList(d.declarations, void 0, void 0, d.declarations.length > 1, m ? function(E) {
            this.token(",", false, E), this.newline();
          } : void 0), c(p)) {
            if (e(p)) {
              if (p.init === d) return;
            } else if (p.left === d) return;
          }
          this.semicolon();
        }, t.VariableDeclarator = function(d) {
          this.print(d.id), d.definite && this.tokenChar(33), this.print(d.id.typeAnnotation), d.init && (this.space(), this.tokenChar(61), this.space(), this.print(d.init));
        }, t.WhileStatement = function(d) {
          this.word("while"), this.space(), this.tokenChar(40), this.print(d.test), this.tokenChar(41), this.printBlock(d);
        }, t.WithStatement = function(d) {
          this.word("with"), this.space(), this.tokenChar(40), this.print(d.object), this.tokenChar(41), this.printBlock(d);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js");
        const { isFor: c, isForStatement: e, isIfStatement: r, isStatement: f } = n;
        function y(d) {
          const { body: p } = d;
          return f(p) === false ? d : y(p);
        }
        function S(d) {
          this.word("for"), this.space();
          const p = d.type === "ForOfStatement";
          p && d.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
          {
            const h = p ? null : this.enterForStatementInit();
            this.tokenContext |= p ? u.TokenContext.forOfHead : u.TokenContext.forInHead, this.print(d.left), h == null ? void 0 : h();
          }
          this.space(), this.word(p ? "of" : "in"), this.space(), this.print(d.right), this.tokenChar(41), this.printBlock(d);
        }
        t.ForInStatement = S, t.ForOfStatement = S;
        function T(d, p) {
          p && (d.space(), d.printTerminatorless(p)), d.semicolon();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/template-literals.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.TaggedTemplateExpression = function(l) {
          this.print(l.tag), this.print(l.typeParameters), this.print(l.quasi);
        }, t.TemplateElement = function() {
          throw new Error("TemplateElement printing is handled in TemplateLiteral");
        }, t.TemplateLiteral = function(l) {
          const n = l.quasis;
          let u = "`";
          for (let c = 0; c < n.length; c++) if (u += n[c].value.raw, c + 1 < n.length && (this.token(u + "${", true), this.print(l.expressions[c]), u = "}", this.tokenMap)) {
            const e = this.tokenMap.findMatching(l, "}", c);
            e && this._catchUpTo(e.loc.start);
          }
          this.token(u + "`", true);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/types.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.ArgumentPlaceholder = function() {
          this.tokenChar(63);
        }, t.ArrayPattern = t.ArrayExpression = function(S) {
          const T = S.elements, d = T.length;
          this.tokenChar(91);
          const p = this.enterDelimited();
          for (let h = 0; h < T.length; h++) {
            const m = T[h];
            m ? (h > 0 && this.space(), this.print(m), (h < d - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", false, h)) : this.token(",", false, h);
          }
          p(), this.tokenChar(93);
        }, t.BigIntLiteral = function(S) {
          const T = this.getPossibleRaw(S);
          if (!this.format.minified && T !== void 0) return void this.word(T);
          this.word(S.value + "n");
        }, t.BooleanLiteral = function(S) {
          this.word(S.value ? "true" : "false");
        }, t.DecimalLiteral = function(S) {
          const T = this.getPossibleRaw(S);
          if (!this.format.minified && T !== void 0) return void this.word(T);
          this.word(S.value + "m");
        }, t.Identifier = function(S) {
          var T;
          this.sourceIdentifierName(((T = S.loc) == null ? void 0 : T.identifierName) || S.name), this.word(this.tokenMap ? this._getRawIdentifier(S) : S.name);
        }, t.NullLiteral = function() {
          this.word("null");
        }, t.NumericLiteral = function(S) {
          const T = this.getPossibleRaw(S), d = this.format.jsescOption, p = S.value, h = p + "";
          d.numbers ? this.number(u(p, d), p) : T == null ? this.number(h, p) : this.format.minified ? this.number(T.length < h.length ? T : h, p) : this.number(T, p);
        }, t.ObjectPattern = t.ObjectExpression = function(S) {
          const T = S.properties;
          if (this.tokenChar(123), T.length) {
            const d = this.enterDelimited();
            this.space(), this.printList(T, this.shouldPrintTrailingComma("}"), true, true), this.space(), d();
          }
          this.sourceWithOffset("end", S.loc, -1), this.tokenChar(125);
        }, t.ObjectMethod = function(S) {
          this.printJoin(S.decorators), this._methodHead(S), this.space(), this.print(S.body);
        }, t.ObjectProperty = function(S) {
          if (this.printJoin(S.decorators), S.computed) this.tokenChar(91), this.print(S.key), this.tokenChar(93);
          else {
            if (c(S.value) && e(S.key) && S.key.name === S.value.left.name) return void this.print(S.value);
            if (this.print(S.key), S.shorthand && e(S.key) && e(S.value) && S.key.name === S.value.name) return;
          }
          this.tokenChar(58), this.space(), this.print(S.value);
        }, t.PipelineBareFunction = function(S) {
          this.print(S.callee);
        }, t.PipelinePrimaryTopicReference = function() {
          this.tokenChar(35);
        }, t.PipelineTopicExpression = function(S) {
          this.print(S.expression);
        }, t.RecordExpression = function(S) {
          const T = S.properties;
          let d, p;
          if (this.format.recordAndTupleSyntaxType === "bar") d = "{|", p = "|}";
          else {
            if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
            d = "#{", p = "}";
          }
          this.token(d), T.length && (this.space(), this.printList(T, this.shouldPrintTrailingComma(p), true, true), this.space()), this.token(p);
        }, t.RegExpLiteral = function(S) {
          this.word(`/${S.pattern}/${S.flags}`);
        }, t.SpreadElement = t.RestElement = function(S) {
          this.token("..."), this.print(S.argument);
        }, t.StringLiteral = function(S) {
          const T = this.getPossibleRaw(S);
          if (!this.format.minified && T !== void 0) return void this.token(T);
          const d = u(S.value, this.format.jsescOption);
          this.token(d);
        }, t.TopicReference = function() {
          const { topicToken: S } = this.format;
          if (!y.has(S)) {
            const T = JSON.stringify(S), d = Array.from(y, (p) => JSON.stringify(p));
            throw new Error(`The "topicToken" generator option must be one of ${d.join(", ")} (${T} received instead).`);
          }
          this.token(S);
        }, t.TupleExpression = function(S) {
          const T = S.elements, d = T.length;
          let p, h;
          if (this.format.recordAndTupleSyntaxType === "bar") p = "[|", h = "|]";
          else {
            if (this.format.recordAndTupleSyntaxType !== "hash") throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
            p = "#[", h = "]";
          }
          this.token(p);
          for (let m = 0; m < T.length; m++) {
            const E = T[m];
            E && (m > 0 && this.space(), this.print(E), (m < d - 1 || this.shouldPrintTrailingComma(h)) && this.token(",", false, m));
          }
          this.token(h);
        }, t._getRawIdentifier = function(S) {
          if (S === r) return f;
          r = S;
          const { name: T } = S, d = this.tokenMap.find(S, (p) => p.value === T);
          return d ? (f = this._originalCode.slice(d.start, d.end), f) : f = S.name;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/jsesc@3.1.0/node_modules/jsesc/jsesc.js");
        const { isAssignmentPattern: c, isIdentifier: e } = n;
        let r = null, f = "";
        const y = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/typescript.js": (P, t) => {
        function l(r, f) {
          r.tokenMap && f.start && f.end ? r.tokenMap.endMatches(f, ",") ? r.token(",") : r.tokenMap.endMatches(f, ";") && r.semicolon() : r.semicolon();
        }
        function n(r, f, y) {
          var S;
          let T = 0;
          (S = r.tokenMap) != null && S.startMatches(f, y) && (T = 1, r.token(y)), r.printJoin(f.types, void 0, void 0, function(d) {
            this.space(), this.token(y, null, d + T), this.space();
          });
        }
        function u(r, f) {
          f !== true && r.token(f);
        }
        function c(r, f, y) {
          r.token("{");
          const S = r.enterDelimited();
          y(), S(), r.rightBrace(f);
        }
        function e(r, f, y) {
          var S;
          const T = /* @__PURE__ */ new Set();
          for (const d of y) d && T.add(d);
          (S = r.tokenMap) == null || S.find(f, (d) => {
            if (T.has(d.value)) return r.token(d.value), r.space(), T.delete(d.value), T.size === 0;
          });
          for (const d of T) r.word(d), r.space();
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.TSAnyKeyword = function() {
          this.word("any");
        }, t.TSArrayType = function(r) {
          this.print(r.elementType, true), this.tokenChar(91), this.tokenChar(93);
        }, t.TSSatisfiesExpression = t.TSAsExpression = function(r) {
          const { type: f, expression: y, typeAnnotation: S } = r;
          this.print(y, true), this.space(), this.word(f === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(S);
        }, t.TSBigIntKeyword = function() {
          this.word("bigint");
        }, t.TSBooleanKeyword = function() {
          this.word("boolean");
        }, t.TSCallSignatureDeclaration = function(r) {
          this.tsPrintSignatureDeclarationBase(r), l(this, r);
        }, t.TSInterfaceHeritage = t.TSExpressionWithTypeArguments = t.TSClassImplements = function(r) {
          this.print(r.expression), this.print(r.typeParameters);
        }, t.TSConditionalType = function(r) {
          this.print(r.checkType), this.space(), this.word("extends"), this.space(), this.print(r.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(r.trueType), this.space(), this.tokenChar(58), this.space(), this.print(r.falseType);
        }, t.TSConstructSignatureDeclaration = function(r) {
          this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(r), l(this, r);
        }, t.TSConstructorType = function(r) {
          r.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(r);
        }, t.TSDeclareFunction = function(r, f) {
          r.declare && (this.word("declare"), this.space()), this._functionHead(r, f), this.semicolon();
        }, t.TSDeclareMethod = function(r) {
          this._classMethodHead(r), this.semicolon();
        }, t.TSEnumDeclaration = function(r) {
          const { declare: f, const: y, id: S, members: T } = r;
          f && (this.word("declare"), this.space()), y && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(S), this.space(), c(this, r, () => {
            var d;
            return this.printList(T, (d = this.shouldPrintTrailingComma("}")) == null || d, true, true);
          });
        }, t.TSEnumMember = function(r) {
          const { id: f, initializer: y } = r;
          this.print(f), y && (this.space(), this.tokenChar(61), this.space(), this.print(y));
        }, t.TSExportAssignment = function(r) {
          this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(r.expression), this.semicolon();
        }, t.TSExternalModuleReference = function(r) {
          this.token("require("), this.print(r.expression), this.tokenChar(41);
        }, t.TSFunctionType = function(r) {
          this.tsPrintFunctionOrConstructorType(r);
        }, t.TSImportEqualsDeclaration = function(r) {
          const { isExport: f, id: y, moduleReference: S } = r;
          f && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(y), this.space(), this.tokenChar(61), this.space(), this.print(S), this.semicolon();
        }, t.TSImportType = function(r) {
          const { argument: f, qualifier: y, typeParameters: S } = r;
          this.word("import"), this.tokenChar(40), this.print(f), this.tokenChar(41), y && (this.tokenChar(46), this.print(y)), S && this.print(S);
        }, t.TSIndexSignature = function(r) {
          const { readonly: f, static: y } = r;
          y && (this.word("static"), this.space()), f && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(r.parameters, "]"), this.print(r.typeAnnotation), l(this, r);
        }, t.TSIndexedAccessType = function(r) {
          this.print(r.objectType, true), this.tokenChar(91), this.print(r.indexType), this.tokenChar(93);
        }, t.TSInferType = function(r) {
          this.word("infer"), this.print(r.typeParameter);
        }, t.TSInstantiationExpression = function(r) {
          this.print(r.expression), this.print(r.typeParameters);
        }, t.TSInterfaceBody = function(r) {
          c(this, r, () => this.printJoin(r.body, true, true));
        }, t.TSInterfaceDeclaration = function(r) {
          const { declare: f, id: y, typeParameters: S, extends: T, body: d } = r;
          f && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(y), this.print(S), T != null && T.length && (this.space(), this.word("extends"), this.space(), this.printList(T)), this.space(), this.print(d);
        }, t.TSIntersectionType = function(r) {
          n(this, r, "&");
        }, t.TSIntrinsicKeyword = function() {
          this.word("intrinsic");
        }, t.TSLiteralType = function(r) {
          this.print(r.literal);
        }, t.TSMappedType = function(r) {
          const { nameType: f, optional: y, readonly: S, typeAnnotation: T } = r;
          this.tokenChar(123);
          const d = this.enterDelimited();
          this.space(), S && (u(this, S), this.word("readonly"), this.space()), this.tokenChar(91), this.word(r.typeParameter.name), this.space(), this.word("in"), this.space(), this.print(r.typeParameter.constraint), f && (this.space(), this.word("as"), this.space(), this.print(f)), this.tokenChar(93), y && (u(this, y), this.tokenChar(63)), T && (this.tokenChar(58), this.space(), this.print(T)), this.space(), d(), this.tokenChar(125);
        }, t.TSMethodSignature = function(r) {
          const { kind: f } = r;
          f !== "set" && f !== "get" || (this.word(f), this.space()), this.tsPrintPropertyOrMethodName(r), this.tsPrintSignatureDeclarationBase(r), l(this, r);
        }, t.TSModuleBlock = function(r) {
          c(this, r, () => this.printSequence(r.body, true));
        }, t.TSModuleDeclaration = function(r) {
          const { declare: f, id: y, kind: S } = r;
          f && (this.word("declare"), this.space());
          {
            if (r.global || (this.word(S ?? (y.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(y), !r.body) return void this.semicolon();
            let T = r.body;
            for (; T.type === "TSModuleDeclaration"; ) this.tokenChar(46), this.print(T.id), T = T.body;
            this.space(), this.print(T);
          }
        }, t.TSNamedTupleMember = function(r) {
          this.print(r.label), r.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(r.elementType);
        }, t.TSNamespaceExportDeclaration = function(r) {
          this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(r.id), this.semicolon();
        }, t.TSNeverKeyword = function() {
          this.word("never");
        }, t.TSNonNullExpression = function(r) {
          this.print(r.expression), this.tokenChar(33);
        }, t.TSNullKeyword = function() {
          this.word("null");
        }, t.TSNumberKeyword = function() {
          this.word("number");
        }, t.TSObjectKeyword = function() {
          this.word("object");
        }, t.TSOptionalType = function(r) {
          this.print(r.typeAnnotation), this.tokenChar(63);
        }, t.TSParameterProperty = function(r) {
          r.accessibility && (this.word(r.accessibility), this.space()), r.readonly && (this.word("readonly"), this.space()), this._param(r.parameter);
        }, t.TSParenthesizedType = function(r) {
          this.tokenChar(40), this.print(r.typeAnnotation), this.tokenChar(41);
        }, t.TSPropertySignature = function(r) {
          const { readonly: f } = r;
          f && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(r), this.print(r.typeAnnotation), l(this, r);
        }, t.TSQualifiedName = function(r) {
          this.print(r.left), this.tokenChar(46), this.print(r.right);
        }, t.TSRestType = function(r) {
          this.token("..."), this.print(r.typeAnnotation);
        }, t.TSStringKeyword = function() {
          this.word("string");
        }, t.TSSymbolKeyword = function() {
          this.word("symbol");
        }, t.TSThisType = function() {
          this.word("this");
        }, t.TSTupleType = function(r) {
          this.tokenChar(91), this.printList(r.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
        }, t.TSTypeAliasDeclaration = function(r) {
          const { declare: f, id: y, typeParameters: S, typeAnnotation: T } = r;
          f && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(y), this.print(S), this.space(), this.tokenChar(61), this.space(), this.print(T), this.semicolon();
        }, t.TSTypeAnnotation = function(r, f) {
          this.token(f.type !== "TSFunctionType" && f.type !== "TSConstructorType" || f.typeAnnotation !== r ? ":" : "=>"), this.space(), r.optional && this.tokenChar(63), this.print(r.typeAnnotation);
        }, t.TSTypeAssertion = function(r) {
          const { typeAnnotation: f, expression: y } = r;
          this.tokenChar(60), this.print(f), this.tokenChar(62), this.space(), this.print(y);
        }, t.TSTypeLiteral = function(r) {
          c(this, r, () => this.printJoin(r.members, true, true));
        }, t.TSTypeOperator = function(r) {
          this.word(r.operator), this.space(), this.print(r.typeAnnotation);
        }, t.TSTypeParameter = function(r) {
          r.in && (this.word("in"), this.space()), r.out && (this.word("out"), this.space()), this.word(r.name), r.constraint && (this.space(), this.word("extends"), this.space(), this.print(r.constraint)), r.default && (this.space(), this.tokenChar(61), this.space(), this.print(r.default));
        }, t.TSTypeParameterDeclaration = t.TSTypeParameterInstantiation = function(r, f) {
          this.tokenChar(60);
          let y = f.type === "ArrowFunctionExpression" && r.params.length === 1;
          this.tokenMap && r.start != null && r.end != null && (y && (y = !!this.tokenMap.find(r, (S) => this.tokenMap.matchesOriginal(S, ","))), y || (y = this.shouldPrintTrailingComma(">"))), this.printList(r.params, y), this.tokenChar(62);
        }, t.TSTypePredicate = function(r) {
          r.asserts && (this.word("asserts"), this.space()), this.print(r.parameterName), r.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(r.typeAnnotation.typeAnnotation));
        }, t.TSTypeQuery = function(r) {
          this.word("typeof"), this.space(), this.print(r.exprName), r.typeParameters && this.print(r.typeParameters);
        }, t.TSTypeReference = function(r) {
          this.print(r.typeName, !!r.typeParameters), this.print(r.typeParameters);
        }, t.TSUndefinedKeyword = function() {
          this.word("undefined");
        }, t.TSUnionType = function(r) {
          n(this, r, "|");
        }, t.TSUnknownKeyword = function() {
          this.word("unknown");
        }, t.TSVoidKeyword = function() {
          this.word("void");
        }, t.tsPrintClassMemberModifiers = function(r) {
          const f = r.type === "ClassAccessorProperty" || r.type === "ClassProperty";
          e(this, r, [f && r.declare && "declare", r.accessibility]), r.static && (this.word("static"), this.space()), e(this, r, [r.override && "override", r.abstract && "abstract", f && r.readonly && "readonly"]);
        }, t.tsPrintFunctionOrConstructorType = function(r) {
          const { typeParameters: f } = r, y = r.parameters;
          this.print(f), this.tokenChar(40), this._parameters(y, ")"), this.space();
          const S = r.typeAnnotation;
          this.print(S);
        }, t.tsPrintPropertyOrMethodName = function(r) {
          r.computed && this.tokenChar(91), this.print(r.key), r.computed && this.tokenChar(93), r.optional && this.tokenChar(63);
        }, t.tsPrintSignatureDeclarationBase = function(r) {
          const { typeParameters: f } = r, y = r.parameters;
          this.print(f), this.tokenChar(40), this._parameters(y, ")");
          const S = r.typeAnnotation;
          this.print(S);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(e, r = {}, f) {
          const y = c(f, r, e), S = r.sourceMaps ? new n.default(r, f) : null;
          return new u.default(y, S, e.tokens, typeof f == "string" ? f : null).generate(e);
        };
        var n = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/source-map.js"), u = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/printer.js");
        function c(e, r, f) {
          if (r.experimental_preserveFormat) {
            if (typeof e != "string") throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
            if (!r.retainLines) throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
            if (r.compact && r.compact !== "auto") throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
            if (r.minified) throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
            if (r.jsescOption) throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
            if (!Array.isArray(f.tokens)) throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");
          }
          const y = { auxiliaryCommentBefore: r.auxiliaryCommentBefore, auxiliaryCommentAfter: r.auxiliaryCommentAfter, shouldPrintComment: r.shouldPrintComment, preserveFormat: r.experimental_preserveFormat, retainLines: r.retainLines, retainFunctionParens: r.retainFunctionParens, comments: r.comments == null || r.comments, compact: r.compact, minified: r.minified, concise: r.concise, indent: { adjustMultilineComment: true, style: "  " }, jsescOption: Object.assign({ quotes: "double", wrap: true, minimal: false }, r.jsescOption), topicToken: r.topicToken, importAttributesKeyword: r.importAttributesKeyword };
          var S;
          y.decoratorsBeforeExport = r.decoratorsBeforeExport, y.jsescOption.json = r.jsonCompatibleStrings, y.recordAndTupleSyntaxType = (S = r.recordAndTupleSyntaxType) != null ? S : "hash", y.minified ? (y.compact = true, y.shouldPrintComment = y.shouldPrintComment || (() => y.comments)) : y.shouldPrintComment = y.shouldPrintComment || ((h) => y.comments || h.includes("@license") || h.includes("@preserve")), y.compact === "auto" && (y.compact = typeof e == "string" && e.length > 5e5, y.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${r.filename} as it exceeds the max of 500KB.`)), (y.compact || y.preserveFormat) && (y.indent.adjustMultilineComment = false);
          const { auxiliaryCommentBefore: T, auxiliaryCommentAfter: d, shouldPrintComment: p } = y;
          return T && !p(T) && (y.auxiliaryCommentBefore = void 0), d && !p(d) && (y.auxiliaryCommentAfter = void 0), y;
        }
        t.CodeGenerator = class {
          constructor(e, r = {}, f) {
            this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e, this._format = c(f, r, e), this._map = r.sourceMaps ? new n.default(r, f) : null;
          }
          generate() {
            return new u.default(this._format, this._map).generate(this._ast);
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.TokenContext = void 0, t.isLastChild = function(I, D) {
          const j = r[I.type];
          for (let L = j.length - 1; L >= 0; L--) {
            const k = I[j[L]];
            if (k === D) return true;
            if (Array.isArray(k)) {
              let N = k.length - 1;
              for (; N >= 0 && k[N] === null; ) N--;
              return N >= 0 && k[N] === D;
            }
            if (k) return false;
          }
          return false;
        }, t.needsParens = function(I, D, j, L, k) {
          var N;
          return D ? d(D) && D.callee === I && _(I) ? true : y(D) ? !(w(I) || f(I) && w(I.callee) || p(I)) : (N = m.get(I.type)) == null ? void 0 : N(I, D, j, L, k) : false;
        }, t.needsWhitespace = C, t.needsWhitespaceAfter = function(I, D) {
          return C(I, D, 2);
        }, t.needsWhitespaceBefore = function(I, D) {
          return C(I, D, 1);
        };
        var n = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/whitespace.js"), u = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/parentheses.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS: e, VISITOR_KEYS: r, isCallExpression: f, isDecorator: y, isExpressionStatement: S, isMemberExpression: T, isNewExpression: d, isParenthesizedExpression: p } = c;
        t.TokenContext = { expressionStatement: 1, arrowBody: 2, exportDefault: 4, forHead: 8, forInHead: 16, forOfHead: 32, arrowFlowReturnType: 64 };
        function h(I) {
          const D = /* @__PURE__ */ new Map();
          function j(L, k) {
            const N = D.get(L);
            D.set(L, N ? function(F, W, X, H, U) {
              var q;
              return (q = N(F, W, X, H, U)) != null ? q : k(F, W, X, H, U);
            } : k);
          }
          for (const L of Object.keys(I)) {
            const k = e[L];
            if (k) for (const N of k) j(N, I[L]);
            else j(L, I[L]);
          }
          return D;
        }
        const m = h(u), E = h(n.nodes);
        function _(I) {
          return !!f(I) || T(I) && _(I.object);
        }
        function C(I, D, j) {
          var L;
          if (!I) return false;
          S(I) && (I = I.expression);
          const k = (L = E.get(I.type)) == null ? void 0 : L(I, D);
          return typeof k == "number" && !!(k & j);
        }
        function w(I) {
          switch (I.type) {
            case "Identifier":
              return true;
            case "MemberExpression":
              return !I.computed && I.property.type === "Identifier" && w(I.object);
            default:
              return false;
          }
        }
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/parentheses.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.AssignmentExpression = function(k, N, F) {
          return !(!I(F) || !T(k.left)) || L(k, N);
        }, t.Binary = D, t.BinaryExpression = function(k, N, F, W) {
          return k.operator === "in" && W;
        }, t.ClassExpression = function(k, N, F) {
          return !!(F & (u.TokenContext.expressionStatement | u.TokenContext.exportDefault));
        }, t.ArrowFunctionExpression = t.ConditionalExpression = L, t.DoExpression = function(k, N, F) {
          return !k.async && !!(F & u.TokenContext.expressionStatement);
        }, t.FunctionExpression = function(k, N, F) {
          return !!(F & (u.TokenContext.expressionStatement | u.TokenContext.exportDefault));
        }, t.FunctionTypeAnnotation = function(k, N, F) {
          const W = N.type;
          return W === "UnionTypeAnnotation" || W === "IntersectionTypeAnnotation" || W === "ArrayTypeAnnotation" || !!(F & u.TokenContext.arrowFlowReturnType);
        }, t.Identifier = function(k, N, F, W, X) {
          var H;
          const U = N.type;
          if ((H = k.extra) != null && H.parenthesized && U === "AssignmentExpression" && N.left === k) {
            const q = N.right.type;
            if ((q === "FunctionExpression" || q === "ClassExpression") && N.right.id == null) return true;
          }
          return X && X(k) !== k.name ? false : k.name === "let" ? !!((S(N, { object: k, computed: true }) || d(N, { object: k, computed: true, optional: false })) && F & (u.TokenContext.expressionStatement | u.TokenContext.forHead | u.TokenContext.forInHead)) || !!(F & u.TokenContext.forOfHead) : k.name === "async" && f(N, { left: k, await: false });
        }, t.LogicalExpression = function(k, N) {
          const F = N.type;
          if (_(F)) return true;
          if (F !== "LogicalExpression") return false;
          switch (k.operator) {
            case "||":
              return N.operator === "??" || N.operator === "&&";
            case "&&":
              return N.operator === "??";
            case "??":
              return N.operator !== "??";
          }
        }, t.NullableTypeAnnotation = function(k, N) {
          return c(N);
        }, t.ObjectExpression = function(k, N, F) {
          return I(F);
        }, t.OptionalIndexedAccessType = function(k, N) {
          return y(N) && N.objectType === k;
        }, t.OptionalCallExpression = t.OptionalMemberExpression = function(k, N) {
          return r(N) && N.callee === k || S(N) && N.object === k;
        }, t.SequenceExpression = function(k, N) {
          const F = N.type;
          return F === "SequenceExpression" || F === "ParenthesizedExpression" || F === "MemberExpression" && N.property === k || F === "OptionalMemberExpression" && N.property === k || F === "TemplateLiteral" ? false : F === "ClassDeclaration" ? true : F === "ForOfStatement" ? N.right === k : F === "ExportDefaultDeclaration" ? true : !h(N);
        }, t.TSSatisfiesExpression = t.TSAsExpression = function(k, N) {
          return (N.type === "AssignmentExpression" || N.type === "AssignmentPattern") && N.left === k || N.type === "BinaryExpression" && (N.operator === "|" || N.operator === "&") && k === N.left ? true : D(k, N);
        }, t.TSInferType = function(k, N) {
          const F = N.type;
          return F === "TSArrayType" || F === "TSOptionalType";
        }, t.TSInstantiationExpression = function(k, N) {
          const F = N.type;
          return (F === "CallExpression" || F === "OptionalCallExpression" || F === "NewExpression" || F === "TSInstantiationExpression") && !!N.typeParameters;
        }, t.UnaryLike = t.TSTypeAssertion = j, t.TSIntersectionType = t.TSUnionType = function(k, N) {
          const F = N.type;
          return F === "TSArrayType" || F === "TSOptionalType" || F === "TSIntersectionType" || F === "TSRestType";
        }, t.IntersectionTypeAnnotation = t.UnionTypeAnnotation = function(k, N) {
          const F = N.type;
          return F === "ArrayTypeAnnotation" || F === "NullableTypeAnnotation" || F === "IntersectionTypeAnnotation" || F === "UnionTypeAnnotation";
        }, t.UpdateExpression = function(k, N) {
          return w(k, N) || C(k, N);
        }, t.AwaitExpression = t.YieldExpression = function(k, N) {
          const F = N.type;
          return F === "BinaryExpression" || F === "LogicalExpression" || F === "UnaryExpression" || F === "SpreadElement" || w(k, N) || F === "AwaitExpression" && p(k) || F === "ConditionalExpression" && k === N.test || C(k, N) || _(F);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js");
        const { isArrayTypeAnnotation: c, isBinaryExpression: e, isCallExpression: r, isForOfStatement: f, isIndexedAccessType: y, isMemberExpression: S, isObjectPattern: T, isOptionalMemberExpression: d, isYieldExpression: p, isStatement: h } = n, m = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
        function E(k, N) {
          return N === "BinaryExpression" || N === "LogicalExpression" ? m.get(k.operator) : N === "TSAsExpression" || N === "TSSatisfiesExpression" ? m.get("in") : void 0;
        }
        function _(k) {
          return k === "TSAsExpression" || k === "TSSatisfiesExpression" || k === "TSTypeAssertion";
        }
        const C = (k, N) => {
          const F = N.type;
          return (F === "ClassDeclaration" || F === "ClassExpression") && N.superClass === k;
        }, w = (k, N) => {
          const F = N.type;
          return (F === "MemberExpression" || F === "OptionalMemberExpression") && N.object === k || (F === "CallExpression" || F === "OptionalCallExpression" || F === "NewExpression") && N.callee === k || F === "TaggedTemplateExpression" && N.tag === k || F === "TSNonNullExpression";
        };
        function I(k) {
          return !!(k & (u.TokenContext.expressionStatement | u.TokenContext.arrowBody));
        }
        function D(k, N) {
          const F = N.type;
          if (k.type === "BinaryExpression" && k.operator === "**" && F === "BinaryExpression" && N.operator === "**") return N.left === k;
          if (C(k, N) || w(k, N) || F === "UnaryExpression" || F === "SpreadElement" || F === "AwaitExpression") return true;
          const W = E(N, F);
          if (W != null) {
            const X = E(k, k.type);
            if (W === X && F === "BinaryExpression" && N.right === k || W > X) return true;
          }
        }
        function j(k, N) {
          return w(k, N) || e(N) && N.operator === "**" && N.left === k || C(k, N);
        }
        function L(k, N) {
          const F = N.type;
          return !!(F === "UnaryExpression" || F === "SpreadElement" || F === "BinaryExpression" || F === "LogicalExpression" || F === "ConditionalExpression" && N.test === k || F === "AwaitExpression" || _(F)) || j(k, N);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/whitespace.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.nodes = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS: u, isArrayExpression: c, isAssignmentExpression: e, isBinary: r, isBlockStatement: f, isCallExpression: y, isFunction: S, isIdentifier: T, isLiteral: d, isMemberExpression: p, isObjectExpression: h, isOptionalCallExpression: m, isOptionalMemberExpression: E, isStringLiteral: _ } = n;
        function C(L, k) {
          return L && (p(L) || E(L) ? (C(L.object, k), L.computed && C(L.property, k)) : r(L) || e(L) ? (C(L.left, k), C(L.right, k)) : y(L) || m(L) ? (k.hasCall = true, C(L.callee, k)) : S(L) ? k.hasFunction = true : T(L) && (k.hasHelper = k.hasHelper || L.callee && I(L.callee))), k;
        }
        function w(L) {
          return C(L, { hasCall: false, hasFunction: false, hasHelper: false });
        }
        function I(L) {
          return !!L && (p(L) ? I(L.object) || I(L.property) : T(L) ? L.name === "require" || L.name.charCodeAt(0) === 95 : y(L) ? I(L.callee) : !(!r(L) && !e(L)) && (T(L.left) && I(L.left) || I(L.right)));
        }
        function D(L) {
          return d(L) || h(L) || c(L) || T(L) || p(L);
        }
        const j = t.nodes = { AssignmentExpression(L) {
          const k = w(L.right);
          if (k.hasCall && k.hasHelper || k.hasFunction) return k.hasFunction ? 3 : 2;
        }, SwitchCase: (L, k) => (L.consequent.length || k.cases[0] === L ? 1 : 0) | (L.consequent.length || k.cases[k.cases.length - 1] !== L ? 0 : 2), LogicalExpression(L) {
          if (S(L.left) || S(L.right)) return 2;
        }, Literal(L) {
          if (_(L) && L.value === "use strict") return 2;
        }, CallExpression(L) {
          if (S(L.callee) || I(L)) return 3;
        }, OptionalCallExpression(L) {
          if (S(L.callee)) return 3;
        }, VariableDeclaration(L) {
          for (let k = 0; k < L.declarations.length; k++) {
            const N = L.declarations[k];
            let F = I(N.id) && !D(N.init);
            if (!F && N.init) {
              const W = w(N.init);
              F = I(N.init) && W.hasCall || W.hasFunction;
            }
            if (F) return 3;
          }
        }, IfStatement(L) {
          if (f(L.consequent)) return 3;
        } };
        j.ObjectProperty = j.ObjectTypeProperty = j.ObjectMethod = function(L, k) {
          if (k.properties[0] === L) return 1;
        }, j.ObjectTypeCallProperty = function(L, k) {
          var N;
          if (k.callProperties[0] === L && ((N = k.properties) == null || !N.length)) return 1;
        }, j.ObjectTypeIndexer = function(L, k) {
          var N, F;
          if (!(k.indexers[0] !== L || (N = k.properties) != null && N.length || (F = k.callProperties) != null && F.length)) return 1;
        }, j.ObjectTypeInternalSlot = function(L, k) {
          var N, F, W;
          if (!(k.internalSlots[0] !== L || (N = k.properties) != null && N.length || (F = k.callProperties) != null && F.length || (W = k.indexers) != null && W.length)) return 1;
        }, [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([L, k]) {
          [L].concat(u[L] || []).forEach(function(N) {
            const F = k ? 3 : 0;
            j[N] = () => F;
          });
        });
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/printer.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/buffer.js"), u = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/node/index.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), e = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/token-map.js"), r = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/generators/index.js");
        const { isExpression: f, isFunction: y, isStatement: S, isClassBody: T, isTSInterfaceBody: d, isTSEnumDeclaration: p } = c, h = /e/i, m = /\.0+$/, E = /[\n\r\u2028\u2029]/, _ = /[\n\r\u2028\u2029]|\*\//;
        function C(j) {
          return j.type === "CommentLine" || E.test(j.value);
        }
        const { needsParens: w } = u;
        class I {
          constructor(L, k, N, F) {
            this.inForStatementInit = false, this.tokenContext = 0, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent = 0, this._indentRepeat = 0, this._insideAux = false, this._noLineTerminator = false, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode = false, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = false, this._endsWithWord = false, this._endsWithDiv = false, this._lastCommentLine = 0, this._endsWithInnerRaw = false, this._indentInnerComments = true, this.tokenMap = null, this._boundGetRawIdentifier = this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = L, this._tokens = N, this._originalCode = F, this._indentRepeat = L.indent.style.length, this._inputMap = k == null ? void 0 : k._inputMap, this._buf = new n.default(k, L.indent.style[0]);
          }
          enterForStatementInit() {
            return this.inForStatementInit ? () => {
            } : (this.inForStatementInit = true, () => {
              this.inForStatementInit = false;
            });
          }
          enterDelimited() {
            const L = this.inForStatementInit, k = this._noLineTerminatorAfterNode;
            return L === false && k === null ? () => {
            } : (this.inForStatementInit = false, this._noLineTerminatorAfterNode = null, () => {
              this.inForStatementInit = L, this._noLineTerminatorAfterNode = k;
            });
          }
          generate(L) {
            return this.format.preserveFormat && (this.tokenMap = new e.TokenMap(L, this._tokens, this._originalCode)), this.print(L), this._maybeAddAuxComment(), this._buf.get();
          }
          indent() {
            const { format: L } = this;
            L.preserveFormat || L.compact || L.concise || this._indent++;
          }
          dedent() {
            const { format: L } = this;
            L.preserveFormat || L.compact || L.concise || this._indent--;
          }
          semicolon(L = false) {
            if (this._maybeAddAuxComment(), L) return this._appendChar(59), void (this._noLineTerminator = false);
            if (this.tokenMap) {
              const k = this._currentNode;
              if (k.start != null && k.end != null) {
                if (!this.tokenMap.endMatches(k, ";")) return void (this._printSemicolonBeforeNextNode = this._buf.getCurrentLine());
                const N = this.tokenMap.getIndexes(this._currentNode);
                this._catchUpTo(this._tokens[N[N.length - 1]].loc.start);
              }
            }
            this._queue(59), this._noLineTerminator = false;
          }
          rightBrace(L) {
            this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", L.loc, -1), this.tokenChar(125);
          }
          rightParens(L) {
            this.sourceWithOffset("end", L.loc, -1), this.tokenChar(41);
          }
          space(L = false) {
            const { format: k } = this;
            if (!k.compact && !k.preserveFormat) {
              if (L) this._space();
              else if (this._buf.hasContent()) {
                const N = this.getLastChar();
                N !== 32 && N !== 10 && this._space();
              }
            }
          }
          word(L, k = false) {
            this.tokenContext = 0, this._maybePrintInnerComments(L), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(L), (this._endsWithWord || this._endsWithDiv && L.charCodeAt(0) === 47) && this._space(), this._append(L, false), this._endsWithWord = true, this._noLineTerminator = k;
          }
          number(L, k) {
            this.word(L), this._endsWithInteger = Number.isInteger(k) && !function(N) {
              if (N.length > 2 && N.charCodeAt(0) === 48) {
                const F = N.charCodeAt(1);
                return F === 98 || F === 111 || F === 120;
              }
              return false;
            }(L) && !h.test(L) && !m.test(L) && L.charCodeAt(L.length - 1) !== 46;
          }
          token(L, k = false, N = 0) {
            this.tokenContext = 0, this._maybePrintInnerComments(L, N), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(L, N);
            const F = this.getLastChar(), W = L.charCodeAt(0);
            (F === 33 && (L === "--" || W === 61) || W === 43 && F === 43 || W === 45 && F === 45 || W === 46 && this._endsWithInteger) && this._space(), this._append(L, k), this._noLineTerminator = false;
          }
          tokenChar(L) {
            this.tokenContext = 0;
            const k = String.fromCharCode(L);
            this._maybePrintInnerComments(k), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(k);
            const N = this.getLastChar();
            (L === 43 && N === 43 || L === 45 && N === 45 || L === 46 && this._endsWithInteger) && this._space(), this._appendChar(L), this._noLineTerminator = false;
          }
          newline(L = 1, k) {
            if (!(L <= 0)) {
              if (!k) {
                if (this.format.retainLines || this.format.compact) return;
                if (this.format.concise) return void this.space();
              }
              L > 2 && (L = 2), L -= this._buf.getNewlineCount();
              for (let N = 0; N < L; N++) this._newline();
            }
          }
          endsWith(L) {
            return this.getLastChar() === L;
          }
          getLastChar() {
            return this._buf.getLastChar();
          }
          endsWithCharAndNewline() {
            return this._buf.endsWithCharAndNewline();
          }
          removeTrailingNewline() {
            this._buf.removeTrailingNewline();
          }
          exactSource(L, k) {
            L ? (this._catchUp("start", L), this._buf.exactSource(L, k)) : k();
          }
          source(L, k) {
            k && (this._catchUp(L, k), this._buf.source(L, k));
          }
          sourceWithOffset(L, k, N) {
            k && !this.format.preserveFormat && (this._catchUp(L, k), this._buf.sourceWithOffset(L, k, N));
          }
          sourceIdentifierName(L, k) {
            if (!this._buf._canMarkIdName) return;
            const N = this._buf._sourcePosition;
            N.identifierNamePos = k, N.identifierName = L;
          }
          _space() {
            this._queue(32);
          }
          _newline() {
            this._queue(10);
          }
          _catchUpToCurrentToken(L, k = 0) {
            const N = this.tokenMap.findMatching(this._currentNode, L, k);
            N && this._catchUpTo(N.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() && (this._buf.appendChar(59), this._endsWithWord = false, this._endsWithInteger = false, this._endsWithDiv = false), this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1;
          }
          _append(L, k) {
            this._maybeIndent(L.charCodeAt(0)), this._buf.append(L, k), this._endsWithWord = false, this._endsWithInteger = false, this._endsWithDiv = false;
          }
          _appendChar(L) {
            this._maybeIndent(L), this._buf.appendChar(L), this._endsWithWord = false, this._endsWithInteger = false, this._endsWithDiv = false;
          }
          _queue(L) {
            this._maybeIndent(L), this._buf.queue(L), this._endsWithWord = false, this._endsWithInteger = false;
          }
          _maybeIndent(L) {
            this._indent && L !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
          }
          _shouldIndent(L) {
            if (this._indent && L !== 10 && this.endsWith(10)) return true;
          }
          catchUp(L) {
            if (!this.format.retainLines) return;
            const k = L - this._buf.getCurrentLine();
            for (let N = 0; N < k; N++) this._newline();
          }
          _catchUp(L, k) {
            const { format: N } = this;
            if (!N.preserveFormat) return void (N.retainLines && k != null && k[L] && this.catchUp(k[L].line));
            const F = k == null ? void 0 : k[L];
            F != null && this._catchUpTo(F);
          }
          _catchUpTo({ line: L, column: k, index: N }) {
            const F = L - this._buf.getCurrentLine();
            if (F > 0 && this._noLineTerminator) return;
            for (let X = 0; X < F; X++) this._newline();
            const W = F > 0 ? k : k - this._buf.getCurrentColumn();
            if (W > 0) {
              const X = this._originalCode ? this._originalCode.slice(N - W, N).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(W);
              this._append(X, false);
            }
          }
          _getIndent() {
            return this._indentRepeat * this._indent;
          }
          printTerminatorless(L) {
            this._noLineTerminator = true, this.print(L);
          }
          print(L, k, N) {
            var F, W, X;
            if (!L) return;
            this._endsWithInnerRaw = false;
            const H = L.type, U = this.format, q = U.concise;
            L._compact && (U.concise = true);
            const ee = this[H];
            if (ee === void 0) throw new ReferenceError(`unknown node of type ${JSON.stringify(H)} with constructor ${JSON.stringify(L.constructor.name)}`);
            const re = this._currentNode;
            this._currentNode = L, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
            const Y = this._insideAux;
            this._insideAux = L.loc == null, this._maybeAddAuxComment(this._insideAux && !Y);
            const Z = (F = L.extra) == null ? void 0 : F.parenthesized;
            let G = Z && U.preserveFormat || Z && U.retainFunctionParens && H === "FunctionExpression" || w(L, re, this.tokenContext, this.inForStatementInit, U.preserveFormat ? this._boundGetRawIdentifier : void 0);
            if (!G && Z && (W = L.leadingComments) != null && W.length && L.leadingComments[0].type === "CommentBlock") switch (re == null ? void 0 : re.type) {
              case "ExpressionStatement":
              case "VariableDeclarator":
              case "AssignmentExpression":
              case "ReturnStatement":
                break;
              case "CallExpression":
              case "OptionalCallExpression":
              case "NewExpression":
                if (re.callee !== L) break;
              default:
                G = true;
            }
            let B, z, M = false;
            var K;
            !G && this._noLineTerminator && ((X = L.leadingComments) != null && X.some(C) || this.format.retainLines && L.loc && L.loc.start.line > this._buf.getCurrentLine()) && (G = true, M = true), G || (k || (k = re && this._noLineTerminatorAfterNode === re && u.isLastChild(re, L)), k && ((K = L.trailingComments) != null && K.some(C) ? f(L) && (G = true) : (B = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = L))), G && (this.tokenChar(40), M && this.indent(), this._endsWithInnerRaw = false, this.inForStatementInit && (z = true, this.inForStatementInit = false), B = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(L, re);
            const Q = H === "Program" || H === "File" ? null : L.loc;
            this.exactSource(Q, ee.bind(this, L, re)), G ? (this._printTrailingComments(L, re), M && (this.dedent(), this.newline()), this.tokenChar(41), this._noLineTerminator = k, z && (this.inForStatementInit = true)) : k && !this._noLineTerminator ? (this._noLineTerminator = true, this._printTrailingComments(L, re)) : this._printTrailingComments(L, re, N), this._currentNode = re, U.concise = q, this._insideAux = Y, B !== void 0 && (this._noLineTerminatorAfterNode = B), this._endsWithInnerRaw = false;
          }
          _maybeAddAuxComment(L) {
            L && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
          }
          _printAuxBeforeComment() {
            if (this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = true;
            const L = this.format.auxiliaryCommentBefore;
            L && this._printComment({ type: "CommentBlock", value: L }, 0);
          }
          _printAuxAfterComment() {
            if (!this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = false;
            const L = this.format.auxiliaryCommentAfter;
            L && this._printComment({ type: "CommentBlock", value: L }, 0);
          }
          getPossibleRaw(L) {
            const k = L.extra;
            if ((k == null ? void 0 : k.raw) != null && k.rawValue != null && L.value === k.rawValue) return k.raw;
          }
          printJoin(L, k, N, F, W, X, H, U) {
            if (L == null || !L.length) return;
            if (N == null && this.format.retainLines) {
              var q;
              const B = (q = L[0].loc) == null ? void 0 : q.start.line;
              B != null && B !== this._buf.getCurrentLine() && (N = true);
            }
            N && this.indent();
            const ee = { addNewlines: X, nextNodeStartLine: 0 }, re = F == null ? void 0 : F.bind(this), Y = L.length;
            for (let B = 0; B < Y; B++) {
              const z = L[B];
              var Z;
              if (z && (k && this._printNewline(B === 0, ee), this.print(z, void 0, U || 0), H == null ? void 0 : H(z, B), re != null && (B < Y - 1 ? re(B, false) : W && re(B, true)), k)) if ((Z = z.trailingComments) != null && Z.length || (this._lastCommentLine = 0), B + 1 === Y) this.newline(1);
              else {
                var G;
                const M = L[B + 1];
                ee.nextNodeStartLine = ((G = M.loc) == null ? void 0 : G.start.line) || 0, this._printNewline(true, ee);
              }
            }
            N && this.dedent();
          }
          printAndIndentOnComments(L) {
            const k = L.leadingComments && L.leadingComments.length > 0;
            k && this.indent(), this.print(L), k && this.dedent();
          }
          printBlock(L) {
            const k = L.body;
            k.type !== "EmptyStatement" && this.space(), this.print(k);
          }
          _printTrailingComments(L, k, N) {
            const { innerComments: F, trailingComments: W } = L;
            F != null && F.length && this._printComments(2, F, L, k, N), W != null && W.length && this._printComments(2, W, L, k, N);
          }
          _printLeadingComments(L, k) {
            const N = L.leadingComments;
            N != null && N.length && this._printComments(0, N, L, k);
          }
          _maybePrintInnerComments(L, k) {
            var N;
            this._endsWithInnerRaw && this.printInnerComments((N = this.tokenMap) == null ? void 0 : N.findMatching(this._currentNode, L, k)), this._endsWithInnerRaw = true, this._indentInnerComments = true;
          }
          printInnerComments(L) {
            const k = this._currentNode, N = k.innerComments;
            if (N == null || !N.length) return;
            const F = this.endsWith(32), W = this._indentInnerComments, X = this._printedComments.size;
            W && this.indent(), this._printComments(1, N, k, void 0, void 0, L), F && X !== this._printedComments.size && this.space(), W && this.dedent();
          }
          noIndentInnerCommentsHere() {
            this._indentInnerComments = false;
          }
          printSequence(L, k, N, F) {
            this.printJoin(L, true, k != null && k, void 0, void 0, F, void 0, N);
          }
          printList(L, k, N, F, W, X) {
            this.printJoin(L, N, F, W ?? D, k, void 0, X);
          }
          shouldPrintTrailingComma(L) {
            if (!this.tokenMap) return null;
            const k = this.tokenMap.findLastIndex(this._currentNode, (N) => this.tokenMap.matchesOriginal(N, L));
            return k <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[k - 1], ",");
          }
          _printNewline(L, k) {
            const N = this.format;
            if (N.retainLines || N.compact) return;
            if (N.concise) return void this.space();
            if (!L) return;
            const F = k.nextNodeStartLine, W = this._lastCommentLine;
            if (F > 0 && W > 0) {
              const X = F - W;
              if (X >= 0) return void this.newline(X || 1);
            }
            this._buf.hasContent() && this.newline(1);
          }
          _shouldPrintComment(L, k) {
            if (L.ignore || this._printedComments.has(L)) return 0;
            if (this._noLineTerminator && _.test(L.value)) return 2;
            if (k && this.tokenMap) {
              const N = this.tokenMap.find(this._currentNode, (F) => F.value === L.value);
              if (N && N.start > k.start) return 2;
            }
            return this._printedComments.add(L), this.format.shouldPrintComment(L.value) ? 1 : 0;
          }
          _printComment(L, k) {
            const N = this._noLineTerminator, F = L.type === "CommentBlock", W = F && k !== 1 && !this._noLineTerminator;
            W && this._buf.hasContent() && k !== 2 && this.newline(1);
            const X = this.getLastChar();
            let H;
            if (X !== 91 && X !== 123 && X !== 40 && this.space(), F) {
              if (H = `/*${L.value}*/`, this.format.indent.adjustMultilineComment) {
                var U;
                const q = (U = L.loc) == null ? void 0 : U.start.column;
                if (q) {
                  const ee = new RegExp("\\n\\s{1," + q + "}", "g");
                  H = H.replace(ee, `
`);
                }
                if (this.format.concise) H = H.replace(/\n(?!$)/g, `
`);
                else {
                  let ee = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                  (this._shouldIndent(47) || this.format.retainLines) && (ee += this._getIndent()), H = H.replace(/\n(?!$)/g, `
${" ".repeat(ee)}`);
                }
              }
            } else H = N ? `/*${L.value}*/` : `//${L.value}`;
            if (this._endsWithDiv && this._space(), this.tokenMap) {
              const { _printSemicolonBeforeNextToken: q, _printSemicolonBeforeNextNode: ee } = this;
              this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", L.loc), this._append(H, F), this._printSemicolonBeforeNextNode = ee, this._printSemicolonBeforeNextToken = q;
            } else this.source("start", L.loc), this._append(H, F);
            F || N || this.newline(1, true), W && k !== 3 && this.newline(1);
          }
          _printComments(L, k, N, F, W = 0, X) {
            const H = N.loc, U = k.length;
            let q = !!H;
            const ee = q ? H.start.line : 0, re = q ? H.end.line : 0;
            let Y = 0, Z = 0;
            const G = this._noLineTerminator ? function() {
            } : this.newline.bind(this);
            for (let B = 0; B < U; B++) {
              const z = k[B], M = this._shouldPrintComment(z, X);
              if (M === 2) {
                q = false;
                break;
              }
              if (q && z.loc && M === 1) {
                const K = z.loc.start.line, Q = z.loc.end.line;
                if (L === 0) {
                  let ie = 0;
                  B === 0 ? !this._buf.hasContent() || z.type !== "CommentLine" && K === Q || (ie = Z = 1) : ie = K - Y, Y = Q, G(ie), this._printComment(z, 1), B + 1 === U && (G(Math.max(ee - Y, Z)), Y = ee);
                } else if (L === 1) {
                  const ie = K - (B === 0 ? ee : Y);
                  Y = Q, G(ie), this._printComment(z, 1), B + 1 === U && (G(Math.min(1, re - Y)), Y = re);
                } else {
                  const ie = K - (B === 0 ? re - W : Y);
                  Y = Q, G(ie), this._printComment(z, 1);
                }
              } else {
                if (q = false, M !== 1) continue;
                if (U === 1) {
                  const K = z.loc ? z.loc.start.line === z.loc.end.line : !E.test(z.value), Q = K && !S(N) && !T(F) && !d(F) && !p(F);
                  L === 0 ? this._printComment(z, Q && N.type !== "ObjectExpression" || K && y(F, { body: N }) ? 1 : 0) : Q && L === 2 ? this._printComment(z, 1) : this._printComment(z, 0);
                } else L !== 1 || N.type === "ObjectExpression" && N.properties.length > 1 || N.type === "ClassBody" || N.type === "TSInterfaceBody" ? this._printComment(z, 0) : this._printComment(z, B === 0 ? 2 : B === U - 1 ? 3 : 0);
              }
            }
            L === 2 && q && Y && (this._lastCommentLine = Y);
          }
        }
        Object.assign(I.prototype, r), I.prototype.Noop = function() {
        }, t.default = I;
        function D(j, L) {
          this.token(",", false, j), L || this.space();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/source-map.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.8/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"), u = l("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.25/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js");
        t.default = class {
          constructor(c, e) {
            var r;
            this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
            const f = this._map = new n.GenMapping({ sourceRoot: c.sourceRoot });
            if (this._sourceFileName = (r = c.sourceFileName) == null ? void 0 : r.replace(/\\/g, "/"), this._rawMappings = void 0, c.inputSourceMap) {
              this._inputMap = new u.TraceMap(c.inputSourceMap);
              const S = this._inputMap.resolvedSources;
              if (S.length) for (let T = 0; T < S.length; T++) {
                var y;
                (0, n.setSourceContent)(f, S[T], (y = this._inputMap.sourcesContent) == null ? void 0 : y[T]);
              }
            }
            if (typeof e != "string" || c.inputSourceMap) {
              if (typeof e == "object") for (const S of Object.keys(e)) (0, n.setSourceContent)(f, S.replace(/\\/g, "/"), e[S]);
            } else (0, n.setSourceContent)(f, this._sourceFileName, e);
          }
          get() {
            return (0, n.toEncodedMap)(this._map);
          }
          getDecoded() {
            return (0, n.toDecodedMap)(this._map);
          }
          getRawMappings() {
            return this._rawMappings || (this._rawMappings = (0, n.allMappings)(this._map));
          }
          mark(c, e, r, f, y, S) {
            var T;
            let d;
            if (this._rawMappings = void 0, e != null) if (this._inputMap) {
              if (d = (0, u.originalPositionFor)(this._inputMap, { line: e, column: r }), !d.name && y) {
                const p = (0, u.originalPositionFor)(this._inputMap, y);
                p.name && (f = p.name);
              }
            } else d = { source: (S == null ? void 0 : S.replace(/\\/g, "/")) || this._sourceFileName, line: e, column: r };
            (0, n.maybeAddMapping)(this._map, { name: f, generated: c, source: (T = d) == null ? void 0 : T.source, original: d });
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/token-map.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.TokenMap = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { traverseFast: u, VISITOR_KEYS: c } = n;
        t.TokenMap = class {
          constructor(e, r, f) {
            this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = r, this._source = f, u(e, (y) => {
              const S = this._getTokensIndexesOfNode(y);
              S.length > 0 && this._nodesToTokenIndexes.set(y, S);
            }), this._tokensCache = null;
          }
          has(e) {
            return this._nodesToTokenIndexes.has(e);
          }
          getIndexes(e) {
            return this._nodesToTokenIndexes.get(e);
          }
          find(e, r) {
            const f = this._nodesToTokenIndexes.get(e);
            if (f) for (let y = 0; y < f.length; y++) {
              const S = f[y], T = this._tokens[S];
              if (r(T, S)) return T;
            }
            return null;
          }
          findLastIndex(e, r) {
            const f = this._nodesToTokenIndexes.get(e);
            if (f) for (let y = f.length - 1; y >= 0; y--) {
              const S = f[y];
              if (r(this._tokens[S], S)) return S;
            }
            return -1;
          }
          findMatching(e, r, f = 0) {
            const y = this._nodesToTokenIndexes.get(e);
            if (y) {
              let S = 0;
              const T = f;
              if (T > 1) {
                const d = this._nodesOccurrencesCountCache.get(e);
                d && d.test === r && d.count < T && (S = d.i + 1, f -= d.count + 1);
              }
              for (; S < y.length; S++) {
                const d = this._tokens[y[S]];
                if (this.matchesOriginal(d, r)) {
                  if (f === 0) return T > 0 && this._nodesOccurrencesCountCache.set(e, { test: r, count: T, i: S }), d;
                  f--;
                }
              }
            }
            return null;
          }
          matchesOriginal(e, r) {
            return e.end - e.start === r.length && (e.value != null ? e.value === r : this._source.startsWith(r, e.start));
          }
          startMatches(e, r) {
            const f = this._nodesToTokenIndexes.get(e);
            if (!f) return false;
            const y = this._tokens[f[0]];
            return y.start === e.start && this.matchesOriginal(y, r);
          }
          endMatches(e, r) {
            const f = this._nodesToTokenIndexes.get(e);
            if (!f) return false;
            const y = this._tokens[f[f.length - 1]];
            return y.end === e.end && this.matchesOriginal(y, r);
          }
          _getTokensIndexesOfNode(e) {
            if (e.start == null || e.end == null) return [];
            const { first: r, last: f } = this._findTokensOfNode(e, 0, this._tokens.length - 1);
            let y = r;
            const S = function* (d) {
              if (d.type === "TemplateLiteral") {
                yield d.quasis[0];
                for (let h = 1; h < d.quasis.length; h++) yield d.expressions[h - 1], yield d.quasis[h];
                return;
              }
              const p = c[d.type];
              for (const h of p) {
                const m = d[h];
                m && (Array.isArray(m) ? yield* m : yield m);
              }
            }(e);
            e.type !== "ExportNamedDeclaration" && e.type !== "ExportDefaultDeclaration" || !e.declaration || e.declaration.type !== "ClassDeclaration" || S.next();
            const T = [];
            for (const d of S) {
              if (d == null || d.start == null || d.end == null) continue;
              const p = this._findTokensOfNode(d, y, f), h = p.first;
              for (let m = y; m < h; m++) T.push(m);
              y = p.last + 1;
            }
            for (let d = y; d <= f; d++) T.push(d);
            return T;
          }
          _findTokensOfNode(e, r, f) {
            const y = this._tokensCache.get(e);
            if (y) return y;
            const S = this._findFirstTokenOfNode(e.start, r, f), T = this._findLastTokenOfNode(e.end, S, f);
            return this._tokensCache.set(e, { first: S, last: T }), { first: S, last: T };
          }
          _findFirstTokenOfNode(e, r, f) {
            for (; r <= f; ) {
              const y = f + r >> 1;
              if (e < this._tokens[y].start) f = y - 1;
              else {
                if (!(e > this._tokens[y].start)) return y;
                r = y + 1;
              }
            }
            return r;
          }
          _findLastTokenOfNode(e, r, f) {
            for (; r <= f; ) {
              const y = f + r >> 1;
              if (e < this._tokens[y].end) f = y - 1;
              else {
                if (!(e > this._tokens[y].end)) return y;
                r = y + 1;
              }
            }
            return f;
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.25.9/node_modules/@babel/helper-annotate-as-pure/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(r) {
          const f = r.node || r;
          e(f) || u(f, "leading", c);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { addComment: u } = n, c = "#__PURE__", e = ({ leadingComments: r }) => !!r && r.some((f) => /[@#]__PURE__/.test(f.value));
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.buildDecoratedClass = function(y, S, T, d) {
          const { node: p, scope: h } = S, m = h.generateUidIdentifier("initialize"), E = p.id && S.isDeclaration(), _ = S.isInStrictMode(), { superClass: C } = p;
          p.type = "ClassDeclaration", p.id || (p.id = n.types.cloneNode(y));
          let w;
          C && (w = h.generateUidIdentifierBasedOnNode(p.superClass, "super"), p.superClass = w);
          const I = r(p), D = n.types.arrayExpression(T.filter((N) => !N.node.abstract && N.node.type !== "TSIndexSignature").map((N) => function(F, W, X, H) {
            const U = H.isClassMethod();
            if (H.isPrivate()) throw H.buildCodeFrameError(`Private ${U ? "methods" : "fields"} in decorated classes are not supported yet.`);
            if (H.node.type === "ClassAccessorProperty") throw H.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
            if (H.node.type === "StaticBlock") throw H.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
            const { node: q, scope: ee } = H;
            H.isTSDeclareMethod() || new u.default({ methodPath: H, objectRef: W, superRef: X, file: F, refToPreserve: W }).replace();
            const re = [e("kind", n.types.stringLiteral(n.types.isClassMethod(q) ? q.kind : "field")), e("decorators", r(q)), e("static", q.static && n.types.booleanLiteral(true)), e("key", f(q))].filter(Boolean);
            U ? (H.ensureFunctionName != null || (H.ensureFunctionName = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.ensureFunctionName), H.ensureFunctionName(false), re.push(e("value", n.types.toExpression(H.node)))) : n.types.isClassProperty(q) && q.value ? re.push((Y = "value", Z = n.template.statements.ast`return ${q.value}`, n.types.objectMethod("method", n.types.identifier(Y), [], n.types.blockStatement(Z)))) : re.push(e("value", ee.buildUndefinedNode()));
            var Y, Z;
            return H.remove(), n.types.objectExpression(re);
          }(d, p.id, w, N))), j = n.template.expression.ast`
    ${function(N) {
            return N.addHelper("decorate");
          }(d)}(
      ${I || n.types.nullLiteral()},
      function (${m}, ${C ? n.types.cloneNode(w) : null}) {
        ${p}
        return { F: ${n.types.cloneNode(p.id)}, d: ${D} };
      },
      ${C}
    )
  `;
          _ || j.arguments[1].body.directives.push(n.types.directive(n.types.directiveLiteral("use strict")));
          let L = j, k = "arguments.1.body.body.0";
          return E && (L = n.template.statement.ast`let ${y} = ${j}`, k = "declarations.0.init." + k), { instanceNodes: [n.template.statement.ast`
        ${n.types.cloneNode(m)}(this)
      `], wrapClass: (N) => (N.replaceWith(L), N.get(k)) };
        }, t.hasDecorators = function(y) {
          return c(y) || y.body.body.some(c);
        }, t.hasOwnDecorators = c;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("./node_modules/.pnpm/@babel+helper-replace-supers@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-replace-supers/lib/index.js");
        function c(y) {
          var S;
          return !((S = y.decorators) == null || !S.length);
        }
        function e(y, S) {
          return S ? n.types.objectProperty(n.types.identifier(y), S) : null;
        }
        function r(y) {
          let S;
          return y.decorators && y.decorators.length > 0 && (S = n.types.arrayExpression(y.decorators.map((T) => T.expression))), y.decorators = void 0, S;
        }
        function f(y) {
          return y.computed ? y.key : n.types.isIdentifier(y.key) ? n.types.stringLiteral(y.key.name) : n.types.stringLiteral(String(y.key.value));
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function({ assertVersion: le, assumption: fe }, { loose: Pe }, xe, we) {
          var me, ye;
          le(xe === "2023-11" || xe === "2023-05" || xe === "2023-01" ? "^7.21.0" : xe === "2021-12" ? "^7.16.0" : "^7.19.0");
          const pe = /* @__PURE__ */ new WeakSet(), J = (me = fe("constantSuper")) != null ? me : Pe, Ee = (ye = fe("ignoreFunctionLength")) != null ? ye : Pe, Me = /* @__PURE__ */ function(qe, He) {
            function Ie(Re, Be, je) {
              switch (Be.type) {
                case "StringLiteral":
                  return n.types.stringLiteral(Be.value);
                case "NumericLiteral":
                case "BigIntLiteral": {
                  const he = Be.value + "";
                  return Re.get("key").replaceWith(n.types.stringLiteral(he)), n.types.stringLiteral(he);
                }
                default: {
                  const he = Re.scope.maybeGenerateMemoised(Be);
                  return Re.get("key").replaceWith(n.types.assignmentExpression("=", he, B(je, Be))), n.types.cloneNode(he);
                }
              }
            }
            return { VariableDeclarator(Re, Be) {
              const je = Re.node.id;
              if (je.type === "Identifier") {
                const he = (0, c.skipTransparentExprWrappers)(Re.get("init"));
                if (qe(he)) {
                  const oe = je.name;
                  He(he, Be, oe);
                }
              }
            }, AssignmentExpression(Re, Be) {
              const je = Re.node.left;
              if (je.type === "Identifier") {
                const he = (0, c.skipTransparentExprWrappers)(Re.get("right"));
                if (qe(he)) switch (Re.node.operator) {
                  case "=":
                  case "&&=":
                  case "||=":
                  case "??=":
                    He(he, Be, je.name);
                }
              }
            }, AssignmentPattern(Re, Be) {
              const je = Re.node.left;
              if (je.type === "Identifier") {
                const he = (0, c.skipTransparentExprWrappers)(Re.get("right"));
                if (qe(he)) {
                  const oe = je.name;
                  He(he, Be, oe);
                }
              }
            }, ObjectExpression(Re, Be) {
              for (const je of Re.get("properties")) {
                if (!je.isObjectProperty()) continue;
                const { node: he } = je, oe = he.key, _e = (0, c.skipTransparentExprWrappers)(je.get("value"));
                if (qe(_e)) {
                  if (he.computed) {
                    const Ne = Ie(je, oe, Be);
                    He(_e, Be, Ne);
                  } else if (!Q(oe)) if (oe.type === "Identifier") He(_e, Be, oe.name);
                  else {
                    const Ne = n.types.stringLiteral(oe.value + "");
                    He(_e, Be, Ne);
                  }
                }
              }
            }, ClassPrivateProperty(Re, Be) {
              const { node: je } = Re, he = (0, c.skipTransparentExprWrappers)(Re.get("value"));
              if (qe(he)) {
                const oe = n.types.stringLiteral("#" + je.key.id.name);
                He(he, Be, oe);
              }
            }, ClassAccessorProperty(Re, Be) {
              const { node: je } = Re, he = je.key, oe = (0, c.skipTransparentExprWrappers)(Re.get("value"));
              if (qe(oe)) if (je.computed) {
                const _e = Ie(Re, he, Be);
                He(oe, Be, _e);
              } else if (he.type === "Identifier") He(oe, Be, he.name);
              else if (he.type === "PrivateName") {
                const _e = n.types.stringLiteral("#" + he.id.name);
                He(oe, Be, _e);
              } else {
                const _e = n.types.stringLiteral(he.value + "");
                He(oe, Be, _e);
              }
            }, ClassProperty(Re, Be) {
              const { node: je } = Re, he = je.key, oe = (0, c.skipTransparentExprWrappers)(Re.get("value"));
              if (qe(oe)) if (je.computed) {
                const _e = Ie(Re, he, Be);
                He(oe, Be, _e);
              } else if (he.type === "Identifier") He(oe, Be, he.name);
              else {
                const _e = n.types.stringLiteral(he.value + "");
                He(oe, Be, _e);
              }
            } };
          }(ge, Ue);
          function Ue(qe, He, Ie) {
            var Re;
            if (pe.has(qe)) return;
            const { node: Be } = qe;
            Ie != null || (Ie = (Re = Be.id) == null ? void 0 : Re.name);
            const je = function(he, oe, _e, Ne, $e, Xe, Je) {
              var st, be;
              const ke = he.get("body.body"), Ve = he.node.decorators;
              let ze = false, rt = false, it = false;
              const Ye = /* @__PURE__ */ function(dt) {
                let ft;
                return () => (ft || (ft = function(at) {
                  const St = [], Ct = /* @__PURE__ */ new Set();
                  return at.traverse({ PrivateName(Mt) {
                    Ct.add(Mt.node.id.name);
                  } }), () => {
                    let Mt;
                    do
                      f(St), Mt = String.fromCharCode(...St);
                    while (Ct.has(Mt));
                    return n.types.privateName(n.types.identifier(Mt));
                  };
                }(dt)), ft());
              }(he), tt = [], pt = he.scope.parent, Et = (dt, ft, at) => {
                const St = Te(pt, ft);
                return at.push(n.types.assignmentExpression("=", St, dt)), n.types.cloneNode(St);
              };
              let Qe, yt;
              const vt = (st = he.node.id) == null ? void 0 : st.name, kt = typeof $e == "object" ? $e : void 0, qt = (dt) => {
                try {
                  return n.types.traverseFast(dt, (ft) => {
                    if (n.types.isThisExpression(ft) || n.types.isSuper(ft) || n.types.isYieldExpression(ft) || n.types.isAwaitExpression(ft) || n.types.isIdentifier(ft, { name: "arguments" }) || vt && n.types.isIdentifier(ft, { name: vt }) || n.types.isMetaProperty(ft) && ft.meta.name !== "import") throw null;
                  }), false;
                } catch {
                  return true;
                }
              }, sn = [];
              for (const dt of ke) {
                if (!re(dt)) continue;
                const ft = dt.node;
                if (!ft.static && n.types.isPrivateName(ft.key) && sn.push(ft.key.id.name), ie(ft)) {
                  switch (ft.type) {
                    case "ClassProperty":
                      Xe.ClassProperty(dt, oe);
                      break;
                    case "ClassPrivateProperty":
                      Xe.ClassPrivateProperty(dt, oe);
                      break;
                    case "ClassAccessorProperty":
                      if (Xe.ClassAccessorProperty(dt, oe), Je === "2023-11") break;
                    default:
                      ft.static ? yt != null || (yt = Te(pt, "initStatic")) : Qe != null || (Qe = Te(pt, "initProto"));
                  }
                  ze = true, it || (it = ft.decorators.some(qt));
                } else if (ft.type === "ClassAccessorProperty") {
                  Xe.ClassAccessorProperty(dt, oe);
                  const { key: at, value: St, static: Ct, computed: Mt } = ft, ct = Ye(), Ot = y(ct, St, Ct), zt = dt.get("key"), [Qt] = dt.replaceWith(Ot);
                  let on, Zt;
                  Mt && !zt.isConstantExpression() ? (on = (0, r.memoiseComputedKey)(B(oe, at), pt, pt.generateUid("computedKey")), Zt = n.types.cloneNode(on.left)) : (on = n.types.cloneNode(at), Zt = n.types.cloneNode(at)), S(he, $e), T(he.node.id, Qt, on, Zt, ct, Mt, Ct, Je);
                }
                "computed" in dt.node && dt.node.computed && (rt || (rt = !pt.isStatic(dt.node.key)));
              }
              if (!Ve && !ze) return he.node.id || typeof $e != "string" || (he.node.id = n.types.identifier($e)), void (kt && he.node.body.body.unshift(I([G(oe, kt)])));
              const _n = [];
              let bn;
              const Kt = /* @__PURE__ */ new Set();
              let Jt, Ft, fn = null;
              function _t(dt) {
                let ft = false, at = false;
                const St = [];
                for (const Ct of dt) {
                  const { expression: Mt } = Ct;
                  let ct;
                  (Je === "2023-11" || Je === "2023-05") && n.types.isMemberExpression(Mt) && (n.types.isSuper(Mt.object) ? ct = n.types.thisExpression() : pt.isStatic(Mt.object) ? ct = n.types.cloneNode(Mt.object) : (fn != null || (fn = Te(pt, "obj")), ct = n.types.assignmentExpression("=", n.types.cloneNode(fn), Mt.object), Mt.object = n.types.cloneNode(fn))), St.push(ct), ft || (ft = !pt.isStatic(Mt)), at || (at = qt(Ct));
                }
                return { hasSideEffects: ft, usesFnContext: at, decoratorsThis: St };
              }
              const Xn = rt || it || Je !== "2023-11";
              let Jn, rr, sr = false, Qn = 0, Br = [], Tn = [];
              if (Ve) {
                Jt = Te(pt, "initClass"), sr = he.isClassDeclaration(), { id: Ft, path: he } = function(ct, Ot) {
                  const zt = ct.node.id, Qt = ct.scope;
                  if (ct.type === "ClassDeclaration") {
                    const on = zt.name, Zt = Qt.generateUidIdentifierBasedOnNode(zt), ln = n.types.identifier(on);
                    return Qt.rename(on, Zt.name), ct.get("id").replaceWith(ln), { id: n.types.cloneNode(Zt), path: ct };
                  }
                  {
                    let on;
                    zt ? (Ot = zt.name, on = Te(Qt.parent, Ot), Qt.rename(Ot, on.name)) : on = Te(Qt.parent, typeof Ot == "string" ? Ot : "decorated_class");
                    const Zt = n.types.classExpression(typeof Ot == "string" ? n.types.identifier(Ot) : null, ct.node.superClass, ct.node.body), [ln] = ct.replaceWith(n.types.sequenceExpression([Zt, on]));
                    return { id: n.types.cloneNode(on), path: ln.get("expressions.0") };
                  }
                }(he, $e), he.node.decorators = null;
                const dt = Ve.some(M), { hasSideEffects: ft, usesFnContext: at, decoratorsThis: St } = _t(Ve), { haveThis: Ct, decs: Mt } = U(Ve, St, Je);
                if (Qn = Ct ? 1 : 0, Br = Mt, (at || ft && Xn || dt) && (Jn = Et(n.types.arrayExpression(Br), "classDecs", tt)), !ze) for (const ct of he.get("body.body")) {
                  const { node: Ot } = ct;
                  if ("computed" in Ot && Ot.computed) if (ct.isClassProperty({ static: true })) {
                    if (!ct.get("key").isConstantExpression()) {
                      const zt = Ot.key, Qt = (0, r.memoiseComputedKey)(zt, pt, pt.generateUid("computedKey"));
                      Qt != null && (Ot.key = n.types.cloneNode(Qt.left), Tn.push(Qt));
                    }
                  } else Tn.length > 0 && (m(Tn, ct), Tn = []);
                }
              } else S(he, $e), Ft = n.types.cloneNode(he.node.id);
              let Zn = false, Gn = [], gn = [];
              if (ze) {
                if (Qe) {
                  const dt = n.types.callExpression(n.types.cloneNode(Qe), [n.types.thisExpression()]);
                  Gn.push(dt);
                }
                for (const dt of ke) {
                  if (!re(dt)) {
                    gn.length > 0 && dt.isStaticBlock() && (_(gn, dt), gn = []);
                    continue;
                  }
                  const { node: ft } = dt, at = ft.decorators, St = !(at == null || !at.length), Ct = "computed" in ft && ft.computed;
                  let Mt, ct, Ot = "computedKey";
                  if (ft.key.type === "PrivateName" ? Ot = ft.key.id.name : Ct || ft.key.type !== "Identifier" || (Ot = ft.key.name), St) {
                    const { hasSideEffects: Un, usesFnContext: Bn, decoratorsThis: Bt } = _t(at), { decs: Vn, haveThis: pr } = U(at, Bt, Je);
                    ct = pr, Mt = Vn.length === 1 ? Vn[0] : n.types.arrayExpression(Vn), (Bn || Un && Xn) && (Mt = Et(Mt, Ot + "Decs", Tn));
                  }
                  if (Ct && !dt.get("key").isConstantExpression()) {
                    const Un = ft.key, Bn = (0, r.memoiseComputedKey)(St ? B(oe, Un) : Un, pt, pt.generateUid("computedKey"));
                    Bn != null && (Ve && dt.isClassProperty({ static: true }) ? (ft.key = n.types.cloneNode(Bn.left), Tn.push(Bn)) : ft.key = Bn);
                  }
                  const { key: zt, static: Qt } = ft, on = zt.type === "PrivateName", Zt = H(dt);
                  let ln;
                  if (on && !Qt && (St && (Zn = true), !n.types.isClassPrivateProperty(ft) && rr || (rr = zt)), dt.isClassMethod({ kind: "constructor" }) && (bn = dt), St) {
                    let Un, Bn;
                    if (Bn = Ct ? h(dt.get("key")) : zt.type === "PrivateName" ? n.types.stringLiteral(zt.id.name) : zt.type === "Identifier" ? n.types.stringLiteral(zt.name) : n.types.cloneNode(zt), Zt === j) {
                      const { value: Bt } = dt.node, Vn = Je === "2023-11" && Qt ? [] : [n.types.thisExpression()];
                      Bt && Vn.push(n.types.cloneNode(Bt));
                      const pr = Ye(), es = Te(pt, `init_${Ot}`), Or = y(pr, n.types.callExpression(n.types.cloneNode(es), Vn), Qt), [Rs] = dt.replaceWith(Or);
                      if (on) {
                        Un = d(pr, Je);
                        const js = Te(pt, `get_${Ot}`), os = Te(pt, `set_${Ot}`);
                        q(Je, Rs, zt, js, os, Qt), ln = [es, js, os];
                      } else S(he, $e), T(he.node.id, Rs, n.types.cloneNode(zt), n.types.isAssignmentExpression(zt) ? n.types.cloneNode(zt.left) : n.types.cloneNode(zt), pr, Ct, Qt, Je), ln = [es];
                    } else if (Zt === D) {
                      const Bt = Te(pt, `init_${Ot}`), Vn = dt.get("value"), pr = Je === "2023-11" && Qt ? [] : [n.types.thisExpression()];
                      Vn.node && pr.push(Vn.node), Vn.replaceWith(n.types.callExpression(n.types.cloneNode(Bt), pr)), ln = [Bt], on && (Un = d(zt, Je));
                    } else if (on) {
                      const Bt = Te(pt, `call_${Ot}`);
                      if (ln = [Bt], new u.default({ constantSuper: _e, methodPath: dt, objectRef: Ft, superRef: he.node.superClass, file: oe.file, refToPreserve: Ft }).replace(), Un = [Z(dt.node)], Zt === k || Zt === N) ee(dt, n.types.cloneNode(zt), n.types.cloneNode(Bt), Qt);
                      else {
                        const Vn = dt.node;
                        he.node.body.body.unshift(n.types.classPrivateProperty(zt, n.types.cloneNode(Bt), [], Vn.static)), Kt.add(zt.id.name), dt.remove();
                      }
                    }
                    _n.push({ kind: Zt, decoratorsArray: Mt, decoratorsHaveThis: ct, name: Bn, isStatic: Qt, privateMethods: Un, locals: ln }), dt.node && (dt.node.decorators = null);
                  }
                  if (Ct && Tn.length > 0 && (Ve && dt.isClassProperty({ static: true }) || (m(Tn, Zt === j ? dt.getNextSibling() : dt), Tn = [])), Gn.length > 0 && !Qt && (Zt === D || Zt === j) && (E(Gn, dt), Gn = []), gn.length > 0 && Qt && (Zt === D || Zt === j) && (E(gn, dt), gn = []), St && Je === "2023-11" && (Zt === D || Zt === j)) {
                    const Un = Te(pt, `init_extra_${Ot}`);
                    ln.push(Un);
                    const Bn = n.types.callExpression(n.types.cloneNode(Un), Qt ? [] : [n.types.thisExpression()]);
                    Qt ? gn.push(Bn) : Gn.push(Bn);
                  }
                }
              }
              if (Tn.length > 0) {
                const dt = he.get("body.body");
                let ft;
                for (let at = dt.length - 1; at >= 0; at--) {
                  const St = dt[at], Ct = St.node;
                  if (Ct.computed) {
                    if (Ve && n.types.isClassProperty(Ct, { static: true })) continue;
                    ft = St;
                    break;
                  }
                }
                ft != null && (function(at, St) {
                  const Ct = St.get("key"), Mt = p(Ct);
                  if (Mt.isConstantExpression()) m(at, St);
                  else {
                    const ct = Ct.scope.parent, Ot = (0, r.memoiseComputedKey)(Mt.node, ct, ct.generateUid("computedKey"));
                    if (Ot) {
                      const zt = [...at, n.types.cloneNode(Ot.left)], Qt = Mt.parentPath;
                      Qt.isSequenceExpression() ? Qt.pushContainer("expressions", zt) : Mt.replaceWith(Y([n.types.cloneNode(Ot), ...zt]));
                    } else m(at, St);
                  }
                }(Tn, ft), Tn = []);
              }
              if (Gn.length > 0) {
                const dt = !!he.node.superClass;
                bn ? dt ? function(ft, at, St) {
                  at.traverse({ CallExpression: { exit(Ct) {
                    if (!Ct.get("callee").isSuper()) return;
                    const Mt = [Ct.node, ...ft.map((ct) => n.types.cloneNode(ct))];
                    Ct.isCompletionRecord() && Mt.push(n.types.thisExpression()), Ct.replaceWith(function(ct, Ot) {
                      if (Ot) {
                        if (ct.length >= 2 && C(ct[1], Ot)) {
                          const zt = n.types.callExpression(n.types.cloneNode(Ot), [ct[0]]);
                          ct.splice(0, 2, zt);
                        }
                        ct.length >= 2 && n.types.isThisExpression(ct[ct.length - 1]) && C(ct[ct.length - 2], Ot) && ct.splice(ct.length - 1, 1);
                      }
                      return Y(ct);
                    }(Mt, St)), Ct.skip();
                  } }, ClassMethod(Ct) {
                    Ct.node.kind === "constructor" && Ct.skip();
                  } });
                }(Gn, bn, Qe) : function(ft, at) {
                  at.node.body.body.unshift(n.types.expressionStatement(Y(ft)));
                }(Gn, bn) : he.node.body.body.unshift(w(Gn, dt)), Gn = [];
              }
              gn.length > 0 && (he.node.body.body.push(I(gn)), gn = []);
              const ur = (kr = _n, [...kr.filter((dt) => dt.isStatic && dt.kind >= j && dt.kind <= N), ...kr.filter((dt) => !dt.isStatic && dt.kind >= j && dt.kind <= N), ...kr.filter((dt) => dt.isStatic && dt.kind === D), ...kr.filter((dt) => !dt.isStatic && dt.kind === D)]), Ir = function(dt, ft) {
                return n.types.arrayExpression(dt.map((at) => {
                  let St = at.kind;
                  return at.isStatic && (St += ft === "2023-11" || ft === "2023-05" ? W : F), at.decoratorsHaveThis && (St += X), n.types.arrayExpression([at.decoratorsArray, n.types.numericLiteral(St), at.name, ...at.privateMethods || []]);
                }));
              }(Je === "2023-11" ? _n : ur, Je), zn = function(dt) {
                const ft = [];
                for (const at of dt) {
                  const { locals: St } = at;
                  Array.isArray(St) ? ft.push(...St) : St !== void 0 && ft.push(St);
                }
                return ft;
              }(ur);
              var kr;
              Qe && zn.push(Qe), yt && zn.push(yt);
              const Jr = [];
              let Qr = false;
              const wt = Jt && n.types.callExpression(n.types.cloneNode(Jt), []);
              let $r = he;
              const vr = he.node, Er = [];
              if (Ve) {
                Jr.push(Ft, Jt);
                const dt = [];
                if (he.get("body.body").forEach((ft) => {
                  if (ft.isStaticBlock()) {
                    if (K(ft, sn)) {
                      const St = Et((at = ft.node, n.types.functionExpression(null, [], n.types.blockStatement(at.body))), "staticBlock", Er);
                      gn.push(n.types.callExpression(n.types.memberExpression(St, n.types.identifier("call")), [n.types.thisExpression()]));
                    } else gn.push(function(St) {
                      return n.types.callExpression(n.types.arrowFunctionExpression([], n.types.blockStatement(St.body)), []);
                    }(ft.node));
                    ft.remove();
                  } else {
                    var at;
                    if ((ft.isClassProperty() || ft.isClassPrivateProperty()) && ft.node.static) {
                      const St = ft.get("value");
                      if (K(St, sn)) {
                        const Ct = Et(function(Mt) {
                          return n.types.functionExpression(null, [], n.types.blockStatement([n.types.returnStatement(Mt)]));
                        }(St.node), "fieldValue", Er);
                        St.replaceWith(n.types.callExpression(n.types.memberExpression(Ct, n.types.identifier("call")), [n.types.thisExpression()]));
                      }
                      gn.length > 0 && (E(gn, ft), gn = []), ft.node.static = false, dt.push(ft.node), ft.remove();
                    } else if (ft.isClassPrivateMethod({ static: true })) {
                      if (K(ft, sn)) {
                        new u.default({ constantSuper: _e, methodPath: ft, objectRef: Ft, superRef: he.node.superClass, file: oe.file, refToPreserve: Ft }).replace();
                        const St = Et(Z(ft.node), ft.get("key.id").node.name, Er);
                        Ne ? (ft.node.params = [n.types.restElement(n.types.identifier("arg"))], ft.node.body = n.types.blockStatement([n.types.returnStatement(n.types.callExpression(n.types.memberExpression(St, n.types.identifier("apply")), [n.types.thisExpression(), n.types.identifier("arg")]))])) : (ft.node.params = ft.node.params.map((Ct, Mt) => n.types.isRestElement(Ct) ? n.types.restElement(n.types.identifier("arg")) : n.types.identifier("_" + Mt)), ft.node.body = n.types.blockStatement([n.types.returnStatement(n.types.callExpression(n.types.memberExpression(St, n.types.identifier("apply")), [n.types.thisExpression(), n.types.identifier("arguments")]))]));
                      }
                      ft.node.static = false, dt.push(ft.node), ft.remove();
                    }
                  }
                }), dt.length > 0 || gn.length > 0) {
                  const ft = n.template.expression.ast`
        class extends ${oe.addHelper("identity")} {}
      `;
                  ft.body.body = [n.types.classProperty(n.types.toExpression(vr), void 0, void 0, void 0, true, true), ...dt];
                  const at = [], St = n.types.newExpression(ft, []);
                  gn.length > 0 && at.push(...gn), wt && (Qr = true, at.push(wt)), at.length > 0 ? (at.unshift(n.types.callExpression(n.types.super(), [n.types.cloneNode(Ft)])), ft.body.body.push(w(at, false))) : St.arguments.push(n.types.cloneNode(Ft));
                  const [Ct] = he.replaceWith(St);
                  $r = Ct.get("callee").get("body").get("body.0.key");
                }
              }
              !Qr && wt && he.node.body.body.push(n.types.staticBlock([n.types.expressionStatement(wt)]));
              let { superClass: Zr } = vr;
              if (Zr && (Je === "2023-11" || Je === "2023-05")) {
                const dt = he.scope.maybeGenerateMemoised(Zr);
                dt && (vr.superClass = n.types.assignmentExpression("=", dt, Zr), Zr = dt);
              }
              const cr = n.types.staticBlock([]);
              vr.body.body.unshift(cr);
              const er = cr.body;
              if (Tn.length > 0) {
                const dt = $r.get("body.body");
                let ft;
                for (const at of dt) if ((at.isClassProperty() || at.isClassMethod()) && at.node.kind !== "constructor") {
                  ft = at;
                  break;
                }
                ft != null ? (function(at) {
                  const { node: St } = at;
                  St.computed = true, n.types.isIdentifier(St.key) && (St.key = n.types.stringLiteral(St.key.name));
                }(ft), m(Tn, ft)) : (vr.body.body.unshift(n.types.classProperty(n.types.sequenceExpression([...Tn, n.types.stringLiteral("_")]), void 0, void 0, void 0, true, true)), er.push(n.types.expressionStatement(n.types.unaryExpression("delete", n.types.memberExpression(n.types.thisExpression(), n.types.identifier("_")))))), Tn = [];
              }
              if (er.push(n.types.expressionStatement(function(dt, ft, at, St, Ct, Mt, ct, Ot, zt, Qt) {
                let on, Zt;
                const ln = [ct ? G(zt, ct) : n.types.thisExpression(), St, at];
                return Qt !== "2023-11" && ln.splice(1, 2, at, St), Qt === "2021-12" || Qt === "2022-03" && !zt.availableHelper("applyDecs2203R") ? (on = n.types.arrayPattern([...dt, ...ft]), Zt = n.types.callExpression(zt.addHelper(Qt === "2021-12" ? "applyDecs" : "applyDecs2203"), ln), n.types.assignmentExpression("=", on, Zt)) : (Qt === "2022-03" ? Zt = n.types.callExpression(zt.addHelper("applyDecs2203R"), ln) : Qt === "2023-01" ? (Mt && ln.push(z(Mt)), Zt = n.types.callExpression(zt.addHelper("applyDecs2301"), ln)) : Qt === "2023-05" && ((Mt || Ot || Ct.value !== 0) && ln.push(Ct), Mt ? ln.push(z(Mt)) : Ot && ln.push(n.types.unaryExpression("void", n.types.numericLiteral(0))), Ot && ln.push(Ot), Zt = n.types.callExpression(zt.addHelper("applyDecs2305"), ln)), Qt === "2023-11" && ((Mt || Ot || Ct.value !== 0) && ln.push(Ct), Mt ? ln.push(z(Mt)) : Ot && ln.push(n.types.unaryExpression("void", n.types.numericLiteral(0))), Ot && ln.push(Ot), Zt = n.types.callExpression(zt.addHelper("applyDecs2311"), ln)), dt.length > 0 ? ft.length > 0 ? on = n.types.objectPattern([n.types.objectProperty(n.types.identifier("e"), n.types.arrayPattern(dt)), n.types.objectProperty(n.types.identifier("c"), n.types.arrayPattern(ft))]) : (on = n.types.arrayPattern(dt), Zt = n.types.memberExpression(Zt, n.types.identifier("e"), false, false)) : (on = n.types.arrayPattern(ft), Zt = n.types.memberExpression(Zt, n.types.identifier("c"), false, false)), n.types.assignmentExpression("=", on, Zt));
              }(zn, Jr, Ir, (be = Jn) != null ? be : n.types.arrayExpression(Br), n.types.numericLiteral(Qn), Zn ? rr : null, kt, n.types.cloneNode(Zr), oe, Je))), yt && er.push(n.types.expressionStatement(n.types.callExpression(n.types.cloneNode(yt), [n.types.thisExpression()]))), Er.length > 0 && er.push(...Er.map((dt) => n.types.expressionStatement(dt))), he.insertBefore(tt.map((dt) => n.types.expressionStatement(dt))), sr) if (pt.getBinding(Ft.name).constantViolations.length) {
                const dt = pt.generateUidIdentifier("t" + Ft.name), ft = Ft;
                he.replaceWithMultiple([n.types.variableDeclaration("let", [n.types.variableDeclarator(n.types.cloneNode(ft)), n.types.variableDeclarator(dt)]), n.types.blockStatement([n.types.variableDeclaration("let", [n.types.variableDeclarator(n.types.cloneNode(Ft))]), he.node, n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(dt), n.types.cloneNode(Ft)))]), n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(ft), n.types.cloneNode(dt)))]);
              } else he.insertBefore(n.types.variableDeclaration("let", [n.types.variableDeclarator(n.types.cloneNode(Ft))]));
              return Kt.size > 0 && function(dt, ft) {
                const at = (0, e.privateNameVisitorFactory)({ PrivateName(Ct, Mt) {
                  if (!Mt.privateNamesMap.has(Ct.node.id.name)) return;
                  const ct = Ct.parentPath, Ot = ct.parentPath;
                  if (Ot.node.type === "AssignmentExpression" && Ot.node.left === ct.node || Ot.node.type === "UpdateExpression" || Ot.node.type === "RestElement" || Ot.node.type === "ArrayPattern" || Ot.node.type === "ObjectProperty" && Ot.node.value === ct.node && Ot.parentPath.type === "ObjectPattern" || Ot.node.type === "ForOfStatement" && Ot.node.left === ct.node) throw Ct.buildCodeFrameError(`Decorated private methods are read-only, but "#${Ct.node.id.name}" is updated via this expression.`);
                } }), St = /* @__PURE__ */ new Map();
                for (const Ct of ft) St.set(Ct, null);
                dt.traverse(at, { privateNamesMap: St });
              }(he, Kt), he.scope.crawl(), he;
            }(qe, He, J, Ee, Ie, Me, xe);
            je ? pe.add(je) : pe.add(qe);
          }
          return { name: "proposal-decorators", inherits: we, visitor: Object.assign({ ExportDefaultDeclaration(qe, He) {
            const { declaration: Ie } = qe.node;
            if ((Ie == null ? void 0 : Ie.type) === "ClassDeclaration" && ie(Ie)) {
              const Re = !Ie.id;
              qe.splitExportDeclaration != null || (qe.splitExportDeclaration = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration);
              const Be = qe.splitExportDeclaration();
              Re && Ue(Be, He, n.types.stringLiteral("default"));
            }
          }, ExportNamedDeclaration(qe) {
            const { declaration: He } = qe.node;
            (He == null ? void 0 : He.type) === "ClassDeclaration" && ie(He) && (qe.splitExportDeclaration != null || (qe.splitExportDeclaration = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration), qe.splitExportDeclaration());
          }, Class(qe, He) {
            Ue(qe, He, void 0);
          } }, Me) };
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("./node_modules/.pnpm/@babel+helper-replace-supers@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-replace-supers/lib/index.js"), c = l("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.25.9/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"), e = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"), r = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js");
        function f(le, fe = le.length - 1) {
          if (fe === -1) return void le.unshift(65);
          const Pe = le[fe];
          Pe === 90 ? le[fe] = 97 : Pe === 122 ? (le[fe] = 65, f(le, fe - 1)) : le[fe] = Pe + 1;
        }
        function y(le, fe, Pe) {
          return le.type === "PrivateName" ? n.types.classPrivateProperty(le, fe, void 0, Pe) : n.types.classProperty(le, fe, void 0, void 0, Pe);
        }
        function S(le, fe) {
          le.node.id || (le.node.id = typeof fe == "string" ? n.types.identifier(fe) : le.scope.generateUidIdentifier("Class"));
        }
        function T(le, fe, Pe, xe, we, me, ye, pe) {
          const J = pe !== "2023-11" && pe !== "2023-05" || !ye ? n.types.thisExpression() : le, Ee = n.types.blockStatement([n.types.returnStatement(n.types.memberExpression(n.types.cloneNode(J), n.types.cloneNode(we)))]), Me = n.types.blockStatement([n.types.expressionStatement(n.types.assignmentExpression("=", n.types.memberExpression(n.types.cloneNode(J), n.types.cloneNode(we)), n.types.identifier("v")))]);
          let Ue, qe;
          Pe.type === "PrivateName" ? (Ue = n.types.classPrivateMethod("get", Pe, [], Ee, ye), qe = n.types.classPrivateMethod("set", xe, [n.types.identifier("v")], Me, ye)) : (Ue = n.types.classMethod("get", Pe, [], Ee, me, ye), qe = n.types.classMethod("set", xe, [n.types.identifier("v")], Me, me, ye)), fe.insertAfter(qe), fe.insertAfter(Ue);
        }
        function d(le, fe) {
          return fe !== "2023-11" && fe !== "2023-05" && fe !== "2023-01" ? [n.template.expression.ast`
        function () {
          return this.${n.types.cloneNode(le)};
        }
      `, n.template.expression.ast`
        function (value) {
          this.${n.types.cloneNode(le)} = value;
        }
      `] : [n.template.expression.ast`
      o => o.${n.types.cloneNode(le)}
    `, n.template.expression.ast`
      (o, v) => o.${n.types.cloneNode(le)} = v
    `];
        }
        function p(le) {
          if ((le = (0, c.skipTransparentExprWrappers)(le)).isSequenceExpression()) {
            const fe = le.get("expressions");
            return p(fe[fe.length - 1]);
          }
          return le;
        }
        function h(le) {
          const fe = p(le);
          if (fe.isConstantExpression() || fe.isIdentifier() && le.scope.hasUid(fe.node.name)) return n.types.cloneNode(le.node);
          if (fe.isAssignmentExpression() && fe.get("left").isIdentifier()) return n.types.cloneNode(fe.node.left);
          throw new Error(`Internal Error: the computed key ${le.toString()} has not yet been memoised.`);
        }
        function m(le, fe) {
          const Pe = fe.get("key");
          Pe.isSequenceExpression() ? le.push(...Pe.node.expressions) : le.push(Pe.node), Pe.replaceWith(Y(le));
        }
        function E(le, fe) {
          const Pe = fe.get("value");
          Pe.node ? le.push(Pe.node) : le.length > 0 && (le[le.length - 1] = n.types.unaryExpression("void", le[le.length - 1])), Pe.replaceWith(Y(le));
        }
        function _(le, fe) {
          fe.unshiftContainer("body", n.types.expressionStatement(Y(le)));
        }
        function C(le, fe) {
          return n.types.isCallExpression(le) && n.types.isIdentifier(le.callee, { name: fe.name });
        }
        function w(le, fe) {
          const Pe = [n.types.expressionStatement(Y(le))];
          return fe && Pe.unshift(n.types.expressionStatement(n.types.callExpression(n.types.super(), [n.types.spreadElement(n.types.identifier("args"))]))), n.types.classMethod("constructor", n.types.identifier("constructor"), fe ? [n.types.restElement(n.types.identifier("args"))] : [], n.types.blockStatement(Pe));
        }
        function I(le) {
          return n.types.staticBlock([n.types.expressionStatement(Y(le))]);
        }
        const D = 0, j = 1, L = 2, k = 3, N = 4, F = 5, W = 8, X = 16;
        function H(le) {
          switch (le.node.type) {
            case "ClassProperty":
            case "ClassPrivateProperty":
              return D;
            case "ClassAccessorProperty":
              return j;
            case "ClassMethod":
            case "ClassPrivateMethod":
              return le.node.kind === "get" ? k : le.node.kind === "set" ? N : L;
          }
        }
        function U(le, fe, Pe) {
          const xe = le.length, we = fe.some(Boolean), me = [];
          for (let ye = 0; ye < xe; ye++) Pe !== "2023-11" && Pe !== "2023-05" || !we || me.push(fe[ye] || n.types.unaryExpression("void", n.types.numericLiteral(0))), me.push(le[ye].expression);
          return { haveThis: we, decs: me };
        }
        function q(le, fe, Pe, xe, we, me) {
          fe.insertAfter(n.types.classPrivateMethod("get", n.types.cloneNode(Pe), [], n.types.blockStatement([n.types.returnStatement(n.types.callExpression(n.types.cloneNode(xe), le === "2023-11" && me ? [] : [n.types.thisExpression()]))]), me)), fe.insertAfter(n.types.classPrivateMethod("set", n.types.cloneNode(Pe), [n.types.identifier("v")], n.types.blockStatement([n.types.expressionStatement(n.types.callExpression(n.types.cloneNode(we), le === "2023-11" && me ? [n.types.identifier("v")] : [n.types.thisExpression(), n.types.identifier("v")]))]), me));
        }
        function ee(le, fe, Pe, xe) {
          let we, me;
          le.node.kind === "set" ? (we = [n.types.identifier("v")], me = [n.types.expressionStatement(n.types.callExpression(Pe, [n.types.thisExpression(), n.types.identifier("v")]))]) : (we = [], me = [n.types.returnStatement(n.types.callExpression(Pe, [n.types.thisExpression()]))]), le.replaceWith(n.types.classPrivateMethod(le.node.kind, n.types.cloneNode(fe), we, n.types.blockStatement(me), xe));
        }
        function re(le) {
          const { type: fe } = le;
          return fe !== "TSDeclareMethod" && fe !== "TSIndexSignature" && fe !== "StaticBlock";
        }
        function Y(le) {
          return le.length === 0 ? n.types.unaryExpression("void", n.types.numericLiteral(0)) : le.length === 1 ? le[0] : n.types.sequenceExpression(le);
        }
        function Z(le) {
          const { params: fe, body: Pe, generator: xe, async: we } = le;
          return n.types.functionExpression(void 0, fe, Pe, xe, we);
        }
        function G(le, fe) {
          return n.types.callExpression(le.addHelper("setFunctionName"), [n.types.thisExpression(), fe]);
        }
        function B(le, fe) {
          return n.types.callExpression(le.addHelper("toPropertyKey"), [fe]);
        }
        function z(le) {
          return n.types.arrowFunctionExpression([n.types.identifier("_")], n.types.binaryExpression("in", n.types.cloneNode(le), n.types.identifier("_")));
        }
        function M(le) {
          try {
            return n.types.traverseFast(le, (fe) => {
              if (n.types.isPrivateName(fe)) throw null;
            }), false;
          } catch {
            return true;
          }
        }
        function K(le, fe) {
          let Pe = false;
          if (fe.length > 0) {
            const xe = (0, e.privateNameVisitorFactory)({ PrivateName(me, ye) {
              ye.privateNamesMap.has(me.node.id.name) && (Pe = true, me.stop());
            } }), we = /* @__PURE__ */ new Map();
            for (const me of fe) we.set(me, null);
            le.traverse(xe, { privateNamesMap: we });
          }
          return Pe;
        }
        function Q(le) {
          return le.type === "Identifier" ? le.name === "__proto__" : le.value === "__proto__";
        }
        function ie(le) {
          return le.decorators && le.decorators.length > 0;
        }
        function ue(le) {
          switch (le.type) {
            case "ClassAccessorProperty":
              return true;
            case "ClassMethod":
            case "ClassProperty":
            case "ClassPrivateMethod":
            case "ClassPrivateProperty":
              return ie(le);
            default:
              return false;
          }
        }
        function ge(le) {
          return le.isClassExpression({ id: null }) && (ie(fe = le.node) || fe.body.body.some(ue));
          var fe;
        }
        function Te(le, fe) {
          const Pe = le.generateUidIdentifier(fe);
          return le.push({ id: Pe, kind: "let" }), n.types.cloneNode(Pe);
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/features.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.FEATURES = void 0, t.enableFeature = function(h, m, E) {
          T(h, m) && !y(h, m) || (h.set(e, h.get(e) | m), E === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" ? (p(h, m, true), h.set(f, h.get(f) | m)) : E === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" ? (p(h, m, false), h.set(f, h.get(f) | m)) : p(h, m, E));
          let _;
          for (const [w, I] of c) {
            if (!T(h, w) || y(h, w)) continue;
            const D = d(h, w);
            if (_ === !D) throw new Error(`'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).

` + S(h));
            _ = D;
            var C = I;
          }
          if (_ !== void 0) for (const [w, I] of c) T(h, w) && d(h, w) !== _ && (p(h, w, _), console.warn(`Though the "loose" option was set to "${!_}" in your @babel/preset-env config, it will not be used for ${I} since the "loose" mode option was set to "${_}" for ${C}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${I}", { "loose": ${_} }]
to the "plugins" section of your Babel config.

` + S(h)));
        }, t.isLoose = d, t.shouldTransform = function(h, m) {
          let E = null, _ = null, C = null, w = null, I = null;
          (0, n.hasOwnDecorators)(h.node) && (E = h.get("decorators.0"));
          for (const D of h.get("body.body")) !E && (0, n.hasOwnDecorators)(D.node) && (E = D.get("decorators.0")), !_ && D.isClassProperty() && (_ = D), !C && D.isClassPrivateProperty() && (C = D), !w && D.isClassPrivateMethod != null && D.isClassPrivateMethod() && (w = D), !I && D.isStaticBlock != null && D.isStaticBlock() && (I = D);
          if (E && C) throw C.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
          if (E && w) throw w.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
          if (E && !T(m, u.decorators)) throw h.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);
          if (w && !T(m, u.privateMethods)) throw w.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
          if ((_ || C) && !T(m, u.fields) && !T(m, u.privateMethods)) throw h.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
          if (I && !T(m, u.staticBlocks)) throw h.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
          return !!(E || w || I || (_ || C) && T(m, u.fields));
        };
        var n = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js");
        const u = t.FEATURES = Object.freeze({ fields: 2, privateMethods: 4, decorators: 8, privateIn: 16, staticBlocks: 32 }), c = /* @__PURE__ */ new Map([[u.fields, "@babel/plugin-transform-class-properties"], [u.privateMethods, "@babel/plugin-transform-private-methods"], [u.privateIn, "@babel/plugin-transform-private-property-in-object"]]), e = "@babel/plugin-class-features/featuresKey", r = "@babel/plugin-class-features/looseKey";
        var f = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing", y = function(h, m) {
          return !!(h.get(f) & m);
        };
        function S(h) {
          let { filename: m } = h.opts;
          return m && m !== "unknown" || (m = "[name of the input file]"), `If you already set the same 'loose' mode for these plugins in your config, it's possible that they are enabled multiple times with different options.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${m} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.`;
        }
        function T(h, m) {
          return !!(h.get(e) & m);
        }
        function d(h, m) {
          return !!(h.get(r) & m);
        }
        function p(h, m, E) {
          E ? h.set(r, h.get(r) | m) : h.set(r, h.get(r) & ~m), h.set(f, h.get(f) & ~m);
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.buildCheckInRHS = m, t.buildFieldsInitNodes = function(M, K, Q, ie, ue, ge, Te, le, fe, Pe) {
          var xe;
          let we, me = 0;
          const ye = [], pe = [];
          let J = false;
          const Ee = [];
          let Me = null;
          const Ue = n.types.isIdentifier(K) ? () => K : () => (we != null || (we = Q[0].scope.generateUidIdentifierBasedOnNode(K)), we), qe = (xe = M) != null ? xe : Q[0].scope.generateUidIdentifier((Pe == null ? void 0 : Pe.name) || "Class");
          M != null || (M = n.types.cloneNode(Pe));
          for (const He of Q) {
            He.isClassProperty() && S.assertFieldTransformed(He);
            const Ie = !(n.types.isStaticBlock != null && n.types.isStaticBlock(He.node)) && He.node.static, Re = !Ie, Be = He.isPrivate(), je = !Be, he = He.isProperty(), oe = !he, _e = He.isStaticBlock == null ? void 0 : He.isStaticBlock();
            switch (Ie && (me |= 1), (Ie || oe && Be || _e) && (new c.default({ methodPath: He, constantSuper: fe, file: ue, refToPreserve: Pe, getSuperRef: Ue, getObjectRef: () => (me |= 2, Ie || _e ? qe : n.types.memberExpression(qe, n.types.identifier("prototype"))) }).replace(), Z(He, qe, Pe) && (me |= 2)), J = false, true) {
              case _e: {
                const Ne = He.node.body;
                Ne.length === 1 && n.types.isExpressionStatement(Ne[0]) ? ye.push(B(Ne[0], He)) : ye.push(n.types.inheritsComments(n.template.statement.ast`(() => { ${Ne} })()`, He.node));
                break;
              }
              case (Ie && Be && he && Te):
                ye.push(L(n.types.cloneNode(M), He, ie));
                break;
              case (Ie && Be && he && !Te):
                T(ue) ? ye.push(N(He, ie, le)) : ye.push(F(He, ie));
                break;
              case (Ie && je && he && ge):
                if (!G(He.node)) {
                  ye.push(H(n.types.cloneNode(M), He));
                  break;
                }
              case (Ie && je && he && !ge):
                ye.push(U(n.types.cloneNode(M), He, ue));
                break;
              case (Re && Be && he && Te):
                pe.push(L(n.types.thisExpression(), He, ie));
                break;
              case (Re && Be && he && !Te):
                pe.push(k(n.types.thisExpression(), He, ie, ue));
                break;
              case (Re && Be && oe && Te):
                pe.unshift(W(n.types.thisExpression(), He, ie)), Ee.push(ee(ue, He, ie, Te));
                break;
              case (Re && Be && oe && !Te):
                pe.unshift(X(n.types.thisExpression(), He, ie, ue)), Ee.push(ee(ue, He, ie, Te));
                break;
              case (Ie && Be && oe && !Te):
                T(ue) || ye.unshift(F(He, ie)), Ee.push(ee(ue, He, ie, Te));
                break;
              case (Ie && Be && oe && Te):
                ye.unshift(q(n.types.cloneNode(M), He, ue, ie)), Ee.push(ee(ue, He, ie, Te));
                break;
              case (Re && je && he && ge):
                pe.push(H(n.types.thisExpression(), He));
                break;
              case (Re && je && he && !ge):
                J = true, pe.push(U(n.types.thisExpression(), He, ue));
                break;
              default:
                throw new Error("Unreachable.");
            }
          }
          return 2 & me && Pe != null && (Me = n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(qe), n.types.cloneNode(Pe)))), { staticNodes: ye.filter(Boolean), instanceNodes: pe.filter(Boolean), lastInstanceNodeReturnsThis: J, pureStaticNodes: Ee.filter(Boolean), classBindingNode: Me, wrapClass(He) {
            for (const Ie of Q) Ie.node.leadingComments = null, Ie.remove();
            return we && (He.scope.push({ id: n.types.cloneNode(we) }), He.set("superClass", n.types.assignmentExpression("=", we, He.node.superClass))), me !== 0 && (He.isClassExpression() ? (He.scope.push({ id: M }), He.replaceWith(n.types.assignmentExpression("=", n.types.cloneNode(M), He.node))) : (Pe == null && (He.node.id = M), Me != null && He.scope.push({ id: qe }))), He;
          } };
        }, t.buildPrivateNamesMap = function(M, K, Q, ie) {
          const ue = /* @__PURE__ */ new Map();
          let ge;
          for (const Te of Q) if (Te.isPrivate()) {
            const { name: le } = Te.node.key.id;
            let fe = ue.get(le);
            if (!fe) {
              const Pe = !Te.isProperty(), xe = Te.node.static;
              let we, me = false;
              !K && T(ie) && Pe && !xe ? (me = !!ge, ge != null || (ge = Te.scope.generateUidIdentifier(`${M}_brand`)), we = ge) : we = Te.scope.generateUidIdentifier(le), fe = { id: we, static: xe, method: Pe, initAdded: me }, ue.set(le, fe);
            }
            if (Te.isClassPrivateMethod()) if (Te.node.kind === "get") {
              const { body: Pe } = Te.node.body;
              let xe;
              Pe.length === 1 && n.types.isReturnStatement(xe = Pe[0]) && n.types.isCallExpression(xe = xe.argument) && xe.arguments.length === 1 && n.types.isThisExpression(xe.arguments[0]) && n.types.isIdentifier(xe = xe.callee) ? (fe.getId = n.types.cloneNode(xe), fe.getterDeclared = true) : fe.getId = Te.scope.generateUidIdentifier(`get_${le}`);
            } else if (Te.node.kind === "set") {
              const { params: Pe } = Te.node, { body: xe } = Te.node.body;
              let we;
              xe.length === 1 && n.types.isExpressionStatement(we = xe[0]) && n.types.isCallExpression(we = we.expression) && we.arguments.length === 2 && n.types.isThisExpression(we.arguments[0]) && n.types.isIdentifier(we.arguments[1], { name: Pe[0].name }) && n.types.isIdentifier(we = we.callee) ? (fe.setId = n.types.cloneNode(we), fe.setterDeclared = true) : fe.setId = Te.scope.generateUidIdentifier(`set_${le}`);
            } else Te.node.kind === "method" && (fe.methodId = Te.scope.generateUidIdentifier(le));
            ue.set(le, fe);
          }
          return ue;
        }, t.buildPrivateNamesNodes = function(M, K, Q, ie) {
          const ue = [], ge = /* @__PURE__ */ new Set();
          for (const [Te, le] of M) {
            const { static: fe, method: Pe, getId: xe, setId: we } = le, me = xe || we, ye = n.types.cloneNode(le.id);
            let pe;
            if (K) pe = n.types.callExpression(ie.addHelper("classPrivateFieldLooseKey"), [n.types.stringLiteral(Te)]);
            else if (Q) pe = n.types.callExpression(n.types.identifier("Symbol"), [n.types.stringLiteral(Te)]);
            else if (!fe) {
              if (ge.has(ye.name)) continue;
              ge.add(ye.name), pe = n.types.newExpression(n.types.identifier(!Pe || me && !T(ie) ? "WeakMap" : "WeakSet"), []);
            }
            pe && (Q || (0, f.default)(pe), ue.push(n.template.statement.ast`var ${ye} = ${pe}`));
          }
          return ue;
        }, t.privateNameVisitorFactory = d, t.transformPrivateNamesUsage = function(M, K, Q, { privateFieldsAsProperties: ie, noUninitializedPrivateFieldAccess: ue, noDocumentAll: ge, innerBinding: Te }, le) {
          if (!Q.size) return;
          const fe = K.get("body"), Pe = ie ? j : D;
          (0, e.default)(fe, p, Object.assign({ privateNamesMap: Q, classRef: M, file: le }, Pe, { noDocumentAll: ge, noUninitializedPrivateFieldAccess: ue, innerBinding: Te })), fe.traverse(E, { privateNamesMap: Q, classRef: M, file: le, privateFieldsAsProperties: ie, innerBinding: Te });
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js"), c = l("./node_modules/.pnpm/@babel+helper-replace-supers@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-replace-supers/lib/index.js"), e = l("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.25.9/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), r = l("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.25.9/node_modules/@babel/helper-optimise-call-expression/lib/index.js"), f = l("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.25.9/node_modules/@babel/helper-annotate-as-pure/lib/index.js"), y = l("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.25.9/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"), S = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js"), T = (M) => M.availableHelper("classPrivateFieldGet2");
        function d(M) {
          const K = u.visitors.environmentVisitor(Object.assign({}, M)), Q = Object.assign({}, M, { Class(ie) {
            const { privateNamesMap: ue } = this, ge = ie.get("body.body"), Te = new Map(ue), le = [];
            for (const fe of ge) {
              if (!fe.isPrivate()) continue;
              const { name: Pe } = fe.node.key.id;
              Te.delete(Pe), le.push(Pe);
            }
            le.length && (ie.get("body").traverse(K, Object.assign({}, this, { redeclared: le })), ie.traverse(Q, Object.assign({}, this, { privateNamesMap: Te })), ie.skipKey("body"));
          } });
          return Q;
        }
        const p = d({ PrivateName(M, { noDocumentAll: K }) {
          const { privateNamesMap: Q, redeclared: ie } = this, { node: ue, parentPath: ge } = M;
          if (!ge.isMemberExpression({ property: ue }) && !ge.isOptionalMemberExpression({ property: ue })) return;
          const { name: Te } = ue.id;
          Q.has(Te) && (ie != null && ie.includes(Te) || this.handle(ge, K));
        } });
        function h(M, K, Q) {
          for (; (ie = K) != null && ie.hasBinding(M) && !K.bindingIdentifierEquals(M, Q); ) {
            var ie;
            K.rename(M), K = K.parent;
          }
        }
        function m(M, K, Q) {
          return Q || K.availableHelper == null || !K.availableHelper("checkInRHS") ? M : n.types.callExpression(K.addHelper("checkInRHS"), [M]);
        }
        const E = d({ BinaryExpression(M, { file: K }) {
          const { operator: Q, left: ie, right: ue } = M.node;
          if (Q !== "in" || !n.types.isPrivateName(ie)) return;
          const { privateFieldsAsProperties: ge, privateNamesMap: Te, redeclared: le } = this, { name: fe } = ie.id;
          if (!Te.has(fe) || le != null && le.includes(fe)) return;
          if (h(this.classRef.name, M.scope, this.innerBinding), ge) {
            const { id: we } = Te.get(fe);
            return void M.replaceWith(n.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${m(ue, K)}, ${n.types.cloneNode(we)})
      `);
          }
          const { id: Pe, static: xe } = Te.get(fe);
          xe ? M.replaceWith(n.template.expression.ast`${m(ue, K)} === ${n.types.cloneNode(this.classRef)}`) : M.replaceWith(n.template.expression.ast`${n.types.cloneNode(Pe)}.has(${m(ue, K)})`);
        } });
        function _(M, K) {
          return n.types.callExpression(M.addHelper("readOnlyError"), [n.types.stringLiteral(`#${K}`)]);
        }
        function C(M, K) {
          return M.availableHelper("writeOnlyError") ? n.types.callExpression(M.addHelper("writeOnlyError"), [n.types.stringLiteral(`#${K}`)]) : (console.warn("@babel/helpers is outdated, update it to silence this warning."), n.types.buildUndefinedNode());
        }
        function w(M, K) {
          return K ? M : n.types.memberExpression(M, n.types.identifier("_"));
        }
        function I(M) {
          return function(K) {
            return n.types.inherits(M.apply(this, arguments), K.node);
          };
        }
        const D = { memoise(M, K) {
          const { scope: Q } = M, { object: ie } = M.node, ue = Q.maybeGenerateMemoised(ie);
          ue && this.memoiser.set(ie, ue, K);
        }, receiver(M) {
          const { object: K } = M.node;
          return this.memoiser.has(K) ? n.types.cloneNode(this.memoiser.get(K)) : n.types.cloneNode(K);
        }, get: I(function(M) {
          const { classRef: K, privateNamesMap: Q, file: ie, innerBinding: ue, noUninitializedPrivateFieldAccess: ge } = this, Te = M.node.property, { name: le } = Te.id, { id: fe, static: Pe, method: xe, methodId: we, getId: me, setId: ye } = Q.get(le), pe = me || ye, J = (Ee) => n.types.inherits(n.types.cloneNode(Ee), Te);
          if (Pe) {
            if (h(K.name, M.scope, ue), !T(ie)) {
              const Ue = xe && !pe ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
              return n.types.callExpression(ie.addHelper(Ue), [this.receiver(M), n.types.cloneNode(K), J(fe)]);
            }
            const Ee = this.receiver(M), Me = n.types.isIdentifier(Ee) && Ee.name === K.name;
            if (!xe) return w(Me ? J(fe) : n.types.callExpression(ie.addHelper("assertClassBrand"), [n.types.cloneNode(K), Ee, J(fe)]), ge);
            if (me) return Me ? n.types.callExpression(J(me), [Ee]) : n.types.callExpression(ie.addHelper("classPrivateGetter"), [n.types.cloneNode(K), Ee, J(me)]);
            if (ye) {
              const Ue = n.types.buildUndefinedNode();
              return Me ? Ue : n.types.sequenceExpression([n.types.callExpression(ie.addHelper("assertClassBrand"), [n.types.cloneNode(K), Ee]), Ue]);
            }
            return Me ? J(fe) : n.types.callExpression(ie.addHelper("assertClassBrand"), [n.types.cloneNode(K), Ee, J(fe)]);
          }
          return xe ? pe ? me ? T(ie) ? n.types.callExpression(ie.addHelper("classPrivateGetter"), [n.types.cloneNode(fe), this.receiver(M), J(me)]) : n.types.callExpression(ie.addHelper("classPrivateFieldGet"), [this.receiver(M), J(fe)]) : n.types.sequenceExpression([this.receiver(M), C(ie, le)]) : T(ie) ? n.types.callExpression(ie.addHelper("assertClassBrand"), [n.types.cloneNode(fe), this.receiver(M), J(we)]) : n.types.callExpression(ie.addHelper("classPrivateMethodGet"), [this.receiver(M), n.types.cloneNode(fe), J(we)]) : T(ie) ? n.types.callExpression(ie.addHelper("classPrivateFieldGet2"), [J(fe), this.receiver(M)]) : n.types.callExpression(ie.addHelper("classPrivateFieldGet"), [this.receiver(M), J(fe)]);
        }), boundGet(M) {
          return this.memoise(M, 1), n.types.callExpression(n.types.memberExpression(this.get(M), n.types.identifier("bind")), [this.receiver(M)]);
        }, set: I(function(M, K) {
          const { classRef: Q, privateNamesMap: ie, file: ue, noUninitializedPrivateFieldAccess: ge } = this, Te = M.node.property, { name: le } = Te.id, { id: fe, static: Pe, method: xe, setId: we, getId: me } = ie.get(le), ye = me || we, pe = (J) => n.types.inherits(n.types.cloneNode(J), Te);
          if (Pe) {
            if (!T(ue)) {
              const Me = xe && !ye ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
              return n.types.callExpression(ue.addHelper(Me), [this.receiver(M), n.types.cloneNode(Q), pe(fe), K]);
            }
            const J = this.receiver(M), Ee = n.types.isIdentifier(J) && J.name === Q.name;
            if (xe && !we) {
              const Me = _(ue, le);
              return Ee ? n.types.sequenceExpression([K, Me]) : n.types.sequenceExpression([K, n.types.callExpression(ue.addHelper("assertClassBrand"), [n.types.cloneNode(Q), J]), _(ue, le)]);
            }
            return we ? Ee ? n.types.callExpression(n.types.cloneNode(we), [J, K]) : n.types.callExpression(ue.addHelper("classPrivateSetter"), [n.types.cloneNode(Q), pe(we), J, K]) : n.types.assignmentExpression("=", w(pe(fe), ge), Ee ? K : n.types.callExpression(ue.addHelper("assertClassBrand"), [n.types.cloneNode(Q), J, K]));
          }
          return xe ? we ? T(ue) ? n.types.callExpression(ue.addHelper("classPrivateSetter"), [n.types.cloneNode(fe), pe(we), this.receiver(M), K]) : n.types.callExpression(ue.addHelper("classPrivateFieldSet"), [this.receiver(M), pe(fe), K]) : n.types.sequenceExpression([this.receiver(M), K, _(ue, le)]) : T(ue) ? n.types.callExpression(ue.addHelper("classPrivateFieldSet2"), [pe(fe), this.receiver(M), K]) : n.types.callExpression(ue.addHelper("classPrivateFieldSet"), [this.receiver(M), pe(fe), K]);
        }), destructureSet(M) {
          const { classRef: K, privateNamesMap: Q, file: ie, noUninitializedPrivateFieldAccess: ue } = this, ge = M.node.property, { name: Te } = ge.id, { id: le, static: fe, method: Pe, setId: xe } = Q.get(Te), we = (J) => n.types.inherits(n.types.cloneNode(J), ge);
          if (!T(ie)) {
            if (fe) {
              try {
                var me = ie.addHelper("classStaticPrivateFieldDestructureSet");
              } catch {
                throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
              }
              return n.types.memberExpression(n.types.callExpression(me, [this.receiver(M), n.types.cloneNode(K), we(le)]), n.types.identifier("value"));
            }
            return n.types.memberExpression(n.types.callExpression(ie.addHelper("classPrivateFieldDestructureSet"), [this.receiver(M), we(le)]), n.types.identifier("value"));
          }
          if (Pe && !xe) return n.types.memberExpression(n.types.sequenceExpression([M.node.object, _(ie, Te)]), n.types.identifier("_"));
          if (fe && !Pe) {
            const J = this.get(M);
            if (!ue || !n.types.isCallExpression(J)) return J;
            const Ee = J.arguments.pop();
            return J.arguments.push(n.template.expression.ast`(_) => ${Ee} = _`), n.types.memberExpression(n.types.callExpression(ie.addHelper("toSetter"), [J]), n.types.identifier("_"));
          }
          const ye = this.set(M, n.types.identifier("_"));
          if (!n.types.isCallExpression(ye) || !n.types.isIdentifier(ye.arguments[ye.arguments.length - 1], { name: "_" })) throw M.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github.com/babel/babel/issues.");
          let pe;
          return pe = n.types.isMemberExpression(ye.callee, { computed: false }) && n.types.isIdentifier(ye.callee.property) && ye.callee.property.name === "call" ? [ye.callee.object, n.types.arrayExpression(ye.arguments.slice(1, -1)), ye.arguments[0]] : [ye.callee, n.types.arrayExpression(ye.arguments.slice(0, -1))], n.types.memberExpression(n.types.callExpression(ie.addHelper("toSetter"), pe), n.types.identifier("_"));
        }, call(M, K) {
          return this.memoise(M, 1), (0, r.default)(this.get(M), this.receiver(M), K, false);
        }, optionalCall(M, K) {
          return this.memoise(M, 1), (0, r.default)(this.get(M), this.receiver(M), K, true);
        }, delete() {
          throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        } }, j = { get(M) {
          const { privateNamesMap: K, file: Q } = this, { object: ie } = M.node, { name: ue } = M.node.property.id;
          return n.template.expression`BASE(REF, PROP)[PROP]`({ BASE: Q.addHelper("classPrivateFieldLooseBase"), REF: n.types.cloneNode(ie), PROP: n.types.cloneNode(K.get(ue).id) });
        }, set() {
          throw new Error("private name handler with loose = true don't need set()");
        }, boundGet(M) {
          return n.types.callExpression(n.types.memberExpression(this.get(M), n.types.identifier("bind")), [n.types.cloneNode(M.node.object)]);
        }, simpleSet(M) {
          return this.get(M);
        }, destructureSet(M) {
          return this.get(M);
        }, call(M, K) {
          return n.types.callExpression(this.get(M), K);
        }, optionalCall(M, K) {
          return n.types.optionalCallExpression(this.get(M), K, true);
        }, delete() {
          throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        } };
        function L(M, K, Q) {
          const { id: ie } = Q.get(K.node.key.id.name), ue = K.node.value || K.scope.buildUndefinedNode();
          return B(n.template.statement.ast`
      Object.defineProperty(${M}, ${n.types.cloneNode(ie)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${ue}
      });
    `, K);
        }
        function k(M, K, Q, ie) {
          const { id: ue } = Q.get(K.node.key.id.name), ge = K.node.value || K.scope.buildUndefinedNode();
          if (!ie.availableHelper("classPrivateFieldInitSpec")) return B(n.template.statement.ast`${n.types.cloneNode(ue)}.set(${M}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${ge},
        })`, K);
          const Te = ie.addHelper("classPrivateFieldInitSpec");
          return z(B(n.types.expressionStatement(n.types.callExpression(Te, [n.types.thisExpression(), z(n.types.cloneNode(ue), K.node.key), T(ie) ? ge : n.template.expression.ast`{ writable: true, value: ${ge} }`])), K), K.node);
        }
        function N(M, K, Q) {
          const ie = K.get(M.node.key.id.name), ue = Q ? M.node.value : n.template.expression.ast`{
        _: ${M.node.value || n.types.buildUndefinedNode()}
      }`;
          return B(n.types.variableDeclaration("var", [n.types.variableDeclarator(n.types.cloneNode(ie.id), ue)]), M);
        }
        var F = function(M, K) {
          const Q = K.get(M.node.key.id.name), { id: ie, getId: ue, setId: ge, initAdded: Te } = Q, le = ue || ge;
          if (!M.isProperty() && (Te || !le)) return;
          if (le) return K.set(M.node.key.id.name, Object.assign({}, Q, { initAdded: true })), B(n.template.statement.ast`
          var ${n.types.cloneNode(ie)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${ue ? ue.name : M.scope.buildUndefinedNode()},
            set: ${ge ? ge.name : M.scope.buildUndefinedNode()}
          }
        `, M);
          const fe = M.node.value || M.scope.buildUndefinedNode();
          return B(n.template.statement.ast`
        var ${n.types.cloneNode(ie)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${fe}
        };
      `, M);
        };
        function W(M, K, Q) {
          const ie = Q.get(K.node.key.id.name), { methodId: ue, id: ge, getId: Te, setId: le, initAdded: fe } = ie;
          if (!fe) return ue ? B(n.template.statement.ast`
        Object.defineProperty(${M}, ${ge}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${ue.name}
        });
      `, K) : Te || le ? (Q.set(K.node.key.id.name, Object.assign({}, ie, { initAdded: true })), B(n.template.statement.ast`
        Object.defineProperty(${M}, ${ge}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${Te ? Te.name : K.scope.buildUndefinedNode()},
          set: ${le ? le.name : K.scope.buildUndefinedNode()}
        });
      `, K)) : void 0;
        }
        function X(M, K, Q, ie) {
          const ue = Q.get(K.node.key.id.name);
          if (!ue.initAdded) return !T(ie) && (ue.getId || ue.setId) ? function(ge, Te, le, fe) {
            const Pe = le.get(Te.node.key.id.name), { id: xe, getId: we, setId: me } = Pe;
            if (le.set(Te.node.key.id.name, Object.assign({}, Pe, { initAdded: true })), !fe.availableHelper("classPrivateFieldInitSpec")) return B(n.template.statement.ast`
          ${xe}.set(${ge}, {
            get: ${we ? we.name : Te.scope.buildUndefinedNode()},
            set: ${me ? me.name : Te.scope.buildUndefinedNode()}
          });
        `, Te);
            const ye = fe.addHelper("classPrivateFieldInitSpec");
            return z(B(n.template.statement.ast`${ye}(
      ${n.types.thisExpression()},
      ${n.types.cloneNode(xe)},
      {
        get: ${we ? we.name : Te.scope.buildUndefinedNode()},
        set: ${me ? me.name : Te.scope.buildUndefinedNode()}
      },
    )`, Te), Te.node);
          }(M, K, Q, ie) : function(ge, Te, le, fe) {
            const Pe = le.get(Te.node.key.id.name), { id: xe } = Pe;
            if (!fe.availableHelper("classPrivateMethodInitSpec")) return B(n.template.statement.ast`${xe}.add(${ge})`, Te);
            const we = fe.addHelper("classPrivateMethodInitSpec");
            return B(n.template.statement.ast`${we}(
      ${n.types.thisExpression()},
      ${n.types.cloneNode(xe)}
    )`, Te);
          }(M, K, Q, ie);
        }
        function H(M, K) {
          const { key: Q, computed: ie } = K.node, ue = K.node.value || K.scope.buildUndefinedNode();
          return B(n.types.expressionStatement(n.types.assignmentExpression("=", n.types.memberExpression(M, Q, ie || n.types.isLiteral(Q)), ue)), K);
        }
        function U(M, K, Q) {
          const { key: ie, computed: ue } = K.node, ge = K.node.value || K.scope.buildUndefinedNode();
          return B(n.types.expressionStatement(n.types.callExpression(Q.addHelper("defineProperty"), [M, ue || n.types.isLiteral(ie) ? ie : n.types.stringLiteral(ie.name), ge])), K);
        }
        function q(M, K, Q, ie) {
          const ue = ie.get(K.node.key.id.name), { id: ge, methodId: Te, getId: le, setId: fe, initAdded: Pe } = ue;
          if (!Pe) return le || fe ? (ie.set(K.node.key.id.name, Object.assign({}, ue, { initAdded: true })), B(n.template.statement.ast`
        Object.defineProperty(${M}, ${ge}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${le ? le.name : K.scope.buildUndefinedNode()},
          set: ${fe ? fe.name : K.scope.buildUndefinedNode()}
        })
      `, K)) : B(n.template.statement.ast`
      Object.defineProperty(${M}, ${ge}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${Te.name}
      });
    `, K);
        }
        function ee(M, K, Q, ie = false) {
          const ue = Q.get(K.node.key.id.name), { id: ge, methodId: Te, getId: le, setId: fe, getterDeclared: Pe, setterDeclared: xe, static: we } = ue, { params: me, body: ye, generator: pe, async: J } = K.node, Ee = le && me.length === 0, Me = fe && me.length > 0;
          if (Ee && Pe || Me && xe) return Q.set(K.node.key.id.name, Object.assign({}, ue, { initAdded: true })), null;
          if (T(M) && (Ee || Me) && !ie) {
            const qe = K.get("body").scope, He = qe.generateUidIdentifier("this"), Ie = { thisRef: He, argumentsPath: [] };
            if (K.traverse(re, Ie), Ie.argumentsPath.length) {
              const Re = qe.generateUidIdentifier("arguments");
              qe.push({ id: Re, init: n.template.expression.ast`[].slice.call(arguments, 1)` });
              for (const Be of Ie.argumentsPath) Be.replaceWith(n.types.cloneNode(Re));
            }
            me.unshift(n.types.cloneNode(He));
          }
          let Ue = Te;
          return Ee ? (Q.set(K.node.key.id.name, Object.assign({}, ue, { getterDeclared: true, initAdded: true })), Ue = le) : Me ? (Q.set(K.node.key.id.name, Object.assign({}, ue, { setterDeclared: true, initAdded: true })), Ue = fe) : we && !ie && (Ue = ge), B(n.types.functionDeclaration(n.types.cloneNode(Ue), me, ye, pe, J), K);
        }
        const re = u.visitors.environmentVisitor({ Identifier(M, K) {
          K.argumentsPath && M.node.name === "arguments" && K.argumentsPath.push(M);
        }, UnaryExpression(M) {
          const { node: K } = M;
          if (K.operator === "delete") {
            const Q = (0, y.skipTransparentExprWrapperNodes)(K.argument);
            n.types.isThisExpression(Q) && M.replaceWith(n.types.booleanLiteral(true));
          }
        }, ThisExpression(M, K) {
          K.needsClassRef = true, M.replaceWith(n.types.cloneNode(K.thisRef));
        }, MetaProperty(M) {
          const { node: K, scope: Q } = M;
          K.meta.name === "new" && K.property.name === "target" && M.replaceWith(Q.buildUndefinedNode());
        } }), Y = { ReferencedIdentifier(M, K) {
          M.scope.bindingIdentifierEquals(M.node.name, K.innerBinding) && (K.needsClassRef = true, M.node.name = K.thisRef.name);
        } };
        function Z(M, K, Q) {
          var ie;
          const ue = { thisRef: K, needsClassRef: false, innerBinding: Q };
          return M.isMethod() || M.traverse(re, ue), Q != null && (ie = ue.thisRef) != null && ie.name && ue.thisRef.name !== Q.name && M.traverse(Y, ue), ue.needsClassRef;
        }
        function G({ key: M, computed: K }) {
          return M.type === "Identifier" ? !K && (M.name === "name" || M.name === "length") : M.type === "StringLiteral" && (M.value === "name" || M.value === "length");
        }
        function B(M, K) {
          return n.types.inheritLeadingComments(M, K.node), n.types.inheritInnerComments(M, K.node), M;
        }
        function z(M, K) {
          return M.start = K.start, M.end = K.end, M.loc = K.loc, M;
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), Object.defineProperty(t, "FEATURES", { enumerable: true, get: function() {
          return y.FEATURES;
        } }), Object.defineProperty(t, "buildCheckInRHS", { enumerable: true, get: function() {
          return e.buildCheckInRHS;
        } }), t.createClassFeaturePlugin = function({ name: d, feature: p, loose: h, manipulateOptions: m, api: E, inherits: _, decoratorVersion: C }) {
          var w;
          if (p & y.FEATURES.decorators && (C === "2023-11" || C === "2023-05" || C === "2023-01" || C === "2022-03" || C === "2021-12")) return (0, u.default)(E, { loose: h }, C, _);
          E != null || (E = { assumption: () => {
          } });
          const I = E.assumption("setPublicClassFields"), D = E.assumption("privateFieldsAsSymbols"), j = E.assumption("privateFieldsAsProperties"), L = (w = E.assumption("noUninitializedPrivateFieldAccess")) != null && w, k = E.assumption("constantSuper"), N = E.assumption("noDocumentAll");
          if (j && D) throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
          const F = j || D;
          if (h === true) {
            const W = [];
            I !== void 0 && W.push('"setPublicClassFields"'), j !== void 0 && W.push('"privateFieldsAsProperties"'), D !== void 0 && W.push('"privateFieldsAsSymbols"'), W.length !== 0 && console.warn(`[${d}]: You are using the "loose: true" option and you are explicitly setting a value for the ${W.join(" and ")} assumption${W.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
          }
          return { name: d, manipulateOptions: m, inherits: _, pre(W) {
            (0, y.enableFeature)(W, p, h), typeof W.get(T) != "number" && W.get(T) && !c.lt(W.get(T), "7.25.9") || W.set(T, "7.25.9");
          }, visitor: { Class(W, { file: X }) {
            var H;
            if (X.get(T) !== "7.25.9" || !(0, y.shouldTransform)(W, X)) return;
            const U = W.isClassDeclaration();
            U && (0, S.assertFieldTransformed)(W);
            const q = (0, y.isLoose)(X, p);
            let ee;
            const re = (0, r.hasDecorators)(W.node), Y = [], Z = [], G = [], B = /* @__PURE__ */ new Set(), z = W.get("body");
            for (const ye of z.get("body")) {
              if ((ye.isClassProperty() || ye.isClassMethod()) && ye.node.computed && G.push(ye), ye.isPrivate()) {
                const { name: pe } = ye.node.key.id, J = `get ${pe}`, Ee = `set ${pe}`;
                if (ye.isClassPrivateMethod()) {
                  if (ye.node.kind === "get") {
                    if (B.has(J) || B.has(pe) && !B.has(Ee)) throw ye.buildCodeFrameError("Duplicate private field");
                    B.add(J).add(pe);
                  } else if (ye.node.kind === "set") {
                    if (B.has(Ee) || B.has(pe) && !B.has(J)) throw ye.buildCodeFrameError("Duplicate private field");
                    B.add(Ee).add(pe);
                  }
                } else {
                  if (B.has(pe) && !B.has(J) && !B.has(Ee) || B.has(pe) && (B.has(J) || B.has(Ee))) throw ye.buildCodeFrameError("Duplicate private field");
                  B.add(pe);
                }
              }
              ye.isClassMethod({ kind: "constructor" }) ? ee = ye : (Z.push(ye), (ye.isProperty() || ye.isPrivate() || ye.isStaticBlock != null && ye.isStaticBlock()) && Y.push(ye));
            }
            if (!Y.length && !re) return;
            const M = W.node.id;
            let K;
            M && U || (W.ensureFunctionName != null || (W.ensureFunctionName = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.ensureFunctionName), W.ensureFunctionName(false), K = W.scope.generateUidIdentifier((M == null ? void 0 : M.name) || "Class"));
            const Q = (H = K) != null ? H : n.types.cloneNode(M), ie = (0, e.buildPrivateNamesMap)(Q.name, F ?? q, Y, X), ue = (0, e.buildPrivateNamesNodes)(ie, j ?? q, D != null && D, X);
            let ge, Te, le, fe, Pe, xe, we;
            (0, e.transformPrivateNamesUsage)(Q, W, ie, { privateFieldsAsProperties: F ?? q, noUninitializedPrivateFieldAccess: L, noDocumentAll: N, innerBinding: M }, X), re ? (Te = Pe = ge = [], { instanceNodes: le, wrapClass: we } = (0, r.buildDecoratedClass)(Q, W, Z, X)) : (ge = (0, f.extractComputedKeys)(W, G, X), { staticNodes: Te, pureStaticNodes: Pe, instanceNodes: le, lastInstanceNodeReturnsThis: fe, classBindingNode: xe, wrapClass: we } = (0, e.buildFieldsInitNodes)(K, W.node.superClass, Y, ie, X, I ?? q, F ?? q, L, k ?? q, M)), le.length > 0 && (0, f.injectInitialization)(W, ee, le, (ye, pe) => {
              if (!re) for (const J of Y) n.types.isStaticBlock != null && n.types.isStaticBlock(J.node) || J.node.static || J.traverse(ye, pe);
            }, fe);
            const me = we(W);
            me.insertBefore([...ue, ...ge]), Te.length > 0 && me.insertAfter(Te), Pe.length > 0 && me.find((ye) => ye.isStatement() || ye.isDeclaration()).insertAfter(Pe), xe != null && U && me.insertAfter(xe);
          }, ExportDefaultDeclaration(W, { file: X }) {
            {
              if (X.get(T) !== "7.25.9") return;
              const H = W.get("declaration");
              H.isClassDeclaration() && (0, r.hasDecorators)(H.node) && (H.node.id ? (W.splitExportDeclaration != null || (W.splitExportDeclaration = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration), W.splitExportDeclaration()) : H.node.type = "ClassExpression");
            }
          } } };
        }, Object.defineProperty(t, "enableFeature", { enumerable: true, get: function() {
          return y.enableFeature;
        } }), Object.defineProperty(t, "injectInitialization", { enumerable: true, get: function() {
          return f.injectInitialization;
        } });
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"), c = l("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"), e = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"), r = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js"), f = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"), y = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/features.js"), S = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");
        const T = "@babel/plugin-class-features/version";
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.extractComputedKeys = function(y, S, T) {
          const { scope: d } = y, p = [], h = { classBinding: y.node.id && d.getBinding(y.node.id.name), file: T };
          for (const m of S) {
            const E = m.get("key");
            E.isReferencedIdentifier() ? e(E, h) : E.traverse(r, h);
            const _ = m.node;
            if (!E.isConstantExpression()) {
              const C = f(E.node, d, d.generateUidBasedOnNode(E.node));
              C && (p.push(n.types.expressionStatement(C)), _.key = n.types.cloneNode(C.left));
            }
          }
          return p;
        }, t.injectInitialization = function(y, S, T, d, p) {
          if (!T.length) return;
          const h = !!y.node.superClass;
          if (!S) {
            const m = n.types.classMethod("constructor", n.types.identifier("constructor"), [], n.types.blockStatement([]));
            h && (m.params = [n.types.restElement(n.types.identifier("args"))], m.body.body.push(n.template.statement.ast`super(...args)`)), [S] = y.get("body").unshiftContainer("body", m);
          }
          if (d && d(c, { scope: S.scope }), h) {
            const m = [];
            S.traverse(u, m);
            let E = true;
            for (const _ of m) if (E ? E = false : T = T.map((C) => n.types.cloneNode(C)), _.parentPath.isExpressionStatement()) _.insertAfter(T);
            else {
              const C = [_.node, ...T.map((w) => n.types.toExpression(w))];
              p || C.push(n.types.thisExpression()), _.replaceWith(n.types.sequenceExpression(C));
            }
          } else S.get("body").unshiftContainer("body", T);
        }, t.memoiseComputedKey = f;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");
        const u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").visitors.environmentVisitor({ Super(y) {
          const { node: S, parentPath: T } = y;
          T.isCallExpression({ callee: S }) && this.push(T);
        } }), c = { "TSTypeAnnotation|TypeAnnotation"(y) {
          y.skip();
        }, ReferencedIdentifier(y, { scope: S }) {
          S.hasOwnBinding(y.node.name) && (S.rename(y.node.name), y.skip());
        } };
        function e(y, S) {
          if (S.classBinding && S.classBinding === y.scope.getBinding(y.node.name)) {
            const T = S.file.addHelper("classNameTDZError"), d = n.types.callExpression(T, [n.types.stringLiteral(y.node.name)]);
            y.replaceWith(n.types.sequenceExpression([d, y.node])), y.skip();
          }
        }
        const r = { ReferencedIdentifier: e };
        function f(y, S, T) {
          if (!(n.types.isIdentifier(y) && S.hasUid(y.name))) {
            if (n.types.isAssignmentExpression(y, { operator: "=" }) && n.types.isIdentifier(y.left) && S.hasUid(y.left.name)) return n.types.cloneNode(y);
            {
              const d = n.types.identifier(T);
              return S.push({ id: d, kind: "let" }), n.types.assignmentExpression("=", n.types.cloneNode(d), y);
            }
          }
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.assertFieldTransformed = function(l) {
          if (l.node.declare) throw l.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`);
        };
      }, "./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.25.9/node_modules/@babel/helper-member-expression-to-functions/lib/index.js": (P, t, l) => {
        function n(U) {
          if (U && U.__esModule) return U;
          var q = /* @__PURE__ */ Object.create(null);
          return U && Object.keys(U).forEach(function(ee) {
            if (ee !== "default") {
              var re = Object.getOwnPropertyDescriptor(U, ee);
              Object.defineProperty(q, ee, re.get ? re : { enumerable: true, get: function() {
                return U[ee];
              } });
            }
          }), q.default = U, Object.freeze(q);
        }
        Object.defineProperty(t, "__esModule", { value: true });
        var u = n(l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"));
        function c(U) {
          const q = U, { node: ee, parentPath: re } = q;
          if (re.isLogicalExpression()) {
            const { operator: Y, right: Z } = re.node;
            if (Y === "&&" || Y === "||" || Y === "??" && ee === Z) return c(re);
          }
          if (re.isSequenceExpression()) {
            const { expressions: Y } = re.node;
            return Y[Y.length - 1] !== ee || c(re);
          }
          return re.isConditional({ test: ee }) || re.isUnaryExpression({ operator: "!" }) || re.isLoop({ test: ee });
        }
        const { LOGICAL_OPERATORS: e, arrowFunctionExpression: r, assignmentExpression: f, binaryExpression: y, booleanLiteral: S, callExpression: T, cloneNode: d, conditionalExpression: p, identifier: h, isMemberExpression: m, isOptionalCallExpression: E, isOptionalMemberExpression: _, isUpdateExpression: C, logicalExpression: w, memberExpression: I, nullLiteral: D, optionalCallExpression: j, optionalMemberExpression: L, sequenceExpression: k, updateExpression: N } = u;
        class F {
          constructor() {
            this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
          }
          has(q) {
            return this._map.has(q);
          }
          get(q) {
            if (!this.has(q)) return;
            const ee = this._map.get(q), { value: re } = ee;
            return ee.count--, ee.count === 0 ? f("=", re, q) : re;
          }
          set(q, ee, re) {
            return this._map.set(q, { count: re, value: ee });
          }
        }
        function W(U, q) {
          const { node: ee } = U;
          if (_(ee)) return I(q, ee.property, ee.computed);
          if (U.isOptionalCallExpression()) {
            const re = U.get("callee");
            if (U.node.optional && re.isOptionalMemberExpression()) {
              const Y = re.node.object, Z = U.scope.maybeGenerateMemoised(Y);
              return re.get("object").replaceWith(f("=", Z, Y)), T(I(q, h("call")), [Z, ...U.node.arguments]);
            }
            return T(q, U.node.arguments);
          }
          return U.node;
        }
        const X = { memoise() {
        }, handle(U, q) {
          const { node: ee, parent: re, parentPath: Y, scope: Z } = U;
          if (U.isOptionalMemberExpression()) {
            if (function(pe) {
              for (; pe && !pe.isProgram(); ) {
                const { parentPath: J, container: Ee, listKey: Me } = pe, Ue = J.node;
                if (Me) {
                  if (Ee !== Ue[Me]) return true;
                } else if (Ee !== Ue) return true;
                pe = J;
              }
              return false;
            }(U)) return;
            const G = U.find(({ node: pe, parent: J }) => _(J) ? J.optional || J.object !== pe : !E(J) || pe !== U.node && J.optional || J.callee !== pe);
            if (Z.path.isPattern()) return void G.replaceWith(T(r([], G.node), []));
            const B = c(G), z = G.parentPath;
            if (z.isUpdateExpression({ argument: ee })) throw U.buildCodeFrameError("can't handle update expression");
            const M = z.isAssignmentExpression({ left: G.node }), K = z.isUnaryExpression({ operator: "delete" });
            if (K && G.isOptionalMemberExpression() && G.get("property").isPrivateName()) throw U.buildCodeFrameError("can't delete a private class element");
            let Q = U;
            for (; ; ) if (Q.isOptionalMemberExpression()) {
              if (Q.node.optional) break;
              Q = Q.get("object");
            } else {
              if (!Q.isOptionalCallExpression()) throw new Error(`Internal error: unexpected ${Q.node.type}`);
              if (Q.node.optional) break;
              Q = Q.get("callee");
            }
            const ie = Q.isOptionalMemberExpression() ? Q.node.object : Q.node.callee, ue = Z.maybeGenerateMemoised(ie), ge = ue ?? ie, Te = Y.isOptionalCallExpression({ callee: ee }), le = (pe) => Te, fe = Y.isCallExpression({ callee: ee });
            Q.replaceWith(W(Q, ge)), le() ? re.optional ? Y.replaceWith(this.optionalCall(U, re.arguments)) : Y.replaceWith(this.call(U, re.arguments)) : fe ? U.replaceWith(this.boundGet(U)) : this.delete && Y.isUnaryExpression({ operator: "delete" }) ? Y.replaceWith(this.delete(U)) : Y.isAssignmentExpression() ? H(this, U, Y) : U.replaceWith(this.get(U));
            let Pe, xe = U.node;
            for (let pe = U; pe !== G; ) {
              const J = pe.parentPath;
              if (J === G && le() && re.optional) {
                xe = J.node;
                break;
              }
              xe = W(J, xe), pe = J;
            }
            const we = G.parentPath;
            if (m(xe) && we.isOptionalCallExpression({ callee: G.node, optional: true })) {
              const { object: pe } = xe;
              Pe = U.scope.maybeGenerateMemoised(pe), Pe && (xe.object = f("=", Pe, pe));
            }
            let me = G;
            (K || M) && (me = we, xe = we.node);
            const ye = ue ? f("=", d(ge), d(ie)) : d(ge);
            if (B) {
              let pe;
              pe = q ? y("!=", ye, D()) : w("&&", y("!==", ye, D()), y("!==", d(ge), Z.buildUndefinedNode())), me.replaceWith(w("&&", pe, xe));
            } else {
              let pe;
              pe = q ? y("==", ye, D()) : w("||", y("===", ye, D()), y("===", d(ge), Z.buildUndefinedNode())), me.replaceWith(p(pe, K ? S(true) : Z.buildUndefinedNode(), xe));
            }
            if (Pe) {
              const pe = we.node;
              we.replaceWith(j(L(pe.callee, h("call"), false, true), [d(Pe), ...pe.arguments], false));
            }
          } else {
            if (C(re, { argument: ee })) {
              if (this.simpleSet) return void U.replaceWith(this.simpleSet(U));
              const { operator: G, prefix: B } = re;
              this.memoise(U, 2);
              const z = Z.generateUidIdentifierBasedOnNode(ee);
              Z.push({ id: z });
              const M = [f("=", d(z), this.get(U))];
              if (B) {
                M.push(N(G, d(z), B));
                const K = k(M);
                return void Y.replaceWith(this.set(U, K));
              }
              {
                const K = Z.generateUidIdentifierBasedOnNode(ee);
                Z.push({ id: K }), M.push(f("=", d(K), N(G, d(z), B)), d(z));
                const Q = k(M);
                return void Y.replaceWith(k([this.set(U, Q), d(K)]));
              }
            }
            if (Y.isAssignmentExpression({ left: ee })) H(this, U, Y);
            else {
              if (!Y.isCallExpression({ callee: ee })) return Y.isOptionalCallExpression({ callee: ee }) ? Z.path.isPattern() ? void Y.replaceWith(T(r([], Y.node), [])) : void Y.replaceWith(this.optionalCall(U, Y.node.arguments)) : void (this.delete && Y.isUnaryExpression({ operator: "delete" }) ? Y.replaceWith(this.delete(U)) : Y.isForXStatement({ left: ee }) || Y.isObjectProperty({ value: ee }) && Y.parentPath.isObjectPattern() || Y.isAssignmentPattern({ left: ee }) && Y.parentPath.isObjectProperty({ value: re }) && Y.parentPath.parentPath.isObjectPattern() || Y.isArrayPattern() || Y.isAssignmentPattern({ left: ee }) && Y.parentPath.isArrayPattern() || Y.isRestElement() ? U.replaceWith(this.destructureSet(U)) : Y.isTaggedTemplateExpression() ? U.replaceWith(this.boundGet(U)) : U.replaceWith(this.get(U)));
              Y.replaceWith(this.call(U, Y.node.arguments));
            }
          }
        } };
        function H(U, q, ee) {
          if (U.simpleSet) return void q.replaceWith(U.simpleSet(q));
          const { operator: re, right: Y } = ee.node;
          if (re === "=") ee.replaceWith(U.set(q, Y));
          else {
            const Z = re.slice(0, -1);
            e.includes(Z) ? (U.memoise(q, 1), ee.replaceWith(w(Z, U.get(q), U.set(q, Y)))) : (U.memoise(q, 2), ee.replaceWith(U.set(q, y(Z, U.get(q), Y))));
          }
        }
        t.default = function(U, q, ee) {
          U.traverse(q, Object.assign({}, X, ee, { memoiser: new F() }));
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/import-builder.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("assert"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { callExpression: c, cloneNode: e, expressionStatement: r, identifier: f, importDeclaration: y, importDefaultSpecifier: S, importNamespaceSpecifier: T, importSpecifier: d, memberExpression: p, stringLiteral: h, variableDeclaration: m, variableDeclarator: E } = u;
        t.default = class {
          constructor(_, C, w) {
            this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = C, this._hub = w, this._importedSource = _;
          }
          done() {
            return { statements: this._statements, resultName: this._resultName };
          }
          import() {
            return this._statements.push(y([], h(this._importedSource))), this;
          }
          require() {
            return this._statements.push(r(c(f("require"), [h(this._importedSource)]))), this;
          }
          namespace(_ = "namespace") {
            const C = this._scope.generateUidIdentifier(_), w = this._statements[this._statements.length - 1];
            return n(w.type === "ImportDeclaration"), n(w.specifiers.length === 0), w.specifiers = [T(C)], this._resultName = e(C), this;
          }
          default(_) {
            const C = this._scope.generateUidIdentifier(_), w = this._statements[this._statements.length - 1];
            return n(w.type === "ImportDeclaration"), n(w.specifiers.length === 0), w.specifiers = [S(C)], this._resultName = e(C), this;
          }
          named(_, C) {
            if (C === "default") return this.default(_);
            const w = this._scope.generateUidIdentifier(_), I = this._statements[this._statements.length - 1];
            return n(I.type === "ImportDeclaration"), n(I.specifiers.length === 0), I.specifiers = [d(w, f(C))], this._resultName = e(w), this;
          }
          var(_) {
            const C = this._scope.generateUidIdentifier(_);
            let w = this._statements[this._statements.length - 1];
            return w.type !== "ExpressionStatement" && (n(this._resultName), w = r(this._resultName), this._statements.push(w)), this._statements[this._statements.length - 1] = m("var", [E(C, w.expression)]), this._resultName = e(C), this;
          }
          defaultInterop() {
            return this._interop(this._hub.addHelper("interopRequireDefault"));
          }
          wildcardInterop() {
            return this._interop(this._hub.addHelper("interopRequireWildcard"));
          }
          _interop(_) {
            const C = this._statements[this._statements.length - 1];
            return C.type === "ExpressionStatement" ? C.expression = c(_, [C.expression]) : C.type === "VariableDeclaration" ? (n(C.declarations.length === 1), C.declarations[0].init = c(_, [C.declarations[0].init])) : n.fail("Unexpected type."), this;
          }
          prop(_) {
            const C = this._statements[this._statements.length - 1];
            return C.type === "ExpressionStatement" ? C.expression = p(C.expression, f(_)) : C.type === "VariableDeclaration" ? (n(C.declarations.length === 1), C.declarations[0].init = p(C.declarations[0].init, f(_))) : n.fail("Unexpected type:" + C.type), this;
          }
          read(_) {
            this._resultName = p(this._resultName, f(_));
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/import-injector.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("assert"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), c = l("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/import-builder.js"), e = l("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/is-module.js");
        const { identifier: r, importSpecifier: f, numericLiteral: y, sequenceExpression: S, isImportDeclaration: T } = u;
        function d(E) {
          return E.importKind !== "type" && E.importKind !== "typeof";
        }
        function p(E) {
          return E.specifiers.length === 1 && E.specifiers[0].type === "ImportNamespaceSpecifier" || E.specifiers.length === 2 && E.specifiers[1].type === "ImportNamespaceSpecifier";
        }
        function h(E) {
          return E.specifiers.length > 0 && E.specifiers[0].type === "ImportDefaultSpecifier";
        }
        function m(E, _) {
          return E.specifiers.length ? !_.specifiers.length || !p(E) && !p(_) && (h(_) && (h(E) ? _.specifiers[0] = f(_.specifiers[0].local, r("default")) : E.specifiers.unshift(_.specifiers.shift())), E.specifiers.push(..._.specifiers), true) : (E.specifiers = _.specifiers, true);
        }
        t.default = class {
          constructor(E, _, C) {
            this._defaultOpts = { importedSource: null, importedType: "commonjs", importedInterop: "babel", importingInterop: "babel", ensureLiveReference: false, ensureNoContext: false, importPosition: "before" };
            const w = E.find((I) => I.isProgram());
            this._programPath = w, this._programScope = w.scope, this._hub = w.hub, this._defaultOpts = this._applyDefaults(_, C, true);
          }
          addDefault(E, _) {
            return this.addNamed("default", E, _);
          }
          addNamed(E, _, C) {
            return n(typeof E == "string"), this._generateImport(this._applyDefaults(_, C), E);
          }
          addNamespace(E, _) {
            return this._generateImport(this._applyDefaults(E, _), null);
          }
          addSideEffect(E, _) {
            return this._generateImport(this._applyDefaults(E, _), void 0);
          }
          _applyDefaults(E, _, C = false) {
            let w;
            return typeof E == "string" ? w = Object.assign({}, this._defaultOpts, { importedSource: E }, _) : (n(!_, "Unexpected secondary arguments."), w = Object.assign({}, this._defaultOpts, E)), !C && _ && (_.nameHint !== void 0 && (w.nameHint = _.nameHint), _.blockHoist !== void 0 && (w.blockHoist = _.blockHoist)), w;
          }
          _generateImport(E, _) {
            const C = _ === "default", w = !!_ && !C, I = _ === null, { importedSource: D, importedType: j, importedInterop: L, importingInterop: k, ensureLiveReference: N, ensureNoContext: F, nameHint: W, importPosition: X, blockHoist: H } = E;
            let U = W || _;
            const q = (0, e.default)(this._programPath), ee = q && k === "node", re = q && k === "babel";
            if (X === "after" && !q) throw new Error('"importPosition": "after" is only supported in modules');
            const Y = new c.default(D, this._programScope, this._hub);
            if (j === "es6") {
              if (!ee && !re) throw new Error("Cannot import an ES6 module from CommonJS");
              Y.import(), I ? Y.namespace(W || D) : (C || w) && Y.named(U, _);
            } else {
              if (j !== "commonjs") throw new Error(`Unexpected interopType "${j}"`);
              if (L === "babel") if (ee) {
                U = U !== "default" ? U : D;
                const B = `${D}$es6Default`;
                Y.import(), I ? Y.default(B).var(U || D).wildcardInterop() : C ? N ? Y.default(B).var(U || D).defaultInterop().read("default") : Y.default(B).var(U).defaultInterop().prop(_) : w && Y.default(B).read(_);
              } else re ? (Y.import(), I ? Y.namespace(U || D) : (C || w) && Y.named(U, _)) : (Y.require(), I ? Y.var(U || D).wildcardInterop() : (C || w) && N ? C ? (U = U !== "default" ? U : D, Y.var(U).read(_), Y.defaultInterop()) : Y.var(D).read(_) : C ? Y.var(U).defaultInterop().prop(_) : w && Y.var(U).prop(_));
              else if (L === "compiled") ee ? (Y.import(), I ? Y.default(U || D) : (C || w) && Y.default(D).read(U)) : re ? (Y.import(), I ? Y.namespace(U || D) : (C || w) && Y.named(U, _)) : (Y.require(), I ? Y.var(U || D) : (C || w) && (N ? Y.var(D).read(U) : Y.prop(_).var(U)));
              else {
                if (L !== "uncompiled") throw new Error(`Unknown importedInterop "${L}".`);
                if (C && N) throw new Error("No live reference for commonjs default");
                ee ? (Y.import(), I ? Y.default(U || D) : C ? Y.default(U) : w && Y.default(D).read(U)) : re ? (Y.import(), I ? Y.default(U || D) : C ? Y.default(U) : w && Y.named(U, _)) : (Y.require(), I ? Y.var(U || D) : C ? Y.var(U) : w && (N ? Y.var(D).read(U) : Y.var(U).prop(_)));
              }
            }
            const { statements: Z, resultName: G } = Y.done();
            return this._insertStatements(Z, X, H), (C || w) && F && G.type !== "Identifier" ? S([y(0), G]) : G;
          }
          _insertStatements(E, _ = "before", C = 3) {
            if (_ === "after") {
              if (this._insertStatementsAfter(E)) return;
            } else if (this._insertStatementsBefore(E, C)) return;
            this._programPath.unshiftContainer("body", E);
          }
          _insertStatementsBefore(E, _) {
            if (E.length === 1 && T(E[0]) && d(E[0])) {
              const w = this._programPath.get("body").find((I) => I.isImportDeclaration() && d(I.node));
              if ((w == null ? void 0 : w.node.source.value) === E[0].source.value && m(w.node, E[0])) return true;
            }
            E.forEach((w) => {
              w._blockHoist = _;
            });
            const C = this._programPath.get("body").find((w) => {
              const I = w.node._blockHoist;
              return Number.isFinite(I) && I < 4;
            });
            return !!C && (C.insertBefore(E), true);
          }
          _insertStatementsAfter(E) {
            const _ = new Set(E), C = /* @__PURE__ */ new Map();
            for (const I of E) if (T(I) && d(I)) {
              const D = I.source.value;
              C.has(D) || C.set(D, []), C.get(D).push(I);
            }
            let w = null;
            for (const I of this._programPath.get("body")) if (I.isImportDeclaration() && d(I.node)) {
              w = I;
              const D = I.node.source.value, j = C.get(D);
              if (!j) continue;
              for (const L of j) _.has(L) && m(I.node, L) && _.delete(L);
            }
            return _.size === 0 || (w && w.insertAfter(Array.from(_)), !!w);
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), Object.defineProperty(t, "ImportInjector", { enumerable: true, get: function() {
          return n.default;
        } }), t.addDefault = function(c, e, r) {
          return new n.default(c).addDefault(e, r);
        }, t.addNamed = function(c, e, r, f) {
          return new n.default(c).addNamed(e, r, f);
        }, t.addNamespace = function(c, e, r) {
          return new n.default(c).addNamespace(e, r);
        }, t.addSideEffect = function(c, e, r) {
          return new n.default(c).addSideEffect(e, r);
        }, Object.defineProperty(t, "isModule", { enumerable: true, get: function() {
          return u.default;
        } });
        var n = l("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/import-injector.js"), u = l("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/is-module.js");
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/is-module.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(l) {
          return l.node.sourceType === "module";
        };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.buildDynamicImport = function(u, c, e, r) {
          const f = n.types.isCallExpression(u) ? u.arguments[0] : u.source;
          if (n.types.isStringLiteral(f) || n.types.isTemplateLiteral(f) && f.quasis.length === 0) return c ? n.template.expression.ast`
        Promise.resolve().then(() => ${r(f)})
      ` : r(f);
          const y = n.types.isTemplateLiteral(f) ? n.types.identifier("specifier") : n.types.templateLiteral([n.types.templateElement({ raw: "" }), n.types.templateElement({ raw: "" })], [n.types.identifier("specifier")]);
          return c ? n.template.expression.ast`
      (specifier =>
        new Promise(r => r(${y}))
          .then(s => ${r(n.types.identifier("s"))})
      )(${f})
    ` : e ? n.template.expression.ast`
      (specifier =>
        new Promise(r => r(${r(y)}))
      )(${f})
    ` : n.template.expression.ast`
      (specifier => ${r(y)})(${f})
    `;
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");
        t.getDynamicImportSource = function(u) {
          const [c] = u.arguments;
          return n.types.isStringLiteral(c) || n.types.isTemplateLiteral(c) ? c : n.template.expression.ast`\`\${${c}}\``;
        };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/get-module-name.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = l;
        {
          const n = l;
          t.default = l = function(u, c) {
            var e, r, f, y;
            return n(u, { moduleId: (e = c.moduleId) != null ? e : u.moduleId, moduleIds: (r = c.moduleIds) != null ? r : u.moduleIds, getModuleId: (f = c.getModuleId) != null ? f : u.getModuleId, moduleRoot: (y = c.moduleRoot) != null ? y : u.moduleRoot });
          };
        }
        function l(n, u) {
          const { filename: c, filenameRelative: e = c, sourceRoot: r = u.moduleRoot } = n, { moduleId: f, moduleIds: y = !!f, getModuleId: S, moduleRoot: T = r } = u;
          if (!y) return null;
          if (f != null && !S) return f;
          let d = T != null ? T + "/" : "";
          if (e) {
            const p = r != null ? new RegExp("^" + r + "/?") : "";
            d += e.replace(p, "").replace(/\.\w*$/, "");
          }
          return d = d.replace(/\\/g, "/"), S && S(d) || d;
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), Object.defineProperty(t, "buildDynamicImport", { enumerable: true, get: function() {
          return S.buildDynamicImport;
        } }), t.buildNamespaceInitStatements = function(E, _, C = false, w = y.wrapReference) {
          var I;
          const D = [], j = u.types.identifier(_.name);
          for (const k of _.importsNamespace) k !== _.name && D.push(u.template.statement`var NAME = SOURCE;`({ NAME: k, SOURCE: u.types.cloneNode(j) }));
          const L = (I = w(j, _.wrap)) != null ? I : j;
          C && D.push(...p(E, _, true, w));
          for (const k of _.reexportNamespace) D.push((u.types.isIdentifier(L) ? u.template.statement`EXPORTS.NAME = NAMESPACE;` : u.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({ EXPORTS: E.exportName, NAME: k, NAMESPACE: u.types.cloneNode(L) }));
          if (_.reexportAll) {
            const k = function(N, F, W) {
              return (W ? u.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : u.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({ NAMESPACE: F, EXPORTS: N.exportName, VERIFY_NAME_LIST: N.exportNameListName ? u.template`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: N.exportNameListName }) : null });
            }(E, u.types.cloneNode(L), C);
            k.loc = _.reexportAll.loc, D.push(k);
          }
          return D;
        }, t.ensureStatementsHoisted = function(E) {
          E.forEach((_) => {
            _._blockHoist = 3;
          });
        }, Object.defineProperty(t, "getModuleName", { enumerable: true, get: function() {
          return T.default;
        } }), Object.defineProperty(t, "hasExports", { enumerable: true, get: function() {
          return f.hasExports;
        } }), Object.defineProperty(t, "isModule", { enumerable: true, get: function() {
          return c.isModule;
        } }), Object.defineProperty(t, "isSideEffectImport", { enumerable: true, get: function() {
          return f.isSideEffectImport;
        } }), t.rewriteModuleStatementsAndPrepareHeader = function(E, { exportName: _, strict: C, allowTopLevelThis: w, strictMode: I, noInterop: D, importInterop: j = D ? "none" : "babel", lazy: L, getWrapperPayload: k = y.toGetWrapperPayload(L != null && L), wrapReference: N = y.wrapReference, esNamespaceOnly: F, filename: W, constantReexports: X = arguments[1].loose, enumerableModuleMeta: H = arguments[1].loose, noIncompleteNsImportDetection: U }) {
          (0, f.validateImportInteropOption)(j), n((0, c.isModule)(E), "Cannot process module statements in a script"), E.node.sourceType = "script";
          const q = (0, f.default)(E, _, { importInterop: j, initializeReexports: X, getWrapperPayload: k, esNamespaceOnly: F, filename: W });
          w || (0, e.default)(E), (0, r.default)(E, q, N), I !== false && (E.node.directives.some((Y) => Y.value.value === "use strict") || E.unshiftContainer("directives", u.types.directive(u.types.directiveLiteral("use strict"))));
          const ee = [];
          (0, f.hasExports)(q) && !C && ee.push(function(Y, Z = false) {
            return (Z ? u.template.statement`
        EXPORTS.__esModule = true;
      ` : u.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({ EXPORTS: Y.exportName });
          }(q, H));
          const re = function(Y, Z) {
            const G = /* @__PURE__ */ Object.create(null);
            for (const M of Z.local.values()) for (const K of M.names) G[K] = true;
            let B = false;
            for (const M of Z.source.values()) {
              for (const K of M.reexports.keys()) G[K] = true;
              for (const K of M.reexportNamespace) G[K] = true;
              B = B || !!M.reexportAll;
            }
            if (!B || Object.keys(G).length === 0) return null;
            const z = Y.scope.generateUidIdentifier("exportNames");
            return delete G.default, { name: z.name, statement: u.types.variableDeclaration("var", [u.types.variableDeclarator(z, u.types.valueToNode(G))]) };
          }(E, q);
          return re && (q.exportNameListName = re.name, ee.push(re.statement)), ee.push(...function(Y, Z, G, B = false, z = false) {
            const M = [];
            for (const [Q, ie] of Z.local) if (ie.kind !== "import") {
              if (ie.kind === "hoisted") M.push([ie.names[0], m(Z, ie.names, u.types.identifier(Q))]);
              else if (!z) for (const ue of ie.names) M.push([ue, null]);
            }
            for (const Q of Z.source.values()) {
              if (!B) {
                const ie = p(Z, Q, false, G), ue = [...Q.reexports.keys()];
                for (let ge = 0; ge < ie.length; ge++) M.push([ue[ge], ie[ge]]);
              }
              if (!z) for (const ie of Q.reexportNamespace) M.push([ie, null]);
            }
            M.sort(([Q], [ie]) => Q < ie ? -1 : ie < Q ? 1 : 0);
            const K = [];
            if (z) for (const [, Q] of M) K.push(Q);
            else for (let ie = 0; ie < M.length; ie += 100) {
              let ue = [];
              for (let ge = 0; ge < 100 && ie + ge < M.length; ge++) {
                const [Te, le] = M[ie + ge];
                le !== null ? (ue.length > 0 && (K.push(m(Z, ue, Y.scope.buildUndefinedNode())), ue = []), K.push(le)) : ue.push(Te);
              }
              ue.length > 0 && K.push(m(Z, ue, Y.scope.buildUndefinedNode()));
            }
            return K;
          }(E, q, N, X, U)), { meta: q, headers: ee };
        }, Object.defineProperty(t, "rewriteThis", { enumerable: true, get: function() {
          return e.default;
        } }), t.wrapInterop = function(E, _, C) {
          if (C === "none") return null;
          if (C === "node-namespace") return u.types.callExpression(E.hub.addHelper("interopRequireWildcard"), [_, u.types.booleanLiteral(true)]);
          if (C === "node-default") return null;
          let w;
          if (C === "default") w = "interopRequireDefault";
          else {
            if (C !== "namespace") throw new Error(`Unknown interop: ${C}`);
            w = "interopRequireWildcard";
          }
          return u.types.callExpression(E.hub.addHelper(w), [_]);
        };
        var n = l("assert"), u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), c = l("./node_modules/.pnpm/@babel+helper-module-imports@7.25.9/node_modules/@babel/helper-module-imports/lib/index.js"), e = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"), r = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"), f = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"), y = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js"), S = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js"), T = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/get-module-name.js");
        t.getDynamicImportSource = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js").getDynamicImportSource;
        const d = { constant: ({ exports: E, exportName: _, namespaceImport: C }) => u.template.statement.ast`
      ${E}.${_} = ${C};
    `, constantComputed: ({ exports: E, exportName: _, namespaceImport: C }) => u.template.statement.ast`
      ${E}["${_}"] = ${C};
    `, spec: ({ exports: E, exportName: _, namespaceImport: C }) => u.template.statement.ast`
      Object.defineProperty(${E}, "${_}", {
        enumerable: true,
        get: function() {
          return ${C};
        },
      });
    ` };
        function p(E, _, C, w) {
          var I;
          let D = u.types.identifier(_.name);
          D = (I = w(D, _.wrap)) != null ? I : D;
          const { stringSpecifiers: j } = E;
          return Array.from(_.reexports, ([L, k]) => {
            let N = u.types.cloneNode(D);
            k === "default" && _.interop === "node-default" || (N = j.has(k) ? u.types.memberExpression(N, u.types.stringLiteral(k), true) : u.types.memberExpression(N, u.types.identifier(k)));
            const F = { exports: E.exportName, exportName: L, namespaceImport: N };
            return C || u.types.isIdentifier(N) ? j.has(L) ? d.constantComputed(F) : d.constant(F) : d.spec(F);
          });
        }
        const h = { computed: ({ exports: E, name: _, value: C }) => u.template.expression.ast`${E}["${_}"] = ${C}`, default: ({ exports: E, name: _, value: C }) => u.template.expression.ast`${E}.${_} = ${C}`, define: ({ exports: E, name: _, value: C }) => u.template.expression.ast`
      Object.defineProperty(${E}, "${_}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${_}"] = ${C}` };
        function m(E, _, C) {
          const { stringSpecifiers: w, exportName: I } = E;
          return u.types.expressionStatement(_.reduce((D, j) => {
            const L = { exports: I, name: j, value: D };
            return j === "__proto__" ? h.define(L) : w.has(j) ? h.computed(L) : h.default(L);
          }, C));
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.toGetWrapperPayload = function(c) {
          return (e, r) => {
            if (c === false || (0, u.isSideEffectImport)(r) || r.reexportAll) return null;
            if (c === true) return e.includes(".") ? null : "lazy";
            if (Array.isArray(c)) return c.includes(e) ? "lazy" : null;
            if (typeof c == "function") return c(e) ? "lazy" : null;
            throw new Error(".lazy must be a boolean, string array, or function");
          };
        }, t.wrapReference = function(c, e) {
          return e === "lazy" ? n.types.callExpression(c, []) : null;
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js");
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(y, S, { importInterop: T, initializeReexports: d = false, getWrapperPayload: p, esNamespaceOnly: h = false, filename: m }) {
          S || (S = y.scope.generateUidIdentifier("exports").name);
          const E = /* @__PURE__ */ new Set();
          (function(I) {
            I.get("body").forEach((D) => {
              D.isExportDefaultDeclaration() && (D.splitExportDeclaration != null || (D.splitExportDeclaration = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration), D.splitExportDeclaration());
            });
          })(y);
          const { local: _, sources: C, hasExports: w } = function(I, { getWrapperPayload: D, initializeReexports: j }, L) {
            const k = function(H, U, q) {
              const ee = /* @__PURE__ */ new Map();
              H.get("body").forEach((Z) => {
                let G;
                if (Z.isImportDeclaration()) G = "import";
                else {
                  if (Z.isExportDefaultDeclaration() && (Z = Z.get("declaration")), Z.isExportNamedDeclaration()) {
                    if (Z.node.declaration) Z = Z.get("declaration");
                    else if (U && Z.node.source && Z.get("source").isStringLiteral()) return void Z.get("specifiers").forEach((B) => {
                      f(B), ee.set(B.get("local").node.name, "block");
                    });
                  }
                  if (Z.isFunctionDeclaration()) G = "hoisted";
                  else if (Z.isClassDeclaration()) G = "block";
                  else if (Z.isVariableDeclaration({ kind: "var" })) G = "var";
                  else {
                    if (!Z.isVariableDeclaration()) return;
                    G = "block";
                  }
                }
                Object.keys(Z.getOuterBindingIdentifiers()).forEach((B) => {
                  ee.set(B, G);
                });
              });
              const re = /* @__PURE__ */ new Map(), Y = (Z) => {
                const G = Z.node.name;
                let B = re.get(G);
                if (!B) {
                  const z = ee.get(G);
                  if (z === void 0) throw Z.buildCodeFrameError(`Exporting local "${G}", which is not declared.`);
                  B = { names: [], kind: z }, re.set(G, B);
                }
                return B;
              };
              return H.get("body").forEach((Z) => {
                if (!Z.isExportNamedDeclaration() || !U && Z.node.source) {
                  if (Z.isExportDefaultDeclaration()) {
                    const G = Z.get("declaration");
                    if (!G.isFunctionDeclaration() && !G.isClassDeclaration()) throw G.buildCodeFrameError("Unexpected default expression export.");
                    Y(G.get("id")).names.push("default");
                  }
                } else if (Z.node.declaration) {
                  const G = Z.get("declaration"), B = G.getOuterBindingIdentifierPaths();
                  Object.keys(B).forEach((z) => {
                    if (z === "__esModule") throw G.buildCodeFrameError('Illegal export "__esModule".');
                    Y(B[z]).names.push(z);
                  });
                } else Z.get("specifiers").forEach((G) => {
                  const B = G.get("local"), z = G.get("exported"), M = Y(B), K = r(z, q);
                  if (K === "__esModule") throw z.buildCodeFrameError('Illegal export "__esModule".');
                  M.names.push(K);
                });
              }), re;
            }(I, j, L), N = /* @__PURE__ */ new Map(), F = /* @__PURE__ */ new Map(), W = (H, U) => {
              const q = H.value;
              let ee = F.get(q);
              return ee ? N.get(q).push(U) : (ee = { name: I.scope.generateUidIdentifier((0, n.basename)(q, (0, n.extname)(q))).name, interop: "none", loc: null, imports: /* @__PURE__ */ new Map(), importsNamespace: /* @__PURE__ */ new Set(), reexports: /* @__PURE__ */ new Map(), reexportNamespace: /* @__PURE__ */ new Set(), reexportAll: null, wrap: null, get lazy() {
                return this.wrap === "lazy";
              }, referenced: false }, F.set(q, ee), N.set(q, [U])), ee;
            };
            let X = false;
            I.get("body").forEach((H) => {
              if (H.isImportDeclaration()) {
                const U = W(H.node.source, H.node);
                U.loc || (U.loc = H.node.loc), H.get("specifiers").forEach((q) => {
                  if (q.isImportDefaultSpecifier()) {
                    const ee = q.get("local").node.name;
                    U.imports.set(ee, "default");
                    const re = k.get(ee);
                    re && (k.delete(ee), re.names.forEach((Y) => {
                      U.reexports.set(Y, "default");
                    }), U.referenced = true);
                  } else if (q.isImportNamespaceSpecifier()) {
                    const ee = q.get("local").node.name;
                    U.importsNamespace.add(ee);
                    const re = k.get(ee);
                    re && (k.delete(ee), re.names.forEach((Y) => {
                      U.reexportNamespace.add(Y);
                    }), U.referenced = true);
                  } else if (q.isImportSpecifier()) {
                    const ee = r(q.get("imported"), L), re = q.get("local").node.name;
                    U.imports.set(re, ee);
                    const Y = k.get(re);
                    Y && (k.delete(re), Y.names.forEach((Z) => {
                      U.reexports.set(Z, ee);
                    }), U.referenced = true);
                  }
                });
              } else if (H.isExportAllDeclaration()) {
                X = true;
                const U = W(H.node.source, H.node);
                U.loc || (U.loc = H.node.loc), U.reexportAll = { loc: H.node.loc }, U.referenced = true;
              } else if (H.isExportNamedDeclaration() && H.node.source) {
                X = true;
                const U = W(H.node.source, H.node);
                U.loc || (U.loc = H.node.loc), H.get("specifiers").forEach((q) => {
                  f(q);
                  const ee = r(q.get("local"), L), re = r(q.get("exported"), L);
                  if (U.reexports.set(re, ee), U.referenced = true, re === "__esModule") throw q.get("exported").buildCodeFrameError('Illegal export "__esModule".');
                });
              } else (H.isExportNamedDeclaration() || H.isExportDefaultDeclaration()) && (X = true);
            });
            for (const H of F.values()) {
              let U = false, q = false;
              H.importsNamespace.size > 0 && (U = true, q = true), H.reexportAll && (q = true);
              for (const ee of H.imports.values()) ee === "default" ? U = true : q = true;
              for (const ee of H.reexports.values()) ee === "default" ? U = true : q = true;
              U && q ? H.interop = "namespace" : U && (H.interop = "default");
            }
            if (D) for (const [H, U] of F) U.wrap = D(H, U, N.get(H));
            return { hasExports: X, local: k, sources: F };
          }(y, { initializeReexports: d, getWrapperPayload: p }, E);
          (function(I) {
            I.get("body").forEach((D) => {
              if (D.isImportDeclaration()) D.remove();
              else if (D.isExportNamedDeclaration()) D.node.declaration ? (D.node.declaration._blockHoist = D.node._blockHoist, D.replaceWith(D.node.declaration)) : D.remove();
              else if (D.isExportDefaultDeclaration()) {
                const j = D.get("declaration");
                if (!j.isFunctionDeclaration() && !j.isClassDeclaration()) throw j.buildCodeFrameError("Unexpected default expression export.");
                j._blockHoist = D.node._blockHoist, D.replaceWith(j);
              } else D.isExportAllDeclaration() && D.remove();
            });
          })(y);
          for (const [I, D] of C) {
            const { importsNamespace: j, imports: L } = D;
            if (j.size > 0 && L.size === 0) {
              const [N] = j;
              D.name = N;
            }
            const k = e(T, I, m);
            k === "none" ? D.interop = "none" : k === "node" && D.interop === "namespace" ? D.interop = "node-namespace" : k === "node" && D.interop === "default" ? D.interop = "node-default" : h && D.interop === "namespace" && (D.interop = "default");
          }
          return { exportName: S, exportNameListName: null, hasExports: w, local: _, source: C, stringSpecifiers: E };
        }, t.hasExports = function(y) {
          return y.hasExports;
        }, t.isSideEffectImport = function(y) {
          return y.imports.size === 0 && y.importsNamespace.size === 0 && y.reexports.size === 0 && y.reexportNamespace.size === 0 && !y.reexportAll;
        }, t.validateImportInteropOption = c;
        var n = l("path"), u = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js");
        function c(y) {
          if (typeof y != "function" && y !== "none" && y !== "babel" && y !== "node") throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${y}).`);
          return y;
        }
        function e(y, S, T) {
          return typeof y == "function" ? c(y(S, T)) : y;
        }
        function r(y, S) {
          if (y.isIdentifier()) return y.node.name;
          if (y.isStringLiteral()) {
            const T = y.node.value;
            return (0, u.isIdentifierName)(T) || S.add(T), T;
          }
          throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${y.node.type}`);
        }
        function f(y) {
          if (!y.isExportSpecifier()) throw y.isExportNamespaceSpecifier() ? y.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.") : y.buildCodeFrameError("Unexpected export specifier type");
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(f, y, S) {
          const T = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map(), p = (E) => {
            f.requeue(E);
          };
          for (const [E, _] of y.source) {
            for (const [C, w] of _.imports) T.set(C, [E, w, null]);
            for (const C of _.importsNamespace) T.set(C, [E, null, C]);
          }
          for (const [E, _] of y.local) {
            let C = d.get(E);
            C || (C = [], d.set(E, C)), C.push(..._.names);
          }
          const h = { metadata: y, requeueInParent: p, scope: f.scope, exported: d };
          f.traverse(u, h);
          const m = { seen: /* @__PURE__ */ new WeakSet(), metadata: y, requeueInParent: p, scope: f.scope, imported: T, exported: d, buildImportReference([E, _, C], w) {
            const I = y.source.get(E);
            if (I.referenced = true, C) {
              var D;
              return I.wrap && (w = (D = S(w, I.wrap)) != null ? D : w), w;
            }
            let j = n.types.identifier(I.name);
            var L;
            if (I.wrap && (j = (L = S(j, I.wrap)) != null ? L : j), _ === "default" && I.interop === "node-default") return j;
            const k = y.stringSpecifiers.has(_);
            return n.types.memberExpression(j, k ? n.types.stringLiteral(_) : n.types.identifier(_), k);
          } };
          f.traverse(r, m);
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");
        const u = { Scope(f) {
          f.skip();
        }, ClassDeclaration(f) {
          const { requeueInParent: y, exported: S, metadata: T } = this, { id: d } = f.node;
          if (!d) throw new Error("Expected class to have a name");
          const p = d.name, h = S.get(p) || [];
          if (h.length > 0) {
            const m = n.types.expressionStatement(c(T, h, n.types.identifier(p), f.scope));
            m._blockHoist = f.node._blockHoist, y(f.insertAfter(m)[0]);
          }
        }, VariableDeclaration(f) {
          const { requeueInParent: y, exported: S, metadata: T } = this, d = f.node.kind === "var";
          for (const p of f.get("declarations")) {
            const { id: h } = p.node;
            let { init: m } = p.node;
            if (!n.types.isIdentifier(h) || !S.has(h.name) || n.types.isArrowFunctionExpression(m) || n.types.isFunctionExpression(m) && !m.id || n.types.isClassExpression(m) && !m.id) {
              for (const E of Object.keys(p.getOuterBindingIdentifiers())) if (S.has(E)) {
                const _ = n.types.expressionStatement(c(T, S.get(E), n.types.identifier(E), f.scope));
                _._blockHoist = f.node._blockHoist, y(f.insertAfter(_)[0]);
              }
            } else {
              if (!m) {
                if (d) continue;
                m = f.scope.buildUndefinedNode();
              }
              p.node.init = c(T, S.get(h.name), m, f.scope), y(p.get("init"));
            }
          }
        } }, c = (f, y, S, T) => {
          const d = f.exportName;
          for (let p = T; p != null; p = p.parent) p.hasOwnBinding(d) && p.rename(d);
          return (y || []).reduce((p, h) => {
            const { stringSpecifiers: m } = f, E = m.has(h);
            return n.types.assignmentExpression("=", n.types.memberExpression(n.types.identifier(d), E ? n.types.stringLiteral(h) : n.types.identifier(h), E), p);
          }, S);
        }, e = (f) => n.template.expression.ast`
    (function() {
      throw new Error('"' + '${f}' + '" is read-only.');
    })()
  `, r = { ReferencedIdentifier(f) {
          const { seen: y, buildImportReference: S, scope: T, imported: d, requeueInParent: p } = this;
          if (y.has(f.node)) return;
          y.add(f.node);
          const h = f.node.name, m = d.get(h);
          if (m) {
            if (function(C) {
              do
                switch (C.parent.type) {
                  case "TSTypeAnnotation":
                  case "TSTypeAliasDeclaration":
                  case "TSTypeReference":
                  case "TypeAnnotation":
                  case "TypeAlias":
                    return true;
                  case "ExportSpecifier":
                    return C.parentPath.parent.exportKind === "type";
                  default:
                    if (C.parentPath.isStatement() || C.parentPath.isExpression()) return false;
                }
              while (C = C.parentPath);
            }(f)) throw f.buildCodeFrameError(`Cannot transform the imported binding "${h}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
            const E = f.scope.getBinding(h);
            if (T.getBinding(h) !== E) return;
            const _ = S(m, f.node);
            if (_.loc = f.node.loc, (f.parentPath.isCallExpression({ callee: f.node }) || f.parentPath.isOptionalCallExpression({ callee: f.node }) || f.parentPath.isTaggedTemplateExpression({ tag: f.node })) && n.types.isMemberExpression(_)) f.replaceWith(n.types.sequenceExpression([n.types.numericLiteral(0), _]));
            else if (f.isJSXIdentifier() && n.types.isMemberExpression(_)) {
              const { object: C, property: w } = _;
              f.replaceWith(n.types.jsxMemberExpression(n.types.jsxIdentifier(C.name), n.types.jsxIdentifier(w.name)));
            } else f.replaceWith(_);
            p(f), f.skip();
          }
        }, UpdateExpression(f) {
          const { scope: y, seen: S, imported: T, exported: d, requeueInParent: p, buildImportReference: h } = this;
          if (S.has(f.node)) return;
          S.add(f.node);
          const m = f.get("argument");
          if (m.isMemberExpression()) return;
          const E = f.node;
          if (m.isIdentifier()) {
            const _ = m.node.name;
            if (y.getBinding(_) !== f.scope.getBinding(_)) return;
            const C = d.get(_), w = T.get(_);
            if ((C == null ? void 0 : C.length) > 0 || w) if (w) f.replaceWith(n.types.assignmentExpression(E.operator[0] + "=", h(w, m.node), e(_)));
            else if (E.prefix) f.replaceWith(c(this.metadata, C, n.types.cloneNode(E), f.scope));
            else {
              const I = y.generateDeclaredUidIdentifier(_);
              f.replaceWith(n.types.sequenceExpression([n.types.assignmentExpression("=", n.types.cloneNode(I), n.types.cloneNode(E)), c(this.metadata, C, n.types.identifier(_), f.scope), n.types.cloneNode(I)]));
            }
          }
          p(f), f.skip();
        }, AssignmentExpression: { exit(f) {
          const { scope: y, seen: S, imported: T, exported: d, requeueInParent: p, buildImportReference: h } = this;
          if (S.has(f.node)) return;
          S.add(f.node);
          const m = f.get("left");
          if (!m.isMemberExpression()) if (m.isIdentifier()) {
            const E = m.node.name;
            if (y.getBinding(E) !== f.scope.getBinding(E)) return;
            const _ = d.get(E), C = T.get(E);
            if ((_ == null ? void 0 : _.length) > 0 || C) {
              const w = f.node;
              C && (w.left = h(C, m.node), w.right = n.types.sequenceExpression([w.right, e(E)]));
              const { operator: I } = w;
              let D;
              D = I === "=" ? w : I === "&&=" || I === "||=" || I === "??=" ? n.types.assignmentExpression("=", w.left, n.types.logicalExpression(I.slice(0, -1), n.types.cloneNode(w.left), w.right)) : n.types.assignmentExpression("=", w.left, n.types.binaryExpression(I.slice(0, -1), n.types.cloneNode(w.left), w.right)), f.replaceWith(c(this.metadata, _, D, f.scope)), p(f), f.skip();
            }
          } else {
            const E = m.getOuterBindingIdentifiers(), _ = Object.keys(E).filter((I) => y.getBinding(I) === f.scope.getBinding(I)), C = _.find((I) => T.has(I));
            C && (f.node.right = n.types.sequenceExpression([f.node.right, e(C)]));
            const w = [];
            if (_.forEach((I) => {
              const D = d.get(I) || [];
              D.length > 0 && w.push(c(this.metadata, D, n.types.identifier(I), f.scope));
            }), w.length > 0) {
              let I = n.types.sequenceExpression(w);
              f.parentPath.isExpressionStatement() && (I = n.types.expressionStatement(I), I._blockHoist = f.parentPath.node._blockHoist), p(f.insertAfter(I)[0]);
            }
          }
        } }, ForXStatement(f) {
          const { scope: y, node: S } = f, { left: T } = S, { exported: d, imported: p, scope: h } = this;
          if (!n.types.isVariableDeclaration(T)) {
            let m, E = false;
            const _ = f.get("body").scope;
            for (const I of Object.keys(n.types.getOuterBindingIdentifiers(T))) h.getBinding(I) === y.getBinding(I) && (d.has(I) && (E = true, _.hasOwnBinding(I) && _.rename(I)), p.has(I) && !m && (m = I));
            if (!E && !m) return;
            f.ensureBlock();
            const C = f.get("body"), w = y.generateUidIdentifierBasedOnNode(T);
            f.get("left").replaceWith(n.types.variableDeclaration("let", [n.types.variableDeclarator(n.types.cloneNode(w))])), y.registerDeclaration(f.get("left")), E && C.unshiftContainer("body", n.types.expressionStatement(n.types.assignmentExpression("=", T, w))), m && C.unshiftContainer("body", n.types.expressionStatement(e(m)));
          }
        } };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(e) {
          c || (c = u.visitors.environmentVisitor({ ThisExpression(r) {
            r.replaceWith(n.types.unaryExpression("void", n.types.numericLiteral(0), true));
          } }), c.noScope = true), (0, u.default)(e.node, c);
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");
        let c;
      }, "./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.25.9/node_modules/@babel/helper-optimise-call-expression/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(T, d, p, h) {
          return p.length === 1 && r(p[0]) && e(p[0].argument, { name: "arguments" }) ? h ? y(S(T, c("apply"), false, true), [d, p[0].argument], false) : u(f(T, c("apply")), [d, p[0].argument]) : h ? y(S(T, c("call"), false, true), [d, ...p], false) : u(f(T, c("call")), [d, ...p]);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { callExpression: u, identifier: c, isIdentifier: e, isSpreadElement: r, memberExpression: f, optionalCallExpression: y, optionalMemberExpression: S } = n;
      }, "./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.declare = n, t.declarePreset = void 0;
        const l = { assertVersion: (c) => (e) => {
          (function(r, f) {
            if (typeof r == "number") {
              if (!Number.isInteger(r)) throw new Error("Expected string or integer value.");
              r = `^${r}.0.0-0`;
            }
            if (typeof r != "string") throw new Error("Expected string or integer value.");
            const y = Error.stackTraceLimit;
            typeof y == "number" && y < 25 && (Error.stackTraceLimit = 25);
            let S;
            throw S = f.slice(0, 2) === "7." ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${f}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${r}", but was loaded with "${f}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof y == "number" && (Error.stackTraceLimit = y), Object.assign(S, { code: "BABEL_VERSION_UNSUPPORTED", version: f, range: r });
          })(e, c.version);
        } };
        function n(c) {
          return (e, r, f) => {
            var y;
            let S;
            for (const T of Object.keys(l)) e[T] || (S != null || (S = u(e)), S[T] = l[T](S));
            return c((y = S) != null ? y : e, r || {}, f);
          };
        }
        Object.assign(l, { targets: () => () => ({}), assumption: () => () => {
        }, addExternalDependency: () => () => {
        } }), t.declarePreset = n;
        function u(c) {
          let e = null;
          return typeof c.version == "string" && /^7\./.test(c.version) && (e = Object.getPrototypeOf(c), !e || hasOwnProperty.call(e, "version") && hasOwnProperty.call(e, "transform") && hasOwnProperty.call(e, "template") && hasOwnProperty.call(e, "types") || (e = null)), Object.assign({}, e, c);
        }
      }, "./node_modules/.pnpm/@babel+helper-replace-supers@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-replace-supers/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.25.9/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), u = l("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.25.9/node_modules/@babel/helper-optimise-call-expression/lib/index.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), e = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js");
        const { assignmentExpression: r, callExpression: f, cloneNode: y, identifier: S, memberExpression: T, sequenceExpression: d, stringLiteral: p, thisExpression: h } = c.types;
        t.environmentVisitor = e.visitors.environmentVisitor({}), t.skipAllButComputedKey = function(I) {
          I.skip(), I.node.computed && I.context.maybeQueue(I.get("key"));
        };
        const m = e.visitors.environmentVisitor({ Super(I, D) {
          const { node: j, parentPath: L } = I;
          L.isMemberExpression({ object: j }) && D.handle(L);
        } }), E = e.visitors.environmentVisitor({ Scopable(I, { refName: D }) {
          const j = I.scope.getOwnBinding(D);
          j && j.identifier.name === D && I.scope.rename(D);
        } }), _ = { memoise(I, D) {
          const { scope: j, node: L } = I, { computed: k, property: N } = L;
          if (!k) return;
          const F = j.maybeGenerateMemoised(N);
          F && this.memoiser.set(N, F, D);
        }, prop(I) {
          const { computed: D, property: j } = I.node;
          return this.memoiser.has(j) ? y(this.memoiser.get(j)) : D ? y(j) : p(j.name);
        }, _getPrototypeOfExpression() {
          const I = y(this.getObjectRef()), D = this.isStatic || this.isPrivateMethod ? I : T(I, S("prototype"));
          return f(this.file.addHelper("getPrototypeOf"), [D]);
        }, get(I) {
          const D = y(this.getObjectRef());
          return f(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? d([h(), D]) : D, this.prop(I), h(), ...this.isStatic || this.isPrivateMethod ? [] : [c.types.numericLiteral(1)]]);
        }, _call(I, D, j) {
          const L = y(this.getObjectRef());
          let k;
          k = D.length === 1 && c.types.isSpreadElement(D[0]) && (c.types.isIdentifier(D[0].argument) || c.types.isArrayExpression(D[0].argument)) ? D[0].argument : c.types.arrayExpression(D);
          const N = c.types.callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? d([h(), L]) : L, this.prop(I), h(), c.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))]);
          return j ? c.types.optionalCallExpression(N, [k], true) : f(N, [k]);
        }, set(I, D) {
          const j = y(this.getObjectRef());
          return f(this.file.addHelper("superPropSet"), [this.isDerivedConstructor ? d([h(), j]) : j, this.prop(I), D, h(), c.types.numericLiteral(I.isInStrictMode() ? 1 : 0), ...this.isStatic || this.isPrivateMethod ? [] : [c.types.numericLiteral(1)]]);
        }, destructureSet(I) {
          throw I.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        }, call(I, D) {
          return this._call(I, D, false);
        }, optionalCall(I, D) {
          return this._call(I, D, true);
        }, delete(I) {
          return I.node.computed ? d([f(this.file.addHelper("toPropertyKey"), [y(I.node.property)]), c.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : c.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        } }, C = { memoise(I, D) {
          const { scope: j, node: L } = I, { computed: k, property: N } = L;
          if (!k) return;
          const F = j.maybeGenerateMemoised(N);
          F && this.memoiser.set(N, F, D);
        }, prop(I) {
          const { computed: D, property: j } = I.node;
          return this.memoiser.has(j) ? y(this.memoiser.get(j)) : D ? y(j) : p(j.name);
        }, _getPrototypeOfExpression() {
          const I = y(this.getObjectRef()), D = this.isStatic || this.isPrivateMethod ? I : T(I, S("prototype"));
          return f(this.file.addHelper("getPrototypeOf"), [D]);
        }, get(I) {
          return this._get(I);
        }, _get(I) {
          const D = this._getPrototypeOfExpression();
          return f(this.file.addHelper("get"), [this.isDerivedConstructor ? d([h(), D]) : D, this.prop(I), h()]);
        }, set(I, D) {
          const j = this._getPrototypeOfExpression();
          return f(this.file.addHelper("set"), [this.isDerivedConstructor ? d([h(), j]) : j, this.prop(I), D, h(), c.types.booleanLiteral(I.isInStrictMode())]);
        }, destructureSet(I) {
          throw I.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        }, call(I, D) {
          return (0, u.default)(this._get(I), h(), D, false);
        }, optionalCall(I, D) {
          return (0, u.default)(this._get(I), y(h()), D, true);
        }, delete(I) {
          return I.node.computed ? d([f(this.file.addHelper("toPropertyKey"), [y(I.node.property)]), c.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : c.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        } }, w = Object.assign({}, _, { prop(I) {
          const { property: D } = I.node;
          return this.memoiser.has(D) ? y(this.memoiser.get(D)) : y(D);
        }, get(I) {
          const { isStatic: D, getSuperRef: j } = this, { computed: L } = I.node, k = this.prop(I);
          let N;
          var F, W;
          return D ? N = (F = j()) != null ? F : T(S("Function"), S("prototype")) : N = T((W = j()) != null ? W : S("Object"), S("prototype")), T(N, k, L);
        }, set(I, D) {
          const { computed: j } = I.node, L = this.prop(I);
          return r("=", T(h(), L, j), D);
        }, destructureSet(I) {
          const { computed: D } = I.node, j = this.prop(I);
          return T(h(), j, D);
        }, call(I, D) {
          return (0, u.default)(this.get(I), h(), D, false);
        }, optionalCall(I, D) {
          return (0, u.default)(this.get(I), h(), D, true);
        } });
        t.default = class {
          constructor(I) {
            var D;
            const j = I.methodPath;
            this.methodPath = j, this.isDerivedConstructor = j.isClassMethod({ kind: "constructor" }) && !!I.superRef, this.isStatic = j.isObjectMethod() || j.node.static || (j.isStaticBlock == null ? void 0 : j.isStaticBlock()), this.isPrivateMethod = j.isPrivate() && j.isMethod(), this.file = I.file, this.constantSuper = (D = I.constantSuper) != null ? D : I.isLoose, this.opts = I;
          }
          getObjectRef() {
            return y(this.opts.objectRef || this.opts.getObjectRef());
          }
          getSuperRef() {
            return this.opts.superRef ? y(this.opts.superRef) : this.opts.getSuperRef ? y(this.opts.getSuperRef()) : void 0;
          }
          replace() {
            const { methodPath: I } = this;
            this.opts.refToPreserve && I.traverse(E, { refName: this.opts.refToPreserve.name });
            const D = this.constantSuper ? w : this.file.availableHelper("superPropSet") ? _ : C;
            m.shouldSkip = (j) => {
              if (j.parentPath === I && (j.parentKey === "decorators" || j.parentKey === "key")) return true;
            }, (0, n.default)(I, m, Object.assign({ file: this.file, scope: this.methodPath.scope, isDerivedConstructor: this.isDerivedConstructor, isStatic: this.isStatic, isPrivateMethod: this.isPrivateMethod, getObjectRef: this.getObjectRef.bind(this), getSuperRef: this.getSuperRef.bind(this), boundGet: D.get }, D));
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.25.9/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.isTransparentExprWrapper = S, t.skipTransparentExprWrapperNodes = function(T) {
          for (; S(T); ) T = T.expression;
          return T;
        }, t.skipTransparentExprWrappers = function(T) {
          for (; S(T.node); ) T = T.get("expression");
          return T;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { isParenthesizedExpression: u, isTSAsExpression: c, isTSNonNullExpression: e, isTSSatisfiesExpression: r, isTSTypeAssertion: f, isTypeCastExpression: y } = n;
        function S(T) {
          return c(T) || r(T) || f(T) || e(T) || y(T) || u(T);
        }
      }, "./node_modules/.pnpm/@babel+helper-string-parser@7.25.9/node_modules/@babel/helper-string-parser/lib/index.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.readCodePoint = y, t.readInt = f, t.readStringContents = function(S, T, d, p, h, m) {
          const E = d, _ = p, C = h;
          let w = "", I = null, D = d;
          const { length: j } = T;
          for (; ; ) {
            if (d >= j) {
              m.unterminated(E, _, C), w += T.slice(D, d);
              break;
            }
            const L = T.charCodeAt(d);
            if (c(S, L, T, d)) {
              w += T.slice(D, d);
              break;
            }
            if (L === 92) {
              w += T.slice(D, d);
              const k = e(T, d, p, h, S === "template", m);
              k.ch !== null || I ? w += k.ch : I = { pos: d, lineStart: p, curLine: h }, { pos: d, lineStart: p, curLine: h } = k, D = d;
            } else L === 8232 || L === 8233 ? (++h, p = ++d) : L === 10 || L === 13 ? S === "template" ? (w += T.slice(D, d) + `
`, ++d, L === 13 && T.charCodeAt(d) === 10 && ++d, ++h, D = p = d) : m.unterminated(E, _, C) : ++d;
          }
          return { pos: d, str: w, firstInvalidLoc: I, lineStart: p, curLine: h, containsInvalid: !!I };
        };
        var l = function(S) {
          return S >= 48 && S <= 57;
        };
        const n = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, u = { bin: (S) => S === 48 || S === 49, oct: (S) => S >= 48 && S <= 55, dec: (S) => S >= 48 && S <= 57, hex: (S) => S >= 48 && S <= 57 || S >= 65 && S <= 70 || S >= 97 && S <= 102 };
        function c(S, T, d, p) {
          return S === "template" ? T === 96 || T === 36 && d.charCodeAt(p + 1) === 123 : T === (S === "double" ? 34 : 39);
        }
        function e(S, T, d, p, h, m) {
          const E = !h;
          T++;
          const _ = (w) => ({ pos: T, ch: w, lineStart: d, curLine: p }), C = S.charCodeAt(T++);
          switch (C) {
            case 110:
              return _(`
`);
            case 114:
              return _("\r");
            case 120: {
              let w;
              return { code: w, pos: T } = r(S, T, d, p, 2, false, E, m), _(w === null ? null : String.fromCharCode(w));
            }
            case 117: {
              let w;
              return { code: w, pos: T } = y(S, T, d, p, E, m), _(w === null ? null : String.fromCodePoint(w));
            }
            case 116:
              return _("	");
            case 98:
              return _("\b");
            case 118:
              return _("\v");
            case 102:
              return _("\f");
            case 13:
              S.charCodeAt(T) === 10 && ++T;
            case 10:
              d = T, ++p;
            case 8232:
            case 8233:
              return _("");
            case 56:
            case 57:
              if (h) return _(null);
              m.strictNumericEscape(T - 1, d, p);
            default:
              if (C >= 48 && C <= 55) {
                const w = T - 1;
                let I = /^[0-7]+/.exec(S.slice(w, T + 2))[0], D = parseInt(I, 8);
                D > 255 && (I = I.slice(0, -1), D = parseInt(I, 8)), T += I.length - 1;
                const j = S.charCodeAt(T);
                if (I !== "0" || j === 56 || j === 57) {
                  if (h) return _(null);
                  m.strictNumericEscape(w, d, p);
                }
                return _(String.fromCharCode(D));
              }
              return _(String.fromCharCode(C));
          }
        }
        function r(S, T, d, p, h, m, E, _) {
          const C = T;
          let w;
          return { n: w, pos: T } = f(S, T, d, p, 16, h, m, false, _, !E), w === null && (E ? _.invalidEscapeSequence(C, d, p) : T = C - 1), { code: w, pos: T };
        }
        function f(S, T, d, p, h, m, E, _, C, w) {
          const I = T, D = h === 16 ? n.hex : n.decBinOct, j = h === 16 ? u.hex : h === 10 ? u.dec : h === 8 ? u.oct : u.bin;
          let L = false, k = 0;
          for (let N = 0, F = m ?? 1 / 0; N < F; ++N) {
            const W = S.charCodeAt(T);
            let X;
            if (W !== 95 || _ === "bail") {
              if (X = W >= 97 ? W - 97 + 10 : W >= 65 ? W - 65 + 10 : l(W) ? W - 48 : 1 / 0, X >= h) {
                if (X <= 9 && w) return { n: null, pos: T };
                if (X <= 9 && C.invalidDigit(T, d, p, h)) X = 0;
                else {
                  if (!E) break;
                  X = 0, L = true;
                }
              }
              ++T, k = k * h + X;
            } else {
              const H = S.charCodeAt(T - 1), U = S.charCodeAt(T + 1);
              if (_) {
                if (Number.isNaN(U) || !j(U) || D.has(H) || D.has(U)) {
                  if (w) return { n: null, pos: T };
                  C.unexpectedNumericSeparator(T, d, p);
                }
              } else {
                if (w) return { n: null, pos: T };
                C.numericSeparatorInEscapeSequence(T, d, p);
              }
              ++T;
            }
          }
          return T === I || m != null && T - I !== m || L ? { n: null, pos: T } : { n: k, pos: T };
        }
        function y(S, T, d, p, h, m) {
          let E;
          if (S.charCodeAt(T) === 123) {
            if (++T, { code: E, pos: T } = r(S, T, d, p, S.indexOf("}", T) - T, true, h, m), ++T, E !== null && E > 1114111) {
              if (!h) return { code: null, pos: T };
              m.invalidCodePoint(T, d, p);
            }
          } else ({ code: E, pos: T } = r(S, T, d, p, 4, false, h, m));
          return { code: E, pos: T };
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/identifier.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.isIdentifierChar = S, t.isIdentifierName = function(T) {
          let d = true;
          for (let p = 0; p < T.length; p++) {
            let h = T.charCodeAt(p);
            if ((64512 & h) == 55296 && p + 1 < T.length) {
              const m = T.charCodeAt(++p);
              (64512 & m) == 56320 && (h = 65536 + ((1023 & h) << 10) + (1023 & m));
            }
            if (d) {
              if (d = false, !y(h)) return false;
            } else if (!S(h)) return false;
          }
          return !d;
        }, t.isIdentifierStart = y;
        let l = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", n = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
        const u = new RegExp("[" + l + "]"), c = new RegExp("[" + l + n + "]");
        l = n = null;
        const e = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], r = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function f(T, d) {
          let p = 65536;
          for (let h = 0, m = d.length; h < m; h += 2) {
            if (p += d[h], p > T) return false;
            if (p += d[h + 1], p >= T) return true;
          }
          return false;
        }
        function y(T) {
          return T < 65 ? T === 36 : T <= 90 || (T < 97 ? T === 95 : T <= 122 || (T <= 65535 ? T >= 170 && u.test(String.fromCharCode(T)) : f(T, e)));
        }
        function S(T) {
          return T < 48 ? T === 36 : T < 58 || !(T < 65) && (T <= 90 || (T < 97 ? T === 95 : T <= 122 || (T <= 65535 ? T >= 170 && c.test(String.fromCharCode(T)) : f(T, e) || f(T, r))));
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), Object.defineProperty(t, "isIdentifierChar", { enumerable: true, get: function() {
          return n.isIdentifierChar;
        } }), Object.defineProperty(t, "isIdentifierName", { enumerable: true, get: function() {
          return n.isIdentifierName;
        } }), Object.defineProperty(t, "isIdentifierStart", { enumerable: true, get: function() {
          return n.isIdentifierStart;
        } }), Object.defineProperty(t, "isKeyword", { enumerable: true, get: function() {
          return u.isKeyword;
        } }), Object.defineProperty(t, "isReservedWord", { enumerable: true, get: function() {
          return u.isReservedWord;
        } }), Object.defineProperty(t, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
          return u.isStrictBindOnlyReservedWord;
        } }), Object.defineProperty(t, "isStrictBindReservedWord", { enumerable: true, get: function() {
          return u.isStrictBindReservedWord;
        } }), Object.defineProperty(t, "isStrictReservedWord", { enumerable: true, get: function() {
          return u.isStrictReservedWord;
        } });
        var n = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/identifier.js"), u = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/keyword.js");
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/keyword.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.isKeyword = function(S) {
          return u.has(S);
        }, t.isReservedWord = r, t.isStrictBindOnlyReservedWord = y, t.isStrictBindReservedWord = function(S, T) {
          return f(S, T) || y(S);
        }, t.isStrictReservedWord = f;
        const l = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], n = ["eval", "arguments"], u = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), c = new Set(l), e = new Set(n);
        function r(S, T) {
          return T && S === "await" || S === "enum";
        }
        function f(S, T) {
          return r(S, T) || c.has(S);
        }
        function y(S) {
          return e.has(S);
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/find-suggestion.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.findSuggestion = function(n, u) {
          const c = u.map((e) => function(r, f) {
            let y, S, T = [], d = [];
            const p = r.length, h = f.length;
            if (!p) return h;
            if (!h) return p;
            for (S = 0; S <= h; S++) T[S] = S;
            for (y = 1; y <= p; y++) {
              for (d = [y], S = 1; S <= h; S++) d[S] = r[y - 1] === f[S - 1] ? T[S - 1] : l(T[S - 1], T[S], d[S - 1]) + 1;
              T = d;
            }
            return d[h];
          }(e, n));
          return u[c.indexOf(l(...c))];
        };
        const { min: l } = Math;
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), Object.defineProperty(t, "OptionValidator", { enumerable: true, get: function() {
          return n.OptionValidator;
        } }), Object.defineProperty(t, "findSuggestion", { enumerable: true, get: function() {
          return u.findSuggestion;
        } });
        var n = l("./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/validator.js"), u = l("./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/validator.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.OptionValidator = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");
        t.OptionValidator = class {
          constructor(u) {
            this.descriptor = u;
          }
          validateTopLevelOptions(u, c) {
            const e = Object.keys(c);
            for (const r of Object.keys(u)) if (!e.includes(r)) throw new Error(this.formatMessage(`'${r}' is not a valid top-level option.
- Did you mean '${(0, n.findSuggestion)(r, e)}'?`));
          }
          validateBooleanOption(u, c, e) {
            return c === void 0 ? e : (this.invariant(typeof c == "boolean", `'${u}' option must be a boolean.`), c);
          }
          validateStringOption(u, c, e) {
            return c === void 0 ? e : (this.invariant(typeof c == "string", `'${u}' option must be a string.`), c);
          }
          invariant(u, c) {
            if (!u) throw new Error(this.formatMessage(c));
          }
          formatMessage(u) {
            return `${this.descriptor}: ${u}`;
          }
        };
      }, "./node_modules/.pnpm/@babel+helpers@7.26.0/node_modules/@babel/helpers/lib/helpers-generated.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js");
        function u(e, r, f) {
          return Object.freeze({ minVersion: e, ast: () => n.default.program.ast(r, { preserveComments: true }), metadata: f });
        }
        const c = t.default = { __proto__: null, OverloadYield: u("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", { globals: [], locals: { _OverloadYield: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_OverloadYield", dependencies: {} }), applyDecoratedDescriptor: u("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach((function(i){a[i]=n[i]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reverse().reduce((function(r,n){return n(i,e,r)||r}),a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}', { globals: ["Object"], locals: { _applyDecoratedDescriptor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_applyDecoratedDescriptor", dependencies: {} }), applyDecs2311: u("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Object.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("Attempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctionName((function(){return v(this)}),r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supported yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', { globals: ["Symbol", "Object", "TypeError", "Error"], locals: { applyDecs2311: ["body.0.id"] }, exportBindingAssignments: [], exportName: "applyDecs2311", dependencies: { checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.consequent.body.body.0.argument.left.callee"], setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"], toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.alternate.callee"] } }), arrayLikeToArray: u("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}", { globals: ["Array"], locals: { _arrayLikeToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_arrayLikeToArray", dependencies: {} }), arrayWithHoles: u("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", { globals: ["Array"], locals: { _arrayWithHoles: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_arrayWithHoles", dependencies: {} }), arrayWithoutHoles: u("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", { globals: ["Array"], locals: { _arrayWithoutHoles: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_arrayWithoutHoles", dependencies: { arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"] } }), assertClassBrand: u("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError("Private element is not present on this object")}', { globals: ["TypeError"], locals: { _assertClassBrand: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_assertClassBrand", dependencies: {} }), assertThisInitialized: u("7.0.0-beta.0", `function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}`, { globals: ["ReferenceError"], locals: { _assertThisInitialized: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_assertThisInitialized", dependencies: {} }), asyncGeneratorDelegate: u("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', { globals: ["Promise", "Symbol"], locals: { _asyncGeneratorDelegate: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_asyncGeneratorDelegate", dependencies: { OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"] } }), asyncIterator: u("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', { globals: ["Symbol", "TypeError", "Object", "Promise"], locals: { _asyncIterator: ["body.0.id"], AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expressions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"] }, exportBindingAssignments: [], exportName: "_asyncIterator", dependencies: {} }), asyncToGenerator: u("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)}))}}', { globals: ["Promise"], locals: { asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.callee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"], _asyncToGenerator: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_asyncToGenerator", dependencies: {} }), awaitAsyncGenerator: u("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", { globals: [], locals: { _awaitAsyncGenerator: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_awaitAsyncGenerator", dependencies: { OverloadYield: ["body.0.body.body.0.argument.callee"] } }), callSuper: u("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", { globals: ["Reflect"], locals: { _callSuper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_callSuper", dependencies: { getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.consequent.arguments.2.object.callee"], isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"], possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"] } }), checkInRHS: u("7.20.5", `function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(null!==e?typeof e:"null"));return e}`, { globals: ["Object", "TypeError"], locals: { _checkInRHS: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_checkInRHS", dependencies: {} }), checkPrivateRedeclaration: u("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}', { globals: ["TypeError"], locals: { _checkPrivateRedeclaration: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_checkPrivateRedeclaration", dependencies: {} }), classCallCheck: u("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}', { globals: ["TypeError"], locals: { _classCallCheck: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classCallCheck", dependencies: {} }), classNameTDZError: u("7.0.0-beta.0", `function _classNameTDZError(e){throw new ReferenceError('Class "'+e+'" cannot be referenced in computed property keys.')}`, { globals: ["ReferenceError"], locals: { _classNameTDZError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classNameTDZError", dependencies: {} }), classPrivateFieldGet2: u("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", { globals: [], locals: { _classPrivateFieldGet2: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldGet2", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"] } }), classPrivateFieldInitSpec: u("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", { globals: [], locals: { _classPrivateFieldInitSpec: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldInitSpec", dependencies: { checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"] } }), classPrivateFieldLooseBase: u("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}', { globals: ["TypeError"], locals: { _classPrivateFieldBase: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldBase", dependencies: {} }), classPrivateFieldLooseKey: u("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', { globals: [], locals: { id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.right.argument"], _classPrivateFieldKey: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldKey", dependencies: {} }), classPrivateFieldSet2: u("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", { globals: [], locals: { _classPrivateFieldSet2: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldSet2", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"] } }), classPrivateGetter: u("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", { globals: [], locals: { _classPrivateGetter: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateGetter", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"] } }), classPrivateMethodInitSpec: u("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", { globals: [], locals: { _classPrivateMethodInitSpec: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateMethodInitSpec", dependencies: { checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"] } }), classPrivateSetter: u("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", { globals: [], locals: { _classPrivateSetter: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateSetter", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"] } }), classStaticPrivateMethodGet: u("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", { globals: [], locals: { _classStaticPrivateMethodGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateMethodGet", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"] } }), construct: u("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", { globals: ["Reflect"], locals: { _construct: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_construct", dependencies: { isNativeReflectConstruct: ["body.0.body.body.0.test.callee"], setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"] } }), createClass: u("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', { globals: ["Object"], locals: { _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.1.right.callee"], _createClass: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_createClass", dependencies: { toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"] } }), createForOfIteratorHelper: u("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||t.return()}finally{if(u)throw o}}}}', { globals: ["Symbol", "Array", "TypeError"], locals: { _createForOfIteratorHelper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_createForOfIteratorHelper", dependencies: { unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"] } }), createForOfIteratorHelperLoose: u("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', { globals: ["Symbol", "Array", "TypeError"], locals: { _createForOfIteratorHelperLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_createForOfIteratorHelperLoose", dependencies: { unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"] } }), createSuper: u("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,e)}}", { globals: ["Reflect"], locals: { _createSuper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_createSuper", dependencies: { getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.consequent.body.0.declarations.0.init.object.callee"], isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"], possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"] } }), decorate: u("7.1.5", `function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r((function(e){o.initializeInstanceElements(e,a.elements)}),t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach((function(t){r.forEach((function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)}),this)}),this)},initializeClassElements:function(e,r){var t=e.prototype;["method","field"].forEach((function(i){r.forEach((function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}}),this)}),this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach((function(e){this.addElementPlacement(e,o)}),this),e.forEach((function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)}),this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map((function(e){var r=this.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r}),this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError('An element descriptor\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "'+r+'"');var t=toPropertyKey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError('An element descriptor\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "'+i+'"');var o=e.descriptor;this.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError('A class descriptor\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "'+r+'"');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+" can't have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can't be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can't be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expected '"+r+"' to be a function");return t}`, { globals: ["Object", "TypeError", "Symbol", "ReferenceError"], locals: { _decorate: ["body.0.id"], _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"], _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"], _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"], _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"], _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"], _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.consequent.test.right.callee"], _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"] }, exportBindingAssignments: [], exportName: "_decorate", dependencies: { toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"], toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.body.0.declarations.1.init.callee"] } }), defaults: u("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.getOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", { globals: ["Object"], locals: { _defaults: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defaults", dependencies: {} }), defineAccessor: u("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}", { globals: ["Object"], locals: { _defineAccessor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defineAccessor", dependencies: {} }), defineProperty: u("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}", { globals: ["Object"], locals: { _defineProperty: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defineProperty", dependencies: { toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"] } }), extends: u("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", { globals: ["Object"], locals: { _extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_extends", dependencies: {} }), get: u("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,arguments)}', { globals: ["Reflect", "Object"], locals: { _get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_get", dependencies: { superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"] } }), getPrototypeOf: u("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", { globals: ["Object"], locals: { _getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_getPrototypeOf", dependencies: {} }), identity: u("7.17.0", "function _identity(t){return t}", { globals: [], locals: { _identity: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_identity", dependencies: {} }), importDeferProxy: u("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}", { globals: ["Proxy", "Reflect"], locals: { _importDeferProxy: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_importDeferProxy", dependencies: {} }), inherits: u("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', { globals: ["TypeError", "Object"], locals: { _inherits: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_inherits", dependencies: { setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"] } }), inheritsLoose: u("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setPrototypeOf(t,o)}", { globals: ["Object"], locals: { _inheritsLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_inheritsLoose", dependencies: { setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"] } }), initializerDefineProperty: u("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.enumerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", { globals: ["Object"], locals: { _initializerDefineProperty: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_initializerDefineProperty", dependencies: {} }), initializerWarningHelper: u("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.")}', { globals: ["Error"], locals: { _initializerWarningHelper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_initializerWarningHelper", dependencies: {} }), instanceof: u("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](n):n instanceof e}', { globals: ["Symbol"], locals: { _instanceof: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_instanceof", dependencies: {} }), interopRequireDefault: u("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", { globals: [], locals: { _interopRequireDefault: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_interopRequireDefault", dependencies: {} }), interopRequireWildcard: u("7.14.0", 'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&{}.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,n),n}', { globals: ["WeakMap", "Object"], locals: { _getRequireWildcardCache: ["body.0.id", "body.1.body.body.2.declarations.0.init.callee", "body.0.body.body.2.argument.callee.left"], _interopRequireWildcard: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_interopRequireWildcard", dependencies: {} }), isNativeFunction: u("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}catch(n){return"function"==typeof t}}', { globals: ["Function"], locals: { _isNativeFunction: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_isNativeFunction", dependencies: {} }), isNativeReflectConstruct: u("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", { globals: ["Boolean", "Reflect"], locals: { _isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"] }, exportBindingAssignments: ["body.0.body.body.1.argument.callee"], exportName: "_isNativeReflectConstruct", dependencies: {} }), iterableToArray: u("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r)}', { globals: ["Symbol", "Array"], locals: { _iterableToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_iterableToArray", dependencies: {} }), iterableToArrayLimit: u("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}', { globals: ["Symbol", "Object"], locals: { _iterableToArrayLimit: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_iterableToArrayLimit", dependencies: {} }), jsx: u("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', { globals: ["Symbol", "Array"], locals: { REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.value", "body.1.body.body.0.expression.right.left"], _createRawReactElement: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_createRawReactElement", dependencies: {} }), maybeArrayLike: u("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return arrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', { globals: ["Array"], locals: { _maybeArrayLike: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_maybeArrayLike", dependencies: { arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"] } }), newArrowCheck: u("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', { globals: ["TypeError"], locals: { _newArrowCheck: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_newArrowCheck", dependencies: {} }), nonIterableRest: u("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', { globals: ["TypeError"], locals: { _nonIterableRest: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_nonIterableRest", dependencies: {} }), nonIterableSpread: u("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', { globals: ["TypeError"], locals: { _nonIterableSpread: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_nonIterableSpread", dependencies: {} }), nullishReceiverError: u("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}', { globals: ["TypeError"], locals: { _nullishReceiverError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_nullishReceiverError", dependencies: {} }), objectDestructuringEmpty: u("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+t)}', { globals: ["TypeError"], locals: { _objectDestructuringEmpty: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectDestructuringEmpty", dependencies: {} }), objectSpread2: u("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}", { globals: ["Object"], locals: { ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.expression.alternate.alternate.callee.object.callee"], _objectSpread2: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_objectSpread2", dependencies: { defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"] } }), objectWithoutProperties: u("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertiesLoose(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)o=s[r],t.includes(o)||{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", { globals: ["Object"], locals: { _objectWithoutProperties: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectWithoutProperties", dependencies: { objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"] } }), objectWithoutPropertiesLoose: u("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(e.includes(n))continue;t[n]=r[n]}return t}", { globals: [], locals: { _objectWithoutPropertiesLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectWithoutPropertiesLoose", dependencies: {} }), possibleConstructorReturn: u("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', { globals: ["TypeError"], locals: { _possibleConstructorReturn: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_possibleConstructorReturn", dependencies: { assertThisInitialized: ["body.0.body.body.2.argument.callee"] } }), readOnlyError: u("7.0.0-beta.0", `function _readOnlyError(r){throw new TypeError('"'+r+'" is read-only')}`, { globals: ["TypeError"], locals: { _readOnlyError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_readOnlyError", dependencies: {} }), regeneratorRuntime: u("7.18.0", `function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}`, { globals: ["Object", "Symbol", "Error", "TypeError", "isNaN", "Promise"], locals: { _regeneratorRuntime: ["body.0.id", "body.0.body.body.0.expression.left"] }, exportBindingAssignments: ["body.0.body.body.0.expression"], exportName: "_regeneratorRuntime", dependencies: {} }), set: u("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOwnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', { globals: ["Reflect", "Object", "TypeError"], locals: { set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.body.0.argument.expressions.0.left"], _set: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_set", dependencies: { superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"], defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"] } }), setFunctionName: u("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', { globals: ["Object"], locals: { setFunctionName: ["body.0.id"] }, exportBindingAssignments: [], exportName: "setFunctionName", dependencies: {} }), setPrototypeOf: u("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", { globals: ["Object"], locals: { _setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_setPrototypeOf", dependencies: {} }), skipFirstGeneratorNext: u("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.next(),r}}", { globals: [], locals: { _skipFirstGeneratorNext: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_skipFirstGeneratorNext", dependencies: {} }), slicedToArray: u("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()}", { globals: [], locals: { _slicedToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_slicedToArray", dependencies: { arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"], iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"], unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"], nonIterableRest: ["body.0.body.body.0.argument.right.callee"] } }), superPropBase: u("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return t}", { globals: [], locals: { _superPropBase: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_superPropBase", dependencies: { getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"] } }), superPropGet: u("7.25.0", 'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typeof p?function(t){return p.apply(e,t)}:p}', { globals: [], locals: { _superPropGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_superPropGet", dependencies: { get: ["body.0.body.body.0.declarations.0.init.callee"], getPrototypeOf: ["body.0.body.body.0.declarations.0.init.arguments.0.callee"] } }), superPropSet: u("7.25.0", "function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", { globals: [], locals: { _superPropSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_superPropSet", dependencies: { set: ["body.0.body.body.0.argument.callee"], getPrototypeOf: ["body.0.body.body.0.argument.arguments.0.callee"] } }), taggedTemplateLiteral: u("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}", { globals: ["Object"], locals: { _taggedTemplateLiteral: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_taggedTemplateLiteral", dependencies: {} }), taggedTemplateLiteralLoose: u("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", { globals: [], locals: { _taggedTemplateLiteralLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_taggedTemplateLiteralLoose", dependencies: {} }), tdz: u("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', { globals: ["ReferenceError"], locals: { _tdzError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_tdzError", dependencies: {} }), temporalRef: u("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", { globals: [], locals: { _temporalRef: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_temporalRef", dependencies: { temporalUndefined: ["body.0.body.body.0.argument.test.right"], tdz: ["body.0.body.body.0.argument.consequent.callee"] } }), temporalUndefined: u("7.0.0-beta.0", "function _temporalUndefined(){}", { globals: [], locals: { _temporalUndefined: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_temporalUndefined", dependencies: {} }), toArray: u("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableRest()}", { globals: [], locals: { _toArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_toArray", dependencies: { arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"], iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"], unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"], nonIterableRest: ["body.0.body.body.0.argument.right.callee"] } }), toConsumableArray: u("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()}", { globals: [], locals: { _toConsumableArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_toConsumableArray", dependencies: { arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"], iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"], unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"], nonIterableSpread: ["body.0.body.body.0.argument.right.callee"] } }), toPrimitive: u("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}', { globals: ["Symbol", "TypeError", "String", "Number"], locals: { toPrimitive: ["body.0.id"] }, exportBindingAssignments: [], exportName: "toPrimitive", dependencies: {} }), toPropertyKey: u("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', { globals: [], locals: { toPropertyKey: ["body.0.id"] }, exportBindingAssignments: [], exportName: "toPropertyKey", dependencies: { toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"] } }), toSetter: u("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,t.apply(n,e)}})}', { globals: ["Object"], locals: { _toSetter: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_toSetter", dependencies: {} }), typeof: u("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}', { globals: ["Symbol"], locals: { _typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_typeof", dependencies: {} }), unsupportedIterableToArray: u("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', { globals: ["Array"], locals: { _unsupportedIterableToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_unsupportedIterableToArray", dependencies: { arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument.expressions.1.alternate.consequent.callee"] } }), usingCtx: u("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)return s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}catch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n,next()}return next()}}}', { globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"], locals: { _usingCtx: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_usingCtx", dependencies: {} }), wrapAsyncGenerator: u("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,arguments))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', { globals: ["Promise", "Symbol"], locals: { _wrapAsyncGenerator: ["body.0.id"], AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.object.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.expressions.3.left.object.object"] }, exportBindingAssignments: [], exportName: "_wrapAsyncGenerator", dependencies: { OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"] } }), wrapNativeSuper: u("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=function(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setPrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', { globals: ["Map", "TypeError", "Object"], locals: { _wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"], exportName: "_wrapNativeSuper", dependencies: { getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"], setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"], isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"], construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"] } }), wrapRegExp: u("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', { globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"], locals: { _wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"] }, exportBindingAssignments: ["body.0.body.body.0.expression"], exportName: "_wrapRegExp", dependencies: { setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"], inherits: ["body.0.body.body.4.argument.expressions.0.callee"] } }), writeOnlyError: u("7.12.13", `function _writeOnlyError(r){throw new TypeError('"'+r+'" is write-only')}`, { globals: ["TypeError"], locals: { _writeOnlyError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_writeOnlyError", dependencies: {} }) };
        Object.assign(c, { AwaitValue: u("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", { globals: [], locals: { _AwaitValue: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_AwaitValue", dependencies: {} }), applyDecs: u("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}', { globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"], locals: { old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"], old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expressions.3.callee"], old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"], old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.left.right.right.callee"], old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expression.expressions.0.callee"], old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"], old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.callee"], old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressions.0.callee"], old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"], old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"], old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"], old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressions.1.callee"], old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"], applyDecs: ["body.13.id"] }, exportBindingAssignments: [], exportName: "applyDecs", dependencies: { setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"], toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"] } }), applyDecs2203: u("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', { globals: ["Error", "TypeError", "Object", "Map", "Array"], locals: { applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"], applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee.left"], applyDecs2203: ["body.2.id"] }, exportBindingAssignments: [], exportName: "applyDecs2203", dependencies: {} }), applyDecs2203R: u("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', { globals: ["Error", "TypeError", "Object", "Map", "Array"], locals: { applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"], applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"] }, exportBindingAssignments: ["body.1.body.body.0.argument.callee"], exportName: "applyDecs2203R", dependencies: { setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"], toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"] } }), applyDecs2301: u("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', { globals: ["Error", "TypeError", "Object", "Map", "Array"], locals: { applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"], applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"] }, exportBindingAssignments: ["body.1.body.body.0.argument.callee"], exportName: "applyDecs2301", dependencies: { checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.body.body.0.argument.left.callee"], setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"], toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"] } }), applyDecs2305: u("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', { globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"], locals: { applyDecs2305: ["body.0.id"] }, exportBindingAssignments: [], exportName: "applyDecs2305", dependencies: { checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"], setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"], toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alternate.callee"] } }), classApplyDescriptorDestructureSet: u("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");return t}', { globals: ["TypeError"], locals: { _classApplyDescriptorDestructureSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classApplyDescriptorDestructureSet", dependencies: {} }), classApplyDescriptorGet: u("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", { globals: [], locals: { _classApplyDescriptorGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classApplyDescriptorGet", dependencies: {} }), classApplyDescriptorSet: u("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=l}}', { globals: ["TypeError"], locals: { _classApplyDescriptorSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classApplyDescriptorSet", dependencies: {} }), classCheckPrivateStaticAccess: u("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", { globals: [], locals: { _classCheckPrivateStaticAccess: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classCheckPrivateStaticAccess", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.callee"] } }), classCheckPrivateStaticFieldDescriptor: u("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new TypeError("attempted to "+e+" private static field before its declaration")}', { globals: ["TypeError"], locals: { _classCheckPrivateStaticFieldDescriptor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classCheckPrivateStaticFieldDescriptor", dependencies: {} }), classExtractFieldDescriptor: u("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", { globals: [], locals: { _classExtractFieldDescriptor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classExtractFieldDescriptor", dependencies: { classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"] } }), classPrivateFieldDestructureSet: u("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorDestructureSet(e,r)}", { globals: [], locals: { _classPrivateFieldDestructureSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldDestructureSet", dependencies: { classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"], classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"] } }), classPrivateFieldGet: u("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorGet(e,r)}", { globals: [], locals: { _classPrivateFieldGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldGet", dependencies: { classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"], classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"] } }), classPrivateFieldSet: u("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescriptorSet(e,s,r),r}", { globals: [], locals: { _classPrivateFieldSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldSet", dependencies: { classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"], classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"] } }), classPrivateMethodGet: u("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", { globals: [], locals: { _classPrivateMethodGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateMethodGet", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"] } }), classPrivateMethodSet: u("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', { globals: ["TypeError"], locals: { _classPrivateMethodSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateMethodSet", dependencies: {} }), classStaticPrivateFieldDestructureSet: u("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t),classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', { globals: [], locals: { _classStaticPrivateFieldDestructureSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateFieldDestructureSet", dependencies: { classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"], assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"], classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"] } }), classStaticPrivateFieldSpecGet: u("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPrivateStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', { globals: [], locals: { _classStaticPrivateFieldSpecGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateFieldSpecGet", dependencies: { classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"], assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"], classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"] } }), classStaticPrivateFieldSpecSet: u("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPrivateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', { globals: [], locals: { _classStaticPrivateFieldSpecSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateFieldSpecSet", dependencies: { classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"], assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"], classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"] } }), classStaticPrivateMethodSet: u("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static private field")}', { globals: ["TypeError"], locals: { _classStaticPrivateMethodSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateMethodSet", dependencies: {} }), defineEnumerableProperties: u("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}', { globals: ["Object"], locals: { _defineEnumerableProperties: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defineEnumerableProperties", dependencies: {} }), dispose: u("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', { globals: ["SuppressedError", "Error", "Object", "Promise"], locals: { dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expressions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"], _dispose: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_dispose", dependencies: {} }), objectSpread: u("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach((function(r){defineProperty(e,r,t[r])}))}return e}', { globals: ["Object"], locals: { _objectSpread: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectSpread", dependencies: { defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"] } }), using: u("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}', { globals: ["Object", "TypeError", "Symbol"], locals: { _using: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_using", dependencies: {} }) });
      }, "./node_modules/.pnpm/@babel+helpers@7.26.0/node_modules/@babel/helpers/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0, t.get = S, t.getDependencies = function(T) {
          return y(T).getDependencies();
        }, t.list = void 0, t.minVersion = function(T) {
          return y(T).minVersion;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+helpers@7.26.0/node_modules/@babel/helpers/lib/helpers-generated.js");
        const { cloneNode: c, identifier: e } = n;
        function r(T, d, p) {
          try {
            const h = d.split(".");
            let m = h.shift();
            for (; h.length > 0; ) T = T[m], m = h.shift();
            if (!(arguments.length > 2)) return T[m];
            T[m] = p;
          } catch (h) {
            throw h.message += ` (when accessing ${d})`, h;
          }
        }
        const f = /* @__PURE__ */ Object.create(null);
        function y(T) {
          if (!f[T]) {
            const d = u.default[T];
            if (!d) throw Object.assign(new ReferenceError(`Unknown helper ${T}`), { code: "BABEL_HELPER_UNKNOWN", helper: T });
            f[T] = { minVersion: d.minVersion, build(p, h, m, E) {
              const _ = d.ast();
              return function(C, w, I, D, j, L) {
                const { locals: k, dependencies: N, exportBindingAssignments: F, exportName: W } = w, X = new Set(D || []);
                I && X.add(I);
                for (const [H, U] of (Object.entries || ((q) => Object.keys(q).map((ee) => [ee, q[ee]])))(k)) {
                  let q = H;
                  if (I && H === W) q = I;
                  else for (; X.has(q); ) q = "_" + q;
                  if (q !== H) for (const ee of U) r(C, ee, e(q));
                }
                for (const [H, U] of (Object.entries || ((q) => Object.keys(q).map((ee) => [ee, q[ee]])))(N)) {
                  const q = typeof j == "function" && j(H) || e(H);
                  for (const ee of U) r(C, ee, c(q));
                }
                L == null ? void 0 : L(C, W, (H) => {
                  F.forEach((U) => r(C, U, H(r(C, U))));
                });
              }(_, d.metadata, h, m, p, E), { nodes: _.body, globals: d.metadata.globals };
            }, getDependencies: () => Object.keys(d.metadata.dependencies) };
          }
          return f[T];
        }
        function S(T, d, p, h, m) {
          if (typeof p == "object") {
            const E = p;
            p = (E == null ? void 0 : E.type) === "Identifier" ? E.name : void 0;
          }
          return y(T).build(d, p, h, m);
        }
        t.ensure = (T) => {
          y(T);
        }, t.list = Object.keys(u.default).map((T) => T.replace(/^_/, "")), t.default = S;
      }, "./node_modules/.pnpm/@babel+parser@7.26.3/node_modules/@babel/parser/lib/index.js": (P, t) => {
        function l(de, i) {
          if (de == null) return {};
          var v = {};
          for (var O in de) if ({}.hasOwnProperty.call(de, O)) {
            if (i.includes(O)) continue;
            v[O] = de[O];
          }
          return v;
        }
        Object.defineProperty(t, "__esModule", { value: true });
        class n {
          constructor(i, v, O) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = i, this.column = v, this.index = O;
          }
        }
        class u {
          constructor(i, v) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = i, this.end = v;
          }
        }
        function c(de, i) {
          const { line: v, column: O, index: V } = de;
          return new n(v, O + i, V + i);
        }
        const e = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
        var r = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: e }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: e } };
        const f = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, y = (de) => de.type === "UpdateExpression" ? f.UpdateExpression[`${de.prefix}`] : f[de.type];
        var S = { AccessorIsGenerator: ({ kind: de }) => `A ${de}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: de }) => `Missing initializer in ${de} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: de }) => `\`${de}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: de }) => `'import.${de}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: de, exportName: i }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${de}' as '${i}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: de }) => `'${de === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: de }) => `Unsyntactic ${de === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.", ImportBindingIsString: ({ importName: de }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${de}" as foo }\`?`, ImportCallArity: "`import()` requires exactly one or two arguments.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: de }) => `Expected number in radix ${de}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: de }) => `Escape sequence in keyword ${de}.`, InvalidIdentifier: ({ identifierName: de }) => `Invalid identifier ${de}.`, InvalidLhs: ({ ancestor: de }) => `Invalid left-hand side in ${y(de)}.`, InvalidLhsBinding: ({ ancestor: de }) => `Binding invalid left-hand side in ${y(de)}.`, InvalidLhsOptionalChaining: ({ ancestor: de }) => `Invalid optional chaining in the left-hand side of ${y(de)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: de }) => `Unexpected character '${de}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: de }) => `Private name #${de} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: de }) => `Label '${de}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: de }) => `This experimental syntax requires enabling the parser plugin: ${de.map((i) => JSON.stringify(i)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: de }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${de.map((i) => JSON.stringify(i)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: de }) => `Duplicate key "${de}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: de }) => `An export name cannot include a lone surrogate, found '\\u${de.toString(16)}'.`, ModuleExportUndefined: ({ localName: de }) => `Export '${de}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: de }) => `Private names are only allowed in property accesses (\`obj.#${de}\`) or in \`in\` expressions (\`#${de} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: de }) => `Duplicate private name #${de}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: de }) => `Unexpected keyword '${de}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: de }) => `Unexpected reserved word '${de}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: de, unexpected: i }) => `Unexpected token${i ? ` '${i}'.` : ""}${de ? `, expected "${de}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: de, onlyValidPropertyName: i }) => `The only valid meta property for ${de} is ${de}.${i}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationExport: "Using declaration cannot be exported.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: de }) => `Identifier '${de}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." };
        const T = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
        var d = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: de }) => `Invalid topic token ${de}. In order to use ${de} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${de}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: de }) => `Hack-style pipe body cannot be an unparenthesized ${y({ type: de })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' };
        const p = ["message"];
        function h(de, i, v) {
          Object.defineProperty(de, i, { enumerable: false, configurable: true, value: v });
        }
        function m({ toMessage: de, code: i, reasonCode: v, syntaxPlugin: O }) {
          const V = v === "MissingPlugin" || v === "MissingOneOfPlugins";
          {
            const ne = { AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter", AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference", SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter", SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter", SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType" };
            ne[v] && (v = ne[v]);
          }
          return function ne(ce, ve) {
            const Ce = new SyntaxError();
            return Ce.code = i, Ce.reasonCode = v, Ce.loc = ce, Ce.pos = ce.index, Ce.syntaxPlugin = O, V && (Ce.missingPlugin = ve.missingPlugin), h(Ce, "clone", function(Le = {}) {
              var Ke;
              const { line: ut, column: At, index: bt } = (Ke = Le.loc) != null ? Ke : ce;
              return ne(new n(ut, At, bt), Object.assign({}, ve, Le.details));
            }), h(Ce, "details", ve), Object.defineProperty(Ce, "message", { configurable: true, get() {
              const Le = `${de(ve)} (${ce.line}:${ce.column})`;
              return this.message = Le, Le;
            }, set(Le) {
              Object.defineProperty(this, "message", { value: Le, writable: true });
            } }), Ce;
          };
        }
        function E(de, i) {
          if (Array.isArray(de)) return (O) => E(O, de[0]);
          const v = {};
          for (const O of Object.keys(de)) {
            const V = de[O], ne = typeof V == "string" ? { message: () => V } : typeof V == "function" ? { message: V } : V, { message: ce } = ne, ve = l(ne, p), Ce = typeof ce == "string" ? () => ce : ce;
            v[O] = m(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: O, toMessage: Ce }, i ? { syntaxPlugin: i } : {}, ve));
          }
          return v;
        }
        const _ = Object.assign({}, E(r), E(S), E({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: de }) => `Assigning to '${de}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: de }) => `Binding '${de}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), E`pipelineOperator`(d)), { defineProperty: C } = Object, w = (de, i) => {
          de && C(de, i, { enumerable: false, value: de[i] });
        };
        function I(de) {
          return w(de.loc.start, "index"), w(de.loc.end, "index"), de;
        }
        class D {
          constructor(i, v) {
            this.token = void 0, this.preserveSpace = void 0, this.token = i, this.preserveSpace = !!v;
          }
        }
        const j = { brace: new D("{"), j_oTag: new D("<tag"), j_cTag: new D("</tag"), j_expr: new D("<tag>...</tag>", true) };
        j.template = new D("`", true);
        class L {
          constructor(i, v = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = i, this.keyword = v.keyword, this.beforeExpr = !!v.beforeExpr, this.startsExpr = !!v.startsExpr, this.rightAssociative = !!v.rightAssociative, this.isLoop = !!v.isLoop, this.isAssign = !!v.isAssign, this.prefix = !!v.prefix, this.postfix = !!v.postfix, this.binop = v.binop != null ? v.binop : null, this.updateContext = null;
          }
        }
        const k = /* @__PURE__ */ new Map();
        function N(de, i = {}) {
          i.keyword = de;
          const v = Y(de, i);
          return k.set(de, v), v;
        }
        function F(de, i) {
          return Y(de, { beforeExpr: true, binop: i });
        }
        let W = -1;
        const X = [], H = [], U = [], q = [], ee = [], re = [];
        function Y(de, i = {}) {
          var v, O, V, ne;
          return ++W, H.push(de), U.push((v = i.binop) != null ? v : -1), q.push((O = i.beforeExpr) != null && O), ee.push((V = i.startsExpr) != null && V), re.push((ne = i.prefix) != null && ne), X.push(new L(de, i)), W;
        }
        function Z(de, i = {}) {
          var v, O, V, ne;
          return ++W, k.set(de, W), H.push(de), U.push((v = i.binop) != null ? v : -1), q.push((O = i.beforeExpr) != null && O), ee.push((V = i.startsExpr) != null && V), re.push((ne = i.prefix) != null && ne), X.push(new L("name", i)), W;
        }
        const G = { bracketL: Y("[", { beforeExpr: true, startsExpr: true }), bracketHashL: Y("#[", { beforeExpr: true, startsExpr: true }), bracketBarL: Y("[|", { beforeExpr: true, startsExpr: true }), bracketR: Y("]"), bracketBarR: Y("|]"), braceL: Y("{", { beforeExpr: true, startsExpr: true }), braceBarL: Y("{|", { beforeExpr: true, startsExpr: true }), braceHashL: Y("#{", { beforeExpr: true, startsExpr: true }), braceR: Y("}"), braceBarR: Y("|}"), parenL: Y("(", { beforeExpr: true, startsExpr: true }), parenR: Y(")"), comma: Y(",", { beforeExpr: true }), semi: Y(";", { beforeExpr: true }), colon: Y(":", { beforeExpr: true }), doubleColon: Y("::", { beforeExpr: true }), dot: Y("."), question: Y("?", { beforeExpr: true }), questionDot: Y("?."), arrow: Y("=>", { beforeExpr: true }), template: Y("template"), ellipsis: Y("...", { beforeExpr: true }), backQuote: Y("`", { startsExpr: true }), dollarBraceL: Y("${", { beforeExpr: true, startsExpr: true }), templateTail: Y("...`", { startsExpr: true }), templateNonTail: Y("...${", { beforeExpr: true, startsExpr: true }), at: Y("@"), hash: Y("#", { startsExpr: true }), interpreterDirective: Y("#!..."), eq: Y("=", { beforeExpr: true, isAssign: true }), assign: Y("_=", { beforeExpr: true, isAssign: true }), slashAssign: Y("_=", { beforeExpr: true, isAssign: true }), xorAssign: Y("_=", { beforeExpr: true, isAssign: true }), moduloAssign: Y("_=", { beforeExpr: true, isAssign: true }), incDec: Y("++/--", { prefix: true, postfix: true, startsExpr: true }), bang: Y("!", { beforeExpr: true, prefix: true, startsExpr: true }), tilde: Y("~", { beforeExpr: true, prefix: true, startsExpr: true }), doubleCaret: Y("^^", { startsExpr: true }), doubleAt: Y("@@", { startsExpr: true }), pipeline: F("|>", 0), nullishCoalescing: F("??", 1), logicalOR: F("||", 1), logicalAND: F("&&", 2), bitwiseOR: F("|", 3), bitwiseXOR: F("^", 4), bitwiseAND: F("&", 5), equality: F("==/!=/===/!==", 6), lt: F("</>/<=/>=", 7), gt: F("</>/<=/>=", 7), relational: F("</>/<=/>=", 7), bitShift: F("<</>>/>>>", 8), bitShiftL: F("<</>>/>>>", 8), bitShiftR: F("<</>>/>>>", 8), plusMin: Y("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: Y("%", { binop: 10, startsExpr: true }), star: Y("*", { binop: 10 }), slash: F("/", 10), exponent: Y("**", { beforeExpr: true, binop: 11, rightAssociative: true }), _in: N("in", { beforeExpr: true, binop: 7 }), _instanceof: N("instanceof", { beforeExpr: true, binop: 7 }), _break: N("break"), _case: N("case", { beforeExpr: true }), _catch: N("catch"), _continue: N("continue"), _debugger: N("debugger"), _default: N("default", { beforeExpr: true }), _else: N("else", { beforeExpr: true }), _finally: N("finally"), _function: N("function", { startsExpr: true }), _if: N("if"), _return: N("return", { beforeExpr: true }), _switch: N("switch"), _throw: N("throw", { beforeExpr: true, prefix: true, startsExpr: true }), _try: N("try"), _var: N("var"), _const: N("const"), _with: N("with"), _new: N("new", { beforeExpr: true, startsExpr: true }), _this: N("this", { startsExpr: true }), _super: N("super", { startsExpr: true }), _class: N("class", { startsExpr: true }), _extends: N("extends", { beforeExpr: true }), _export: N("export"), _import: N("import", { startsExpr: true }), _null: N("null", { startsExpr: true }), _true: N("true", { startsExpr: true }), _false: N("false", { startsExpr: true }), _typeof: N("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: N("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: N("delete", { beforeExpr: true, prefix: true, startsExpr: true }), _do: N("do", { isLoop: true, beforeExpr: true }), _for: N("for", { isLoop: true }), _while: N("while", { isLoop: true }), _as: Z("as", { startsExpr: true }), _assert: Z("assert", { startsExpr: true }), _async: Z("async", { startsExpr: true }), _await: Z("await", { startsExpr: true }), _defer: Z("defer", { startsExpr: true }), _from: Z("from", { startsExpr: true }), _get: Z("get", { startsExpr: true }), _let: Z("let", { startsExpr: true }), _meta: Z("meta", { startsExpr: true }), _of: Z("of", { startsExpr: true }), _sent: Z("sent", { startsExpr: true }), _set: Z("set", { startsExpr: true }), _source: Z("source", { startsExpr: true }), _static: Z("static", { startsExpr: true }), _using: Z("using", { startsExpr: true }), _yield: Z("yield", { startsExpr: true }), _asserts: Z("asserts", { startsExpr: true }), _checks: Z("checks", { startsExpr: true }), _exports: Z("exports", { startsExpr: true }), _global: Z("global", { startsExpr: true }), _implements: Z("implements", { startsExpr: true }), _intrinsic: Z("intrinsic", { startsExpr: true }), _infer: Z("infer", { startsExpr: true }), _is: Z("is", { startsExpr: true }), _mixins: Z("mixins", { startsExpr: true }), _proto: Z("proto", { startsExpr: true }), _require: Z("require", { startsExpr: true }), _satisfies: Z("satisfies", { startsExpr: true }), _keyof: Z("keyof", { startsExpr: true }), _readonly: Z("readonly", { startsExpr: true }), _unique: Z("unique", { startsExpr: true }), _abstract: Z("abstract", { startsExpr: true }), _declare: Z("declare", { startsExpr: true }), _enum: Z("enum", { startsExpr: true }), _module: Z("module", { startsExpr: true }), _namespace: Z("namespace", { startsExpr: true }), _interface: Z("interface", { startsExpr: true }), _type: Z("type", { startsExpr: true }), _opaque: Z("opaque", { startsExpr: true }), name: Y("name", { startsExpr: true }), placeholder: Y("%%", { startsExpr: true }), string: Y("string", { startsExpr: true }), num: Y("num", { startsExpr: true }), bigint: Y("bigint", { startsExpr: true }), decimal: Y("decimal", { startsExpr: true }), regexp: Y("regexp", { startsExpr: true }), privateName: Y("#name", { startsExpr: true }), eof: Y("eof"), jsxName: Y("jsxName"), jsxText: Y("jsxText", { beforeExpr: true }), jsxTagStart: Y("jsxTagStart", { startsExpr: true }), jsxTagEnd: Y("jsxTagEnd") };
        function B(de) {
          return de >= 93 && de <= 133;
        }
        function z(de) {
          return de >= 58 && de <= 133;
        }
        function M(de) {
          return de >= 58 && de <= 137;
        }
        function K(de) {
          return ee[de];
        }
        function Q(de) {
          return de >= 129 && de <= 131;
        }
        function ie(de) {
          return de >= 58 && de <= 92;
        }
        function ue(de) {
          return H[de];
        }
        function ge(de) {
          return U[de];
        }
        function Te(de) {
          return de >= 24 && de <= 25;
        }
        function le(de) {
          return X[de];
        }
        X[8].updateContext = (de) => {
          de.pop();
        }, X[5].updateContext = X[7].updateContext = X[23].updateContext = (de) => {
          de.push(j.brace);
        }, X[22].updateContext = (de) => {
          de[de.length - 1] === j.template ? de.pop() : de.push(j.template);
        }, X[143].updateContext = (de) => {
          de.push(j.j_expr, j.j_oTag);
        };
        let fe = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Pe = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
        const xe = new RegExp("[" + fe + "]"), we = new RegExp("[" + fe + Pe + "]");
        fe = Pe = null;
        const me = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], ye = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function pe(de, i) {
          let v = 65536;
          for (let O = 0, V = i.length; O < V; O += 2) {
            if (v += i[O], v > de) return false;
            if (v += i[O + 1], v >= de) return true;
          }
          return false;
        }
        function J(de) {
          return de < 65 ? de === 36 : de <= 90 || (de < 97 ? de === 95 : de <= 122 || (de <= 65535 ? de >= 170 && xe.test(String.fromCharCode(de)) : pe(de, me)));
        }
        function Ee(de) {
          return de < 48 ? de === 36 : de < 58 || !(de < 65) && (de <= 90 || (de < 97 ? de === 95 : de <= 122 || (de <= 65535 ? de >= 170 && we.test(String.fromCharCode(de)) : pe(de, me) || pe(de, ye))));
        }
        const Me = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], Ue = ["eval", "arguments"], qe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), He = new Set(Me), Ie = new Set(Ue);
        function Re(de, i) {
          return i && de === "await" || de === "enum";
        }
        function Be(de, i) {
          return Re(de, i) || He.has(de);
        }
        function je(de) {
          return Ie.has(de);
        }
        function he(de, i) {
          return Be(de, i) || je(de);
        }
        const oe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        class _e {
          constructor(i) {
            this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = i;
          }
        }
        class Ne {
          constructor(i, v) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = i, this.inModule = v;
          }
          get inTopLevel() {
            return (1 & this.currentScope().flags) > 0;
          }
          get inFunction() {
            return (2 & this.currentVarScopeFlags()) > 0;
          }
          get allowSuper() {
            return (16 & this.currentThisScopeFlags()) > 0;
          }
          get allowDirectSuper() {
            return (32 & this.currentThisScopeFlags()) > 0;
          }
          get inClass() {
            return (64 & this.currentThisScopeFlags()) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            const i = this.currentThisScopeFlags();
            return (64 & i) > 0 && !(2 & i);
          }
          get inStaticBlock() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const { flags: v } = this.scopeStack[i];
              if (128 & v) return true;
              if (451 & v) return false;
            }
          }
          get inNonArrowFunction() {
            return (2 & this.currentThisScopeFlags()) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(i) {
            return new _e(i);
          }
          enter(i) {
            this.scopeStack.push(this.createScope(i));
          }
          exit() {
            return this.scopeStack.pop().flags;
          }
          treatFunctionsAsVarInScope(i) {
            return !!(130 & i.flags || !this.parser.inModule && 1 & i.flags);
          }
          declareName(i, v, O) {
            let V = this.currentScope();
            if (8 & v || 16 & v) {
              this.checkRedeclarationInScope(V, i, v, O);
              let ne = V.names.get(i) || 0;
              16 & v ? ne |= 4 : (V.firstLexicalName || (V.firstLexicalName = i), ne |= 2), V.names.set(i, ne), 8 & v && this.maybeExportDefined(V, i);
            } else if (4 & v) for (let ne = this.scopeStack.length - 1; ne >= 0 && (V = this.scopeStack[ne], this.checkRedeclarationInScope(V, i, v, O), V.names.set(i, 1 | (V.names.get(i) || 0)), this.maybeExportDefined(V, i), !(387 & V.flags)); --ne) ;
            this.parser.inModule && 1 & V.flags && this.undefinedExports.delete(i);
          }
          maybeExportDefined(i, v) {
            this.parser.inModule && 1 & i.flags && this.undefinedExports.delete(v);
          }
          checkRedeclarationInScope(i, v, O, V) {
            this.isRedeclaredInScope(i, v, O) && this.parser.raise(_.VarRedeclaration, V, { identifierName: v });
          }
          isRedeclaredInScope(i, v, O) {
            if (!(1 & O)) return false;
            if (8 & O) return i.names.has(v);
            const V = i.names.get(v);
            return 16 & O ? (2 & V) > 0 || !this.treatFunctionsAsVarInScope(i) && (1 & V) > 0 : (2 & V) > 0 && !(8 & i.flags && i.firstLexicalName === v) || !this.treatFunctionsAsVarInScope(i) && (4 & V) > 0;
          }
          checkLocalExport(i) {
            const { name: v } = i;
            this.scopeStack[0].names.has(v) || this.undefinedExports.set(v, i.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const { flags: v } = this.scopeStack[i];
              if (387 & v) return v;
            }
          }
          currentThisScopeFlags() {
            for (let i = this.scopeStack.length - 1; ; i--) {
              const { flags: v } = this.scopeStack[i];
              if (451 & v && !(4 & v)) return v;
            }
          }
        }
        class $e extends _e {
          constructor(...i) {
            super(...i), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }
        class Xe extends Ne {
          createScope(i) {
            return new $e(i);
          }
          declareName(i, v, O) {
            const V = this.currentScope();
            if (2048 & v) return this.checkRedeclarationInScope(V, i, v, O), this.maybeExportDefined(V, i), void V.declareFunctions.add(i);
            super.declareName(i, v, O);
          }
          isRedeclaredInScope(i, v, O) {
            if (super.isRedeclaredInScope(i, v, O)) return true;
            if (2048 & O && !i.declareFunctions.has(v)) {
              const V = i.names.get(v);
              return (4 & V) > 0 || (2 & V) > 0;
            }
            return false;
          }
          checkLocalExport(i) {
            this.scopeStack[0].declareFunctions.has(i.name) || super.checkLocalExport(i);
          }
        }
        class Je {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          sourceToOffsetPos(i) {
            return i + this.startIndex;
          }
          offsetToSourcePos(i) {
            return i - this.startIndex;
          }
          hasPlugin(i) {
            if (typeof i == "string") return this.plugins.has(i);
            {
              const [v, O] = i;
              if (!this.hasPlugin(v)) return false;
              const V = this.plugins.get(v);
              for (const ne of Object.keys(O)) if ((V == null ? void 0 : V[ne]) !== O[ne]) return false;
              return true;
            }
          }
          getPluginOption(i, v) {
            var O;
            return (O = this.plugins.get(i)) == null ? void 0 : O[v];
          }
        }
        function st(de, i) {
          de.trailingComments === void 0 ? de.trailingComments = i : de.trailingComments.unshift(...i);
        }
        function be(de, i) {
          de.innerComments === void 0 ? de.innerComments = i : de.innerComments.unshift(...i);
        }
        function ke(de, i, v) {
          let O = null, V = i.length;
          for (; O === null && V > 0; ) O = i[--V];
          O === null || O.start > v.start ? be(de, v.comments) : st(O, v.comments);
        }
        class Ve extends Je {
          addComment(i) {
            this.filename && (i.loc.filename = this.filename);
            const { commentsLen: v } = this.state;
            this.comments.length !== v && (this.comments.length = v), this.comments.push(i), this.state.commentsLen++;
          }
          processComment(i) {
            const { commentStack: v } = this.state, O = v.length;
            if (O === 0) return;
            let V = O - 1;
            const ne = v[V];
            ne.start === i.end && (ne.leadingNode = i, V--);
            const { start: ce } = i;
            for (; V >= 0; V--) {
              const ve = v[V], Ce = ve.end;
              if (!(Ce > ce)) {
                Ce === ce && (ve.trailingNode = i);
                break;
              }
              ve.containingNode = i, this.finalizeComment(ve), v.splice(V, 1);
            }
          }
          finalizeComment(i) {
            const { comments: v } = i;
            if (i.leadingNode !== null || i.trailingNode !== null) i.leadingNode !== null && st(i.leadingNode, v), i.trailingNode !== null && function(O, V) {
              O.leadingComments === void 0 ? O.leadingComments = V : O.leadingComments.unshift(...V);
            }(i.trailingNode, v);
            else {
              const { containingNode: O, start: V } = i;
              if (this.input.charCodeAt(this.offsetToSourcePos(V) - 1) === 44) switch (O.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  ke(O, O.properties, i);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  ke(O, O.arguments, i);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  ke(O, O.params, i);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  ke(O, O.elements, i);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  ke(O, O.specifiers, i);
                  break;
                default:
                  be(O, v);
              }
              else be(O, v);
            }
          }
          finalizeRemainingComments() {
            const { commentStack: i } = this.state;
            for (let v = i.length - 1; v >= 0; v--) this.finalizeComment(i[v]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(i) {
            const { commentStack: v } = this.state, { length: O } = v;
            if (O === 0) return;
            const V = v[O - 1];
            V.leadingNode === i && (V.leadingNode = null);
          }
          resetPreviousIdentifierLeadingComments(i) {
            const { commentStack: v } = this.state, { length: O } = v;
            O !== 0 && (v[O - 1].trailingNode === i ? v[O - 1].trailingNode = null : O >= 2 && v[O - 2].trailingNode === i && (v[O - 2].trailingNode = null));
          }
          takeSurroundingComments(i, v, O) {
            const { commentStack: V } = this.state, ne = V.length;
            if (ne === 0) return;
            let ce = ne - 1;
            for (; ce >= 0; ce--) {
              const ve = V[ce], Ce = ve.end;
              if (ve.start === O) ve.leadingNode = i;
              else if (Ce === v) ve.trailingNode = i;
              else if (Ce < v) break;
            }
          }
        }
        const ze = new RegExp(/\r\n|[\r\n\u2028\u2029]/.source, "g");
        function rt(de) {
          switch (de) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        function it(de, i, v) {
          for (let O = i; O < v; O++) if (rt(de.charCodeAt(O))) return true;
          return false;
        }
        const Ye = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, tt = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
        function pt(de) {
          switch (de) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        class Et {
          constructor() {
            this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [j.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          get strict() {
            return (1 & this.flags) > 0;
          }
          set strict(i) {
            i ? this.flags |= 1 : this.flags &= -2;
          }
          init({ strictMode: i, sourceType: v, startIndex: O, startLine: V, startColumn: ne }) {
            this.strict = i !== false && (i === true || v === "module"), this.startIndex = O, this.curLine = V, this.lineStart = -ne, this.startLoc = this.endLoc = new n(V, ne, O);
          }
          get maybeInArrowParameters() {
            return (2 & this.flags) > 0;
          }
          set maybeInArrowParameters(i) {
            i ? this.flags |= 2 : this.flags &= -3;
          }
          get inType() {
            return (4 & this.flags) > 0;
          }
          set inType(i) {
            i ? this.flags |= 4 : this.flags &= -5;
          }
          get noAnonFunctionType() {
            return (8 & this.flags) > 0;
          }
          set noAnonFunctionType(i) {
            i ? this.flags |= 8 : this.flags &= -9;
          }
          get hasFlowComment() {
            return (16 & this.flags) > 0;
          }
          set hasFlowComment(i) {
            i ? this.flags |= 16 : this.flags &= -17;
          }
          get isAmbientContext() {
            return (32 & this.flags) > 0;
          }
          set isAmbientContext(i) {
            i ? this.flags |= 32 : this.flags &= -33;
          }
          get inAbstractClass() {
            return (64 & this.flags) > 0;
          }
          set inAbstractClass(i) {
            i ? this.flags |= 64 : this.flags &= -65;
          }
          get inDisallowConditionalTypesContext() {
            return (128 & this.flags) > 0;
          }
          set inDisallowConditionalTypesContext(i) {
            i ? this.flags |= 128 : this.flags &= -129;
          }
          get soloAwait() {
            return (256 & this.flags) > 0;
          }
          set soloAwait(i) {
            i ? this.flags |= 256 : this.flags &= -257;
          }
          get inFSharpPipelineDirectBody() {
            return (512 & this.flags) > 0;
          }
          set inFSharpPipelineDirectBody(i) {
            i ? this.flags |= 512 : this.flags &= -513;
          }
          get canStartJSXElement() {
            return (1024 & this.flags) > 0;
          }
          set canStartJSXElement(i) {
            i ? this.flags |= 1024 : this.flags &= -1025;
          }
          get containsEsc() {
            return (2048 & this.flags) > 0;
          }
          set containsEsc(i) {
            i ? this.flags |= 2048 : this.flags &= -2049;
          }
          get hasTopLevelAwait() {
            return (4096 & this.flags) > 0;
          }
          set hasTopLevelAwait(i) {
            i ? this.flags |= 4096 : this.flags &= -4097;
          }
          curPosition() {
            return new n(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
          }
          clone() {
            const i = new Et();
            return i.flags = this.flags, i.startIndex = this.startIndex, i.curLine = this.curLine, i.lineStart = this.lineStart, i.startLoc = this.startLoc, i.endLoc = this.endLoc, i.errors = this.errors.slice(), i.potentialArrowAt = this.potentialArrowAt, i.noArrowAt = this.noArrowAt.slice(), i.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), i.topicContext = this.topicContext, i.labels = this.labels.slice(), i.commentsLen = this.commentsLen, i.commentStack = this.commentStack.slice(), i.pos = this.pos, i.type = this.type, i.value = this.value, i.start = this.start, i.end = this.end, i.lastTokEndLoc = this.lastTokEndLoc, i.lastTokStartLoc = this.lastTokStartLoc, i.context = this.context.slice(), i.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, i.strictErrors = this.strictErrors, i.tokensLength = this.tokensLength, i;
          }
        }
        var Qe = function(de) {
          return de >= 48 && de <= 57;
        };
        const yt = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, vt = { bin: (de) => de === 48 || de === 49, oct: (de) => de >= 48 && de <= 55, dec: (de) => de >= 48 && de <= 57, hex: (de) => de >= 48 && de <= 57 || de >= 65 && de <= 70 || de >= 97 && de <= 102 };
        function kt(de, i, v, O, V, ne) {
          const ce = v, ve = O, Ce = V;
          let Le = "", Ke = null, ut = v;
          const { length: At } = i;
          for (; ; ) {
            if (v >= At) {
              ne.unterminated(ce, ve, Ce), Le += i.slice(ut, v);
              break;
            }
            const bt = i.charCodeAt(v);
            if (qt(de, bt, i, v)) {
              Le += i.slice(ut, v);
              break;
            }
            if (bt === 92) {
              Le += i.slice(ut, v);
              const Nt = sn(i, v, O, V, de === "template", ne);
              Nt.ch !== null || Ke ? Le += Nt.ch : Ke = { pos: v, lineStart: O, curLine: V }, { pos: v, lineStart: O, curLine: V } = Nt, ut = v;
            } else bt === 8232 || bt === 8233 ? (++V, O = ++v) : bt === 10 || bt === 13 ? de === "template" ? (Le += i.slice(ut, v) + `
`, ++v, bt === 13 && i.charCodeAt(v) === 10 && ++v, ++V, ut = O = v) : ne.unterminated(ce, ve, Ce) : ++v;
          }
          return { pos: v, str: Le, firstInvalidLoc: Ke, lineStart: O, curLine: V, containsInvalid: !!Ke };
        }
        function qt(de, i, v, O) {
          return de === "template" ? i === 96 || i === 36 && v.charCodeAt(O + 1) === 123 : i === (de === "double" ? 34 : 39);
        }
        function sn(de, i, v, O, V, ne) {
          const ce = !V;
          i++;
          const ve = (Le) => ({ pos: i, ch: Le, lineStart: v, curLine: O }), Ce = de.charCodeAt(i++);
          switch (Ce) {
            case 110:
              return ve(`
`);
            case 114:
              return ve("\r");
            case 120: {
              let Le;
              return { code: Le, pos: i } = _n(de, i, v, O, 2, false, ce, ne), ve(Le === null ? null : String.fromCharCode(Le));
            }
            case 117: {
              let Le;
              return { code: Le, pos: i } = Kt(de, i, v, O, ce, ne), ve(Le === null ? null : String.fromCodePoint(Le));
            }
            case 116:
              return ve("	");
            case 98:
              return ve("\b");
            case 118:
              return ve("\v");
            case 102:
              return ve("\f");
            case 13:
              de.charCodeAt(i) === 10 && ++i;
            case 10:
              v = i, ++O;
            case 8232:
            case 8233:
              return ve("");
            case 56:
            case 57:
              if (V) return ve(null);
              ne.strictNumericEscape(i - 1, v, O);
            default:
              if (Ce >= 48 && Ce <= 55) {
                const Le = i - 1;
                let Ke = /^[0-7]+/.exec(de.slice(Le, i + 2))[0], ut = parseInt(Ke, 8);
                ut > 255 && (Ke = Ke.slice(0, -1), ut = parseInt(Ke, 8)), i += Ke.length - 1;
                const At = de.charCodeAt(i);
                if (Ke !== "0" || At === 56 || At === 57) {
                  if (V) return ve(null);
                  ne.strictNumericEscape(Le, v, O);
                }
                return ve(String.fromCharCode(ut));
              }
              return ve(String.fromCharCode(Ce));
          }
        }
        function _n(de, i, v, O, V, ne, ce, ve) {
          const Ce = i;
          let Le;
          return { n: Le, pos: i } = bn(de, i, v, O, 16, V, ne, false, ve, !ce), Le === null && (ce ? ve.invalidEscapeSequence(Ce, v, O) : i = Ce - 1), { code: Le, pos: i };
        }
        function bn(de, i, v, O, V, ne, ce, ve, Ce, Le) {
          const Ke = i, ut = V === 16 ? yt.hex : yt.decBinOct, At = V === 16 ? vt.hex : V === 10 ? vt.dec : V === 8 ? vt.oct : vt.bin;
          let bt = false, Nt = 0;
          for (let dn = 0, kn = ne ?? 1 / 0; dn < kn; ++dn) {
            const en = de.charCodeAt(i);
            let wn;
            if (en !== 95 || ve === "bail") {
              if (wn = en >= 97 ? en - 97 + 10 : en >= 65 ? en - 65 + 10 : Qe(en) ? en - 48 : 1 / 0, wn >= V) {
                if (wn <= 9 && Le) return { n: null, pos: i };
                if (wn <= 9 && Ce.invalidDigit(i, v, O, V)) wn = 0;
                else {
                  if (!ce) break;
                  wn = 0, bt = true;
                }
              }
              ++i, Nt = Nt * V + wn;
            } else {
              const ls = de.charCodeAt(i - 1), ti = de.charCodeAt(i + 1);
              if (ve) {
                if (Number.isNaN(ti) || !At(ti) || ut.has(ls) || ut.has(ti)) {
                  if (Le) return { n: null, pos: i };
                  Ce.unexpectedNumericSeparator(i, v, O);
                }
              } else {
                if (Le) return { n: null, pos: i };
                Ce.numericSeparatorInEscapeSequence(i, v, O);
              }
              ++i;
            }
          }
          return i === Ke || ne != null && i - Ke !== ne || bt ? { n: null, pos: i } : { n: Nt, pos: i };
        }
        function Kt(de, i, v, O, V, ne) {
          let ce;
          if (de.charCodeAt(i) === 123) {
            if (++i, { code: ce, pos: i } = _n(de, i, v, O, de.indexOf("}", i) - i, true, V, ne), ++i, ce !== null && ce > 1114111) {
              if (!V) return { code: null, pos: i };
              ne.invalidCodePoint(i, v, O);
            }
          } else ({ code: ce, pos: i } = _n(de, i, v, O, 4, false, V, ne));
          return { code: ce, pos: i };
        }
        function Jt(de, i, v) {
          return new n(v, de - i, de);
        }
        const Ft = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
        class fn {
          constructor(i) {
            const v = i.startIndex || 0;
            this.type = i.type, this.value = i.value, this.start = v + i.start, this.end = v + i.end, this.loc = new u(i.startLoc, i.endLoc);
          }
        }
        class _t extends Ve {
          constructor(i, v) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (O, V, ne, ce) => !!this.options.errorRecovery && (this.raise(_.InvalidDigit, Jt(O, V, ne), { radix: ce }), true), numericSeparatorInEscapeSequence: this.errorBuilder(_.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(_.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(_.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(_.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (O, V, ne) => {
              this.recordStrictModeErrors(_.StrictNumericEscape, Jt(O, V, ne));
            }, unterminated: (O, V, ne) => {
              throw this.raise(_.UnterminatedString, Jt(O - 1, V, ne));
            } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(_.StrictNumericEscape), unterminated: (O, V, ne) => {
              throw this.raise(_.UnterminatedTemplate, Jt(O, V, ne));
            } }), this.state = new Et(), this.state.init(i), this.input = v, this.length = v.length, this.comments = [], this.isLookahead = false;
          }
          pushToken(i) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(i), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new fn(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(i) {
            return !!this.match(i) && (this.next(), true);
          }
          match(i) {
            return this.state.type === i;
          }
          createLookaheadState(i) {
            return { pos: i.pos, value: null, type: i.type, start: i.start, end: i.end, context: [this.curContext()], inType: i.inType, startLoc: i.startLoc, lastTokEndLoc: i.lastTokEndLoc, curLine: i.curLine, lineStart: i.lineStart, curPosition: i.curPosition };
          }
          lookahead() {
            const i = this.state;
            this.state = this.createLookaheadState(i), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
            const v = this.state;
            return this.state = i, v;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(i) {
            return Ye.lastIndex = i, Ye.test(this.input) ? Ye.lastIndex : i;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
          nextTokenInLineStartSince(i) {
            return tt.lastIndex = i, tt.test(this.input) ? tt.lastIndex : i;
          }
          lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
          codePointAtPos(i) {
            let v = this.input.charCodeAt(i);
            if ((64512 & v) == 55296 && ++i < this.input.length) {
              const O = this.input.charCodeAt(i);
              (64512 & O) == 56320 && (v = 65536 + ((1023 & v) << 10) + (1023 & O));
            }
            return v;
          }
          setStrict(i) {
            this.state.strict = i, i && (this.state.strictErrors.forEach(([v, O]) => this.raise(v, O)), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(140) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment(i) {
            let v;
            this.isLookahead || (v = this.state.curPosition());
            const O = this.state.pos, V = this.input.indexOf(i, O + 2);
            if (V === -1) throw this.raise(_.UnterminatedComment, this.state.curPosition());
            for (this.state.pos = V + i.length, ze.lastIndex = O + 2; ze.test(this.input) && ze.lastIndex <= V; ) ++this.state.curLine, this.state.lineStart = ze.lastIndex;
            if (this.isLookahead) return;
            const ne = { type: "CommentBlock", value: this.input.slice(O + 2, V), start: this.sourceToOffsetPos(O), end: this.sourceToOffsetPos(V + i.length), loc: new u(v, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(ne), ne;
          }
          skipLineComment(i) {
            const v = this.state.pos;
            let O;
            this.isLookahead || (O = this.state.curPosition());
            let V = this.input.charCodeAt(this.state.pos += i);
            if (this.state.pos < this.length) for (; !rt(V) && ++this.state.pos < this.length; ) V = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead) return;
            const ne = this.state.pos, ce = { type: "CommentLine", value: this.input.slice(v + i, ne), start: this.sourceToOffsetPos(v), end: this.sourceToOffsetPos(ne), loc: new u(O, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(ce), ce;
          }
          skipSpace() {
            const i = this.state.pos, v = [];
            e: for (; this.state.pos < this.length; ) {
              const O = this.input.charCodeAt(this.state.pos);
              switch (O) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      const V = this.skipBlockComment("*/");
                      V !== void 0 && (this.addComment(V), this.options.attachComment && v.push(V));
                      break;
                    }
                    case 47: {
                      const V = this.skipLineComment(2);
                      V !== void 0 && (this.addComment(V), this.options.attachComment && v.push(V));
                      break;
                    }
                    default:
                      break e;
                  }
                  break;
                default:
                  if (pt(O)) ++this.state.pos;
                  else if (O === 45 && !this.inModule && this.options.annexB) {
                    const V = this.state.pos;
                    if (this.input.charCodeAt(V + 1) !== 45 || this.input.charCodeAt(V + 2) !== 62 || !(i === 0 || this.state.lineStart > i)) break e;
                    {
                      const ne = this.skipLineComment(3);
                      ne !== void 0 && (this.addComment(ne), this.options.attachComment && v.push(ne));
                    }
                  } else {
                    if (O !== 60 || this.inModule || !this.options.annexB) break e;
                    {
                      const V = this.state.pos;
                      if (this.input.charCodeAt(V + 1) !== 33 || this.input.charCodeAt(V + 2) !== 45 || this.input.charCodeAt(V + 3) !== 45) break e;
                      {
                        const ne = this.skipLineComment(4);
                        ne !== void 0 && (this.addComment(ne), this.options.attachComment && v.push(ne));
                      }
                    }
                  }
              }
            }
            if (v.length > 0) {
              const O = this.state.pos, V = { start: this.sourceToOffsetPos(i), end: this.sourceToOffsetPos(O), comments: v, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(V);
            }
          }
          finishToken(i, v) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            const O = this.state.type;
            this.state.type = i, this.state.value = v, this.isLookahead || this.updateContext(O);
          }
          replaceToken(i) {
            this.state.type = i, this.updateContext();
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter()) return;
            const i = this.state.pos + 1, v = this.codePointAtPos(i);
            if (v >= 48 && v <= 57) throw this.raise(_.UnexpectedDigitAfterHash, this.state.curPosition());
            if (v === 123 || v === 91 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar") throw this.raise(v === 123 ? _.RecordExpressionHashIncorrectStartSyntaxType : _.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
              this.state.pos += 2, v === 123 ? this.finishToken(7) : this.finishToken(1);
            } else J(v) ? (++this.state.pos, this.finishToken(139, this.readWord1(v))) : v === 92 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            const i = this.input.charCodeAt(this.state.pos + 1);
            i >= 48 && i <= 57 ? this.readNumber(true) : i === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2) return false;
            let i = this.input.charCodeAt(this.state.pos + 1);
            if (i !== 33) return false;
            const v = this.state.pos;
            for (this.state.pos += 1; !rt(i) && ++this.state.pos < this.length; ) i = this.input.charCodeAt(this.state.pos);
            const O = this.input.slice(v + 2, this.state.pos);
            return this.finishToken(28, O), true;
          }
          readToken_mult_modulo(i) {
            let v = i === 42 ? 55 : 54, O = 1, V = this.input.charCodeAt(this.state.pos + 1);
            i === 42 && V === 42 && (O++, V = this.input.charCodeAt(this.state.pos + 2), v = 57), V !== 61 || this.state.inType || (O++, v = i === 37 ? 33 : 30), this.finishOp(v, O);
          }
          readToken_pipe_amp(i) {
            const v = this.input.charCodeAt(this.state.pos + 1);
            if (v !== i) {
              if (i === 124) {
                if (v === 62) return void this.finishOp(39, 2);
                if (this.hasPlugin("recordAndTuple") && v === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(_.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                  return this.state.pos += 2, void this.finishToken(9);
                }
                if (this.hasPlugin("recordAndTuple") && v === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(_.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                  return this.state.pos += 2, void this.finishToken(4);
                }
              }
              v !== 61 ? this.finishOp(i === 124 ? 43 : 45, 1) : this.finishOp(30, 2);
            } else this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(i === 124 ? 41 : 42, 2);
          }
          readToken_caret() {
            const i = this.input.charCodeAt(this.state.pos + 1);
            i !== 61 || this.state.inType ? i === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1) : this.finishOp(32, 2);
          }
          readToken_atSign() {
            this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
          }
          readToken_plus_min(i) {
            const v = this.input.charCodeAt(this.state.pos + 1);
            v !== i ? v === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
          }
          readToken_lt() {
            const { pos: i } = this.state, v = this.input.charCodeAt(i + 1);
            if (v === 60) return this.input.charCodeAt(i + 2) === 61 ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
            v !== 61 ? this.finishOp(47, 1) : this.finishOp(49, 2);
          }
          readToken_gt() {
            const { pos: i } = this.state, v = this.input.charCodeAt(i + 1);
            if (v === 62) {
              const O = this.input.charCodeAt(i + 2) === 62 ? 3 : 2;
              return this.input.charCodeAt(i + O) === 61 ? void this.finishOp(30, O + 1) : void this.finishOp(52, O);
            }
            v !== 61 ? this.finishOp(48, 1) : this.finishOp(49, 2);
          }
          readToken_eq_excl(i) {
            const v = this.input.charCodeAt(this.state.pos + 1);
            if (v !== 61) return i === 61 && v === 62 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(i === 61 ? 29 : 35, 1);
            this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          }
          readToken_question() {
            const i = this.input.charCodeAt(this.state.pos + 1), v = this.input.charCodeAt(this.state.pos + 2);
            i === 63 ? v === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : i !== 46 || v >= 48 && v <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
          }
          getTokenFromCode(i) {
            switch (i) {
              case 46:
                return void this.readToken_dot();
              case 40:
                return ++this.state.pos, void this.finishToken(10);
              case 41:
                return ++this.state.pos, void this.finishToken(11);
              case 59:
                return ++this.state.pos, void this.finishToken(13);
              case 44:
                return ++this.state.pos, void this.finishToken(12);
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(_.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(2);
                } else ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                return ++this.state.pos, void this.finishToken(3);
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(_.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(6);
                } else ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                return ++this.state.pos, void this.finishToken(8);
              case 58:
                return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
              case 63:
                return void this.readToken_question();
              case 96:
                return void this.readTemplateToken();
              case 48: {
                const v = this.input.charCodeAt(this.state.pos + 1);
                if (v === 120 || v === 88) return void this.readRadixNumber(16);
                if (v === 111 || v === 79) return void this.readRadixNumber(8);
                if (v === 98 || v === 66) return void this.readRadixNumber(2);
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return void this.readNumber(false);
              case 34:
              case 39:
                return void this.readString(i);
              case 47:
                return void this.readToken_slash();
              case 37:
              case 42:
                return void this.readToken_mult_modulo(i);
              case 124:
              case 38:
                return void this.readToken_pipe_amp(i);
              case 94:
                return void this.readToken_caret();
              case 43:
              case 45:
                return void this.readToken_plus_min(i);
              case 60:
                return void this.readToken_lt();
              case 62:
                return void this.readToken_gt();
              case 61:
              case 33:
                return void this.readToken_eq_excl(i);
              case 126:
                return void this.finishOp(36, 1);
              case 64:
                return void this.readToken_atSign();
              case 35:
                return void this.readToken_numberSign();
              case 92:
                return void this.readWord();
              default:
                if (J(i)) return void this.readWord(i);
            }
            throw this.raise(_.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(i) });
          }
          finishOp(i, v) {
            const O = this.input.slice(this.state.pos, this.state.pos + v);
            this.state.pos += v, this.finishToken(i, O);
          }
          readRegexp() {
            const i = this.state.startLoc, v = this.state.start + 1;
            let O, V, { pos: ne } = this.state;
            for (; ; ++ne) {
              if (ne >= this.length) throw this.raise(_.UnterminatedRegExp, c(i, 1));
              const Le = this.input.charCodeAt(ne);
              if (rt(Le)) throw this.raise(_.UnterminatedRegExp, c(i, 1));
              if (O) O = false;
              else {
                if (Le === 91) V = true;
                else if (Le === 93 && V) V = false;
                else if (Le === 47 && !V) break;
                O = Le === 92;
              }
            }
            const ce = this.input.slice(v, ne);
            ++ne;
            let ve = "";
            const Ce = () => c(i, ne + 2 - v);
            for (; ne < this.length; ) {
              const Le = this.codePointAtPos(ne), Ke = String.fromCharCode(Le);
              if (Ft.has(Le)) Le === 118 ? ve.includes("u") && this.raise(_.IncompatibleRegExpUVFlags, Ce()) : Le === 117 && ve.includes("v") && this.raise(_.IncompatibleRegExpUVFlags, Ce()), ve.includes(Ke) && this.raise(_.DuplicateRegExpFlags, Ce());
              else {
                if (!Ee(Le) && Le !== 92) break;
                this.raise(_.MalformedRegExpFlags, Ce());
              }
              ++ne, ve += Ke;
            }
            this.state.pos = ne, this.finishToken(138, { pattern: ce, flags: ve });
          }
          readInt(i, v, O = false, V = true) {
            const { n: ne, pos: ce } = bn(this.input, this.state.pos, this.state.lineStart, this.state.curLine, i, v, O, V, this.errorHandlers_readInt, false);
            return this.state.pos = ce, ne;
          }
          readRadixNumber(i) {
            const v = this.state.pos, O = this.state.curPosition();
            let V = false;
            this.state.pos += 2;
            const ne = this.readInt(i);
            ne == null && this.raise(_.InvalidDigit, c(O, 2), { radix: i });
            const ce = this.input.charCodeAt(this.state.pos);
            if (ce === 110) ++this.state.pos, V = true;
            else if (ce === 109) throw this.raise(_.InvalidDecimal, O);
            if (J(this.codePointAtPos(this.state.pos))) throw this.raise(_.NumberIdentifier, this.state.curPosition());
            if (V) {
              const ve = this.input.slice(v, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(136, ve);
            } else this.finishToken(135, ne);
          }
          readNumber(i) {
            const v = this.state.pos, O = this.state.curPosition();
            let V = false, ne = false, ce = false, ve = false;
            i || this.readInt(10) !== null || this.raise(_.InvalidNumber, this.state.curPosition());
            const Ce = this.state.pos - v >= 2 && this.input.charCodeAt(v) === 48;
            if (Ce) {
              const bt = this.input.slice(v, this.state.pos);
              if (this.recordStrictModeErrors(_.StrictOctalLiteral, O), !this.state.strict) {
                const Nt = bt.indexOf("_");
                Nt > 0 && this.raise(_.ZeroDigitNumericSeparator, c(O, Nt));
              }
              ve = Ce && !/[89]/.test(bt);
            }
            let Le = this.input.charCodeAt(this.state.pos);
            if (Le !== 46 || ve || (++this.state.pos, this.readInt(10), V = true, Le = this.input.charCodeAt(this.state.pos)), Le !== 69 && Le !== 101 || ve || (Le = this.input.charCodeAt(++this.state.pos), Le !== 43 && Le !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(_.InvalidOrMissingExponent, O), V = true, ce = true, Le = this.input.charCodeAt(this.state.pos)), Le === 110 && ((V || Ce) && this.raise(_.InvalidBigIntLiteral, O), ++this.state.pos, ne = true), Le === 109) {
              this.expectPlugin("decimal", this.state.curPosition()), (ce || Ce) && this.raise(_.InvalidDecimal, O), ++this.state.pos;
              var Ke = true;
            }
            if (J(this.codePointAtPos(this.state.pos))) throw this.raise(_.NumberIdentifier, this.state.curPosition());
            const ut = this.input.slice(v, this.state.pos).replace(/[_mn]/g, "");
            if (ne) return void this.finishToken(136, ut);
            if (Ke) return void this.finishToken(137, ut);
            const At = ve ? parseInt(ut, 8) : parseFloat(ut);
            this.finishToken(135, At);
          }
          readCodePoint(i) {
            const { code: v, pos: O } = Kt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, i, this.errorHandlers_readCodePoint);
            return this.state.pos = O, v;
          }
          readString(i) {
            const { str: v, pos: O, curLine: V, lineStart: ne } = kt(i === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = O + 1, this.state.lineStart = ne, this.state.curLine = V, this.finishToken(134, v);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            const i = this.input[this.state.pos], { str: v, firstInvalidLoc: O, pos: V, curLine: ne, lineStart: ce } = kt("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = V + 1, this.state.lineStart = ce, this.state.curLine = ne, O && (this.state.firstInvalidTemplateEscapePos = new n(O.curLine, O.pos - O.lineStart, this.sourceToOffsetPos(O.pos))), this.input.codePointAt(V) === 96 ? this.finishToken(24, O ? null : i + v + "`") : (this.state.pos++, this.finishToken(25, O ? null : i + v + "${"));
          }
          recordStrictModeErrors(i, v) {
            const O = v.index;
            this.state.strict && !this.state.strictErrors.has(O) ? this.raise(i, v) : this.state.strictErrors.set(O, [i, v]);
          }
          readWord1(i) {
            this.state.containsEsc = false;
            let v = "";
            const O = this.state.pos;
            let V = this.state.pos;
            for (i !== void 0 && (this.state.pos += i <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              const ne = this.codePointAtPos(this.state.pos);
              if (Ee(ne)) this.state.pos += ne <= 65535 ? 1 : 2;
              else {
                if (ne !== 92) break;
                {
                  this.state.containsEsc = true, v += this.input.slice(V, this.state.pos);
                  const ce = this.state.curPosition(), ve = this.state.pos === O ? J : Ee;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(_.MissingUnicodeEscape, this.state.curPosition()), V = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  const Ce = this.readCodePoint(true);
                  Ce !== null && (ve(Ce) || this.raise(_.EscapedCharNotAnIdentifier, ce), v += String.fromCodePoint(Ce)), V = this.state.pos;
                }
              }
            }
            return v + this.input.slice(V, this.state.pos);
          }
          readWord(i) {
            const v = this.readWord1(i), O = k.get(v);
            O !== void 0 ? this.finishToken(O, ue(O)) : this.finishToken(132, v);
          }
          checkKeywordEscapes() {
            const { type: i } = this.state;
            ie(i) && this.state.containsEsc && this.raise(_.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: ue(i) });
          }
          raise(i, v, O = {}) {
            const V = i(v instanceof n ? v : v.loc.start, O);
            if (!this.options.errorRecovery) throw V;
            return this.isLookahead || this.state.errors.push(V), V;
          }
          raiseOverwrite(i, v, O = {}) {
            const V = v instanceof n ? v : v.loc.start, ne = V.index, ce = this.state.errors;
            for (let ve = ce.length - 1; ve >= 0; ve--) {
              const Ce = ce[ve];
              if (Ce.loc.index === ne) return ce[ve] = i(V, O);
              if (Ce.loc.index < ne) break;
            }
            return this.raise(i, v, O);
          }
          updateContext(i) {
          }
          unexpected(i, v) {
            throw this.raise(_.UnexpectedToken, i ?? this.state.startLoc, { expected: v ? ue(v) : null });
          }
          expectPlugin(i, v) {
            if (this.hasPlugin(i)) return true;
            throw this.raise(_.MissingPlugin, v ?? this.state.startLoc, { missingPlugin: [i] });
          }
          expectOnePlugin(i) {
            if (!i.some((v) => this.hasPlugin(v))) throw this.raise(_.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: i });
          }
          errorBuilder(i) {
            return (v, O, V) => {
              this.raise(i, Jt(v, O, V));
            };
          }
        }
        class Xn {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }
        class Jn {
          constructor(i) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = i;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new Xn());
          }
          exit() {
            const i = this.stack.pop(), v = this.current();
            for (const [O, V] of Array.from(i.undefinedPrivateNames)) v ? v.undefinedPrivateNames.has(O) || v.undefinedPrivateNames.set(O, V) : this.parser.raise(_.InvalidPrivateFieldResolution, V, { identifierName: O });
          }
          declarePrivateName(i, v, O) {
            const { privateNames: V, loneAccessors: ne, undefinedPrivateNames: ce } = this.current();
            let ve = V.has(i);
            if (3 & v) {
              const Ce = ve && ne.get(i);
              Ce ? (ve = (3 & Ce) === (3 & v) || (4 & Ce) !== (4 & v), ve || ne.delete(i)) : ve || ne.set(i, v);
            }
            ve && this.parser.raise(_.PrivateNameRedeclaration, O, { identifierName: i }), V.add(i), ce.delete(i);
          }
          usePrivateName(i, v) {
            let O;
            for (O of this.stack) if (O.privateNames.has(i)) return;
            O ? O.undefinedPrivateNames.set(i, v) : this.parser.raise(_.InvalidPrivateFieldResolution, v, { identifierName: i });
          }
        }
        class rr {
          constructor(i = 0) {
            this.type = i;
          }
          canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
          }
          isCertainlyParameterDeclaration() {
            return this.type === 3;
          }
        }
        class sr extends rr {
          constructor(i) {
            super(i), this.declarationErrors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(i, v) {
            const O = v.index;
            this.declarationErrors.set(O, [i, v]);
          }
          clearDeclarationError(i) {
            this.declarationErrors.delete(i);
          }
          iterateErrors(i) {
            this.declarationErrors.forEach(i);
          }
        }
        class Qn {
          constructor(i) {
            this.parser = void 0, this.stack = [new rr()], this.parser = i;
          }
          enter(i) {
            this.stack.push(i);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(i, v) {
            const O = v.loc.start, { stack: V } = this;
            let ne = V.length - 1, ce = V[ne];
            for (; !ce.isCertainlyParameterDeclaration(); ) {
              if (!ce.canBeArrowParameterDeclaration()) return;
              ce.recordDeclarationError(i, O), ce = V[--ne];
            }
            this.parser.raise(i, O);
          }
          recordArrowParameterBindingError(i, v) {
            const { stack: O } = this, V = O[O.length - 1], ne = v.loc.start;
            if (V.isCertainlyParameterDeclaration()) this.parser.raise(i, ne);
            else {
              if (!V.canBeArrowParameterDeclaration()) return;
              V.recordDeclarationError(i, ne);
            }
          }
          recordAsyncArrowParametersError(i) {
            const { stack: v } = this;
            let O = v.length - 1, V = v[O];
            for (; V.canBeArrowParameterDeclaration(); ) V.type === 2 && V.recordDeclarationError(_.AwaitBindingIdentifier, i), V = v[--O];
          }
          validateAsPattern() {
            const { stack: i } = this, v = i[i.length - 1];
            v.canBeArrowParameterDeclaration() && v.iterateErrors(([O, V]) => {
              this.parser.raise(O, V);
              let ne = i.length - 2, ce = i[ne];
              for (; ce.canBeArrowParameterDeclaration(); ) ce.clearDeclarationError(V.index), ce = i[--ne];
            });
          }
        }
        function Br() {
          return new rr();
        }
        class Tn {
          constructor() {
            this.stacks = [];
          }
          enter(i) {
            this.stacks.push(i);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (2 & this.currentFlags()) > 0;
          }
          get hasYield() {
            return (1 & this.currentFlags()) > 0;
          }
          get hasReturn() {
            return (4 & this.currentFlags()) > 0;
          }
          get hasIn() {
            return (8 & this.currentFlags()) > 0;
          }
        }
        function Zn(de, i) {
          return (de ? 2 : 0) | (i ? 1 : 0);
        }
        class Gn extends _t {
          addExtra(i, v, O, V = true) {
            if (!i) return;
            let { extra: ne } = i;
            ne == null && (ne = {}, i.extra = ne), V ? ne[v] = O : Object.defineProperty(ne, v, { enumerable: V, value: O });
          }
          isContextual(i) {
            return this.state.type === i && !this.state.containsEsc;
          }
          isUnparsedContextual(i, v) {
            const O = i + v.length;
            if (this.input.slice(i, O) === v) {
              const V = this.input.charCodeAt(O);
              return !(Ee(V) || (64512 & V) == 55296);
            }
            return false;
          }
          isLookaheadContextual(i) {
            const v = this.nextTokenStart();
            return this.isUnparsedContextual(v, i);
          }
          eatContextual(i) {
            return !!this.isContextual(i) && (this.next(), true);
          }
          expectContextual(i, v) {
            if (!this.eatContextual(i)) {
              if (v != null) throw this.raise(v, this.state.startLoc);
              this.unexpected(null, i);
            }
          }
          canInsertSemicolon() {
            return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return it(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
          }
          hasFollowingLineBreak() {
            return it(this.input, this.state.end, this.nextTokenStart());
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(i = true) {
            (i ? this.isLineTerminator() : this.eat(13)) || this.raise(_.MissingSemicolon, this.state.lastTokEndLoc);
          }
          expect(i, v) {
            this.eat(i) || this.unexpected(v, i);
          }
          tryParse(i, v = this.state.clone()) {
            const O = { node: null };
            try {
              const V = i((ne = null) => {
                throw O.node = ne, O;
              });
              if (this.state.errors.length > v.errors.length) {
                const ne = this.state;
                return this.state = v, this.state.tokensLength = ne.tokensLength, { node: V, error: ne.errors[v.errors.length], thrown: false, aborted: false, failState: ne };
              }
              return { node: V, error: null, thrown: false, aborted: false, failState: null };
            } catch (V) {
              const ne = this.state;
              if (this.state = v, V instanceof SyntaxError) return { node: null, error: V, thrown: true, aborted: false, failState: ne };
              if (V === O) return { node: O.node, error: null, thrown: false, aborted: true, failState: ne };
              throw V;
            }
          }
          checkExpressionErrors(i, v) {
            if (!i) return false;
            const { shorthandAssignLoc: O, doubleProtoLoc: V, privateKeyLoc: ne, optionalParametersLoc: ce } = i;
            if (!v) return !!(O || V || ce || ne);
            O != null && this.raise(_.InvalidCoverInitializedName, O), V != null && this.raise(_.DuplicateProto, V), ne != null && this.raise(_.UnexpectedPrivateField, ne), ce != null && this.unexpected(ce);
          }
          isLiteralPropertyName() {
            return M(this.state.type);
          }
          isPrivateName(i) {
            return i.type === "PrivateName";
          }
          getPrivateNameSV(i) {
            return i.id.name;
          }
          hasPropertyAsPrivateName(i) {
            return (i.type === "MemberExpression" || i.type === "OptionalMemberExpression") && this.isPrivateName(i.property);
          }
          isObjectProperty(i) {
            return i.type === "ObjectProperty";
          }
          isObjectMethod(i) {
            return i.type === "ObjectMethod";
          }
          initializeScopes(i = this.options.sourceType === "module") {
            const v = this.state.labels;
            this.state.labels = [];
            const O = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            const V = this.inModule;
            this.inModule = i;
            const ne = this.scope, ce = this.getScopeHandler();
            this.scope = new ce(this, i);
            const ve = this.prodParam;
            this.prodParam = new Tn();
            const Ce = this.classScope;
            this.classScope = new Jn(this);
            const Le = this.expressionScope;
            return this.expressionScope = new Qn(this), () => {
              this.state.labels = v, this.exportedIdentifiers = O, this.inModule = V, this.scope = ne, this.prodParam = ve, this.classScope = Ce, this.expressionScope = Le;
            };
          }
          enterInitialScopes() {
            let i = 0;
            this.inModule && (i |= 2), this.scope.enter(1), this.prodParam.enter(i);
          }
          checkDestructuringPrivate(i) {
            const { privateKeyLoc: v } = i;
            v !== null && this.expectPlugin("destructuringPrivate", v);
          }
        }
        class gn {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
          }
        }
        class ur {
          constructor(i, v, O) {
            this.type = "", this.start = v, this.end = 0, this.loc = new u(O), i != null && i.options.ranges && (this.range = [v, 0]), i != null && i.filename && (this.loc.filename = i.filename);
          }
        }
        const Ir = ur.prototype;
        function zn(de) {
          const { type: i, start: v, end: O, loc: V, range: ne, extra: ce, name: ve } = de, Ce = Object.create(Ir);
          return Ce.type = i, Ce.start = v, Ce.end = O, Ce.loc = V, Ce.range = ne, Ce.extra = ce, Ce.name = ve, i === "Placeholder" && (Ce.expectedNode = de.expectedNode), Ce;
        }
        function kr(de) {
          const { type: i, start: v, end: O, loc: V, range: ne, extra: ce } = de;
          if (i === "Placeholder") return function(Ce) {
            return zn(Ce);
          }(de);
          const ve = Object.create(Ir);
          return ve.type = i, ve.start = v, ve.end = O, ve.loc = V, ve.range = ne, de.raw !== void 0 ? ve.raw = de.raw : ve.extra = ce, ve.value = de.value, ve;
        }
        Ir.__clone = function() {
          const de = new ur(void 0, this.start, this.loc.start), i = Object.keys(this);
          for (let v = 0, O = i.length; v < O; v++) {
            const V = i[v];
            V !== "leadingComments" && V !== "trailingComments" && V !== "innerComments" && (de[V] = this[V]);
          }
          return de;
        };
        class Jr extends Gn {
          startNode() {
            const i = this.state.startLoc;
            return new ur(this, i.index, i);
          }
          startNodeAt(i) {
            return new ur(this, i.index, i);
          }
          startNodeAtNode(i) {
            return this.startNodeAt(i.loc.start);
          }
          finishNode(i, v) {
            return this.finishNodeAt(i, v, this.state.lastTokEndLoc);
          }
          finishNodeAt(i, v, O) {
            return i.type = v, i.end = O.index, i.loc.end = O, this.options.ranges && (i.range[1] = O.index), this.options.attachComment && this.processComment(i), i;
          }
          resetStartLocation(i, v) {
            i.start = v.index, i.loc.start = v, this.options.ranges && (i.range[0] = v.index);
          }
          resetEndLocation(i, v = this.state.lastTokEndLoc) {
            i.end = v.index, i.loc.end = v, this.options.ranges && (i.range[1] = v.index);
          }
          resetStartLocationFromNode(i, v) {
            this.resetStartLocation(i, v.loc.start);
          }
        }
        const Qr = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), wt = E`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: de }) => `Cannot overwrite reserved type ${de}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: de, enumName: i }) => `Boolean enum members need to be initialized. Use either \`${de} = true,\` or \`${de} = false,\` in enum \`${i}\`.`, EnumDuplicateMemberName: ({ memberName: de, enumName: i }) => `Enum member names need to be unique, but the name \`${de}\` has already been used before in enum \`${i}\`.`, EnumInconsistentMemberValues: ({ enumName: de }) => `Enum \`${de}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: de, enumName: i }) => `Enum type \`${de}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${i}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: de }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${de}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: de, memberName: i, explicitType: v }) => `Enum \`${de}\` has type \`${v}\`, so the initializer of \`${i}\` needs to be a ${v} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: de, memberName: i }) => `Symbol enum members cannot be initialized. Use \`${i},\` in enum \`${de}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: de, memberName: i }) => `The enum member initializer for \`${i}\` needs to be a literal (either a boolean, number, or string) in enum \`${de}\`.`, EnumInvalidMemberName: ({ enumName: de, memberName: i, suggestion: v }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${i}\`, consider using \`${v}\`, in enum \`${de}\`.`, EnumNumberMemberNotInitialized: ({ enumName: de, memberName: i }) => `Number enum members need to be initialized, e.g. \`${i} = 1\` in enum \`${de}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: de }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${de}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: de }) => `Unexpected reserved type ${de}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: de, suggestion: i }) => `\`declare export ${de}\` is not supported. Use \`${i}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
        function $r(de) {
          return de.importKind === "type" || de.importKind === "typeof";
        }
        const vr = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" }, Er = /\*?\s*@((?:no)?flow)\b/, Zr = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, cr = E`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: de }) => `Expected corresponding JSX closing tag for <${de}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: de, HTMLEntity: i }) => `Unexpected token \`${de}\`. Did you mean \`${i}\` or \`{'${de}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
        function er(de) {
          return !!de && (de.type === "JSXOpeningFragment" || de.type === "JSXClosingFragment");
        }
        function dt(de) {
          if (de.type === "JSXIdentifier") return de.name;
          if (de.type === "JSXNamespacedName") return de.namespace.name + ":" + de.name.name;
          if (de.type === "JSXMemberExpression") return dt(de.object) + "." + dt(de.property);
          throw new Error("Node had unexpected type: " + de.type);
        }
        class ft extends _e {
          constructor(...i) {
            super(...i), this.tsNames = /* @__PURE__ */ new Map();
          }
        }
        class at extends Ne {
          constructor(...i) {
            super(...i), this.importsStack = [];
          }
          createScope(i) {
            return this.importsStack.push(/* @__PURE__ */ new Set()), new ft(i);
          }
          enter(i) {
            i === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(i);
          }
          exit() {
            const i = super.exit();
            return i === 256 && this.importsStack.pop(), i;
          }
          hasImport(i, v) {
            const O = this.importsStack.length;
            if (this.importsStack[O - 1].has(i)) return true;
            if (!v && O > 1) {
              for (let V = 0; V < O - 1; V++) if (this.importsStack[V].has(i)) return true;
            }
            return false;
          }
          declareName(i, v, O) {
            if (4096 & v) return this.hasImport(i, true) && this.parser.raise(_.VarRedeclaration, O, { identifierName: i }), void this.importsStack[this.importsStack.length - 1].add(i);
            const V = this.currentScope();
            let ne = V.tsNames.get(i) || 0;
            if (1024 & v) return this.maybeExportDefined(V, i), void V.tsNames.set(i, 16 | ne);
            super.declareName(i, v, O), 2 & v && (1 & v || (this.checkRedeclarationInScope(V, i, v, O), this.maybeExportDefined(V, i)), ne |= 1), 256 & v && (ne |= 2), 512 & v && (ne |= 4), 128 & v && (ne |= 8), ne && V.tsNames.set(i, ne);
          }
          isRedeclaredInScope(i, v, O) {
            const V = i.tsNames.get(v);
            return (2 & V) > 0 ? 256 & O ? !!(512 & O) != (4 & V) > 0 : true : 128 & O && (8 & V) > 0 ? !!(2 & i.names.get(v)) && !!(1 & O) : !!(2 & O && (1 & V) > 0) || super.isRedeclaredInScope(i, v, O);
          }
          checkLocalExport(i) {
            const { name: v } = i;
            if (!this.hasImport(v)) {
              for (let O = this.scopeStack.length - 1; O >= 0; O--) {
                const V = this.scopeStack[O].tsNames.get(v);
                if ((1 & V) > 0 || (16 & V) > 0) return;
              }
              super.checkLocalExport(i);
            }
          }
        }
        const St = (de) => de.type === "ParenthesizedExpression" ? St(de.expression) : de;
        class Ct extends Jr {
          toAssignable(i, v = false) {
            var O, V;
            let ne;
            switch ((i.type === "ParenthesizedExpression" || (O = i.extra) != null && O.parenthesized) && (ne = St(i), v ? ne.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(_.InvalidParenthesizedAssignment, i) : ne.type === "MemberExpression" || this.isOptionalMemberExpression(ne) || this.raise(_.InvalidParenthesizedAssignment, i) : this.raise(_.InvalidParenthesizedAssignment, i)), i.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                i.type = "ObjectPattern";
                for (let ve = 0, Ce = i.properties.length, Le = Ce - 1; ve < Ce; ve++) {
                  var ce;
                  const Ke = i.properties[ve], ut = ve === Le;
                  this.toAssignableObjectExpressionProp(Ke, ut, v), ut && Ke.type === "RestElement" && (ce = i.extra) != null && ce.trailingCommaLoc && this.raise(_.RestTrailingComma, i.extra.trailingCommaLoc);
                }
                break;
              case "ObjectProperty": {
                const { key: ve, value: Ce } = i;
                this.isPrivateName(ve) && this.classScope.usePrivateName(this.getPrivateNameSV(ve), ve.loc.start), this.toAssignable(Ce, v);
                break;
              }
              case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              case "ArrayExpression":
                i.type = "ArrayPattern", this.toAssignableList(i.elements, (V = i.extra) == null ? void 0 : V.trailingCommaLoc, v);
                break;
              case "AssignmentExpression":
                i.operator !== "=" && this.raise(_.MissingEqInAssignment, i.left.loc.end), i.type = "AssignmentPattern", delete i.operator, this.toAssignable(i.left, v);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(ne, v);
            }
          }
          toAssignableObjectExpressionProp(i, v, O) {
            if (i.type === "ObjectMethod") this.raise(i.kind === "get" || i.kind === "set" ? _.PatternHasAccessor : _.PatternHasMethod, i.key);
            else if (i.type === "SpreadElement") {
              i.type = "RestElement";
              const V = i.argument;
              this.checkToRestConversion(V, false), this.toAssignable(V, O), v || this.raise(_.RestTrailingComma, i);
            } else this.toAssignable(i, O);
          }
          toAssignableList(i, v, O) {
            const V = i.length - 1;
            for (let ne = 0; ne <= V; ne++) {
              const ce = i[ne];
              if (ce) {
                if (ce.type === "SpreadElement") {
                  ce.type = "RestElement";
                  const ve = ce.argument;
                  this.checkToRestConversion(ve, true), this.toAssignable(ve, O);
                } else this.toAssignable(ce, O);
                ce.type === "RestElement" && (ne < V ? this.raise(_.RestTrailingComma, ce) : v && this.raise(_.RestTrailingComma, v));
              }
            }
          }
          isAssignable(i, v) {
            switch (i.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return true;
              case "ObjectExpression": {
                const O = i.properties.length - 1;
                return i.properties.every((V, ne) => V.type !== "ObjectMethod" && (ne === O || V.type !== "SpreadElement") && this.isAssignable(V));
              }
              case "ObjectProperty":
                return this.isAssignable(i.value);
              case "SpreadElement":
                return this.isAssignable(i.argument);
              case "ArrayExpression":
                return i.elements.every((O) => O === null || this.isAssignable(O));
              case "AssignmentExpression":
                return i.operator === "=";
              case "ParenthesizedExpression":
                return this.isAssignable(i.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !v;
              default:
                return false;
            }
          }
          toReferencedList(i, v) {
            return i;
          }
          toReferencedListDeep(i, v) {
            this.toReferencedList(i, v);
            for (const O of i) (O == null ? void 0 : O.type) === "ArrayExpression" && this.toReferencedListDeep(O.elements);
          }
          parseSpread(i) {
            const v = this.startNode();
            return this.next(), v.argument = this.parseMaybeAssignAllowIn(i, void 0), this.finishNode(v, "SpreadElement");
          }
          parseRestBinding() {
            const i = this.startNode();
            return this.next(), i.argument = this.parseBindingAtom(), this.finishNode(i, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                const i = this.startNode();
                return this.next(), i.elements = this.parseBindingList(3, 93, 1), this.finishNode(i, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(i, v, O) {
            const V = 1 & O, ne = [];
            let ce = true;
            for (; !this.eat(i); ) if (ce ? ce = false : this.expect(12), V && this.match(12)) ne.push(null);
            else {
              if (this.eat(i)) break;
              if (this.match(21)) {
                let ve = this.parseRestBinding();
                if ((this.hasPlugin("flow") || 2 & O) && (ve = this.parseFunctionParamType(ve)), ne.push(ve), !this.checkCommaAfterRest(v)) {
                  this.expect(i);
                  break;
                }
              } else {
                const ve = [];
                for (this.match(26) && this.hasPlugin("decorators") && this.raise(_.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) ve.push(this.parseDecorator());
                ne.push(this.parseAssignableListItem(O, ve));
              }
            }
            return ne;
          }
          parseBindingRestProperty(i) {
            return this.next(), i.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(i, "RestElement");
          }
          parseBindingProperty() {
            const { type: i, startLoc: v } = this.state;
            if (i === 21) return this.parseBindingRestProperty(this.startNode());
            const O = this.startNode();
            return i === 139 ? (this.expectPlugin("destructuringPrivate", v), this.classScope.usePrivateName(this.state.value, v), O.key = this.parsePrivateName()) : this.parsePropertyName(O), O.method = false, this.parseObjPropValue(O, v, false, false, true, false);
          }
          parseAssignableListItem(i, v) {
            const O = this.parseMaybeDefault();
            (this.hasPlugin("flow") || 2 & i) && this.parseFunctionParamType(O);
            const V = this.parseMaybeDefault(O.loc.start, O);
            return v.length && (O.decorators = v), V;
          }
          parseFunctionParamType(i) {
            return i;
          }
          parseMaybeDefault(i, v) {
            var O;
            if (i != null || (i = this.state.startLoc), v = (O = v) != null ? O : this.parseBindingAtom(), !this.eat(29)) return v;
            const V = this.startNodeAt(i);
            return V.left = v, V.right = this.parseMaybeAssignAllowIn(), this.finishNode(V, "AssignmentPattern");
          }
          isValidLVal(i, v, O) {
            switch (i) {
              case "AssignmentPattern":
                return "left";
              case "RestElement":
                return "argument";
              case "ObjectProperty":
                return "value";
              case "ParenthesizedExpression":
                return "expression";
              case "ArrayPattern":
                return "elements";
              case "ObjectPattern":
                return "properties";
            }
            return false;
          }
          isOptionalMemberExpression(i) {
            return i.type === "OptionalMemberExpression";
          }
          checkLVal(i, v, O = 64, V = false, ne = false, ce = false) {
            var ve;
            const Ce = i.type;
            if (this.isObjectMethod(i)) return;
            const Le = this.isOptionalMemberExpression(i);
            if (Le || Ce === "MemberExpression") return Le && (this.expectPlugin("optionalChainingAssign", i.loc.start), v.type !== "AssignmentExpression" && this.raise(_.InvalidLhsOptionalChaining, i, { ancestor: v })), void (O !== 64 && this.raise(_.InvalidPropertyBindingPattern, i));
            if (Ce === "Identifier") {
              this.checkIdentifier(i, O, ne);
              const { name: dn } = i;
              return void (V && (V.has(dn) ? this.raise(_.ParamDupe, i) : V.add(dn)));
            }
            const Ke = this.isValidLVal(Ce, !(ce || (ve = i.extra) != null && ve.parenthesized) && v.type === "AssignmentExpression", O);
            if (Ke === true) return;
            if (Ke === false) {
              const dn = O === 64 ? _.InvalidLhs : _.InvalidLhsBinding;
              return void this.raise(dn, i, { ancestor: v });
            }
            let ut, At;
            typeof Ke == "string" ? (ut = Ke, At = Ce === "ParenthesizedExpression") : [ut, At] = Ke;
            const bt = Ce === "ArrayPattern" || Ce === "ObjectPattern" ? { type: Ce } : v, Nt = i[ut];
            if (Array.isArray(Nt)) for (const dn of Nt) dn && this.checkLVal(dn, bt, O, V, ne, At);
            else Nt && this.checkLVal(Nt, bt, O, V, ne, At);
          }
          checkIdentifier(i, v, O = false) {
            this.state.strict && (O ? he(i.name, this.inModule) : je(i.name)) && (v === 64 ? this.raise(_.StrictEvalArguments, i, { referenceName: i.name }) : this.raise(_.StrictEvalArgumentsBinding, i, { bindingName: i.name })), 8192 & v && i.name === "let" && this.raise(_.LetInLexicalBinding, i), 64 & v || this.declareNameFromIdentifier(i, v);
          }
          declareNameFromIdentifier(i, v) {
            this.scope.declareName(i.name, v, i.loc.start);
          }
          checkToRestConversion(i, v) {
            switch (i.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(i.expression, v);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (v) break;
              default:
                this.raise(_.InvalidRestAssignmentPattern, i);
            }
          }
          checkCommaAfterRest(i) {
            return !!this.match(12) && (this.raise(this.lookaheadCharCode() === i ? _.RestTrailingComma : _.ElementAfterRest, this.state.startLoc), true);
          }
        }
        function Mt(de) {
          if (!de) throw new Error("Assert fail");
        }
        const ct = E`typescript`({ AbstractMethodHasImplementation: ({ methodName: de }) => `Method '${de}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: de }) => `Property '${de}' cannot have an initializer because it is marked abstract.`, AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: de }) => `'declare' is not allowed in ${de}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: de }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: de }) => `Duplicate modifier: '${de}'.`, EmptyHeritageClauseType: ({ token: de }) => `'${de}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: de }) => `'${de[0]}' modifier cannot be used with '${de[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: de }) => `Index signatures cannot have an accessibility modifier ('${de}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: de }) => `'${de}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: de }) => `'${de}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: de }) => `'${de}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: de }) => `'${de[0]}' modifier must precede '${de[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: de }) => `Private elements cannot have an accessibility modifier ('${de}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: de }) => `Single type parameter ${de} should have a trailing comma. Example usage: <${de},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: de }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${de}.` });
        function Ot(de) {
          return de === "private" || de === "public" || de === "protected";
        }
        function zt(de) {
          return de === "in" || de === "out";
        }
        function Qt(de) {
          if (de.type !== "MemberExpression") return false;
          const { computed: i, property: v } = de;
          return (!i || v.type === "StringLiteral" || !(v.type !== "TemplateLiteral" || v.expressions.length > 0)) && ln(de.object);
        }
        function on(de, i) {
          var v;
          const { type: O } = de;
          if ((v = de.extra) != null && v.parenthesized) return false;
          if (i) {
            if (O === "Literal") {
              const { value: V } = de;
              if (typeof V == "string" || typeof V == "boolean") return true;
            }
          } else if (O === "StringLiteral" || O === "BooleanLiteral") return true;
          return !(!Zt(de, i) && !function(V, ne) {
            if (V.type === "UnaryExpression") {
              const { operator: ce, argument: ve } = V;
              if (ce === "-" && Zt(ve, ne)) return true;
            }
            return false;
          }(de, i)) || O === "TemplateLiteral" && de.expressions.length === 0 || !!Qt(de);
        }
        function Zt(de, i) {
          return i ? de.type === "Literal" && (typeof de.value == "number" || "bigint" in de) : de.type === "NumericLiteral" || de.type === "BigIntLiteral";
        }
        function ln(de) {
          return de.type === "Identifier" || de.type === "MemberExpression" && !de.computed && ln(de.object);
        }
        const Un = E`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), Bn = ["minimal", "fsharp", "hack", "smart"], Bt = ["^^", "@@", "^", "%", "#"], Vn = { estree: (de) => class extends de {
          parse() {
            const i = I(super.parse());
            return this.options.tokens && (i.tokens = i.tokens.map(I)), i;
          }
          parseRegExpLiteral({ pattern: i, flags: v }) {
            let O = null;
            try {
              O = new RegExp(i, v);
            } catch {
            }
            const V = this.estreeParseLiteral(O);
            return V.regex = { pattern: i, flags: v }, V;
          }
          parseBigIntLiteral(i) {
            let v;
            try {
              v = BigInt(i);
            } catch {
              v = null;
            }
            const O = this.estreeParseLiteral(v);
            return O.bigint = String(O.value || i), O;
          }
          parseDecimalLiteral(i) {
            const v = this.estreeParseLiteral(null);
            return v.decimal = String(v.value || i), v;
          }
          estreeParseLiteral(i) {
            return this.parseLiteral(i, "Literal");
          }
          parseStringLiteral(i) {
            return this.estreeParseLiteral(i);
          }
          parseNumericLiteral(i) {
            return this.estreeParseLiteral(i);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(i) {
            return this.estreeParseLiteral(i);
          }
          directiveToStmt(i) {
            const v = i.value;
            delete i.value, v.type = "Literal", v.raw = v.extra.raw, v.value = v.extra.expressionValue;
            const O = i;
            return O.type = "ExpressionStatement", O.expression = v, O.directive = v.extra.rawValue, delete v.extra, O;
          }
          initFunction(i, v) {
            super.initFunction(i, v), i.expression = false;
          }
          checkDeclaration(i) {
            i != null && this.isObjectProperty(i) ? this.checkDeclaration(i.value) : super.checkDeclaration(i);
          }
          getObjectOrClassMethodParams(i) {
            return i.value.params;
          }
          isValidDirective(i) {
            var v;
            return i.type === "ExpressionStatement" && i.expression.type === "Literal" && typeof i.expression.value == "string" && !((v = i.expression.extra) != null && v.parenthesized);
          }
          parseBlockBody(i, v, O, V, ne) {
            super.parseBlockBody(i, v, O, V, ne);
            const ce = i.directives.map((ve) => this.directiveToStmt(ve));
            i.body = ce.concat(i.body), delete i.directives;
          }
          pushClassMethod(i, v, O, V, ne, ce) {
            this.parseMethod(v, O, V, ne, ce, "ClassMethod", true), v.typeParameters && (v.value.typeParameters = v.typeParameters, delete v.typeParameters), i.body.push(v);
          }
          parsePrivateName() {
            const i = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(i) : i;
          }
          convertPrivateNameToPrivateIdentifier(i) {
            const v = super.getPrivateNameSV(i);
            return delete i.id, i.name = v, i.type = "PrivateIdentifier", i;
          }
          isPrivateName(i) {
            return this.getPluginOption("estree", "classFeatures") ? i.type === "PrivateIdentifier" : super.isPrivateName(i);
          }
          getPrivateNameSV(i) {
            return this.getPluginOption("estree", "classFeatures") ? i.name : super.getPrivateNameSV(i);
          }
          parseLiteral(i, v) {
            const O = super.parseLiteral(i, v);
            return O.raw = O.extra.raw, delete O.extra, O;
          }
          parseFunctionBody(i, v, O = false) {
            super.parseFunctionBody(i, v, O), i.expression = i.body.type !== "BlockStatement";
          }
          parseMethod(i, v, O, V, ne, ce, ve = false) {
            let Ce = this.startNode();
            return Ce.kind = i.kind, Ce = super.parseMethod(Ce, v, O, V, ne, ce, ve), Ce.type = "FunctionExpression", delete Ce.kind, i.value = Ce, ce === "ClassPrivateMethod" && (i.computed = false), this.finishNode(i, "MethodDefinition");
          }
          nameIsConstructor(i) {
            return i.type === "Literal" ? i.value === "constructor" : super.nameIsConstructor(i);
          }
          parseClassProperty(...i) {
            const v = super.parseClassProperty(...i);
            return this.getPluginOption("estree", "classFeatures") && (v.type = "PropertyDefinition"), v;
          }
          parseClassPrivateProperty(...i) {
            const v = super.parseClassPrivateProperty(...i);
            return this.getPluginOption("estree", "classFeatures") && (v.type = "PropertyDefinition", v.computed = false), v;
          }
          parseObjectMethod(i, v, O, V, ne) {
            const ce = super.parseObjectMethod(i, v, O, V, ne);
            return ce && (ce.type = "Property", ce.kind === "method" && (ce.kind = "init"), ce.shorthand = false), ce;
          }
          parseObjectProperty(i, v, O, V) {
            const ne = super.parseObjectProperty(i, v, O, V);
            return ne && (ne.kind = "init", ne.type = "Property"), ne;
          }
          isValidLVal(i, v, O) {
            return i === "Property" ? "value" : super.isValidLVal(i, v, O);
          }
          isAssignable(i, v) {
            return i != null && this.isObjectProperty(i) ? this.isAssignable(i.value, v) : super.isAssignable(i, v);
          }
          toAssignable(i, v = false) {
            if (i != null && this.isObjectProperty(i)) {
              const { key: O, value: V } = i;
              this.isPrivateName(O) && this.classScope.usePrivateName(this.getPrivateNameSV(O), O.loc.start), this.toAssignable(V, v);
            } else super.toAssignable(i, v);
          }
          toAssignableObjectExpressionProp(i, v, O) {
            i.type !== "Property" || i.kind !== "get" && i.kind !== "set" ? i.type === "Property" && i.method ? this.raise(_.PatternHasMethod, i.key) : super.toAssignableObjectExpressionProp(i, v, O) : this.raise(_.PatternHasAccessor, i.key);
          }
          finishCallExpression(i, v) {
            const O = super.finishCallExpression(i, v);
            var V, ne;
            return O.callee.type === "Import" && (O.type = "ImportExpression", O.source = O.arguments[0], O.options = (V = O.arguments[1]) != null ? V : null, O.attributes = (ne = O.arguments[1]) != null ? ne : null, delete O.arguments, delete O.callee), O;
          }
          toReferencedArguments(i) {
            i.type !== "ImportExpression" && super.toReferencedArguments(i);
          }
          parseExport(i, v) {
            const O = this.state.lastTokStartLoc, V = super.parseExport(i, v);
            switch (V.type) {
              case "ExportAllDeclaration":
                V.exported = null;
                break;
              case "ExportNamedDeclaration":
                V.specifiers.length === 1 && V.specifiers[0].type === "ExportNamespaceSpecifier" && (V.type = "ExportAllDeclaration", V.exported = V.specifiers[0].exported, delete V.specifiers);
              case "ExportDefaultDeclaration": {
                var ne;
                const { declaration: ce } = V;
                (ce == null ? void 0 : ce.type) === "ClassDeclaration" && ((ne = ce.decorators) == null ? void 0 : ne.length) > 0 && ce.start === V.start && this.resetStartLocation(V, O);
              }
            }
            return V;
          }
          parseSubscript(i, v, O, V) {
            const ne = super.parseSubscript(i, v, O, V);
            if (V.optionalChainMember) {
              if (ne.type !== "OptionalMemberExpression" && ne.type !== "OptionalCallExpression" || (ne.type = ne.type.substring(8)), V.stop) {
                const ce = this.startNodeAtNode(ne);
                return ce.expression = ne, this.finishNode(ce, "ChainExpression");
              }
            } else ne.type !== "MemberExpression" && ne.type !== "CallExpression" || (ne.optional = false);
            return ne;
          }
          isOptionalMemberExpression(i) {
            return i.type === "ChainExpression" ? i.expression.type === "MemberExpression" : super.isOptionalMemberExpression(i);
          }
          hasPropertyAsPrivateName(i) {
            return i.type === "ChainExpression" && (i = i.expression), super.hasPropertyAsPrivateName(i);
          }
          isObjectProperty(i) {
            return i.type === "Property" && i.kind === "init" && !i.method;
          }
          isObjectMethod(i) {
            return i.type === "Property" && (i.method || i.kind === "get" || i.kind === "set");
          }
          finishNodeAt(i, v, O) {
            return I(super.finishNodeAt(i, v, O));
          }
          resetStartLocation(i, v) {
            super.resetStartLocation(i, v), I(i);
          }
          resetEndLocation(i, v = this.state.lastTokEndLoc) {
            super.resetEndLocation(i, v), I(i);
          }
        }, jsx: (de) => class extends de {
          jsxReadToken() {
            let i = "", v = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(cr.UnterminatedJsxContent, this.state.startLoc);
              const O = this.input.charCodeAt(this.state.pos);
              switch (O) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start ? void (O === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(O)) : (i += this.input.slice(v, this.state.pos), void this.finishToken(142, i));
                case 38:
                  i += this.input.slice(v, this.state.pos), i += this.jsxReadEntity(), v = this.state.pos;
                  break;
                default:
                  rt(O) ? (i += this.input.slice(v, this.state.pos), i += this.jsxReadNewLine(true), v = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(i) {
            const v = this.input.charCodeAt(this.state.pos);
            let O;
            return ++this.state.pos, v === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, O = i ? `
` : `\r
`) : O = String.fromCharCode(v), ++this.state.curLine, this.state.lineStart = this.state.pos, O;
          }
          jsxReadString(i) {
            let v = "", O = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(_.UnterminatedString, this.state.startLoc);
              const V = this.input.charCodeAt(this.state.pos);
              if (V === i) break;
              V === 38 ? (v += this.input.slice(O, this.state.pos), v += this.jsxReadEntity(), O = this.state.pos) : rt(V) ? (v += this.input.slice(O, this.state.pos), v += this.jsxReadNewLine(false), O = this.state.pos) : ++this.state.pos;
            }
            v += this.input.slice(O, this.state.pos++), this.finishToken(134, v);
          }
          jsxReadEntity() {
            const i = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let v = 10;
              this.codePointAtPos(this.state.pos) === 120 && (v = 16, ++this.state.pos);
              const O = this.readInt(v, void 0, false, "bail");
              if (O !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(O);
            } else {
              let v = 0, O = false;
              for (; v++ < 10 && this.state.pos < this.length && !(O = this.codePointAtPos(this.state.pos) === 59); ) ++this.state.pos;
              if (O) {
                const V = this.input.slice(i, this.state.pos), ne = Zr[V];
                if (++this.state.pos, ne) return ne;
              }
            }
            return this.state.pos = i, "&";
          }
          jsxReadWord() {
            let i;
            const v = this.state.pos;
            do
              i = this.input.charCodeAt(++this.state.pos);
            while (Ee(i) || i === 45);
            this.finishToken(141, this.input.slice(v, this.state.pos));
          }
          jsxParseIdentifier() {
            const i = this.startNode();
            return this.match(141) ? i.name = this.state.value : ie(this.state.type) ? i.name = ue(this.state.type) : this.unexpected(), this.next(), this.finishNode(i, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const i = this.state.startLoc, v = this.jsxParseIdentifier();
            if (!this.eat(14)) return v;
            const O = this.startNodeAt(i);
            return O.namespace = v, O.name = this.jsxParseIdentifier(), this.finishNode(O, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const i = this.state.startLoc;
            let v = this.jsxParseNamespacedName();
            if (v.type === "JSXNamespacedName") return v;
            for (; this.eat(16); ) {
              const O = this.startNodeAt(i);
              O.object = v, O.property = this.jsxParseIdentifier(), v = this.finishNode(O, "JSXMemberExpression");
            }
            return v;
          }
          jsxParseAttributeValue() {
            let i;
            switch (this.state.type) {
              case 5:
                return i = this.startNode(), this.setContext(j.brace), this.next(), i = this.jsxParseExpressionContainer(i, j.j_oTag), i.expression.type === "JSXEmptyExpression" && this.raise(cr.AttributeIsEmpty, i), i;
              case 143:
              case 134:
                return this.parseExprAtom();
              default:
                throw this.raise(cr.UnsupportedJsxValue, this.state.startLoc);
            }
          }
          jsxParseEmptyExpression() {
            const i = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(i, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(i) {
            return this.next(), i.expression = this.parseExpression(), this.setContext(j.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(i, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(i, v) {
            if (this.match(8)) i.expression = this.jsxParseEmptyExpression();
            else {
              const O = this.parseExpression();
              i.expression = O;
            }
            return this.setContext(v), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(i, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const i = this.startNode();
            return this.match(5) ? (this.setContext(j.brace), this.next(), this.expect(21), i.argument = this.parseMaybeAssignAllowIn(), this.setContext(j.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(i, "JSXSpreadAttribute")) : (i.name = this.jsxParseNamespacedName(), i.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(i, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(i) {
            const v = this.startNodeAt(i);
            return this.eat(144) ? this.finishNode(v, "JSXOpeningFragment") : (v.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(v));
          }
          jsxParseOpeningElementAfterName(i) {
            const v = [];
            for (; !this.match(56) && !this.match(144); ) v.push(this.jsxParseAttribute());
            return i.attributes = v, i.selfClosing = this.eat(56), this.expect(144), this.finishNode(i, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(i) {
            const v = this.startNodeAt(i);
            return this.eat(144) ? this.finishNode(v, "JSXClosingFragment") : (v.name = this.jsxParseElementName(), this.expect(144), this.finishNode(v, "JSXClosingElement"));
          }
          jsxParseElementAt(i) {
            const v = this.startNodeAt(i), O = [], V = this.jsxParseOpeningElementAt(i);
            let ne = null;
            if (!V.selfClosing) {
              e: for (; ; ) switch (this.state.type) {
                case 143:
                  if (i = this.state.startLoc, this.next(), this.eat(56)) {
                    ne = this.jsxParseClosingElementAt(i);
                    break e;
                  }
                  O.push(this.jsxParseElementAt(i));
                  break;
                case 142:
                  O.push(this.parseLiteral(this.state.value, "JSXText"));
                  break;
                case 5: {
                  const ce = this.startNode();
                  this.setContext(j.brace), this.next(), this.match(21) ? O.push(this.jsxParseSpreadChild(ce)) : O.push(this.jsxParseExpressionContainer(ce, j.j_expr));
                  break;
                }
                default:
                  this.unexpected();
              }
              er(V) && !er(ne) && ne !== null ? this.raise(cr.MissingClosingTagFragment, ne) : !er(V) && er(ne) ? this.raise(cr.MissingClosingTagElement, ne, { openingTagName: dt(V.name) }) : er(V) || er(ne) || dt(ne.name) !== dt(V.name) && this.raise(cr.MissingClosingTagElement, ne, { openingTagName: dt(V.name) });
            }
            if (er(V) ? (v.openingFragment = V, v.closingFragment = ne) : (v.openingElement = V, v.closingElement = ne), v.children = O, this.match(47)) throw this.raise(cr.UnwrappedAdjacentJSXElements, this.state.startLoc);
            return er(V) ? this.finishNode(v, "JSXFragment") : this.finishNode(v, "JSXElement");
          }
          jsxParseElement() {
            const i = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(i);
          }
          setContext(i) {
            const { context: v } = this.state;
            v[v.length - 1] = i;
          }
          parseExprAtom(i) {
            return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(i);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(i) {
            const v = this.curContext();
            if (v !== j.j_expr) {
              if (v === j.j_oTag || v === j.j_cTag) {
                if (J(i)) return void this.jsxReadWord();
                if (i === 62) return ++this.state.pos, void this.finishToken(144);
                if ((i === 34 || i === 39) && v === j.j_oTag) return void this.jsxReadString(i);
              }
              if (i === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) return ++this.state.pos, void this.finishToken(143);
              super.getTokenFromCode(i);
            } else this.jsxReadToken();
          }
          updateContext(i) {
            const { context: v, type: O } = this.state;
            if (O === 56 && i === 143) v.splice(-2, 2, j.j_cTag), this.state.canStartJSXElement = false;
            else if (O === 143) v.push(j.j_oTag);
            else if (O === 144) {
              const V = v[v.length - 1];
              V === j.j_oTag && i === 56 || V === j.j_cTag ? (v.pop(), this.state.canStartJSXElement = v[v.length - 1] === j.j_expr) : (this.setContext(j.j_expr), this.state.canStartJSXElement = true);
            } else this.state.canStartJSXElement = q[O];
          }
        }, flow: (de) => class extends de {
          constructor(...i) {
            super(...i), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return Xe;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          finishToken(i, v) {
            i !== 134 && i !== 13 && i !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(i, v);
          }
          addComment(i) {
            if (this.flowPragma === void 0) {
              const v = Er.exec(i.value);
              if (v) if (v[1] === "flow") this.flowPragma = "flow";
              else {
                if (v[1] !== "noflow") throw new Error("Unexpected flow pragma");
                this.flowPragma = "noflow";
              }
            }
            super.addComment(i);
          }
          flowParseTypeInitialiser(i) {
            const v = this.state.inType;
            this.state.inType = true, this.expect(i || 14);
            const O = this.flowParseType();
            return this.state.inType = v, O;
          }
          flowParsePredicate() {
            const i = this.startNode(), v = this.state.startLoc;
            return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > v.index + 1 && this.raise(wt.UnexpectedSpaceBetweenModuloChecks, v), this.eat(10) ? (i.value = super.parseExpression(), this.expect(11), this.finishNode(i, "DeclaredPredicate")) : this.finishNode(i, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const i = this.state.inType;
            this.state.inType = true, this.expect(14);
            let v = null, O = null;
            return this.match(54) ? (this.state.inType = i, O = this.flowParsePredicate()) : (v = this.flowParseType(), this.state.inType = i, this.match(54) && (O = this.flowParsePredicate())), [v, O];
          }
          flowParseDeclareClass(i) {
            return this.next(), this.flowParseInterfaceish(i, true), this.finishNode(i, "DeclareClass");
          }
          flowParseDeclareFunction(i) {
            this.next();
            const v = i.id = this.parseIdentifier(), O = this.startNode(), V = this.startNode();
            this.match(47) ? O.typeParameters = this.flowParseTypeParameterDeclaration() : O.typeParameters = null, this.expect(10);
            const ne = this.flowParseFunctionTypeParams();
            return O.params = ne.params, O.rest = ne.rest, O.this = ne._this, this.expect(11), [O.returnType, i.predicate] = this.flowParseTypeAndPredicateInitialiser(), V.typeAnnotation = this.finishNode(O, "FunctionTypeAnnotation"), v.typeAnnotation = this.finishNode(V, "TypeAnnotation"), this.resetEndLocation(v), this.semicolon(), this.scope.declareName(i.id.name, 2048, i.id.loc.start), this.finishNode(i, "DeclareFunction");
          }
          flowParseDeclare(i, v) {
            return this.match(80) ? this.flowParseDeclareClass(i) : this.match(68) ? this.flowParseDeclareFunction(i) : this.match(74) ? this.flowParseDeclareVariable(i) : this.eatContextual(127) ? this.match(16) ? this.flowParseDeclareModuleExports(i) : (v && this.raise(wt.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(i)) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(i) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(i) : this.isContextual(129) ? this.flowParseDeclareInterface(i) : this.match(82) ? this.flowParseDeclareExportDeclaration(i, v) : void this.unexpected();
          }
          flowParseDeclareVariable(i) {
            return this.next(), i.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(i.id.name, 5, i.id.loc.start), this.semicolon(), this.finishNode(i, "DeclareVariable");
          }
          flowParseDeclareModule(i) {
            this.scope.enter(0), this.match(134) ? i.id = super.parseExprAtom() : i.id = this.parseIdentifier();
            const v = i.body = this.startNode(), O = v.body = [];
            for (this.expect(5); !this.match(8); ) {
              let ce = this.startNode();
              this.match(83) ? (this.next(), this.isContextual(130) || this.match(87) || this.raise(wt.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(ce)) : (this.expectContextual(125, wt.UnsupportedStatementInDeclareModule), ce = this.flowParseDeclare(ce, true)), O.push(ce);
            }
            this.scope.exit(), this.expect(8), this.finishNode(v, "BlockStatement");
            let V = null, ne = false;
            return O.forEach((ce) => {
              (function(ve) {
                return ve.type === "DeclareExportAllDeclaration" || ve.type === "DeclareExportDeclaration" && (!ve.declaration || ve.declaration.type !== "TypeAlias" && ve.declaration.type !== "InterfaceDeclaration");
              })(ce) ? (V === "CommonJS" && this.raise(wt.AmbiguousDeclareModuleKind, ce), V = "ES") : ce.type === "DeclareModuleExports" && (ne && this.raise(wt.DuplicateDeclareModuleExports, ce), V === "ES" && this.raise(wt.AmbiguousDeclareModuleKind, ce), V = "CommonJS", ne = true);
            }), i.kind = V || "CommonJS", this.finishNode(i, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(i, v) {
            if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? i.declaration = this.flowParseDeclare(this.startNode()) : (i.declaration = this.flowParseType(), this.semicolon()), i.default = true, this.finishNode(i, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !v) {
              const O = this.state.value;
              throw this.raise(wt.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: O, suggestion: vr[O] });
            }
            return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? (i.declaration = this.flowParseDeclare(this.startNode()), i.default = false, this.finishNode(i, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? ((i = this.parseExport(i, null)).type === "ExportNamedDeclaration" && (i.type = "ExportDeclaration", i.default = false, delete i.exportKind), i.type = "Declare" + i.type, i) : void this.unexpected();
          }
          flowParseDeclareModuleExports(i) {
            return this.next(), this.expectContextual(111), i.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(i, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(i) {
            this.next();
            const v = this.flowParseTypeAlias(i);
            return v.type = "DeclareTypeAlias", v;
          }
          flowParseDeclareOpaqueType(i) {
            this.next();
            const v = this.flowParseOpaqueType(i, true);
            return v.type = "DeclareOpaqueType", v;
          }
          flowParseDeclareInterface(i) {
            return this.next(), this.flowParseInterfaceish(i, false), this.finishNode(i, "DeclareInterface");
          }
          flowParseInterfaceish(i, v) {
            if (i.id = this.flowParseRestrictedIdentifier(!v, true), this.scope.declareName(i.id.name, v ? 17 : 8201, i.id.loc.start), this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, i.extends = [], this.eat(81)) do
              i.extends.push(this.flowParseInterfaceExtends());
            while (!v && this.eat(12));
            if (v) {
              if (i.implements = [], i.mixins = [], this.eatContextual(117)) do
                i.mixins.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
              if (this.eatContextual(113)) do
                i.implements.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            }
            i.body = this.flowParseObjectType({ allowStatic: v, allowExact: false, allowSpread: false, allowProto: v, allowInexact: false });
          }
          flowParseInterfaceExtends() {
            const i = this.startNode();
            return i.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, this.finishNode(i, "InterfaceExtends");
          }
          flowParseInterface(i) {
            return this.flowParseInterfaceish(i, false), this.finishNode(i, "InterfaceDeclaration");
          }
          checkNotUnderscore(i) {
            i === "_" && this.raise(wt.UnexpectedReservedUnderscore, this.state.startLoc);
          }
          checkReservedType(i, v, O) {
            Qr.has(i) && this.raise(O ? wt.AssignReservedType : wt.UnexpectedReservedType, v, { reservedType: i });
          }
          flowParseRestrictedIdentifier(i, v) {
            return this.checkReservedType(this.state.value, this.state.startLoc, v), this.parseIdentifier(i);
          }
          flowParseTypeAlias(i) {
            return i.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(i.id.name, 8201, i.id.loc.start), this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, i.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(i, "TypeAlias");
          }
          flowParseOpaqueType(i, v) {
            return this.expectContextual(130), i.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(i.id.name, 8201, i.id.loc.start), this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, i.supertype = null, this.match(14) && (i.supertype = this.flowParseTypeInitialiser(14)), i.impltype = null, v || (i.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(i, "OpaqueType");
          }
          flowParseTypeParameter(i = false) {
            const v = this.state.startLoc, O = this.startNode(), V = this.flowParseVariance(), ne = this.flowParseTypeAnnotatableIdentifier();
            return O.name = ne.name, O.variance = V, O.bound = ne.typeAnnotation, this.match(29) ? (this.eat(29), O.default = this.flowParseType()) : i && this.raise(wt.MissingTypeParamDefault, v), this.finishNode(O, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const i = this.state.inType, v = this.startNode();
            v.params = [], this.state.inType = true, this.match(47) || this.match(143) ? this.next() : this.unexpected();
            let O = false;
            do {
              const V = this.flowParseTypeParameter(O);
              v.params.push(V), V.default && (O = true), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = i, this.finishNode(v, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            const i = this.startNode(), v = this.state.inType;
            i.params = [], this.state.inType = true, this.expect(47);
            const O = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.match(48); ) i.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = O, this.expect(48), this.state.inType = v, this.finishNode(i, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            const i = this.startNode(), v = this.state.inType;
            for (i.params = [], this.state.inType = true, this.expect(47); !this.match(48); ) i.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = v, this.finishNode(i, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const i = this.startNode();
            if (this.expectContextual(129), i.extends = [], this.eat(81)) do
              i.extends.push(this.flowParseInterfaceExtends());
            while (this.eat(12));
            return i.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(i, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(i, v, O) {
            return i.static = v, this.lookahead().type === 14 ? (i.id = this.flowParseObjectPropertyKey(), i.key = this.flowParseTypeInitialiser()) : (i.id = null, i.key = this.flowParseType()), this.expect(3), i.value = this.flowParseTypeInitialiser(), i.variance = O, this.finishNode(i, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(i, v) {
            return i.static = v, i.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (i.method = true, i.optional = false, i.value = this.flowParseObjectTypeMethodish(this.startNodeAt(i.loc.start))) : (i.method = false, this.eat(17) && (i.optional = true), i.value = this.flowParseTypeInitialiser()), this.finishNode(i, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(i) {
            for (i.params = [], i.rest = null, i.typeParameters = null, i.this = null, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (i.this = this.flowParseFunctionTypeParam(true), i.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) i.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (i.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), i.returnType = this.flowParseTypeInitialiser(), this.finishNode(i, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(i, v) {
            const O = this.startNode();
            return i.static = v, i.value = this.flowParseObjectTypeMethodish(O), this.finishNode(i, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic: i, allowExact: v, allowSpread: O, allowProto: V, allowInexact: ne }) {
            const ce = this.state.inType;
            this.state.inType = true;
            const ve = this.startNode();
            let Ce, Le;
            ve.callProperties = [], ve.properties = [], ve.indexers = [], ve.internalSlots = [];
            let Ke = false;
            for (v && this.match(6) ? (this.expect(6), Ce = 9, Le = true) : (this.expect(5), Ce = 8, Le = false), ve.exact = Le; !this.match(Ce); ) {
              let At = false, bt = null, Nt = null;
              const dn = this.startNode();
              if (V && this.isContextual(118)) {
                const en = this.lookahead();
                en.type !== 14 && en.type !== 17 && (this.next(), bt = this.state.startLoc, i = false);
              }
              if (i && this.isContextual(106)) {
                const en = this.lookahead();
                en.type !== 14 && en.type !== 17 && (this.next(), At = true);
              }
              const kn = this.flowParseVariance();
              if (this.eat(0)) bt != null && this.unexpected(bt), this.eat(0) ? (kn && this.unexpected(kn.loc.start), ve.internalSlots.push(this.flowParseObjectTypeInternalSlot(dn, At))) : ve.indexers.push(this.flowParseObjectTypeIndexer(dn, At, kn));
              else if (this.match(10) || this.match(47)) bt != null && this.unexpected(bt), kn && this.unexpected(kn.loc.start), ve.callProperties.push(this.flowParseObjectTypeCallProperty(dn, At));
              else {
                let en = "init";
                (this.isContextual(99) || this.isContextual(104)) && M(this.lookahead().type) && (en = this.state.value, this.next());
                const wn = this.flowParseObjectTypeProperty(dn, At, bt, kn, en, O, ne ?? !Le);
                wn === null ? (Ke = true, Nt = this.state.lastTokStartLoc) : ve.properties.push(wn);
              }
              this.flowObjectTypeSemicolon(), !Nt || this.match(8) || this.match(9) || this.raise(wt.UnexpectedExplicitInexactInObject, Nt);
            }
            this.expect(Ce), O && (ve.inexact = Ke);
            const ut = this.finishNode(ve, "ObjectTypeAnnotation");
            return this.state.inType = ce, ut;
          }
          flowParseObjectTypeProperty(i, v, O, V, ne, ce, ve) {
            if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (ce ? ve || this.raise(wt.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(wt.InexactInsideNonObject, this.state.lastTokStartLoc), V && this.raise(wt.InexactVariance, V), null) : (ce || this.raise(wt.UnexpectedSpreadType, this.state.lastTokStartLoc), O != null && this.unexpected(O), V && this.raise(wt.SpreadVariance, V), i.argument = this.flowParseType(), this.finishNode(i, "ObjectTypeSpreadProperty"));
            {
              i.key = this.flowParseObjectPropertyKey(), i.static = v, i.proto = O != null, i.kind = ne;
              let Ce = false;
              return this.match(47) || this.match(10) ? (i.method = true, O != null && this.unexpected(O), V && this.unexpected(V.loc.start), i.value = this.flowParseObjectTypeMethodish(this.startNodeAt(i.loc.start)), ne !== "get" && ne !== "set" || this.flowCheckGetterSetterParams(i), !ce && i.key.name === "constructor" && i.value.this && this.raise(wt.ThisParamBannedInConstructor, i.value.this)) : (ne !== "init" && this.unexpected(), i.method = false, this.eat(17) && (Ce = true), i.value = this.flowParseTypeInitialiser(), i.variance = V), i.optional = Ce, this.finishNode(i, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(i) {
            const v = i.kind === "get" ? 0 : 1, O = i.value.params.length + (i.value.rest ? 1 : 0);
            i.value.this && this.raise(i.kind === "get" ? wt.GetterMayNotHaveThisParam : wt.SetterMayNotHaveThisParam, i.value.this), O !== v && this.raise(i.kind === "get" ? _.BadGetterArity : _.BadSetterArity, i), i.kind === "set" && i.value.rest && this.raise(_.BadSetterRestParameter, i);
          }
          flowObjectTypeSemicolon() {
            this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(i, v) {
            i != null || (i = this.state.startLoc);
            let O = v || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(16); ) {
              const V = this.startNodeAt(i);
              V.qualification = O, V.id = this.flowParseRestrictedIdentifier(true), O = this.finishNode(V, "QualifiedTypeIdentifier");
            }
            return O;
          }
          flowParseGenericType(i, v) {
            const O = this.startNodeAt(i);
            return O.typeParameters = null, O.id = this.flowParseQualifiedTypeIdentifier(i, v), this.match(47) && (O.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(O, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const i = this.startNode();
            return this.expect(87), i.argument = this.flowParsePrimaryType(), this.finishNode(i, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const i = this.startNode();
            for (i.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (i.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
            return this.expect(3), this.finishNode(i, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(i) {
            let v = null, O = false, V = null;
            const ne = this.startNode(), ce = this.lookahead(), ve = this.state.type === 78;
            return ce.type === 14 || ce.type === 17 ? (ve && !i && this.raise(wt.ThisParamMustBeFirst, ne), v = this.parseIdentifier(ve), this.eat(17) && (O = true, ve && this.raise(wt.ThisParamMayNotBeOptional, ne)), V = this.flowParseTypeInitialiser()) : V = this.flowParseType(), ne.name = v, ne.optional = O, ne.typeAnnotation = V, this.finishNode(ne, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(i) {
            const v = this.startNodeAt(i.loc.start);
            return v.name = null, v.optional = false, v.typeAnnotation = i, this.finishNode(v, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(i = []) {
            let v = null, O = null;
            for (this.match(78) && (O = this.flowParseFunctionTypeParam(true), O.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) i.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (v = this.flowParseFunctionTypeParam(false)), { params: i, rest: v, _this: O };
          }
          flowIdentToTypeAnnotation(i, v, O) {
            switch (O.name) {
              case "any":
                return this.finishNode(v, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(v, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(v, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(v, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(v, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(v, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(v, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(O.name), this.flowParseGenericType(i, O);
            }
          }
          flowParsePrimaryType() {
            const i = this.state.startLoc, v = this.startNode();
            let O, V, ne = false;
            const ce = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
              case 6:
                return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
              case 0:
                return this.state.noAnonFunctionType = false, V = this.flowParseTupleType(), this.state.noAnonFunctionType = ce, V;
              case 47: {
                const ve = this.startNode();
                return ve.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), O = this.flowParseFunctionTypeParams(), ve.params = O.params, ve.rest = O.rest, ve.this = O._this, this.expect(11), this.expect(19), ve.returnType = this.flowParseType(), this.finishNode(ve, "FunctionTypeAnnotation");
              }
              case 10: {
                const ve = this.startNode();
                if (this.next(), !this.match(11) && !this.match(21)) if (B(this.state.type) || this.match(78)) {
                  const Ce = this.lookahead().type;
                  ne = Ce !== 17 && Ce !== 14;
                } else ne = true;
                if (ne) {
                  if (this.state.noAnonFunctionType = false, V = this.flowParseType(), this.state.noAnonFunctionType = ce, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) return this.expect(11), V;
                  this.eat(12);
                }
                return O = V ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(V)]) : this.flowParseFunctionTypeParams(), ve.params = O.params, ve.rest = O.rest, ve.this = O._this, this.expect(11), this.expect(19), ve.returnType = this.flowParseType(), ve.typeParameters = null, this.finishNode(ve, "FunctionTypeAnnotation");
              }
              case 134:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 85:
              case 86:
                return v.value = this.match(85), this.next(), this.finishNode(v, "BooleanLiteralTypeAnnotation");
              case 53:
                if (this.state.value === "-") {
                  if (this.next(), this.match(135)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", v);
                  if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", v);
                  throw this.raise(wt.UnexpectedSubtractionOperand, this.state.startLoc);
                }
                return void this.unexpected();
              case 135:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 136:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 88:
                return this.next(), this.finishNode(v, "VoidTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(v, "NullLiteralTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(v, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(v, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (ie(this.state.type)) {
                  const ve = ue(this.state.type);
                  return this.next(), super.createIdentifier(v, ve);
                }
                if (B(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(i, v, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            const i = this.state.startLoc;
            let v = this.flowParsePrimaryType(), O = false;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              const V = this.startNodeAt(i), ne = this.eat(18);
              O = O || ne, this.expect(0), !ne && this.match(3) ? (V.elementType = v, this.next(), v = this.finishNode(V, "ArrayTypeAnnotation")) : (V.objectType = v, V.indexType = this.flowParseType(), this.expect(3), O ? (V.optional = ne, v = this.finishNode(V, "OptionalIndexedAccessType")) : v = this.finishNode(V, "IndexedAccessType"));
            }
            return v;
          }
          flowParsePrefixType() {
            const i = this.startNode();
            return this.eat(17) ? (i.typeAnnotation = this.flowParsePrefixType(), this.finishNode(i, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const i = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              const v = this.startNodeAt(i.loc.start);
              return v.params = [this.reinterpretTypeAsFunctionTypeParam(i)], v.rest = null, v.this = null, v.returnType = this.flowParseType(), v.typeParameters = null, this.finishNode(v, "FunctionTypeAnnotation");
            }
            return i;
          }
          flowParseIntersectionType() {
            const i = this.startNode();
            this.eat(45);
            const v = this.flowParseAnonFunctionWithoutParens();
            for (i.types = [v]; this.eat(45); ) i.types.push(this.flowParseAnonFunctionWithoutParens());
            return i.types.length === 1 ? v : this.finishNode(i, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const i = this.startNode();
            this.eat(43);
            const v = this.flowParseIntersectionType();
            for (i.types = [v]; this.eat(43); ) i.types.push(this.flowParseIntersectionType());
            return i.types.length === 1 ? v : this.finishNode(i, "UnionTypeAnnotation");
          }
          flowParseType() {
            const i = this.state.inType;
            this.state.inType = true;
            const v = this.flowParseUnionType();
            return this.state.inType = i, v;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 132 && this.state.value === "_") {
              const i = this.state.startLoc, v = this.parseIdentifier();
              return this.flowParseGenericType(i, v);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const i = this.startNode();
            return i.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(i, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(i) {
            const v = i ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (v.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(v)), v;
          }
          typeCastToParameter(i) {
            return i.expression.typeAnnotation = i.typeAnnotation, this.resetEndLocation(i.expression, i.typeAnnotation.loc.end), i.expression;
          }
          flowParseVariance() {
            let i = null;
            return this.match(53) ? (i = this.startNode(), this.state.value === "+" ? i.kind = "plus" : i.kind = "minus", this.next(), this.finishNode(i, "Variance")) : i;
          }
          parseFunctionBody(i, v, O = false) {
            v ? this.forwardNoArrowParamsConversionAt(i, () => super.parseFunctionBody(i, true, O)) : super.parseFunctionBody(i, false, O);
          }
          parseFunctionBodyAndFinish(i, v, O = false) {
            if (this.match(14)) {
              const V = this.startNode();
              [V.typeAnnotation, i.predicate] = this.flowParseTypeAndPredicateInitialiser(), i.returnType = V.typeAnnotation ? this.finishNode(V, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(i, v, O);
          }
          parseStatementLike(i) {
            if (this.state.strict && this.isContextual(129)) {
              if (z(this.lookahead().type)) {
                const O = this.startNode();
                return this.next(), this.flowParseInterface(O);
              }
            } else if (this.isContextual(126)) {
              const O = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(O);
            }
            const v = super.parseStatementLike(i);
            return this.flowPragma !== void 0 || this.isValidDirective(v) || (this.flowPragma = null), v;
          }
          parseExpressionStatement(i, v, O) {
            if (v.type === "Identifier") {
              if (v.name === "declare") {
                if (this.match(80) || B(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(i);
              } else if (B(this.state.type)) {
                if (v.name === "interface") return this.flowParseInterface(i);
                if (v.name === "type") return this.flowParseTypeAlias(i);
                if (v.name === "opaque") return this.flowParseOpaqueType(i, false);
              }
            }
            return super.parseExpressionStatement(i, v, O);
          }
          shouldParseExportDeclaration() {
            const { type: i } = this.state;
            return i === 126 || Q(i) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            const { type: i } = this.state;
            return i === 126 || Q(i) ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.isContextual(126)) {
              const i = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(i);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(i, v, O) {
            if (!this.match(17)) return i;
            if (this.state.maybeInArrowParameters) {
              const ut = this.lookaheadCharCode();
              if (ut === 44 || ut === 61 || ut === 58 || ut === 41) return this.setOptionalParametersError(O), i;
            }
            this.expect(17);
            const V = this.state.clone(), ne = this.state.noArrowAt, ce = this.startNodeAt(v);
            let { consequent: ve, failed: Ce } = this.tryParseConditionalConsequent(), [Le, Ke] = this.getArrowLikeExpressions(ve);
            if (Ce || Ke.length > 0) {
              const ut = [...ne];
              if (Ke.length > 0) {
                this.state = V, this.state.noArrowAt = ut;
                for (let At = 0; At < Ke.length; At++) ut.push(Ke[At].start);
                ({ consequent: ve, failed: Ce } = this.tryParseConditionalConsequent()), [Le, Ke] = this.getArrowLikeExpressions(ve);
              }
              Ce && Le.length > 1 && this.raise(wt.AmbiguousConditionalArrow, V.startLoc), Ce && Le.length === 1 && (this.state = V, ut.push(Le[0].start), this.state.noArrowAt = ut, { consequent: ve, failed: Ce } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(ve, true), this.state.noArrowAt = ne, this.expect(14), ce.test = i, ce.consequent = ve, ce.alternate = this.forwardNoArrowParamsConversionAt(ce, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(ce, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const i = this.parseMaybeAssignAllowIn(), v = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: i, failed: v };
          }
          getArrowLikeExpressions(i, v) {
            const O = [i], V = [];
            for (; O.length !== 0; ) {
              const ne = O.pop();
              ne.type === "ArrowFunctionExpression" && ne.body.type !== "BlockStatement" ? (ne.typeParameters || !ne.returnType ? this.finishArrowValidation(ne) : V.push(ne), O.push(ne.body)) : ne.type === "ConditionalExpression" && (O.push(ne.consequent), O.push(ne.alternate));
            }
            return v ? (V.forEach((ne) => this.finishArrowValidation(ne)), [V, []]) : function(ne, ce) {
              const ve = [], Ce = [];
              for (let Le = 0; Le < ne.length; Le++) (ce(ne[Le], Le, ne) ? ve : Ce).push(ne[Le]);
              return [ve, Ce];
            }(V, (ne) => ne.params.every((ce) => this.isAssignable(ce, true)));
          }
          finishArrowValidation(i) {
            var v;
            this.toAssignableList(i.params, (v = i.extra) == null ? void 0 : v.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(i, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(i, v) {
            let O;
            return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(i.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), O = v(), this.state.noArrowParamsConversionAt.pop()) : O = v(), O;
          }
          parseParenItem(i, v) {
            const O = super.parseParenItem(i, v);
            if (this.eat(17) && (O.optional = true, this.resetEndLocation(i)), this.match(14)) {
              const V = this.startNodeAt(v);
              return V.expression = O, V.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(V, "TypeCastExpression");
            }
            return O;
          }
          assertModuleNodeAllowed(i) {
            i.type === "ImportDeclaration" && (i.importKind === "type" || i.importKind === "typeof") || i.type === "ExportNamedDeclaration" && i.exportKind === "type" || i.type === "ExportAllDeclaration" && i.exportKind === "type" || super.assertModuleNodeAllowed(i);
          }
          parseExportDeclaration(i) {
            if (this.isContextual(130)) {
              i.exportKind = "type";
              const v = this.startNode();
              return this.next(), this.match(5) ? (i.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(i), null) : this.flowParseTypeAlias(v);
            }
            if (this.isContextual(131)) {
              i.exportKind = "type";
              const v = this.startNode();
              return this.next(), this.flowParseOpaqueType(v, false);
            }
            if (this.isContextual(129)) {
              i.exportKind = "type";
              const v = this.startNode();
              return this.next(), this.flowParseInterface(v);
            }
            if (this.isContextual(126)) {
              i.exportKind = "value";
              const v = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(v);
            }
            return super.parseExportDeclaration(i);
          }
          eatExportStar(i) {
            return !!super.eatExportStar(i) || !(!this.isContextual(130) || this.lookahead().type !== 55) && (i.exportKind = "type", this.next(), this.next(), true);
          }
          maybeParseExportNamespaceSpecifier(i) {
            const { startLoc: v } = this.state, O = super.maybeParseExportNamespaceSpecifier(i);
            return O && i.exportKind === "type" && this.unexpected(v), O;
          }
          parseClassId(i, v, O) {
            super.parseClassId(i, v, O), this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(i, v, O) {
            const { startLoc: V } = this.state;
            if (this.isContextual(125)) {
              if (super.parseClassMemberFromModifier(i, v)) return;
              v.declare = true;
            }
            super.parseClassMember(i, v, O), v.declare && (v.type !== "ClassProperty" && v.type !== "ClassPrivateProperty" && v.type !== "PropertyDefinition" ? this.raise(wt.DeclareClassElement, V) : v.value && this.raise(wt.DeclareClassFieldInitializer, v.value));
          }
          isIterator(i) {
            return i === "iterator" || i === "asyncIterator";
          }
          readIterator() {
            const i = super.readWord1(), v = "@@" + i;
            this.isIterator(i) && this.state.inType || this.raise(_.InvalidIdentifier, this.state.curPosition(), { identifierName: v }), this.finishToken(132, v);
          }
          getTokenFromCode(i) {
            const v = this.input.charCodeAt(this.state.pos + 1);
            i === 123 && v === 124 ? this.finishOp(6, 2) : !this.state.inType || i !== 62 && i !== 60 ? this.state.inType && i === 63 ? v === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : function(O, V, ne) {
              return O === 64 && V === 64 && J(ne);
            }(i, v, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(i) : this.finishOp(i === 62 ? 48 : 47, 1);
          }
          isAssignable(i, v) {
            return i.type === "TypeCastExpression" ? this.isAssignable(i.expression, v) : super.isAssignable(i, v);
          }
          toAssignable(i, v = false) {
            v || i.type !== "AssignmentExpression" || i.left.type !== "TypeCastExpression" || (i.left = this.typeCastToParameter(i.left)), super.toAssignable(i, v);
          }
          toAssignableList(i, v, O) {
            for (let V = 0; V < i.length; V++) {
              const ne = i[V];
              (ne == null ? void 0 : ne.type) === "TypeCastExpression" && (i[V] = this.typeCastToParameter(ne));
            }
            super.toAssignableList(i, v, O);
          }
          toReferencedList(i, v) {
            for (let V = 0; V < i.length; V++) {
              var O;
              const ne = i[V];
              !ne || ne.type !== "TypeCastExpression" || (O = ne.extra) != null && O.parenthesized || !(i.length > 1) && v || this.raise(wt.TypeCastInPattern, ne.typeAnnotation);
            }
            return i;
          }
          parseArrayLike(i, v, O, V) {
            const ne = super.parseArrayLike(i, v, O, V);
            return v && !this.state.maybeInArrowParameters && this.toReferencedList(ne.elements), ne;
          }
          isValidLVal(i, v, O) {
            return i === "TypeCastExpression" || super.isValidLVal(i, v, O);
          }
          parseClassProperty(i) {
            return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(i);
          }
          parseClassPrivateProperty(i) {
            return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(i);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(i) {
            return !this.match(14) && super.isNonstaticConstructor(i);
          }
          pushClassMethod(i, v, O, V, ne, ce) {
            if (v.variance && this.unexpected(v.variance.loc.start), delete v.variance, this.match(47) && (v.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(i, v, O, V, ne, ce), v.params && ne) {
              const ve = v.params;
              ve.length > 0 && this.isThisParam(ve[0]) && this.raise(wt.ThisParamBannedInConstructor, v);
            } else if (v.type === "MethodDefinition" && ne && v.value.params) {
              const ve = v.value.params;
              ve.length > 0 && this.isThisParam(ve[0]) && this.raise(wt.ThisParamBannedInConstructor, v);
            }
          }
          pushClassPrivateMethod(i, v, O, V) {
            v.variance && this.unexpected(v.variance.loc.start), delete v.variance, this.match(47) && (v.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(i, v, O, V);
          }
          parseClassSuper(i) {
            if (super.parseClassSuper(i), i.superClass && this.match(47) && (i.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
              this.next();
              const v = i.implements = [];
              do {
                const O = this.startNode();
                O.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? O.typeParameters = this.flowParseTypeParameterInstantiation() : O.typeParameters = null, v.push(this.finishNode(O, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(i) {
            super.checkGetterSetterParams(i);
            const v = this.getObjectOrClassMethodParams(i);
            if (v.length > 0) {
              const O = v[0];
              this.isThisParam(O) && i.kind === "get" ? this.raise(wt.GetterMayNotHaveThisParam, O) : this.isThisParam(O) && this.raise(wt.SetterMayNotHaveThisParam, O);
            }
          }
          parsePropertyNamePrefixOperator(i) {
            i.variance = this.flowParseVariance();
          }
          parseObjPropValue(i, v, O, V, ne, ce, ve) {
            let Ce;
            i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && !ce && (Ce = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            const Le = super.parseObjPropValue(i, v, O, V, ne, ce, ve);
            return Ce && ((Le.value || Le).typeParameters = Ce), Le;
          }
          parseFunctionParamType(i) {
            return this.eat(17) && (i.type !== "Identifier" && this.raise(wt.PatternIsOptional, i), this.isThisParam(i) && this.raise(wt.ThisParamMayNotBeOptional, i), i.optional = true), this.match(14) ? i.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(i) && this.raise(wt.ThisParamAnnotationRequired, i), this.match(29) && this.isThisParam(i) && this.raise(wt.ThisParamNoDefault, i), this.resetEndLocation(i), i;
          }
          parseMaybeDefault(i, v) {
            const O = super.parseMaybeDefault(i, v);
            return O.type === "AssignmentPattern" && O.typeAnnotation && O.right.start < O.typeAnnotation.start && this.raise(wt.TypeBeforeInitializer, O.typeAnnotation), O;
          }
          checkImportReflection(i) {
            super.checkImportReflection(i), i.module && i.importKind !== "value" && this.raise(wt.ImportReflectionHasImportType, i.specifiers[0].loc.start);
          }
          parseImportSpecifierLocal(i, v, O) {
            v.local = $r(i) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), i.specifiers.push(this.finishImportSpecifier(v, O));
          }
          isPotentialImportPhase(i) {
            if (super.isPotentialImportPhase(i)) return true;
            if (this.isContextual(130)) {
              if (!i) return true;
              const v = this.lookaheadCharCode();
              return v === 123 || v === 42;
            }
            return !i && this.isContextual(87);
          }
          applyImportPhase(i, v, O, V) {
            if (super.applyImportPhase(i, v, O, V), v) {
              if (!O && this.match(65)) return;
              i.exportKind = O === "type" ? O : "value";
            } else O === "type" && this.match(55) && this.unexpected(), i.importKind = O === "type" || O === "typeof" ? O : "value";
          }
          parseImportSpecifier(i, v, O, V, ne) {
            const ce = i.imported;
            let ve = null;
            ce.type === "Identifier" && (ce.name === "type" ? ve = "type" : ce.name === "typeof" && (ve = "typeof"));
            let Ce = false;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              const Ke = this.parseIdentifier(true);
              ve === null || z(this.state.type) ? (i.imported = ce, i.importKind = null, i.local = this.parseIdentifier()) : (i.imported = Ke, i.importKind = ve, i.local = zn(Ke));
            } else {
              if (ve !== null && z(this.state.type)) i.imported = this.parseIdentifier(true), i.importKind = ve;
              else {
                if (v) throw this.raise(_.ImportBindingIsString, i, { importName: ce.value });
                i.imported = ce, i.importKind = null;
              }
              this.eatContextual(93) ? i.local = this.parseIdentifier() : (Ce = true, i.local = zn(i.imported));
            }
            const Le = $r(i);
            return O && Le && this.raise(wt.ImportTypeShorthandOnlyInPureImport, i), (O || Le) && this.checkReservedType(i.local.name, i.local.loc.start, true), !Ce || O || Le || this.checkReservedWord(i.local.name, i.loc.start, true, true), this.finishImportSpecifier(i, "ImportSpecifier");
          }
          parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseFunctionParams(i, v) {
            const O = i.kind;
            O !== "get" && O !== "set" && this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(i, v);
          }
          parseVarId(i, v) {
            super.parseVarId(i, v), this.match(14) && (i.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i.id));
          }
          parseAsyncArrowFromCallExpression(i, v) {
            if (this.match(14)) {
              const O = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, i.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = O;
            }
            return super.parseAsyncArrowFromCallExpression(i, v);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(i, v) {
            var O;
            let V, ne = null;
            if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
              if (ne = this.state.clone(), V = this.tryParse(() => super.parseMaybeAssign(i, v), ne), !V.error) return V.node;
              const { context: Ce } = this.state, Le = Ce[Ce.length - 1];
              Le !== j.j_oTag && Le !== j.j_expr || Ce.pop();
            }
            if ((O = V) != null && O.error || this.match(47)) {
              var ce, ve;
              let Ce;
              ne = ne || this.state.clone();
              const Le = this.tryParse((ut) => {
                var At;
                Ce = this.flowParseTypeParameterDeclaration();
                const bt = this.forwardNoArrowParamsConversionAt(Ce, () => {
                  const dn = super.parseMaybeAssign(i, v);
                  return this.resetStartLocationFromNode(dn, Ce), dn;
                });
                (At = bt.extra) != null && At.parenthesized && ut();
                const Nt = this.maybeUnwrapTypeCastExpression(bt);
                return Nt.type !== "ArrowFunctionExpression" && ut(), Nt.typeParameters = Ce, this.resetStartLocationFromNode(Nt, Ce), bt;
              }, ne);
              let Ke = null;
              if (Le.node && this.maybeUnwrapTypeCastExpression(Le.node).type === "ArrowFunctionExpression") {
                if (!Le.error && !Le.aborted) return Le.node.async && this.raise(wt.UnexpectedTypeParameterBeforeAsyncArrowFunction, Ce), Le.node;
                Ke = Le.node;
              }
              if ((ce = V) != null && ce.node) return this.state = V.failState, V.node;
              if (Ke) return this.state = Le.failState, Ke;
              throw (ve = V) != null && ve.thrown ? V.error : Le.thrown ? Le.error : this.raise(wt.UnexpectedTokenAfterTypeParameter, Ce);
            }
            return super.parseMaybeAssign(i, v);
          }
          parseArrow(i) {
            if (this.match(14)) {
              const v = this.tryParse(() => {
                const O = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                const V = this.startNode();
                return [V.typeAnnotation, i.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = O, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), V;
              });
              if (v.thrown) return null;
              v.error && (this.state = v.failState), i.returnType = v.node.typeAnnotation ? this.finishNode(v.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(i);
          }
          shouldParseArrow(i) {
            return this.match(14) || super.shouldParseArrow(i);
          }
          setArrowFunctionParameters(i, v) {
            this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(i.start)) ? i.params = v : super.setArrowFunctionParameters(i, v);
          }
          checkParams(i, v, O, V = true) {
            if (!O || !this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(i.start))) {
              for (let ne = 0; ne < i.params.length; ne++) this.isThisParam(i.params[ne]) && ne > 0 && this.raise(wt.ThisParamMustBeFirst, i.params[ne]);
              super.checkParams(i, v, O, V);
            }
          }
          parseParenAndDistinguishExpression(i) {
            return super.parseParenAndDistinguishExpression(i && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
          }
          parseSubscripts(i, v, O) {
            if (i.type === "Identifier" && i.name === "async" && this.state.noArrowAt.includes(v.index)) {
              this.next();
              const V = this.startNodeAt(v);
              V.callee = i, V.arguments = super.parseCallExpressionArguments(11), i = this.finishNode(V, "CallExpression");
            } else if (i.type === "Identifier" && i.name === "async" && this.match(47)) {
              const V = this.state.clone(), ne = this.tryParse((ve) => this.parseAsyncArrowWithTypeParameters(v) || ve(), V);
              if (!ne.error && !ne.aborted) return ne.node;
              const ce = this.tryParse(() => super.parseSubscripts(i, v, O), V);
              if (ce.node && !ce.error) return ce.node;
              if (ne.node) return this.state = ne.failState, ne.node;
              if (ce.node) return this.state = ce.failState, ce.node;
              throw ne.error || ce.error;
            }
            return super.parseSubscripts(i, v, O);
          }
          parseSubscript(i, v, O, V) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (V.optionalChainMember = true, O) return V.stop = true, i;
              this.next();
              const ne = this.startNodeAt(v);
              return ne.callee = i, ne.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), ne.arguments = this.parseCallExpressionArguments(11), ne.optional = true, this.finishCallExpression(ne, true);
            }
            if (!O && this.shouldParseTypes() && this.match(47)) {
              const ne = this.startNodeAt(v);
              ne.callee = i;
              const ce = this.tryParse(() => (ne.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), ne.arguments = super.parseCallExpressionArguments(11), V.optionalChainMember && (ne.optional = false), this.finishCallExpression(ne, V.optionalChainMember)));
              if (ce.node) return ce.error && (this.state = ce.failState), ce.node;
            }
            return super.parseSubscript(i, v, O, V);
          }
          parseNewCallee(i) {
            super.parseNewCallee(i);
            let v = null;
            this.shouldParseTypes() && this.match(47) && (v = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), i.typeArguments = v;
          }
          parseAsyncArrowWithTypeParameters(i) {
            const v = this.startNodeAt(i);
            if (this.parseFunctionParams(v, false), this.parseArrow(v)) return super.parseArrowExpression(v, void 0, true);
          }
          readToken_mult_modulo(i) {
            const v = this.input.charCodeAt(this.state.pos + 1);
            if (i === 42 && v === 47 && this.state.hasFlowComment) return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(i);
          }
          readToken_pipe_amp(i) {
            const v = this.input.charCodeAt(this.state.pos + 1);
            i !== 124 || v !== 125 ? super.readToken_pipe_amp(i) : this.finishOp(9, 2);
          }
          parseTopLevel(i, v) {
            const O = super.parseTopLevel(i, v);
            return this.state.hasFlowComment && this.raise(wt.UnterminatedFlowComment, this.state.curPosition()), O;
          }
          skipBlockComment() {
            if (!this.hasPlugin("flowComments") || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
            {
              if (this.state.hasFlowComment) throw this.raise(wt.NestedFlowComment, this.state.startLoc);
              this.hasFlowCommentCompletion();
              const i = this.skipFlowComment();
              i && (this.state.pos += i, this.state.hasFlowComment = true);
            }
          }
          skipFlowComment() {
            const { pos: i } = this.state;
            let v = 2;
            for (; [32, 9].includes(this.input.charCodeAt(i + v)); ) v++;
            const O = this.input.charCodeAt(v + i), V = this.input.charCodeAt(v + i + 1);
            return O === 58 && V === 58 ? v + 2 : this.input.slice(v + i, v + i + 12) === "flow-include" ? v + 12 : O === 58 && V !== 58 && v;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1) throw this.raise(_.UnterminatedComment, this.state.curPosition());
          }
          flowEnumErrorBooleanMemberNotInitialized(i, { enumName: v, memberName: O }) {
            this.raise(wt.EnumBooleanMemberNotInitialized, i, { memberName: O, enumName: v });
          }
          flowEnumErrorInvalidMemberInitializer(i, v) {
            return this.raise(v.explicitType ? v.explicitType === "symbol" ? wt.EnumInvalidMemberInitializerSymbolType : wt.EnumInvalidMemberInitializerPrimaryType : wt.EnumInvalidMemberInitializerUnknownType, i, v);
          }
          flowEnumErrorNumberMemberNotInitialized(i, v) {
            this.raise(wt.EnumNumberMemberNotInitialized, i, v);
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(i, v) {
            this.raise(wt.EnumStringMemberInconsistentlyInitialized, i, v);
          }
          flowEnumMemberInit() {
            const i = this.state.startLoc, v = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 135: {
                const O = this.parseNumericLiteral(this.state.value);
                return v() ? { type: "number", loc: O.loc.start, value: O } : { type: "invalid", loc: i };
              }
              case 134: {
                const O = this.parseStringLiteral(this.state.value);
                return v() ? { type: "string", loc: O.loc.start, value: O } : { type: "invalid", loc: i };
              }
              case 85:
              case 86: {
                const O = this.parseBooleanLiteral(this.match(85));
                return v() ? { type: "boolean", loc: O.loc.start, value: O } : { type: "invalid", loc: i };
              }
              default:
                return { type: "invalid", loc: i };
            }
          }
          flowEnumMemberRaw() {
            const i = this.state.startLoc;
            return { id: this.parseIdentifier(true), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: i } };
          }
          flowEnumCheckExplicitTypeMismatch(i, v, O) {
            const { explicitType: V } = v;
            V !== null && V !== O && this.flowEnumErrorInvalidMemberInitializer(i, v);
          }
          flowEnumMembers({ enumName: i, explicitType: v }) {
            const O = /* @__PURE__ */ new Set(), V = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
            let ne = false;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                ne = true;
                break;
              }
              const ce = this.startNode(), { id: ve, init: Ce } = this.flowEnumMemberRaw(), Le = ve.name;
              if (Le === "") continue;
              /^[a-z]/.test(Le) && this.raise(wt.EnumInvalidMemberName, ve, { memberName: Le, suggestion: Le[0].toUpperCase() + Le.slice(1), enumName: i }), O.has(Le) && this.raise(wt.EnumDuplicateMemberName, ve, { memberName: Le, enumName: i }), O.add(Le);
              const Ke = { enumName: i, explicitType: v, memberName: Le };
              switch (ce.id = ve, Ce.type) {
                case "boolean":
                  this.flowEnumCheckExplicitTypeMismatch(Ce.loc, Ke, "boolean"), ce.init = Ce.value, V.booleanMembers.push(this.finishNode(ce, "EnumBooleanMember"));
                  break;
                case "number":
                  this.flowEnumCheckExplicitTypeMismatch(Ce.loc, Ke, "number"), ce.init = Ce.value, V.numberMembers.push(this.finishNode(ce, "EnumNumberMember"));
                  break;
                case "string":
                  this.flowEnumCheckExplicitTypeMismatch(Ce.loc, Ke, "string"), ce.init = Ce.value, V.stringMembers.push(this.finishNode(ce, "EnumStringMember"));
                  break;
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(Ce.loc, Ke);
                case "none":
                  switch (v) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(Ce.loc, Ke);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(Ce.loc, Ke);
                      break;
                    default:
                      V.defaultedMembers.push(this.finishNode(ce, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: V, hasUnknownMembers: ne };
          }
          flowEnumStringMembers(i, v, { enumName: O }) {
            if (i.length === 0) return v;
            if (v.length === 0) return i;
            if (v.length > i.length) {
              for (const V of i) this.flowEnumErrorStringMemberInconsistentlyInitialized(V, { enumName: O });
              return v;
            }
            for (const V of v) this.flowEnumErrorStringMemberInconsistentlyInitialized(V, { enumName: O });
            return i;
          }
          flowEnumParseExplicitType({ enumName: i }) {
            if (!this.eatContextual(102)) return null;
            if (!B(this.state.type)) throw this.raise(wt.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: i });
            const { value: v } = this.state;
            return this.next(), v !== "boolean" && v !== "number" && v !== "string" && v !== "symbol" && this.raise(wt.EnumInvalidExplicitType, this.state.startLoc, { enumName: i, invalidEnumType: v }), v;
          }
          flowEnumBody(i, v) {
            const O = v.name, V = v.loc.start, ne = this.flowEnumParseExplicitType({ enumName: O });
            this.expect(5);
            const { members: ce, hasUnknownMembers: ve } = this.flowEnumMembers({ enumName: O, explicitType: ne });
            switch (i.hasUnknownMembers = ve, ne) {
              case "boolean":
                return i.explicitType = true, i.members = ce.booleanMembers, this.expect(8), this.finishNode(i, "EnumBooleanBody");
              case "number":
                return i.explicitType = true, i.members = ce.numberMembers, this.expect(8), this.finishNode(i, "EnumNumberBody");
              case "string":
                return i.explicitType = true, i.members = this.flowEnumStringMembers(ce.stringMembers, ce.defaultedMembers, { enumName: O }), this.expect(8), this.finishNode(i, "EnumStringBody");
              case "symbol":
                return i.members = ce.defaultedMembers, this.expect(8), this.finishNode(i, "EnumSymbolBody");
              default: {
                const Ce = () => (i.members = [], this.expect(8), this.finishNode(i, "EnumStringBody"));
                i.explicitType = false;
                const Le = ce.booleanMembers.length, Ke = ce.numberMembers.length, ut = ce.stringMembers.length, At = ce.defaultedMembers.length;
                if (Le || Ke || ut || At) {
                  if (Le || Ke) {
                    if (!Ke && !ut && Le >= At) {
                      for (const bt of ce.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(bt.loc.start, { enumName: O, memberName: bt.id.name });
                      return i.members = ce.booleanMembers, this.expect(8), this.finishNode(i, "EnumBooleanBody");
                    }
                    if (!Le && !ut && Ke >= At) {
                      for (const bt of ce.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(bt.loc.start, { enumName: O, memberName: bt.id.name });
                      return i.members = ce.numberMembers, this.expect(8), this.finishNode(i, "EnumNumberBody");
                    }
                    return this.raise(wt.EnumInconsistentMemberValues, V, { enumName: O }), Ce();
                  }
                  return i.members = this.flowEnumStringMembers(ce.stringMembers, ce.defaultedMembers, { enumName: O }), this.expect(8), this.finishNode(i, "EnumStringBody");
                }
                return Ce();
              }
            }
          }
          flowParseEnumDeclaration(i) {
            const v = this.parseIdentifier();
            return i.id = v, i.body = this.flowEnumBody(this.startNode(), v), this.finishNode(i, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            const i = this.nextTokenStart();
            if (this.input.charCodeAt(i) === 60) {
              const v = this.input.charCodeAt(i + 1);
              return v !== 60 && v !== 61;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(i) {
            return i.type === "TypeCastExpression" ? i.expression : i;
          }
        }, typescript: (de) => class extends de {
          constructor(...i) {
            super(...i), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: ct.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: ct.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: ct.InvalidModifierOnTypeParameter });
          }
          getScopeHandler() {
            return at;
          }
          tsIsIdentifier() {
            return B(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
          }
          tsNextTokenOnSameLineAndCanFollowModifier() {
            return this.next(), !this.hasPrecedingLineBreak() && this.tsTokenCanFollowModifier();
          }
          tsNextTokenCanFollowModifier() {
            return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
          }
          tsParseModifier(i, v) {
            if (!B(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
            const O = this.state.value;
            if (i.includes(O)) {
              if (v && this.tsIsStartOfStaticBlocks()) return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return O;
            }
          }
          tsParseModifiers({ allowedModifiers: i, disallowedModifiers: v, stopOnStartOfClassStaticBlock: O, errorTemplate: V = ct.InvalidModifierOnTypeMember }, ne) {
            const ce = (Ce, Le, Ke, ut) => {
              Le === Ke && ne[ut] && this.raise(ct.InvalidModifiersOrder, Ce, { orderedModifiers: [Ke, ut] });
            }, ve = (Ce, Le, Ke, ut) => {
              (ne[Ke] && Le === ut || ne[ut] && Le === Ke) && this.raise(ct.IncompatibleModifiers, Ce, { modifiers: [Ke, ut] });
            };
            for (; ; ) {
              const { startLoc: Ce } = this.state, Le = this.tsParseModifier(i.concat(v ?? []), O);
              if (!Le) break;
              Ot(Le) ? ne.accessibility ? this.raise(ct.DuplicateAccessibilityModifier, Ce, { modifier: Le }) : (ce(Ce, Le, Le, "override"), ce(Ce, Le, Le, "static"), ce(Ce, Le, Le, "readonly"), ne.accessibility = Le) : zt(Le) ? (ne[Le] && this.raise(ct.DuplicateModifier, Ce, { modifier: Le }), ne[Le] = true, ce(Ce, Le, "in", "out")) : (hasOwnProperty.call(ne, Le) ? this.raise(ct.DuplicateModifier, Ce, { modifier: Le }) : (ce(Ce, Le, "static", "readonly"), ce(Ce, Le, "static", "override"), ce(Ce, Le, "override", "readonly"), ce(Ce, Le, "abstract", "override"), ve(Ce, Le, "declare", "override"), ve(Ce, Le, "static", "abstract")), ne[Le] = true), v != null && v.includes(Le) && this.raise(V, Ce, { modifier: Le });
            }
          }
          tsIsListTerminator(i) {
            switch (i) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(48);
            }
          }
          tsParseList(i, v) {
            const O = [];
            for (; !this.tsIsListTerminator(i); ) O.push(v());
            return O;
          }
          tsParseDelimitedList(i, v, O) {
            return function(V) {
              if (V == null) throw new Error(`Unexpected ${V} value.`);
              return V;
            }(this.tsParseDelimitedListWorker(i, v, true, O));
          }
          tsParseDelimitedListWorker(i, v, O, V) {
            const ne = [];
            let ce = -1;
            for (; !this.tsIsListTerminator(i); ) {
              ce = -1;
              const ve = v();
              if (ve == null) return;
              if (ne.push(ve), !this.eat(12)) {
                if (this.tsIsListTerminator(i)) break;
                return void (O && this.expect(12));
              }
              ce = this.state.lastTokStartLoc.index;
            }
            return V && (V.value = ce), ne;
          }
          tsParseBracketedList(i, v, O, V, ne) {
            V || (O ? this.expect(0) : this.expect(47));
            const ce = this.tsParseDelimitedList(i, v, ne);
            return O ? this.expect(3) : this.expect(48), ce;
          }
          tsParseImportType() {
            const i = this.startNode();
            return this.expect(83), this.expect(10), this.match(134) || this.raise(ct.UnsupportedImportTypeArgument, this.state.startLoc), i.argument = super.parseExprAtom(), this.eat(12) && !this.match(11) ? (i.options = super.parseMaybeAssignAllowIn(), this.eat(12)) : i.options = null, this.expect(11), this.eat(16) && (i.qualifier = this.tsParseEntityName()), this.match(47) && (i.typeParameters = this.tsParseTypeArguments()), this.finishNode(i, "TSImportType");
          }
          tsParseEntityName(i = true) {
            let v = this.parseIdentifier(i);
            for (; this.eat(16); ) {
              const O = this.startNodeAtNode(v);
              O.left = v, O.right = this.parseIdentifier(i), v = this.finishNode(O, "TSQualifiedName");
            }
            return v;
          }
          tsParseTypeReference() {
            const i = this.startNode();
            return i.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (i.typeParameters = this.tsParseTypeArguments()), this.finishNode(i, "TSTypeReference");
          }
          tsParseThisTypePredicate(i) {
            this.next();
            const v = this.startNodeAtNode(i);
            return v.parameterName = i, v.typeAnnotation = this.tsParseTypeAnnotation(false), v.asserts = false, this.finishNode(v, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const i = this.startNode();
            return this.next(), this.finishNode(i, "TSThisType");
          }
          tsParseTypeQuery() {
            const i = this.startNode();
            return this.expect(87), this.match(83) ? i.exprName = this.tsParseImportType() : i.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (i.typeParameters = this.tsParseTypeArguments()), this.finishNode(i, "TSTypeQuery");
          }
          tsParseTypeParameter(i) {
            const v = this.startNode();
            return i(v), v.name = this.tsParseTypeParameterName(), v.constraint = this.tsEatThenParseType(81), v.default = this.tsEatThenParseType(29), this.finishNode(v, "TSTypeParameter");
          }
          tsTryParseTypeParameters(i) {
            if (this.match(47)) return this.tsParseTypeParameters(i);
          }
          tsParseTypeParameters(i) {
            const v = this.startNode();
            this.match(47) || this.match(143) ? this.next() : this.unexpected();
            const O = { value: -1 };
            return v.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, i), false, true, O), v.params.length === 0 && this.raise(ct.EmptyTypeParameters, v), O.value !== -1 && this.addExtra(v, "trailingComma", O.value), this.finishNode(v, "TSTypeParameterDeclaration");
          }
          tsFillSignature(i, v) {
            const O = i === 19;
            v.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), v.parameters = this.tsParseBindingListForSignature(), (O || this.match(i)) && (v.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(i));
          }
          tsParseBindingListForSignature() {
            const i = super.parseBindingList(11, 41, 2);
            for (const v of i) {
              const { type: O } = v;
              O !== "AssignmentPattern" && O !== "TSParameterProperty" || this.raise(ct.UnsupportedSignatureParameterKind, v, { type: O });
            }
            return i;
          }
          tsParseTypeMemberSemicolon() {
            this.eat(12) || this.isLineTerminator() || this.expect(13);
          }
          tsParseSignatureMember(i, v) {
            return this.tsFillSignature(14, v), this.tsParseTypeMemberSemicolon(), this.finishNode(v, i);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), !!B(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(i) {
            if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
            this.expect(0);
            const v = this.parseIdentifier();
            v.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(v), this.expect(3), i.parameters = [v];
            const O = this.tsTryParseTypeAnnotation();
            return O && (i.typeAnnotation = O), this.tsParseTypeMemberSemicolon(), this.finishNode(i, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(i, v) {
            this.eat(17) && (i.optional = true);
            const O = i;
            if (this.match(10) || this.match(47)) {
              v && this.raise(ct.ReadonlyForMethodSignature, i);
              const V = O;
              V.kind && this.match(47) && this.raise(ct.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, V), this.tsParseTypeMemberSemicolon();
              const ne = "parameters", ce = "typeAnnotation";
              if (V.kind === "get") V[ne].length > 0 && (this.raise(_.BadGetterArity, this.state.curPosition()), this.isThisParam(V[ne][0]) && this.raise(ct.AccessorCannotDeclareThisParameter, this.state.curPosition()));
              else if (V.kind === "set") {
                if (V[ne].length !== 1) this.raise(_.BadSetterArity, this.state.curPosition());
                else {
                  const ve = V[ne][0];
                  this.isThisParam(ve) && this.raise(ct.AccessorCannotDeclareThisParameter, this.state.curPosition()), ve.type === "Identifier" && ve.optional && this.raise(ct.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), ve.type === "RestElement" && this.raise(ct.SetAccessorCannotHaveRestParameter, this.state.curPosition());
                }
                V[ce] && this.raise(ct.SetAccessorCannotHaveReturnType, V[ce]);
              } else V.kind = "method";
              return this.finishNode(V, "TSMethodSignature");
            }
            {
              const V = O;
              v && (V.readonly = true);
              const ne = this.tsTryParseTypeAnnotation();
              return ne && (V.typeAnnotation = ne), this.tsParseTypeMemberSemicolon(), this.finishNode(V, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const i = this.startNode();
            if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", i);
            if (this.match(77)) {
              const O = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", i) : (i.key = this.createIdentifier(O, "new"), this.tsParsePropertyOrMethodSignature(i, false));
            }
            return this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, i), this.tsTryParseIndexSignature(i) || (super.parsePropertyName(i), i.computed || i.key.type !== "Identifier" || i.key.name !== "get" && i.key.name !== "set" || !this.tsTokenCanFollowModifier() || (i.kind = i.key.name, super.parsePropertyName(i)), this.tsParsePropertyOrMethodSignature(i, !!i.readonly));
          }
          tsParseTypeLiteral() {
            const i = this.startNode();
            return i.members = this.tsParseObjectTypeMembers(), this.finishNode(i, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            const i = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), i;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
          }
          tsParseMappedType() {
            const i = this.startNode();
            this.expect(5), this.match(53) ? (i.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (i.readonly = true), this.expect(0);
            {
              const v = this.startNode();
              v.name = this.tsParseTypeParameterName(), v.constraint = this.tsExpectThenParseType(58), i.typeParameter = this.finishNode(v, "TSTypeParameter");
            }
            return i.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (i.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (i.optional = true), i.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(i, "TSMappedType");
          }
          tsParseTupleType() {
            const i = this.startNode();
            i.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let v = false;
            return i.elementTypes.forEach((O) => {
              const { type: V } = O;
              !v || V === "TSRestType" || V === "TSOptionalType" || V === "TSNamedTupleMember" && O.optional || this.raise(ct.OptionalTypeBeforeRequired, O), v || (v = V === "TSNamedTupleMember" && O.optional || V === "TSOptionalType");
            }), this.finishNode(i, "TSTupleType");
          }
          tsParseTupleElementType() {
            const { startLoc: i } = this.state, v = this.eat(21);
            let O, V, ne, ce;
            const ve = z(this.state.type) ? this.lookaheadCharCode() : null;
            if (ve === 58) O = true, ne = false, V = this.parseIdentifier(true), this.expect(14), ce = this.tsParseType();
            else if (ve === 63) {
              ne = true;
              const Ce = this.state.startLoc, Le = this.state.value, Ke = this.tsParseNonArrayType();
              this.lookaheadCharCode() === 58 ? (O = true, V = this.createIdentifier(this.startNodeAt(Ce), Le), this.expect(17), this.expect(14), ce = this.tsParseType()) : (O = false, ce = Ke, this.expect(17));
            } else ce = this.tsParseType(), ne = this.eat(17), O = this.eat(14);
            if (O) {
              let Ce;
              V ? (Ce = this.startNodeAtNode(V), Ce.optional = ne, Ce.label = V, Ce.elementType = ce, this.eat(17) && (Ce.optional = true, this.raise(ct.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (Ce = this.startNodeAtNode(ce), Ce.optional = ne, this.raise(ct.InvalidTupleMemberLabel, ce), Ce.label = ce, Ce.elementType = this.tsParseType()), ce = this.finishNode(Ce, "TSNamedTupleMember");
            } else if (ne) {
              const Ce = this.startNodeAtNode(ce);
              Ce.typeAnnotation = ce, ce = this.finishNode(Ce, "TSOptionalType");
            }
            if (v) {
              const Ce = this.startNodeAt(i);
              Ce.typeAnnotation = ce, ce = this.finishNode(Ce, "TSRestType");
            }
            return ce;
          }
          tsParseParenthesizedType() {
            const i = this.startNode();
            return this.expect(10), i.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(i, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(i, v) {
            const O = this.startNode();
            return i === "TSConstructorType" && (O.abstract = !!v, v && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, O)), this.finishNode(O, i);
          }
          tsParseLiteralTypeNode() {
            const i = this.startNode();
            switch (this.state.type) {
              case 135:
              case 136:
              case 134:
              case 85:
              case 86:
                i.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(i, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            const i = this.startNode();
            return i.literal = super.parseTemplate(false), this.finishNode(i, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const i = this.tsParseThisTypeNode();
            return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(i) : i;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 134:
              case 135:
              case 136:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if (this.state.value === "-") {
                  const i = this.startNode(), v = this.lookahead();
                  return v.type !== 135 && v.type !== 136 && this.unexpected(), i.literal = this.parseMaybeUnary(), this.finishNode(i, "TSLiteralType");
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                const { type: i } = this.state;
                if (B(i) || i === 88 || i === 84) {
                  const v = i === 88 ? "TSVoidKeyword" : i === 84 ? "TSNullKeyword" : function(O) {
                    switch (O) {
                      case "any":
                        return "TSAnyKeyword";
                      case "boolean":
                        return "TSBooleanKeyword";
                      case "bigint":
                        return "TSBigIntKeyword";
                      case "never":
                        return "TSNeverKeyword";
                      case "number":
                        return "TSNumberKeyword";
                      case "object":
                        return "TSObjectKeyword";
                      case "string":
                        return "TSStringKeyword";
                      case "symbol":
                        return "TSSymbolKeyword";
                      case "undefined":
                        return "TSUndefinedKeyword";
                      case "unknown":
                        return "TSUnknownKeyword";
                      default:
                        return;
                    }
                  }(this.state.value);
                  if (v !== void 0 && this.lookaheadCharCode() !== 46) {
                    const O = this.startNode();
                    return this.next(), this.finishNode(O, v);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let i = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
              const v = this.startNodeAtNode(i);
              v.elementType = i, this.expect(3), i = this.finishNode(v, "TSArrayType");
            } else {
              const v = this.startNodeAtNode(i);
              v.objectType = i, v.indexType = this.tsParseType(), this.expect(3), i = this.finishNode(v, "TSIndexedAccessType");
            }
            return i;
          }
          tsParseTypeOperator() {
            const i = this.startNode(), v = this.state.value;
            return this.next(), i.operator = v, i.typeAnnotation = this.tsParseTypeOperatorOrHigher(), v === "readonly" && this.tsCheckTypeAnnotationForReadOnly(i), this.finishNode(i, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(i) {
            switch (i.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(ct.UnexpectedReadonly, i);
            }
          }
          tsParseInferType() {
            const i = this.startNode();
            this.expectContextual(115);
            const v = this.startNode();
            return v.name = this.tsParseTypeParameterName(), v.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), i.typeParameter = this.finishNode(v, "TSTypeParameter"), this.finishNode(i, "TSInferType");
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              const i = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
              if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return i;
            }
          }
          tsParseTypeOperatorOrHigher() {
            var i;
            return (i = this.state.type) >= 121 && i <= 123 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(i, v, O) {
            const V = this.startNode(), ne = this.eat(O), ce = [];
            do
              ce.push(v());
            while (this.eat(O));
            return ce.length !== 1 || ne ? (V.types = ce, this.finishNode(V, i)) : ce[0];
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (B(this.state.type) || this.match(78)) return this.next(), true;
            if (this.match(5)) {
              const { errors: i } = this.state, v = i.length;
              try {
                return this.parseObjectLike(8, true), i.length === v;
              } catch {
                return false;
              }
            }
            if (this.match(0)) {
              this.next();
              const { errors: i } = this.state, v = i.length;
              try {
                return super.parseBindingList(3, 93, 1), i.length === v;
              } catch {
                return false;
              }
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
          }
          tsParseTypeOrTypePredicateAnnotation(i) {
            return this.tsInType(() => {
              const v = this.startNode();
              this.expect(i);
              const O = this.startNode(), V = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (V && this.match(78)) {
                let ve = this.tsParseThisTypeOrThisTypePredicate();
                return ve.type === "TSThisType" ? (O.parameterName = ve, O.asserts = true, O.typeAnnotation = null, ve = this.finishNode(O, "TSTypePredicate")) : (this.resetStartLocationFromNode(ve, O), ve.asserts = true), v.typeAnnotation = ve, this.finishNode(v, "TSTypeAnnotation");
              }
              const ne = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!ne) return V ? (O.parameterName = this.parseIdentifier(), O.asserts = V, O.typeAnnotation = null, v.typeAnnotation = this.finishNode(O, "TSTypePredicate"), this.finishNode(v, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, v);
              const ce = this.tsParseTypeAnnotation(false);
              return O.parameterName = ne, O.typeAnnotation = ce, O.asserts = V, v.typeAnnotation = this.finishNode(O, "TSTypePredicate"), this.finishNode(v, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14)) return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            const i = this.parseIdentifier();
            if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), i;
          }
          tsParseTypePredicateAsserts() {
            if (this.state.type !== 109) return false;
            const i = this.state.containsEsc;
            return this.next(), !(!B(this.state.type) && !this.match(78)) && (i && this.raise(_.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), true);
          }
          tsParseTypeAnnotation(i = true, v = this.startNode()) {
            return this.tsInType(() => {
              i && this.expect(14), v.typeAnnotation = this.tsParseType();
            }), this.finishNode(v, "TSTypeAnnotation");
          }
          tsParseType() {
            Mt(this.state.inType);
            const i = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return i;
            const v = this.startNodeAtNode(i);
            return v.checkType = i, v.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), v.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), v.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(v, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(124) && this.lookahead().type === 77;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ct.ReservedTypeAssertion, this.state.startLoc);
            const i = this.startNode();
            return i.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), i.expression = this.parseMaybeUnary(), this.finishNode(i, "TSTypeAssertion");
          }
          tsParseHeritageClause(i) {
            const v = this.state.startLoc, O = this.tsParseDelimitedList("HeritageClauseElement", () => {
              const V = this.startNode();
              return V.expression = this.tsParseEntityName(), this.match(47) && (V.typeParameters = this.tsParseTypeArguments()), this.finishNode(V, "TSExpressionWithTypeArguments");
            });
            return O.length || this.raise(ct.EmptyHeritageClauseType, v, { token: i }), O;
          }
          tsParseInterfaceDeclaration(i, v = {}) {
            if (this.hasFollowingLineBreak()) return null;
            this.expectContextual(129), v.declare && (i.declare = true), B(this.state.type) ? (i.id = this.parseIdentifier(), this.checkIdentifier(i.id, 130)) : (i.id = null, this.raise(ct.MissingInterfaceName, this.state.startLoc)), i.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (i.extends = this.tsParseHeritageClause("extends"));
            const O = this.startNode();
            return O.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), i.body = this.finishNode(O, "TSInterfaceBody"), this.finishNode(i, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(i) {
            return i.id = this.parseIdentifier(), this.checkIdentifier(i.id, 2), i.typeAnnotation = this.tsInType(() => {
              if (i.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
                const v = this.startNode();
                return this.next(), this.finishNode(v, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(i, "TSTypeAliasDeclaration");
          }
          tsInNoContext(i) {
            const v = this.state.context;
            this.state.context = [v[0]];
            try {
              return i();
            } finally {
              this.state.context = v;
            }
          }
          tsInType(i) {
            const v = this.state.inType;
            this.state.inType = true;
            try {
              return i();
            } finally {
              this.state.inType = v;
            }
          }
          tsInDisallowConditionalTypesContext(i) {
            const v = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = true;
            try {
              return i();
            } finally {
              this.state.inDisallowConditionalTypesContext = v;
            }
          }
          tsInAllowConditionalTypesContext(i) {
            const v = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = false;
            try {
              return i();
            } finally {
              this.state.inDisallowConditionalTypesContext = v;
            }
          }
          tsEatThenParseType(i) {
            if (this.match(i)) return this.tsNextThenParseType();
          }
          tsExpectThenParseType(i) {
            return this.tsInType(() => (this.expect(i), this.tsParseType()));
          }
          tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
            const i = this.startNode();
            return i.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (i.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(i, "TSEnumMember");
          }
          tsParseEnumDeclaration(i, v = {}) {
            return v.const && (i.const = true), v.declare && (i.declare = true), this.expectContextual(126), i.id = this.parseIdentifier(), this.checkIdentifier(i.id, i.const ? 8971 : 8459), this.expect(5), i.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(i, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            const i = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(i.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(i, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(i, v = false) {
            if (i.id = this.parseIdentifier(), v || this.checkIdentifier(i.id, 1024), this.eat(16)) {
              const O = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(O, true), i.body = O;
            } else this.scope.enter(256), this.prodParam.enter(0), i.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(i, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(i) {
            return this.isContextual(112) ? (i.kind = "global", i.global = true, i.id = this.parseIdentifier()) : this.match(134) ? (i.kind = "module", i.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), i.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(i, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(i, v, O) {
            i.isExport = O || false, i.id = v || this.parseIdentifier(), this.checkIdentifier(i.id, 4096), this.expect(29);
            const V = this.tsParseModuleReference();
            return i.importKind === "type" && V.type !== "TSExternalModuleReference" && this.raise(ct.ImportAliasHasImportType, V), i.moduleReference = V, this.semicolon(), this.finishNode(i, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(119) && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            const i = this.startNode();
            return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), i.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(i, "TSExternalModuleReference");
          }
          tsLookAhead(i) {
            const v = this.state.clone(), O = i();
            return this.state = v, O;
          }
          tsTryParseAndCatch(i) {
            const v = this.tryParse((O) => i() || O());
            if (!v.aborted && v.node) return v.error && (this.state = v.failState), v.node;
          }
          tsTryParse(i) {
            const v = this.state.clone(), O = i();
            if (O !== void 0 && O !== false) return O;
            this.state = v;
          }
          tsTryParseDeclare(i) {
            if (this.isLineTerminator()) return;
            let v, O = this.state.type;
            return this.isContextual(100) && (O = 74, v = "let"), this.tsInAmbientContext(() => {
              switch (O) {
                case 68:
                  return i.declare = true, super.parseFunctionStatement(i, false, false);
                case 80:
                  return i.declare = true, this.parseClass(i, true, false);
                case 126:
                  return this.tsParseEnumDeclaration(i, { declare: true });
                case 112:
                  return this.tsParseAmbientExternalModuleDeclaration(i);
                case 75:
                case 74:
                  return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(i, { const: true, declare: true })) : (i.declare = true, this.parseVarStatement(i, v || this.state.value, true));
                case 129: {
                  const V = this.tsParseInterfaceDeclaration(i, { declare: true });
                  if (V) return V;
                }
                default:
                  if (B(O)) return this.tsParseDeclaration(i, this.state.value, true, null);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
          }
          tsParseExpressionStatement(i, v, O) {
            switch (v.name) {
              case "declare": {
                const V = this.tsTryParseDeclare(i);
                return V && (V.declare = true), V;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(256), this.prodParam.enter(0);
                  const V = i;
                  return V.kind = "global", i.global = true, V.id = v, V.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(V, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(i, v.name, false, O);
            }
          }
          tsParseDeclaration(i, v, O, V) {
            switch (v) {
              case "abstract":
                if (this.tsCheckLineTerminator(O) && (this.match(80) || B(this.state.type))) return this.tsParseAbstractDeclaration(i, V);
                break;
              case "module":
                if (this.tsCheckLineTerminator(O)) {
                  if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(i);
                  if (B(this.state.type)) return i.kind = "module", this.tsParseModuleOrNamespaceDeclaration(i);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(O) && B(this.state.type)) return i.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(i);
                break;
              case "type":
                if (this.tsCheckLineTerminator(O) && B(this.state.type)) return this.tsParseTypeAliasDeclaration(i);
            }
          }
          tsCheckLineTerminator(i) {
            return i ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(i) {
            if (!this.match(47)) return;
            const v = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const O = this.tsTryParseAndCatch(() => {
              const V = this.startNodeAt(i);
              return V.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(V), V.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), V;
            });
            return this.state.maybeInArrowParameters = v, O ? super.parseArrowExpression(O, null, true) : void 0;
          }
          tsParseTypeArgumentsInExpression() {
            if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            const i = this.startNode();
            return i.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), i.params.length === 0 ? this.raise(ct.EmptyTypeArguments, i) : this.state.inType || this.curContext() !== j.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(i, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return (i = this.state.type) >= 124 && i <= 130;
            var i;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(i, v) {
            const O = this.state.startLoc, V = {};
            this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, V);
            const ne = V.accessibility, ce = V.override, ve = V.readonly;
            4 & i || !(ne || ve || ce) || this.raise(ct.UnexpectedParameterModifier, O);
            const Ce = this.parseMaybeDefault();
            2 & i && this.parseFunctionParamType(Ce);
            const Le = this.parseMaybeDefault(Ce.loc.start, Ce);
            if (ne || ve || ce) {
              const Ke = this.startNodeAt(O);
              return v.length && (Ke.decorators = v), ne && (Ke.accessibility = ne), ve && (Ke.readonly = ve), ce && (Ke.override = ce), Le.type !== "Identifier" && Le.type !== "AssignmentPattern" && this.raise(ct.UnsupportedParameterPropertyKind, Ke), Ke.parameter = Le, this.finishNode(Ke, "TSParameterProperty");
            }
            return v.length && (Ce.decorators = v), Le;
          }
          isSimpleParameter(i) {
            return i.type === "TSParameterProperty" && super.isSimpleParameter(i.parameter) || super.isSimpleParameter(i);
          }
          tsDisallowOptionalPattern(i) {
            for (const v of i.params) v.type !== "Identifier" && v.optional && !this.state.isAmbientContext && this.raise(ct.PatternIsOptional, v);
          }
          setArrowFunctionParameters(i, v, O) {
            super.setArrowFunctionParameters(i, v, O), this.tsDisallowOptionalPattern(i);
          }
          parseFunctionBodyAndFinish(i, v, O = false) {
            this.match(14) && (i.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            const V = v === "FunctionDeclaration" ? "TSDeclareFunction" : v === "ClassMethod" || v === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
            return V && !this.match(5) && this.isLineTerminator() ? this.finishNode(i, V) : V === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(ct.DeclareFunctionHasImplementation, i), i.declare) ? super.parseFunctionBodyAndFinish(i, V, O) : (this.tsDisallowOptionalPattern(i), super.parseFunctionBodyAndFinish(i, v, O));
          }
          registerFunctionStatementId(i) {
            !i.body && i.id ? this.checkIdentifier(i.id, 1024) : super.registerFunctionStatementId(i);
          }
          tsCheckForInvalidTypeCasts(i) {
            i.forEach((v) => {
              (v == null ? void 0 : v.type) === "TSTypeCastExpression" && this.raise(ct.UnexpectedTypeAnnotation, v.typeAnnotation);
            });
          }
          toReferencedList(i, v) {
            return this.tsCheckForInvalidTypeCasts(i), i;
          }
          parseArrayLike(i, v, O, V) {
            const ne = super.parseArrayLike(i, v, O, V);
            return ne.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(ne.elements), ne;
          }
          parseSubscript(i, v, O, V) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = false, this.next();
              const ce = this.startNodeAt(v);
              return ce.expression = i, this.finishNode(ce, "TSNonNullExpression");
            }
            let ne = false;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
              if (O) return V.stop = true, i;
              V.optionalChainMember = ne = true, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let ce;
              const ve = this.tsTryParseAndCatch(() => {
                if (!O && this.atPossibleAsyncArrow(i)) {
                  const ut = this.tsTryParseGenericAsyncArrowFunction(v);
                  if (ut) return ut;
                }
                const Ce = this.tsParseTypeArgumentsInExpression();
                if (!Ce) return;
                if (ne && !this.match(10)) return void (ce = this.state.curPosition());
                if (Te(this.state.type)) {
                  const ut = super.parseTaggedTemplateExpression(i, v, V);
                  return ut.typeParameters = Ce, ut;
                }
                if (!O && this.eat(10)) {
                  const ut = this.startNodeAt(v);
                  return ut.callee = i, ut.arguments = this.parseCallExpressionArguments(11), this.tsCheckForInvalidTypeCasts(ut.arguments), ut.typeParameters = Ce, V.optionalChainMember && (ut.optional = ne), this.finishCallExpression(ut, V.optionalChainMember);
                }
                const Le = this.state.type;
                if (Le === 48 || Le === 52 || Le !== 10 && K(Le) && !this.hasPrecedingLineBreak()) return;
                const Ke = this.startNodeAt(v);
                return Ke.expression = i, Ke.typeParameters = Ce, this.finishNode(Ke, "TSInstantiationExpression");
              });
              if (ce && this.unexpected(ce, 10), ve) return ve.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(ct.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), ve;
            }
            return super.parseSubscript(i, v, O, V);
          }
          parseNewCallee(i) {
            var v;
            super.parseNewCallee(i);
            const { callee: O } = i;
            O.type !== "TSInstantiationExpression" || (v = O.extra) != null && v.parenthesized || (i.typeParameters = O.typeParameters, i.callee = O.expression);
          }
          parseExprOp(i, v, O) {
            let V;
            if (ge(58) > O && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (V = this.isContextual(120)))) {
              const ne = this.startNodeAt(v);
              return ne.expression = i, ne.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (V && this.raise(_.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(ne, V ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(ne, v, O);
            }
            return super.parseExprOp(i, v, O);
          }
          checkReservedWord(i, v, O, V) {
            this.state.isAmbientContext || super.checkReservedWord(i, v, O, V);
          }
          checkImportReflection(i) {
            super.checkImportReflection(i), i.module && i.importKind !== "value" && this.raise(ct.ImportReflectionHasImportType, i.specifiers[0].loc.start);
          }
          checkDuplicateExports() {
          }
          isPotentialImportPhase(i) {
            if (super.isPotentialImportPhase(i)) return true;
            if (this.isContextual(130)) {
              const v = this.lookaheadCharCode();
              return i ? v === 123 || v === 42 : v !== 61;
            }
            return !i && this.isContextual(87);
          }
          applyImportPhase(i, v, O, V) {
            super.applyImportPhase(i, v, O, V), v ? i.exportKind = O === "type" ? "type" : "value" : i.importKind = O === "type" || O === "typeof" ? O : "value";
          }
          parseImport(i) {
            if (this.match(134)) return i.importKind = "value", super.parseImport(i);
            let v;
            if (B(this.state.type) && this.lookaheadCharCode() === 61) return i.importKind = "value", this.tsParseImportEqualsDeclaration(i);
            if (this.isContextual(130)) {
              const O = this.parseMaybeImportPhase(i, false);
              if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(i, O);
              v = super.parseImportSpecifiersAndAfter(i, O);
            } else v = super.parseImport(i);
            return v.importKind === "type" && v.specifiers.length > 1 && v.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ct.TypeImportCannotSpecifyDefaultAndNamed, v), v;
          }
          parseExport(i, v) {
            if (this.match(83)) {
              this.next();
              const O = i;
              let V = null;
              return this.isContextual(130) && this.isPotentialImportPhase(false) ? V = this.parseMaybeImportPhase(O, false) : O.importKind = "value", this.tsParseImportEqualsDeclaration(O, V, true);
            }
            if (this.eat(29)) {
              const O = i;
              return O.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(O, "TSExportAssignment");
            }
            if (this.eatContextual(93)) {
              const O = i;
              return this.expectContextual(128), O.id = this.parseIdentifier(), this.semicolon(), this.finishNode(O, "TSNamespaceExportDeclaration");
            }
            return super.parseExport(i, v);
          }
          isAbstractClass() {
            return this.isContextual(124) && this.lookahead().type === 80;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const i = this.startNode();
              return this.next(), i.abstract = true, this.parseClass(i, true, true);
            }
            if (this.match(129)) {
              const i = this.tsParseInterfaceDeclaration(this.startNode());
              if (i) return i;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(i, v, O = false) {
            const { isAmbientContext: V } = this.state, ne = super.parseVarStatement(i, v, O || V);
            if (!V) return ne;
            for (const { id: ce, init: ve } of ne.declarations) ve && (v !== "const" || ce.typeAnnotation ? this.raise(ct.InitializerNotAllowedInAmbientContext, ve) : on(ve, this.hasPlugin("estree")) || this.raise(ct.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, ve));
            return ne;
          }
          parseStatementContent(i, v) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              const O = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(O, { const: true });
            }
            if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(129)) {
              const O = this.tsParseInterfaceDeclaration(this.startNode());
              if (O) return O;
            }
            return super.parseStatementContent(i, v);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(i, v) {
            return v.some((O) => Ot(O) ? i.accessibility === O : !!i[O]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(106) && this.lookaheadCharCode() === 123;
          }
          parseClassMember(i, v, O) {
            const V = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({ allowedModifiers: V, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: ct.InvalidModifierOnTypeParameterPositions }, v);
            const ne = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(v, V) && this.raise(ct.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(i, v)) : this.parseClassMemberWithIsStatic(i, v, O, !!v.static);
            };
            v.declare ? this.tsInAmbientContext(ne) : ne();
          }
          parseClassMemberWithIsStatic(i, v, O, V) {
            const ne = this.tsTryParseIndexSignature(v);
            if (ne) return i.body.push(ne), v.abstract && this.raise(ct.IndexSignatureHasAbstract, v), v.accessibility && this.raise(ct.IndexSignatureHasAccessibility, v, { modifier: v.accessibility }), v.declare && this.raise(ct.IndexSignatureHasDeclare, v), void (v.override && this.raise(ct.IndexSignatureHasOverride, v));
            !this.state.inAbstractClass && v.abstract && this.raise(ct.NonAbstractClassHasAbstractMethod, v), v.override && (O.hadSuperClass || this.raise(ct.OverrideNotInSubClass, v)), super.parseClassMemberWithIsStatic(i, v, O, V);
          }
          parsePostMemberNameModifiers(i) {
            this.eat(17) && (i.optional = true), i.readonly && this.match(10) && this.raise(ct.ClassMethodHasReadonly, i), i.declare && this.match(10) && this.raise(ct.ClassMethodHasDeclare, i);
          }
          parseExpressionStatement(i, v, O) {
            return (v.type === "Identifier" ? this.tsParseExpressionStatement(i, v, O) : void 0) || super.parseExpressionStatement(i, v, O);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(i, v, O) {
            if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(i, v, O);
            const V = this.tryParse(() => super.parseConditional(i, v));
            return V.node ? (V.error && (this.state = V.failState), V.node) : (V.error && super.setOptionalParametersError(O, V.error), i);
          }
          parseParenItem(i, v) {
            const O = super.parseParenItem(i, v);
            if (this.eat(17) && (O.optional = true, this.resetEndLocation(i)), this.match(14)) {
              const V = this.startNodeAt(v);
              return V.expression = i, V.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(V, "TSTypeCastExpression");
            }
            return i;
          }
          parseExportDeclaration(i) {
            if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(i));
            const v = this.state.startLoc, O = this.eatContextual(125);
            if (O && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(ct.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
            const V = B(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(i);
            return V ? ((V.type === "TSInterfaceDeclaration" || V.type === "TSTypeAliasDeclaration" || O) && (i.exportKind = "type"), O && (this.resetStartLocation(V, v), V.declare = true), V) : null;
          }
          parseClassId(i, v, O, V) {
            if ((!v || O) && this.isContextual(113)) return;
            super.parseClassId(i, v, O, i.declare ? 1024 : 8331);
            const ne = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            ne && (i.typeParameters = ne);
          }
          parseClassPropertyAnnotation(i) {
            i.optional || (this.eat(35) ? i.definite = true : this.eat(17) && (i.optional = true));
            const v = this.tsTryParseTypeAnnotation();
            v && (i.typeAnnotation = v);
          }
          parseClassProperty(i) {
            if (this.parseClassPropertyAnnotation(i), this.state.isAmbientContext && (!i.readonly || i.typeAnnotation) && this.match(29) && this.raise(ct.DeclareClassFieldHasInitializer, this.state.startLoc), i.abstract && this.match(29)) {
              const { key: v } = i;
              this.raise(ct.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: v.type !== "Identifier" || i.computed ? `[${this.input.slice(this.offsetToSourcePos(v.start), this.offsetToSourcePos(v.end))}]` : v.name });
            }
            return super.parseClassProperty(i);
          }
          parseClassPrivateProperty(i) {
            return i.abstract && this.raise(ct.PrivateElementHasAbstract, i), i.accessibility && this.raise(ct.PrivateElementHasAccessibility, i, { modifier: i.accessibility }), this.parseClassPropertyAnnotation(i), super.parseClassPrivateProperty(i);
          }
          parseClassAccessorProperty(i) {
            return this.parseClassPropertyAnnotation(i), i.optional && this.raise(ct.AccessorCannotBeOptional, i), super.parseClassAccessorProperty(i);
          }
          pushClassMethod(i, v, O, V, ne, ce) {
            const ve = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            ve && ne && this.raise(ct.ConstructorHasTypeParameters, ve);
            const { declare: Ce = false, kind: Le } = v;
            !Ce || Le !== "get" && Le !== "set" || this.raise(ct.DeclareAccessor, v, { kind: Le }), ve && (v.typeParameters = ve), super.pushClassMethod(i, v, O, V, ne, ce);
          }
          pushClassPrivateMethod(i, v, O, V) {
            const ne = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            ne && (v.typeParameters = ne), super.pushClassPrivateMethod(i, v, O, V);
          }
          declareClassPrivateMethodInScope(i, v) {
            i.type !== "TSDeclareMethod" && (i.type !== "MethodDefinition" || hasOwnProperty.call(i.value, "body")) && super.declareClassPrivateMethodInScope(i, v);
          }
          parseClassSuper(i) {
            super.parseClassSuper(i), i.superClass && (this.match(47) || this.match(51)) && (i.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (i.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(i, v, O, V, ne, ce, ve) {
            const Ce = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return Ce && (i.typeParameters = Ce), super.parseObjPropValue(i, v, O, V, ne, ce, ve);
          }
          parseFunctionParams(i, v) {
            const O = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            O && (i.typeParameters = O), super.parseFunctionParams(i, v);
          }
          parseVarId(i, v) {
            super.parseVarId(i, v), i.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (i.definite = true);
            const O = this.tsTryParseTypeAnnotation();
            O && (i.id.typeAnnotation = O, this.resetEndLocation(i.id));
          }
          parseAsyncArrowFromCallExpression(i, v) {
            return this.match(14) && (i.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(i, v);
          }
          parseMaybeAssign(i, v) {
            var O, V, ne, ce, ve;
            let Ce, Le, Ke, ut;
            if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
              if (Ce = this.state.clone(), Le = this.tryParse(() => super.parseMaybeAssign(i, v), Ce), !Le.error) return Le.node;
              const { context: bt } = this.state, Nt = bt[bt.length - 1];
              Nt !== j.j_oTag && Nt !== j.j_expr || bt.pop();
            }
            if (!((O = Le) != null && O.error || this.match(47))) return super.parseMaybeAssign(i, v);
            Ce && Ce !== this.state || (Ce = this.state.clone());
            const At = this.tryParse((bt) => {
              var Nt, dn;
              ut = this.tsParseTypeParameters(this.tsParseConstModifier);
              const kn = super.parseMaybeAssign(i, v);
              return (kn.type !== "ArrowFunctionExpression" || (Nt = kn.extra) != null && Nt.parenthesized) && bt(), ((dn = ut) == null ? void 0 : dn.params.length) !== 0 && this.resetStartLocationFromNode(kn, ut), kn.typeParameters = ut, kn;
            }, Ce);
            if (!At.error && !At.aborted) return ut && this.reportReservedArrowTypeParam(ut), At.node;
            if (!Le && (Mt(!this.hasPlugin("jsx")), Ke = this.tryParse(() => super.parseMaybeAssign(i, v), Ce), !Ke.error)) return Ke.node;
            if ((V = Le) != null && V.node) return this.state = Le.failState, Le.node;
            if (At.node) return this.state = At.failState, ut && this.reportReservedArrowTypeParam(ut), At.node;
            if ((ne = Ke) != null && ne.node) return this.state = Ke.failState, Ke.node;
            throw ((ce = Le) == null ? void 0 : ce.error) || At.error || ((ve = Ke) == null ? void 0 : ve.error);
          }
          reportReservedArrowTypeParam(i) {
            var v;
            i.params.length !== 1 || i.params[0].constraint || (v = i.extra) != null && v.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(ct.ReservedArrowTypeParam, i);
          }
          parseMaybeUnary(i, v) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(i, v);
          }
          parseArrow(i) {
            if (this.match(14)) {
              const v = this.tryParse((O) => {
                const V = this.tsParseTypeOrTypePredicateAnnotation(14);
                return !this.canInsertSemicolon() && this.match(19) || O(), V;
              });
              if (v.aborted) return;
              v.thrown || (v.error && (this.state = v.failState), i.returnType = v.node);
            }
            return super.parseArrow(i);
          }
          parseFunctionParamType(i) {
            this.eat(17) && (i.optional = true);
            const v = this.tsTryParseTypeAnnotation();
            return v && (i.typeAnnotation = v), this.resetEndLocation(i), i;
          }
          isAssignable(i, v) {
            switch (i.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(i.expression, v);
              case "TSParameterProperty":
                return true;
              default:
                return super.isAssignable(i, v);
            }
          }
          toAssignable(i, v = false) {
            switch (i.type) {
              case "ParenthesizedExpression":
                this.toAssignableParenthesizedExpression(i, v);
                break;
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                v ? this.expressionScope.recordArrowParameterBindingError(ct.UnexpectedTypeCastInParameter, i) : this.raise(ct.UnexpectedTypeCastInParameter, i), this.toAssignable(i.expression, v);
                break;
              case "AssignmentExpression":
                v || i.left.type !== "TSTypeCastExpression" || (i.left = this.typeCastToParameter(i.left));
              default:
                super.toAssignable(i, v);
            }
          }
          toAssignableParenthesizedExpression(i, v) {
            switch (i.expression.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                this.toAssignable(i.expression, v);
                break;
              default:
                super.toAssignable(i, v);
            }
          }
          checkToRestConversion(i, v) {
            switch (i.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
              case "TSNonNullExpression":
                this.checkToRestConversion(i.expression, false);
                break;
              default:
                super.checkToRestConversion(i, v);
            }
          }
          isValidLVal(i, v, O) {
            switch (i) {
              case "TSTypeCastExpression":
                return true;
              case "TSParameterProperty":
                return "parameter";
              case "TSNonNullExpression":
              case "TSInstantiationExpression":
                return "expression";
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
                return (O !== 64 || !v) && ["expression", true];
              default:
                return super.isValidLVal(i, v, O);
            }
          }
          parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(i) {
            if (this.match(47) || this.match(51)) {
              const v = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                const O = super.parseMaybeDecoratorArguments(i);
                return O.typeParameters = v, O;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(i);
          }
          checkCommaAfterRest(i) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === i ? (this.next(), false) : super.checkCommaAfterRest(i);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(i, v) {
            const O = super.parseMaybeDefault(i, v);
            return O.type === "AssignmentPattern" && O.typeAnnotation && O.right.start < O.typeAnnotation.start && this.raise(ct.TypeAnnotationAfterAssign, O.typeAnnotation), O;
          }
          getTokenFromCode(i) {
            if (this.state.inType) {
              if (i === 62) return void this.finishOp(48, 1);
              if (i === 60) return void this.finishOp(47, 1);
            }
            super.getTokenFromCode(i);
          }
          reScan_lt_gt() {
            const { type: i } = this.state;
            i === 47 ? (this.state.pos -= 1, this.readToken_lt()) : i === 48 && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            const { type: i } = this.state;
            return i === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : i;
          }
          toAssignableList(i, v, O) {
            for (let V = 0; V < i.length; V++) {
              const ne = i[V];
              (ne == null ? void 0 : ne.type) === "TSTypeCastExpression" && (i[V] = this.typeCastToParameter(ne));
            }
            super.toAssignableList(i, v, O);
          }
          typeCastToParameter(i) {
            return i.expression.typeAnnotation = i.typeAnnotation, this.resetEndLocation(i.expression, i.typeAnnotation.loc.end), i.expression;
          }
          shouldParseArrow(i) {
            return this.match(14) ? i.every((v) => this.isAssignable(v, true)) : super.shouldParseArrow(i);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(i) {
            if (this.match(47) || this.match(51)) {
              const v = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
              v && (i.typeParameters = v);
            }
            return super.jsxParseOpeningElementAfterName(i);
          }
          getGetterSetterExpectedParamCount(i) {
            const v = super.getGetterSetterExpectedParamCount(i), O = this.getObjectOrClassMethodParams(i)[0];
            return O && this.isThisParam(O) ? v + 1 : v;
          }
          parseCatchClauseParam() {
            const i = super.parseCatchClauseParam(), v = this.tsTryParseTypeAnnotation();
            return v && (i.typeAnnotation = v, this.resetEndLocation(i)), i;
          }
          tsInAmbientContext(i) {
            const { isAmbientContext: v, strict: O } = this.state;
            this.state.isAmbientContext = true, this.state.strict = false;
            try {
              return i();
            } finally {
              this.state.isAmbientContext = v, this.state.strict = O;
            }
          }
          parseClass(i, v, O) {
            const V = this.state.inAbstractClass;
            this.state.inAbstractClass = !!i.abstract;
            try {
              return super.parseClass(i, v, O);
            } finally {
              this.state.inAbstractClass = V;
            }
          }
          tsParseAbstractDeclaration(i, v) {
            if (this.match(80)) return i.abstract = true, this.maybeTakeDecorators(v, this.parseClass(i, true, false));
            if (this.isContextual(129)) {
              if (!this.hasFollowingLineBreak()) return i.abstract = true, this.raise(ct.NonClassMethodPropertyHasAbstractModifer, i), this.tsParseInterfaceDeclaration(i);
            } else this.unexpected(null, 80);
          }
          parseMethod(i, v, O, V, ne, ce, ve) {
            const Ce = super.parseMethod(i, v, O, V, ne, ce, ve);
            if (Ce.abstract && (this.hasPlugin("estree") ? Ce.value.body : Ce.body)) {
              const { key: Le } = Ce;
              this.raise(ct.AbstractMethodHasImplementation, Ce, { methodName: Le.type !== "Identifier" || Ce.computed ? `[${this.input.slice(this.offsetToSourcePos(Le.start), this.offsetToSourcePos(Le.end))}]` : Le.name });
            }
            return Ce;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
          parseExportSpecifier(i, v, O, V) {
            return !v && V ? (this.parseTypeOnlyImportExportSpecifier(i, false, O), this.finishNode(i, "ExportSpecifier")) : (i.exportKind = "value", super.parseExportSpecifier(i, v, O, V));
          }
          parseImportSpecifier(i, v, O, V, ne) {
            return !v && V ? (this.parseTypeOnlyImportExportSpecifier(i, true, O), this.finishNode(i, "ImportSpecifier")) : (i.importKind = "value", super.parseImportSpecifier(i, v, O, V, O ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(i, v, O) {
            const V = v ? "imported" : "local", ne = v ? "local" : "exported";
            let ce, ve = i[V], Ce = false, Le = true;
            const Ke = ve.loc.start;
            if (this.isContextual(93)) {
              const ut = this.parseIdentifier();
              if (this.isContextual(93)) {
                const At = this.parseIdentifier();
                z(this.state.type) ? (Ce = true, ve = ut, ce = v ? this.parseIdentifier() : this.parseModuleExportName(), Le = false) : (ce = At, Le = false);
              } else z(this.state.type) ? (Le = false, ce = v ? this.parseIdentifier() : this.parseModuleExportName()) : (Ce = true, ve = ut);
            } else z(this.state.type) && (Ce = true, v ? (ve = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(ve.name, ve.loc.start, true, true)) : ve = this.parseModuleExportName());
            Ce && O && this.raise(v ? ct.TypeModifierIsUsedInTypeImports : ct.TypeModifierIsUsedInTypeExports, Ke), i[V] = ve, i[ne] = ce, i[v ? "importKind" : "exportKind"] = Ce ? "type" : "value", Le && this.eatContextual(93) && (i[ne] = v ? this.parseIdentifier() : this.parseModuleExportName()), i[ne] || (i[ne] = zn(i[V])), v && this.checkIdentifier(i[ne], Ce ? 4098 : 4096);
          }
        }, v8intrinsic: (de) => class extends de {
          parseV8Intrinsic() {
            if (this.match(54)) {
              const i = this.state.startLoc, v = this.startNode();
              if (this.next(), B(this.state.type)) {
                const O = this.parseIdentifierName(), V = this.createIdentifier(v, O);
                if (V.type = "V8IntrinsicIdentifier", this.match(10)) return V;
              }
              this.unexpected(i);
            }
          }
          parseExprAtom(i) {
            return this.parseV8Intrinsic() || super.parseExprAtom(i);
          }
        }, placeholders: (de) => class extends de {
          parsePlaceholder(i) {
            if (this.match(133)) {
              const v = this.startNode();
              return this.next(), this.assertNoSpace(), v.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(v, i);
            }
          }
          finishPlaceholder(i, v) {
            let O = i;
            return O.expectedNode && O.type || (O = this.finishNode(O, "Placeholder")), O.expectedNode = v, O;
          }
          getTokenFromCode(i) {
            i === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(i);
          }
          parseExprAtom(i) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(i);
          }
          parseIdentifier(i) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(i);
          }
          checkReservedWord(i, v, O, V) {
            i !== void 0 && super.checkReservedWord(i, v, O, V);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(i, v, O) {
            return i === "Placeholder" || super.isValidLVal(i, v, O);
          }
          toAssignable(i, v) {
            i && i.type === "Placeholder" && i.expectedNode === "Expression" ? i.expectedNode = "Pattern" : super.toAssignable(i, v);
          }
          chStartsBindingIdentifier(i, v) {
            return super.chStartsBindingIdentifier(i, v) ? true : this.lookahead().type === 133;
          }
          verifyBreakContinue(i, v) {
            i.label && i.label.type === "Placeholder" || super.verifyBreakContinue(i, v);
          }
          parseExpressionStatement(i, v) {
            var O;
            if (v.type !== "Placeholder" || (O = v.extra) != null && O.parenthesized) return super.parseExpressionStatement(i, v);
            if (this.match(14)) {
              const ne = i;
              return ne.label = this.finishPlaceholder(v, "Identifier"), this.next(), ne.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(ne, "LabeledStatement");
            }
            this.semicolon();
            const V = i;
            return V.name = v.name, this.finishPlaceholder(V, "Statement");
          }
          parseBlock(i, v, O) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(i, v, O);
          }
          parseFunctionId(i) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(i);
          }
          parseClass(i, v, O) {
            const V = v ? "ClassDeclaration" : "ClassExpression";
            this.next();
            const ne = this.state.strict, ce = this.parsePlaceholder("Identifier");
            if (ce) {
              if (!(this.match(81) || this.match(133) || this.match(5))) {
                if (O || !v) return i.id = null, i.body = this.finishPlaceholder(ce, "ClassBody"), this.finishNode(i, V);
                throw this.raise(Un.ClassNameIsRequired, this.state.startLoc);
              }
              i.id = ce;
            } else this.parseClassId(i, v, O);
            return super.parseClassSuper(i), i.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!i.superClass, ne), this.finishNode(i, V);
          }
          parseExport(i, v) {
            const O = this.parsePlaceholder("Identifier");
            if (!O) return super.parseExport(i, v);
            const V = i;
            if (!this.isContextual(98) && !this.match(12)) return V.specifiers = [], V.source = null, V.declaration = this.finishPlaceholder(O, "Declaration"), this.finishNode(V, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const ne = this.startNode();
            return ne.exported = O, V.specifiers = [this.finishNode(ne, "ExportDefaultSpecifier")], super.parseExport(V, v);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              const i = this.nextTokenStart();
              if (this.isUnparsedContextual(i, "from") && this.input.startsWith(ue(133), this.nextTokenStartSince(i + 4))) return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(i, v) {
            var O;
            return !((O = i.specifiers) == null || !O.length) || super.maybeParseExportDefaultSpecifier(i, v);
          }
          checkExport(i) {
            const { specifiers: v } = i;
            v != null && v.length && (i.specifiers = v.filter((O) => O.exported.type === "Placeholder")), super.checkExport(i), i.specifiers = v;
          }
          parseImport(i) {
            const v = this.parsePlaceholder("Identifier");
            if (!v) return super.parseImport(i);
            if (i.specifiers = [], !this.isContextual(98) && !this.match(12)) return i.source = this.finishPlaceholder(v, "StringLiteral"), this.semicolon(), this.finishNode(i, "ImportDeclaration");
            const O = this.startNodeAtNode(v);
            return O.local = v, i.specifiers.push(this.finishNode(O, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(i) || this.parseNamedImportSpecifiers(i)), this.expectContextual(98), i.source = this.parseImportSource(), this.semicolon(), this.finishNode(i, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(Un.UnexpectedSpace, this.state.lastTokEndLoc);
          }
        } }, pr = Object.keys(Vn);
        class es extends Ct {
          checkProto(i, v, O, V) {
            if (i.type === "SpreadElement" || this.isObjectMethod(i) || i.computed || i.shorthand) return;
            const ne = i.key;
            if ((ne.type === "Identifier" ? ne.name : ne.value) === "__proto__") {
              if (v) return void this.raise(_.RecordNoProto, ne);
              O.used && (V ? V.doubleProtoLoc === null && (V.doubleProtoLoc = ne.loc.start) : this.raise(_.DuplicateProto, ne)), O.used = true;
            }
          }
          shouldExitDescending(i, v) {
            return i.type === "ArrowFunctionExpression" && this.offsetToSourcePos(i.start) === v;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            const i = this.parseExpression();
            return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), i.comments = this.comments, i.errors = this.state.errors, this.options.tokens && (i.tokens = this.tokens), i;
          }
          parseExpression(i, v) {
            return i ? this.disallowInAnd(() => this.parseExpressionBase(v)) : this.allowInAnd(() => this.parseExpressionBase(v));
          }
          parseExpressionBase(i) {
            const v = this.state.startLoc, O = this.parseMaybeAssign(i);
            if (this.match(12)) {
              const V = this.startNodeAt(v);
              for (V.expressions = [O]; this.eat(12); ) V.expressions.push(this.parseMaybeAssign(i));
              return this.toReferencedList(V.expressions), this.finishNode(V, "SequenceExpression");
            }
            return O;
          }
          parseMaybeAssignDisallowIn(i, v) {
            return this.disallowInAnd(() => this.parseMaybeAssign(i, v));
          }
          parseMaybeAssignAllowIn(i, v) {
            return this.allowInAnd(() => this.parseMaybeAssign(i, v));
          }
          setOptionalParametersError(i, v) {
            var O;
            i.optionalParametersLoc = (O = v == null ? void 0 : v.loc) != null ? O : this.state.startLoc;
          }
          parseMaybeAssign(i, v) {
            const O = this.state.startLoc;
            if (this.isContextual(108) && this.prodParam.hasYield) {
              let Ce = this.parseYield();
              return v && (Ce = v.call(this, Ce, O)), Ce;
            }
            let V;
            i ? V = false : (i = new gn(), V = true);
            const { type: ne } = this.state;
            (ne === 10 || B(ne)) && (this.state.potentialArrowAt = this.state.start);
            let ce = this.parseMaybeConditional(i);
            if (v && (ce = v.call(this, ce, O)), (ve = this.state.type) >= 29 && ve <= 33) {
              const Ce = this.startNodeAt(O), Le = this.state.value;
              if (Ce.operator = Le, this.match(29)) {
                this.toAssignable(ce, true), Ce.left = ce;
                const Ke = O.index;
                i.doubleProtoLoc != null && i.doubleProtoLoc.index >= Ke && (i.doubleProtoLoc = null), i.shorthandAssignLoc != null && i.shorthandAssignLoc.index >= Ke && (i.shorthandAssignLoc = null), i.privateKeyLoc != null && i.privateKeyLoc.index >= Ke && (this.checkDestructuringPrivate(i), i.privateKeyLoc = null);
              } else Ce.left = ce;
              return this.next(), Ce.right = this.parseMaybeAssign(), this.checkLVal(ce, this.finishNode(Ce, "AssignmentExpression")), Ce;
            }
            var ve;
            return V && this.checkExpressionErrors(i, true), ce;
          }
          parseMaybeConditional(i) {
            const v = this.state.startLoc, O = this.state.potentialArrowAt, V = this.parseExprOps(i);
            return this.shouldExitDescending(V, O) ? V : this.parseConditional(V, v, i);
          }
          parseConditional(i, v, O) {
            if (this.eat(17)) {
              const V = this.startNodeAt(v);
              return V.test = i, V.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), V.alternate = this.parseMaybeAssign(), this.finishNode(V, "ConditionalExpression");
            }
            return i;
          }
          parseMaybeUnaryOrPrivate(i) {
            return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(i);
          }
          parseExprOps(i) {
            const v = this.state.startLoc, O = this.state.potentialArrowAt, V = this.parseMaybeUnaryOrPrivate(i);
            return this.shouldExitDescending(V, O) ? V : this.parseExprOp(V, v, -1);
          }
          parseExprOp(i, v, O) {
            if (this.isPrivateName(i)) {
              const ce = this.getPrivateNameSV(i);
              (O >= ge(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(_.PrivateInExpectedIn, i, { identifierName: ce }), this.classScope.usePrivateName(ce, i.loc.start);
            }
            const V = this.state.type;
            if ((ne = V) >= 39 && ne <= 59 && (this.prodParam.hasIn || !this.match(58))) {
              let ce = ge(V);
              if (ce > O) {
                if (V === 39) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return i;
                  this.checkPipelineAtInfixOperator(i, v);
                }
                const ve = this.startNodeAt(v);
                ve.left = i, ve.operator = this.state.value;
                const Ce = V === 41 || V === 42, Le = V === 40;
                if (Le && (ce = ge(42)), this.next(), V === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait) throw this.raise(_.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                ve.right = this.parseExprOpRightExpr(V, ce);
                const Ke = this.finishNode(ve, Ce || Le ? "LogicalExpression" : "BinaryExpression"), ut = this.state.type;
                if (Le && (ut === 41 || ut === 42) || Ce && ut === 40) throw this.raise(_.MixingCoalesceWithLogical, this.state.startLoc);
                return this.parseExprOp(Ke, v, O);
              }
            }
            var ne;
            return i;
          }
          parseExprOpRightExpr(i, v) {
            const O = this.state.startLoc;
            if (i === 39) switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => this.parseHackPipeBody());
              case "smart":
                return this.withTopicBindingContext(() => {
                  if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(_.PipeBodyIsTighter, this.state.startLoc);
                  return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(i, v), O);
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(v));
            }
            return this.parseExprOpBaseRightExpr(i, v);
          }
          parseExprOpBaseRightExpr(i, v) {
            const O = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), O, i === 57 ? v - 1 : v);
          }
          parseHackPipeBody() {
            var i;
            const { startLoc: v } = this.state, O = this.parseMaybeAssign();
            return !T.has(O.type) || (i = O.extra) != null && i.parenthesized || this.raise(_.PipeUnparenthesizedBody, v, { type: O.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(_.PipeTopicUnused, v), O;
          }
          checkExponentialAfterUnary(i) {
            this.match(57) && this.raise(_.UnexpectedTokenUnaryExponentiation, i.argument);
          }
          parseMaybeUnary(i, v) {
            const O = this.state.startLoc, V = this.isContextual(96);
            if (V && this.recordAwaitIfAllowed()) {
              this.next();
              const Le = this.parseAwait(O);
              return v || this.checkExponentialAfterUnary(Le), Le;
            }
            const ne = this.match(34), ce = this.startNode();
            if (ve = this.state.type, re[ve]) {
              ce.operator = this.state.value, ce.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
              const Le = this.match(89);
              if (this.next(), ce.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(i, true), this.state.strict && Le) {
                const Ke = ce.argument;
                Ke.type === "Identifier" ? this.raise(_.StrictDelete, ce) : this.hasPropertyAsPrivateName(Ke) && this.raise(_.DeletePrivateField, ce);
              }
              if (!ne) return v || this.checkExponentialAfterUnary(ce), this.finishNode(ce, "UnaryExpression");
            }
            var ve;
            const Ce = this.parseUpdate(ce, ne, i);
            if (V) {
              const { type: Le } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? K(Le) : K(Le) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(_.AwaitNotInAsyncContext, O), this.parseAwait(O);
            }
            return Ce;
          }
          parseUpdate(i, v, O) {
            if (v) {
              const ce = i;
              return this.checkLVal(ce.argument, this.finishNode(ce, "UpdateExpression")), i;
            }
            const V = this.state.startLoc;
            let ne = this.parseExprSubscripts(O);
            if (this.checkExpressionErrors(O, false)) return ne;
            for (; this.state.type === 34 && !this.canInsertSemicolon(); ) {
              const ce = this.startNodeAt(V);
              ce.operator = this.state.value, ce.prefix = false, ce.argument = ne, this.next(), this.checkLVal(ne, ne = this.finishNode(ce, "UpdateExpression"));
            }
            return ne;
          }
          parseExprSubscripts(i) {
            const v = this.state.startLoc, O = this.state.potentialArrowAt, V = this.parseExprAtom(i);
            return this.shouldExitDescending(V, O) ? V : this.parseSubscripts(V, v);
          }
          parseSubscripts(i, v, O) {
            const V = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(i), stop: false };
            do
              i = this.parseSubscript(i, v, O, V), V.maybeAsyncArrow = false;
            while (!V.stop);
            return i;
          }
          parseSubscript(i, v, O, V) {
            const { type: ne } = this.state;
            if (!O && ne === 15) return this.parseBind(i, v, O, V);
            if (Te(ne)) return this.parseTaggedTemplateExpression(i, v, V);
            let ce = false;
            if (ne === 18) {
              if (O && (this.raise(_.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40)) return V.stop = true, i;
              V.optionalChainMember = ce = true, this.next();
            }
            if (!O && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(i, v, V, ce);
            {
              const ve = this.eat(0);
              return ve || ce || this.eat(16) ? this.parseMember(i, v, V, ve, ce) : (V.stop = true, i);
            }
          }
          parseMember(i, v, O, V, ne) {
            const ce = this.startNodeAt(v);
            return ce.object = i, ce.computed = V, V ? (ce.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (i.type === "Super" && this.raise(_.SuperPrivateField, v), this.classScope.usePrivateName(this.state.value, this.state.startLoc), ce.property = this.parsePrivateName()) : ce.property = this.parseIdentifier(true), O.optionalChainMember ? (ce.optional = ne, this.finishNode(ce, "OptionalMemberExpression")) : this.finishNode(ce, "MemberExpression");
          }
          parseBind(i, v, O, V) {
            const ne = this.startNodeAt(v);
            return ne.object = i, this.next(), ne.callee = this.parseNoCallExpr(), V.stop = true, this.parseSubscripts(this.finishNode(ne, "BindExpression"), v, O);
          }
          parseCoverCallAndAsyncArrowHead(i, v, O, V) {
            const ne = this.state.maybeInArrowParameters;
            let ce = null;
            this.state.maybeInArrowParameters = true, this.next();
            const ve = this.startNodeAt(v);
            ve.callee = i;
            const { maybeAsyncArrow: Ce, optionalChainMember: Le } = O;
            Ce && (this.expressionScope.enter(new sr(2)), ce = new gn()), Le && (ve.optional = V), ve.arguments = V ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, i.type !== "Super", ve, ce);
            let Ke = this.finishCallExpression(ve, Le);
            return Ce && this.shouldParseAsyncArrow() && !V ? (O.stop = true, this.checkDestructuringPrivate(ce), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), Ke = this.parseAsyncArrowFromCallExpression(this.startNodeAt(v), Ke)) : (Ce && (this.checkExpressionErrors(ce, true), this.expressionScope.exit()), this.toReferencedArguments(Ke)), this.state.maybeInArrowParameters = ne, Ke;
          }
          toReferencedArguments(i, v) {
            this.toReferencedListDeep(i.arguments, v);
          }
          parseTaggedTemplateExpression(i, v, O) {
            const V = this.startNodeAt(v);
            return V.tag = i, V.quasi = this.parseTemplate(true), O.optionalChainMember && this.raise(_.OptionalChainingNoTemplate, v), this.finishNode(V, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(i) {
            return i.type === "Identifier" && i.name === "async" && this.state.lastTokEndLoc.index === i.end && !this.canInsertSemicolon() && i.end - i.start == 5 && this.offsetToSourcePos(i.start) === this.state.potentialArrowAt;
          }
          finishCallExpression(i, v) {
            if (i.callee.type === "Import") if (i.arguments.length === 0 || i.arguments.length > 2) this.raise(_.ImportCallArity, i);
            else for (const O of i.arguments) O.type === "SpreadElement" && this.raise(_.ImportCallSpreadArgument, O);
            return this.finishNode(i, v ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(i, v, O, V) {
            const ne = [];
            let ce = true;
            const ve = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(i); ) {
              if (ce) ce = false;
              else if (this.expect(12), this.match(i)) {
                O && this.addTrailingCommaExtraToNode(O), this.next();
                break;
              }
              ne.push(this.parseExprListItem(false, V, v));
            }
            return this.state.inFSharpPipelineDirectBody = ve, ne;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(i, v) {
            var O;
            return this.resetPreviousNodeTrailingComments(v), this.expect(19), this.parseArrowExpression(i, v.arguments, true, (O = v.extra) == null ? void 0 : O.trailingCommaLoc), v.innerComments && be(i, v.innerComments), v.callee.trailingComments && be(i, v.callee.trailingComments), i;
          }
          parseNoCallExpr() {
            const i = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), i, true);
          }
          parseExprAtom(i) {
            let v, O = null;
            const { type: V } = this.state;
            switch (V) {
              case 79:
                return this.parseSuper();
              case 83:
                return v = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(v) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(v) : this.finishNode(v, "Import") : (this.raise(_.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(v, "Import"));
              case 78:
                return v = this.startNode(), this.next(), this.finishNode(v, "ThisExpression");
              case 90:
                return this.parseDo(this.startNode(), false);
              case 56:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 135:
                return this.parseNumericLiteral(this.state.value);
              case 136:
                return this.parseBigIntLiteral(this.state.value);
              case 134:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(true);
              case 86:
                return this.parseBooleanLiteral(false);
              case 10: {
                const ne = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(ne);
              }
              case 2:
              case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
              case 0:
                return this.parseArrayLike(3, true, false, i);
              case 6:
              case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
              case 5:
                return this.parseObjectLike(8, false, false, i);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                O = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(O, this.startNode()), false);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(false);
              case 15: {
                v = this.startNode(), this.next(), v.object = null;
                const ne = v.callee = this.parseNoCallExpr();
                if (ne.type === "MemberExpression") return this.finishNode(v, "BindExpression");
                throw this.raise(_.UnsupportedBind, ne);
              }
              case 139:
                return this.raise(_.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27: {
                const ne = this.getPluginOption("pipelineOperator", "proposal");
                if (ne) return this.parseTopicReference(ne);
                this.unexpected();
                break;
              }
              case 47: {
                const ne = this.input.codePointAt(this.nextTokenStart());
                J(ne) || ne === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                break;
              }
              default:
                if (V === 137) return this.parseDecimalLiteral(this.state.value);
                if (B(V)) {
                  if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
                  const ne = this.state.potentialArrowAt === this.state.start, ce = this.state.containsEsc, ve = this.parseIdentifier();
                  if (!ce && ve.name === "async" && !this.canInsertSemicolon()) {
                    const { type: Ce } = this.state;
                    if (Ce === 68) return this.resetPreviousNodeTrailingComments(ve), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(ve));
                    if (B(Ce)) return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(ve)) : ve;
                    if (Ce === 90) return this.resetPreviousNodeTrailingComments(ve), this.parseDo(this.startNodeAtNode(ve), true);
                  }
                  return ne && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(ve), [ve], false)) : ve;
                }
                this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(i, v) {
            const O = this.getPluginOption("pipelineOperator", "proposal");
            if (O) return this.state.type = i, this.state.value = v, this.state.pos--, this.state.end--, this.state.endLoc = c(this.state.endLoc, -1), this.parseTopicReference(O);
            this.unexpected();
          }
          parseTopicReference(i) {
            const v = this.startNode(), O = this.state.startLoc, V = this.state.type;
            return this.next(), this.finishTopicReference(v, O, i, V);
          }
          finishTopicReference(i, v, O, V) {
            if (this.testTopicReferenceConfiguration(O, v, V)) {
              const ne = O === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
              return this.topicReferenceIsAllowedInCurrentContext() || this.raise(O === "smart" ? _.PrimaryTopicNotAllowed : _.PipeTopicUnbound, v), this.registerTopicReference(), this.finishNode(i, ne);
            }
            throw this.raise(_.PipeTopicUnconfiguredToken, v, { token: ue(V) });
          }
          testTopicReferenceConfiguration(i, v, O) {
            switch (i) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: ue(O) }]);
              case "smart":
                return O === 27;
              default:
                throw this.raise(_.PipeTopicRequiresHackPipes, v);
            }
          }
          parseAsyncArrowUnaryFunction(i) {
            this.prodParam.enter(Zn(true, this.prodParam.hasYield));
            const v = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(_.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(i, v, true);
          }
          parseDo(i, v) {
            this.expectPlugin("doExpressions"), v && this.expectPlugin("asyncDoExpressions"), i.async = v, this.next();
            const O = this.state.labels;
            return this.state.labels = [], v ? (this.prodParam.enter(2), i.body = this.parseBlock(), this.prodParam.exit()) : i.body = this.parseBlock(), this.state.labels = O, this.finishNode(i, "DoExpression");
          }
          parseSuper() {
            const i = this.startNode();
            return this.next(), !this.match(10) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(_.UnexpectedSuper, i) : this.raise(_.SuperNotAllowed, i), this.match(10) || this.match(0) || this.match(16) || this.raise(_.UnsupportedSuper, i), this.finishNode(i, "Super");
          }
          parsePrivateName() {
            const i = this.startNode(), v = this.startNodeAt(c(this.state.startLoc, 1)), O = this.state.value;
            return this.next(), i.id = this.createIdentifier(v, O), this.finishNode(i, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            const i = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              const v = this.createIdentifier(this.startNodeAtNode(i), "function");
              return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(i, v, "sent");
            }
            return this.parseFunction(i);
          }
          parseMetaProperty(i, v, O) {
            i.meta = v;
            const V = this.state.containsEsc;
            return i.property = this.parseIdentifier(true), (i.property.name !== O || V) && this.raise(_.UnsupportedMetaProperty, i.property, { target: v.name, onlyValidPropertyName: O }), this.finishNode(i, "MetaProperty");
          }
          parseImportMetaProperty(i) {
            const v = this.createIdentifier(this.startNodeAtNode(i), "import");
            if (this.next(), this.isContextual(101)) this.inModule || this.raise(_.ImportMetaOutsideModule, v), this.sawUnambiguousESM = true;
            else if (this.isContextual(105) || this.isContextual(97)) {
              const O = this.isContextual(105);
              if (O || this.unexpected(), this.expectPlugin(O ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions) throw this.raise(_.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
              return this.next(), i.phase = O ? "source" : "defer", this.parseImportCall(i);
            }
            return this.parseMetaProperty(i, v, "meta");
          }
          parseLiteralAtNode(i, v, O) {
            return this.addExtra(O, "rawValue", i), this.addExtra(O, "raw", this.input.slice(this.offsetToSourcePos(O.start), this.state.end)), O.value = i, this.next(), this.finishNode(O, v);
          }
          parseLiteral(i, v) {
            const O = this.startNode();
            return this.parseLiteralAtNode(i, v, O);
          }
          parseStringLiteral(i) {
            return this.parseLiteral(i, "StringLiteral");
          }
          parseNumericLiteral(i) {
            return this.parseLiteral(i, "NumericLiteral");
          }
          parseBigIntLiteral(i) {
            return this.parseLiteral(i, "BigIntLiteral");
          }
          parseDecimalLiteral(i) {
            return this.parseLiteral(i, "DecimalLiteral");
          }
          parseRegExpLiteral(i) {
            const v = this.startNode();
            return this.addExtra(v, "raw", this.input.slice(this.offsetToSourcePos(v.start), this.state.end)), v.pattern = i.pattern, v.flags = i.flags, this.next(), this.finishNode(v, "RegExpLiteral");
          }
          parseBooleanLiteral(i) {
            const v = this.startNode();
            return v.value = i, this.next(), this.finishNode(v, "BooleanLiteral");
          }
          parseNullLiteral() {
            const i = this.startNode();
            return this.next(), this.finishNode(i, "NullLiteral");
          }
          parseParenAndDistinguishExpression(i) {
            const v = this.state.startLoc;
            let O;
            this.next(), this.expressionScope.enter(new sr(1));
            const V = this.state.maybeInArrowParameters, ne = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
            const ce = this.state.startLoc, ve = [], Ce = new gn();
            let Le, Ke, ut = true;
            for (; !this.match(11); ) {
              if (ut) ut = false;
              else if (this.expect(12, Ce.optionalParametersLoc === null ? null : Ce.optionalParametersLoc), this.match(11)) {
                Ke = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                const Nt = this.state.startLoc;
                if (Le = this.state.startLoc, ve.push(this.parseParenItem(this.parseRestBinding(), Nt)), !this.checkCommaAfterRest(41)) break;
              } else ve.push(this.parseMaybeAssignAllowIn(Ce, this.parseParenItem));
            }
            const At = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = V, this.state.inFSharpPipelineDirectBody = ne;
            let bt = this.startNodeAt(v);
            return i && this.shouldParseArrow(ve) && (bt = this.parseArrow(bt)) ? (this.checkDestructuringPrivate(Ce), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(bt, ve, false), bt) : (this.expressionScope.exit(), ve.length || this.unexpected(this.state.lastTokStartLoc), Ke && this.unexpected(Ke), Le && this.unexpected(Le), this.checkExpressionErrors(Ce, true), this.toReferencedListDeep(ve, true), ve.length > 1 ? (O = this.startNodeAt(ce), O.expressions = ve, this.finishNode(O, "SequenceExpression"), this.resetEndLocation(O, At)) : O = ve[0], this.wrapParenthesis(v, O));
          }
          wrapParenthesis(i, v) {
            if (!this.options.createParenthesizedExpressions) return this.addExtra(v, "parenthesized", true), this.addExtra(v, "parenStart", i.index), this.takeSurroundingComments(v, i.index, this.state.lastTokEndLoc.index), v;
            const O = this.startNodeAt(i);
            return O.expression = v, this.finishNode(O, "ParenthesizedExpression");
          }
          shouldParseArrow(i) {
            return !this.canInsertSemicolon();
          }
          parseArrow(i) {
            if (this.eat(19)) return i;
          }
          parseParenItem(i, v) {
            return i;
          }
          parseNewOrNewTarget() {
            const i = this.startNode();
            if (this.next(), this.match(16)) {
              const v = this.createIdentifier(this.startNodeAtNode(i), "new");
              this.next();
              const O = this.parseMetaProperty(i, v, "target");
              return this.scope.inNonArrowFunction || this.scope.inClass || this.options.allowNewTargetOutsideFunction || this.raise(_.UnexpectedNewTarget, O), O;
            }
            return this.parseNew(i);
          }
          parseNew(i) {
            if (this.parseNewCallee(i), this.eat(10)) {
              const v = this.parseExprList(11);
              this.toReferencedList(v), i.arguments = v;
            } else i.arguments = [];
            return this.finishNode(i, "NewExpression");
          }
          parseNewCallee(i) {
            const v = this.match(83), O = this.parseNoCallExpr();
            i.callee = O, !v || O.type !== "Import" && O.type !== "ImportExpression" || this.raise(_.ImportCallNotNewExpression, O);
          }
          parseTemplateElement(i) {
            const { start: v, startLoc: O, end: V, value: ne } = this.state, ce = v + 1, ve = this.startNodeAt(c(O, 1));
            ne === null && (i || this.raise(_.InvalidEscapeSequenceTemplate, c(this.state.firstInvalidTemplateEscapePos, 1)));
            const Ce = this.match(24), Le = Ce ? -1 : -2, Ke = V + Le;
            ve.value = { raw: this.input.slice(ce, Ke).replace(/\r\n?/g, `
`), cooked: ne === null ? null : ne.slice(1, Le) }, ve.tail = Ce, this.next();
            const ut = this.finishNode(ve, "TemplateElement");
            return this.resetEndLocation(ut, c(this.state.lastTokEndLoc, Le)), ut;
          }
          parseTemplate(i) {
            const v = this.startNode();
            let O = this.parseTemplateElement(i);
            const V = [O], ne = [];
            for (; !O.tail; ) ne.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), V.push(O = this.parseTemplateElement(i));
            return v.expressions = ne, v.quasis = V, this.finishNode(v, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(i, v, O, V) {
            O && this.expectPlugin("recordAndTuple");
            const ne = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const ce = /* @__PURE__ */ Object.create(null);
            let ve = true;
            const Ce = this.startNode();
            for (Ce.properties = [], this.next(); !this.match(i); ) {
              if (ve) ve = false;
              else if (this.expect(12), this.match(i)) {
                this.addTrailingCommaExtraToNode(Ce);
                break;
              }
              let Ke;
              v ? Ke = this.parseBindingProperty() : (Ke = this.parsePropertyDefinition(V), this.checkProto(Ke, O, ce, V)), O && !this.isObjectProperty(Ke) && Ke.type !== "SpreadElement" && this.raise(_.InvalidRecordProperty, Ke), Ke.shorthand && this.addExtra(Ke, "shorthand", true), Ce.properties.push(Ke);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = ne;
            let Le = "ObjectExpression";
            return v ? Le = "ObjectPattern" : O && (Le = "RecordExpression"), this.finishNode(Ce, Le);
          }
          addTrailingCommaExtraToNode(i) {
            this.addExtra(i, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(i, "trailingCommaLoc", this.state.lastTokStartLoc, false);
          }
          maybeAsyncOrAccessorProp(i) {
            return !i.computed && i.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
          parsePropertyDefinition(i) {
            let v = [];
            if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(_.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) v.push(this.parseDecorator());
            const O = this.startNode();
            let V, ne = false, ce = false;
            if (this.match(21)) return v.length && this.unexpected(), this.parseSpread();
            v.length && (O.decorators = v, v = []), O.method = false, i && (V = this.state.startLoc);
            let ve = this.eat(55);
            this.parsePropertyNamePrefixOperator(O);
            const Ce = this.state.containsEsc;
            if (this.parsePropertyName(O, i), !ve && !Ce && this.maybeAsyncOrAccessorProp(O)) {
              const { key: Le } = O, Ke = Le.name;
              Ke !== "async" || this.hasPrecedingLineBreak() || (ne = true, this.resetPreviousNodeTrailingComments(Le), ve = this.eat(55), this.parsePropertyName(O)), Ke !== "get" && Ke !== "set" || (ce = true, this.resetPreviousNodeTrailingComments(Le), O.kind = Ke, this.match(55) && (ve = true, this.raise(_.AccessorIsGenerator, this.state.curPosition(), { kind: Ke }), this.next()), this.parsePropertyName(O));
            }
            return this.parseObjPropValue(O, V, ve, ne, false, ce, i);
          }
          getGetterSetterExpectedParamCount(i) {
            return i.kind === "get" ? 0 : 1;
          }
          getObjectOrClassMethodParams(i) {
            return i.params;
          }
          checkGetterSetterParams(i) {
            var v;
            const O = this.getGetterSetterExpectedParamCount(i), V = this.getObjectOrClassMethodParams(i);
            V.length !== O && this.raise(i.kind === "get" ? _.BadGetterArity : _.BadSetterArity, i), i.kind === "set" && ((v = V[V.length - 1]) == null ? void 0 : v.type) === "RestElement" && this.raise(_.BadSetterRestParameter, i);
          }
          parseObjectMethod(i, v, O, V, ne) {
            if (ne) {
              const ce = this.parseMethod(i, v, false, false, false, "ObjectMethod");
              return this.checkGetterSetterParams(ce), ce;
            }
            if (O || v || this.match(10)) return V && this.unexpected(), i.kind = "method", i.method = true, this.parseMethod(i, v, O, false, false, "ObjectMethod");
          }
          parseObjectProperty(i, v, O, V) {
            if (i.shorthand = false, this.eat(14)) return i.value = O ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(V), this.finishNode(i, "ObjectProperty");
            if (!i.computed && i.key.type === "Identifier") {
              if (this.checkReservedWord(i.key.name, i.key.loc.start, true, false), O) i.value = this.parseMaybeDefault(v, zn(i.key));
              else if (this.match(29)) {
                const ne = this.state.startLoc;
                V != null ? V.shorthandAssignLoc === null && (V.shorthandAssignLoc = ne) : this.raise(_.InvalidCoverInitializedName, ne), i.value = this.parseMaybeDefault(v, zn(i.key));
              } else i.value = zn(i.key);
              return i.shorthand = true, this.finishNode(i, "ObjectProperty");
            }
          }
          parseObjPropValue(i, v, O, V, ne, ce, ve) {
            const Ce = this.parseObjectMethod(i, O, V, ne, ce) || this.parseObjectProperty(i, v, ne, ve);
            return Ce || this.unexpected(), Ce;
          }
          parsePropertyName(i, v) {
            if (this.eat(0)) i.computed = true, i.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              const { type: O, value: V } = this.state;
              let ne;
              if (z(O)) ne = this.parseIdentifier(true);
              else switch (O) {
                case 135:
                  ne = this.parseNumericLiteral(V);
                  break;
                case 134:
                  ne = this.parseStringLiteral(V);
                  break;
                case 136:
                  ne = this.parseBigIntLiteral(V);
                  break;
                case 139: {
                  const ce = this.state.startLoc;
                  v != null ? v.privateKeyLoc === null && (v.privateKeyLoc = ce) : this.raise(_.UnexpectedPrivateField, ce), ne = this.parsePrivateName();
                  break;
                }
                default:
                  if (O === 137) {
                    ne = this.parseDecimalLiteral(V);
                    break;
                  }
                  this.unexpected();
              }
              i.key = ne, O !== 139 && (i.computed = false);
            }
          }
          initFunction(i, v) {
            i.id = null, i.generator = false, i.async = v;
          }
          parseMethod(i, v, O, V, ne, ce, ve = false) {
            this.initFunction(i, O), i.generator = v, this.scope.enter(18 | (ve ? 64 : 0) | (ne ? 32 : 0)), this.prodParam.enter(Zn(O, i.generator)), this.parseFunctionParams(i, V);
            const Ce = this.parseFunctionBodyAndFinish(i, ce, true);
            return this.prodParam.exit(), this.scope.exit(), Ce;
          }
          parseArrayLike(i, v, O, V) {
            O && this.expectPlugin("recordAndTuple");
            const ne = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const ce = this.startNode();
            return this.next(), ce.elements = this.parseExprList(i, !O, V, ce), this.state.inFSharpPipelineDirectBody = ne, this.finishNode(ce, O ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(i, v, O, V) {
            this.scope.enter(6);
            let ne = Zn(O, false);
            !this.match(5) && this.prodParam.hasIn && (ne |= 8), this.prodParam.enter(ne), this.initFunction(i, O);
            const ce = this.state.maybeInArrowParameters;
            return v && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(i, v, V)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(i, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = ce, this.finishNode(i, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(i, v, O) {
            this.toAssignableList(v, O, false), i.params = v;
          }
          parseFunctionBodyAndFinish(i, v, O = false) {
            return this.parseFunctionBody(i, false, O), this.finishNode(i, v);
          }
          parseFunctionBody(i, v, O = false) {
            const V = v && !this.match(5);
            if (this.expressionScope.enter(Br()), V) i.body = this.parseMaybeAssign(), this.checkParams(i, false, v, false);
            else {
              const ne = this.state.strict, ce = this.state.labels;
              this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), i.body = this.parseBlock(true, false, (ve) => {
                const Ce = !this.isSimpleParamList(i.params);
                ve && Ce && this.raise(_.IllegalLanguageModeDirective, i.kind !== "method" && i.kind !== "constructor" || !i.key ? i : i.key.loc.end);
                const Le = !ne && this.state.strict;
                this.checkParams(i, !(this.state.strict || v || O || Ce), v, Le), this.state.strict && i.id && this.checkIdentifier(i.id, 65, Le);
              }), this.prodParam.exit(), this.state.labels = ce;
            }
            this.expressionScope.exit();
          }
          isSimpleParameter(i) {
            return i.type === "Identifier";
          }
          isSimpleParamList(i) {
            for (let v = 0, O = i.length; v < O; v++) if (!this.isSimpleParameter(i[v])) return false;
            return true;
          }
          checkParams(i, v, O, V = true) {
            const ne = !v && /* @__PURE__ */ new Set(), ce = { type: "FormalParameters" };
            for (const ve of i.params) this.checkLVal(ve, ce, 5, ne, V);
          }
          parseExprList(i, v, O, V) {
            const ne = [];
            let ce = true;
            for (; !this.eat(i); ) {
              if (ce) ce = false;
              else if (this.expect(12), this.match(i)) {
                V && this.addTrailingCommaExtraToNode(V), this.next();
                break;
              }
              ne.push(this.parseExprListItem(v, O));
            }
            return ne;
          }
          parseExprListItem(i, v, O) {
            let V;
            if (this.match(12)) i || this.raise(_.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), V = null;
            else if (this.match(21)) {
              const ne = this.state.startLoc;
              V = this.parseParenItem(this.parseSpread(v), ne);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), O || this.raise(_.UnexpectedArgumentPlaceholder, this.state.startLoc);
              const ne = this.startNode();
              this.next(), V = this.finishNode(ne, "ArgumentPlaceholder");
            } else V = this.parseMaybeAssignAllowIn(v, this.parseParenItem);
            return V;
          }
          parseIdentifier(i) {
            const v = this.startNode(), O = this.parseIdentifierName(i);
            return this.createIdentifier(v, O);
          }
          createIdentifier(i, v) {
            return i.name = v, i.loc.identifierName = v, this.finishNode(i, "Identifier");
          }
          parseIdentifierName(i) {
            let v;
            const { startLoc: O, type: V } = this.state;
            z(V) ? v = this.state.value : this.unexpected();
            const ne = V <= 92;
            return i ? ne && this.replaceToken(132) : this.checkReservedWord(v, O, ne, false), this.next(), v;
          }
          checkReservedWord(i, v, O, V) {
            if (!(i.length > 10) && function(ne) {
              return oe.has(ne);
            }(i)) {
              if (O && function(ne) {
                return qe.has(ne);
              }(i)) return void this.raise(_.UnexpectedKeyword, v, { keyword: i });
              if ((this.state.strict ? V ? he : Be : Re)(i, this.inModule)) this.raise(_.UnexpectedReservedWord, v, { reservedWord: i });
              else if (i === "yield") {
                if (this.prodParam.hasYield) return void this.raise(_.YieldBindingIdentifier, v);
              } else if (i === "await") {
                if (this.prodParam.hasAwait) return void this.raise(_.AwaitBindingIdentifier, v);
                if (this.scope.inStaticBlock) return void this.raise(_.AwaitBindingIdentifierInStaticBlock, v);
                this.expressionScope.recordAsyncArrowParametersError(v);
              } else if (i === "arguments" && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(_.ArgumentsInClass, v);
            }
          }
          recordAwaitIfAllowed() {
            const i = this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction;
            return i && !this.scope.inFunction && (this.state.hasTopLevelAwait = true), i;
          }
          parseAwait(i) {
            const v = this.startNodeAt(i);
            return this.expressionScope.recordParameterInitializerError(_.AwaitExpressionFormalParameter, v), this.eat(55) && this.raise(_.ObsoleteAwaitStar, v), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (v.argument = this.parseMaybeUnary(null, true)), this.finishNode(v, "AwaitExpression");
          }
          isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak()) return true;
            const { type: i } = this.state;
            return i === 53 || i === 10 || i === 0 || Te(i) || i === 102 && !this.state.containsEsc || i === 138 || i === 56 || this.hasPlugin("v8intrinsic") && i === 54;
          }
          parseYield() {
            const i = this.startNode();
            this.expressionScope.recordParameterInitializerError(_.YieldInParameter, i), this.next();
            let v = false, O = null;
            if (!this.hasPrecedingLineBreak()) switch (v = this.eat(55), this.state.type) {
              case 13:
              case 140:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!v) break;
              default:
                O = this.parseMaybeAssign();
            }
            return i.delegate = v, i.argument = O, this.finishNode(i, "YieldExpression");
          }
          parseImportCall(i) {
            if (this.next(), i.source = this.parseMaybeAssignAllowIn(), i.options = null, this.eat(12) && !this.match(11) && (i.options = this.parseMaybeAssignAllowIn(), this.eat(12) && !this.match(11))) {
              do
                this.parseMaybeAssignAllowIn();
              while (this.eat(12) && !this.match(11));
              this.raise(_.ImportCallArity, i);
            }
            return this.expect(11), this.finishNode(i, "ImportExpression");
          }
          checkPipelineAtInfixOperator(i, v) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && i.type === "SequenceExpression" && this.raise(_.PipelineHeadSequenceExpression, v);
          }
          parseSmartPipelineBodyInStyle(i, v) {
            if (this.isSimpleReference(i)) {
              const O = this.startNodeAt(v);
              return O.callee = i, this.finishNode(O, "PipelineBareFunction");
            }
            {
              const O = this.startNodeAt(v);
              return this.checkSmartPipeTopicBodyEarlyErrors(v), O.expression = i, this.finishNode(O, "PipelineTopicExpression");
            }
          }
          isSimpleReference(i) {
            switch (i.type) {
              case "MemberExpression":
                return !i.computed && this.isSimpleReference(i.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(i) {
            if (this.match(19)) throw this.raise(_.PipelineBodyNoArrow, this.state.startLoc);
            this.topicReferenceWasUsedInCurrentContext() || this.raise(_.PipelineTopicUnused, i);
          }
          withTopicBindingContext(i) {
            const v = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return i();
            } finally {
              this.state.topicContext = v;
            }
          }
          withSmartMixTopicForbiddingContext(i) {
            if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) return i();
            {
              const v = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return i();
              } finally {
                this.state.topicContext = v;
              }
            }
          }
          withSoloAwaitPermittingContext(i) {
            const v = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return i();
            } finally {
              this.state.soloAwait = v;
            }
          }
          allowInAnd(i) {
            const v = this.prodParam.currentFlags();
            if (8 & ~v) {
              this.prodParam.enter(8 | v);
              try {
                return i();
              } finally {
                this.prodParam.exit();
              }
            }
            return i();
          }
          disallowInAnd(i) {
            const v = this.prodParam.currentFlags();
            if (8 & v) {
              this.prodParam.enter(-9 & v);
              try {
                return i();
              } finally {
                this.prodParam.exit();
              }
            }
            return i();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(i) {
            const v = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const O = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            const V = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), v, i);
            return this.state.inFSharpPipelineDirectBody = O, V;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            const i = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            const v = this.startNodeAt(this.state.endLoc);
            this.next();
            const O = this.initializeScopes(true);
            this.enterInitialScopes();
            try {
              i.body = this.parseProgram(v, 8, "module");
            } finally {
              O();
            }
            return this.finishNode(i, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(i) {
          }
        }
        const Or = { kind: 1 }, Rs = { kind: 2 }, js = /[\uD800-\uDFFF]/u, os = /in(?:stanceof)?/y;
        class Wi extends es {
          parseTopLevel(i, v) {
            return i.program = this.parseProgram(v), i.comments = this.comments, this.options.tokens && (i.tokens = function(O, V, ne) {
              for (let ce = 0; ce < O.length; ce++) {
                const ve = O[ce], { type: Ce } = ve;
                if (typeof Ce == "number") {
                  if (Ce === 139) {
                    const { loc: Le, start: Ke, value: ut, end: At } = ve, bt = Ke + 1, Nt = c(Le.start, 1);
                    O.splice(ce, 1, new fn({ type: le(27), value: "#", start: Ke, end: bt, startLoc: Le.start, endLoc: Nt }), new fn({ type: le(132), value: ut, start: bt, end: At, startLoc: Nt, endLoc: Le.end })), ce++;
                    continue;
                  }
                  if (Te(Ce)) {
                    const { loc: Le, start: Ke, value: ut, end: At } = ve, bt = Ke + 1, Nt = c(Le.start, 1);
                    let dn, kn, en, wn, ls;
                    dn = V.charCodeAt(Ke - ne) === 96 ? new fn({ type: le(22), value: "`", start: Ke, end: bt, startLoc: Le.start, endLoc: Nt }) : new fn({ type: le(8), value: "}", start: Ke, end: bt, startLoc: Le.start, endLoc: Nt }), Ce === 24 ? (en = At - 1, wn = c(Le.end, -1), kn = ut === null ? null : ut.slice(1, -1), ls = new fn({ type: le(22), value: "`", start: en, end: At, startLoc: wn, endLoc: Le.end })) : (en = At - 2, wn = c(Le.end, -2), kn = ut === null ? null : ut.slice(1, -2), ls = new fn({ type: le(23), value: "${", start: en, end: At, startLoc: wn, endLoc: Le.end })), O.splice(ce, 1, dn, new fn({ type: le(20), value: kn, start: bt, end: en, startLoc: Nt, endLoc: wn }), ls), ce += 2;
                    continue;
                  }
                  ve.type = le(Ce);
                }
              }
              return O;
            }(this.tokens, this.input, this.startIndex)), this.finishNode(i, "File");
          }
          parseProgram(i, v = 140, O = this.options.sourceType) {
            if (i.sourceType = O, i.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(i, true, true, v), this.inModule) {
              if (!this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (const [ne, ce] of Array.from(this.scope.undefinedExports)) this.raise(_.ModuleExportUndefined, ce, { localName: ne });
              this.addExtra(i, "topLevelAwait", this.state.hasTopLevelAwait);
            }
            let V;
            return V = v === 140 ? this.finishNode(i, "Program") : this.finishNodeAt(i, "Program", c(this.state.startLoc, -1)), V;
          }
          stmtToDirective(i) {
            const v = i;
            v.type = "Directive", v.value = v.expression, delete v.expression;
            const O = v.value, V = O.value, ne = this.input.slice(this.offsetToSourcePos(O.start), this.offsetToSourcePos(O.end)), ce = O.value = ne.slice(1, -1);
            return this.addExtra(O, "raw", ne), this.addExtra(O, "rawValue", ce), this.addExtra(O, "expressionValue", V), O.type = "DirectiveLiteral", v;
          }
          parseInterpreterDirective() {
            if (!this.match(28)) return null;
            const i = this.startNode();
            return i.value = this.state.value, this.next(), this.finishNode(i, "InterpreterDirective");
          }
          isLet() {
            return !!this.isContextual(100) && this.hasFollowingBindingAtom();
          }
          chStartsBindingIdentifier(i, v) {
            if (J(i)) {
              if (os.lastIndex = v, os.test(this.input)) {
                const O = this.codePointAtPos(os.lastIndex);
                if (!Ee(O) && O !== 92) return false;
              }
              return true;
            }
            return i === 92;
          }
          chStartsBindingPattern(i) {
            return i === 91 || i === 123;
          }
          hasFollowingBindingAtom() {
            const i = this.nextTokenStart(), v = this.codePointAtPos(i);
            return this.chStartsBindingPattern(v) || this.chStartsBindingIdentifier(v, i);
          }
          hasInLineFollowingBindingIdentifierOrBrace() {
            const i = this.nextTokenInLineStart(), v = this.codePointAtPos(i);
            return v === 123 || this.chStartsBindingIdentifier(v, i);
          }
          startsUsingForOf() {
            const { type: i, containsEsc: v } = this.lookahead();
            return !(i === 102 && !v) && (B(i) && !this.hasFollowingLineBreak() ? (this.expectPlugin("explicitResourceManagement"), true) : void 0);
          }
          startsAwaitUsing() {
            let i = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(i, "using")) {
              i = this.nextTokenInLineStartSince(i + 5);
              const v = this.codePointAtPos(i);
              if (this.chStartsBindingIdentifier(v, i)) return this.expectPlugin("explicitResourceManagement"), true;
            }
            return false;
          }
          parseModuleItem() {
            return this.parseStatementLike(15);
          }
          parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
          parseStatementOrSloppyAnnexBFunctionDeclaration(i = false) {
            let v = 0;
            return this.options.annexB && !this.state.strict && (v |= 4, i && (v |= 8)), this.parseStatementLike(v);
          }
          parseStatement() {
            return this.parseStatementLike(0);
          }
          parseStatementLike(i) {
            let v = null;
            return this.match(26) && (v = this.parseDecorators(true)), this.parseStatementContent(i, v);
          }
          parseStatementContent(i, v) {
            const O = this.state.type, V = this.startNode(), ne = !!(2 & i), ce = !!(4 & i), ve = 1 & i;
            switch (O) {
              case 60:
                return this.parseBreakContinueStatement(V, true);
              case 63:
                return this.parseBreakContinueStatement(V, false);
              case 64:
                return this.parseDebuggerStatement(V);
              case 90:
                return this.parseDoWhileStatement(V);
              case 91:
                return this.parseForStatement(V);
              case 68:
                if (this.lookaheadCharCode() === 46) break;
                return ce || this.raise(this.state.strict ? _.StrictFunction : this.options.annexB ? _.SloppyFunctionAnnexB : _.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(V, false, !ne && ce);
              case 80:
                return ne || this.unexpected(), this.parseClass(this.maybeTakeDecorators(v, V), true);
              case 69:
                return this.parseIfStatement(V);
              case 70:
                return this.parseReturnStatement(V);
              case 71:
                return this.parseSwitchStatement(V);
              case 72:
                return this.parseThrowStatement(V);
              case 73:
                return this.parseTryStatement(V);
              case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing()) return this.recordAwaitIfAllowed() ? ne || this.raise(_.UnexpectedLexicalDeclaration, V) : this.raise(_.AwaitUsingNotInAsyncContext, V), this.next(), this.parseVarStatement(V, "await using");
                break;
              case 107:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
                return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(_.UnexpectedUsingDeclaration, this.state.startLoc) : ne || this.raise(_.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(V, "using");
              case 100: {
                if (this.state.containsEsc) break;
                const Ke = this.nextTokenStart(), ut = this.codePointAtPos(Ke);
                if (ut !== 91 && (!ne && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(ut, Ke) && ut !== 123)) break;
              }
              case 75:
                ne || this.raise(_.UnexpectedLexicalDeclaration, this.state.startLoc);
              case 74: {
                const Ke = this.state.value;
                return this.parseVarStatement(V, Ke);
              }
              case 92:
                return this.parseWhileStatement(V);
              case 76:
                return this.parseWithStatement(V);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(V);
              case 83: {
                const Ke = this.lookaheadCharCode();
                if (Ke === 40 || Ke === 46) break;
              }
              case 82: {
                let Ke;
                return this.options.allowImportExportEverywhere || ve || this.raise(_.UnexpectedImportExport, this.state.startLoc), this.next(), O === 83 ? (Ke = this.parseImport(V), Ke.type !== "ImportDeclaration" || Ke.importKind && Ke.importKind !== "value" || (this.sawUnambiguousESM = true)) : (Ke = this.parseExport(V, v), (Ke.type !== "ExportNamedDeclaration" || Ke.exportKind && Ke.exportKind !== "value") && (Ke.type !== "ExportAllDeclaration" || Ke.exportKind && Ke.exportKind !== "value") && Ke.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(Ke), Ke;
              }
              default:
                if (this.isAsyncFunction()) return ne || this.raise(_.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(V, true, !ne && ce);
            }
            const Ce = this.state.value, Le = this.parseExpression();
            return B(O) && Le.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(V, Ce, Le, i) : this.parseExpressionStatement(V, Le, v);
          }
          assertModuleNodeAllowed(i) {
            this.options.allowImportExportEverywhere || this.inModule || this.raise(_.ImportOutsideModule, i);
          }
          decoratorsEnabledBeforeExport() {
            return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
          }
          maybeTakeDecorators(i, v, O) {
            return i && (v.decorators && v.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(_.DecoratorsBeforeAfterExport, v.decorators[0]), v.decorators.unshift(...i)) : v.decorators = i, this.resetStartLocationFromNode(v, i[0]), O && this.resetStartLocationFromNode(O, v)), v;
          }
          canHaveLeadingDecorator() {
            return this.match(80);
          }
          parseDecorators(i) {
            const v = [];
            do
              v.push(this.parseDecorator());
            while (this.match(26));
            if (this.match(82)) i || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(_.DecoratorExportClass, this.state.startLoc);
            else if (!this.canHaveLeadingDecorator()) throw this.raise(_.UnexpectedLeadingDecorator, this.state.startLoc);
            return v;
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            const i = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              const v = this.state.startLoc;
              let O;
              if (this.match(10)) {
                const V = this.state.startLoc;
                this.next(), O = this.parseExpression(), this.expect(11), O = this.wrapParenthesis(V, O);
                const ne = this.state.startLoc;
                i.expression = this.parseMaybeDecoratorArguments(O), this.getPluginOption("decorators", "allowCallParenthesized") === false && i.expression !== O && this.raise(_.DecoratorArgumentsOutsideParentheses, ne);
              } else {
                for (O = this.parseIdentifier(false); this.eat(16); ) {
                  const V = this.startNodeAt(v);
                  V.object = O, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), V.property = this.parsePrivateName()) : V.property = this.parseIdentifier(true), V.computed = false, O = this.finishNode(V, "MemberExpression");
                }
                i.expression = this.parseMaybeDecoratorArguments(O);
              }
            } else i.expression = this.parseExprSubscripts();
            return this.finishNode(i, "Decorator");
          }
          parseMaybeDecoratorArguments(i) {
            if (this.eat(10)) {
              const v = this.startNodeAtNode(i);
              return v.callee = i, v.arguments = this.parseCallExpressionArguments(11), this.toReferencedList(v.arguments), this.finishNode(v, "CallExpression");
            }
            return i;
          }
          parseBreakContinueStatement(i, v) {
            return this.next(), this.isLineTerminator() ? i.label = null : (i.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(i, v), this.finishNode(i, v ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(i, v) {
            let O;
            for (O = 0; O < this.state.labels.length; ++O) {
              const V = this.state.labels[O];
              if ((i.label == null || V.name === i.label.name) && (V.kind != null && (v || V.kind === 1) || i.label && v)) break;
            }
            if (O === this.state.labels.length) {
              const V = v ? "BreakStatement" : "ContinueStatement";
              this.raise(_.IllegalBreakContinue, i, { type: V });
            }
          }
          parseDebuggerStatement(i) {
            return this.next(), this.semicolon(), this.finishNode(i, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            const i = this.parseExpression();
            return this.expect(11), i;
          }
          parseDoWhileStatement(i) {
            return this.next(), this.state.labels.push(Or), i.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), i.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(i, "DoWhileStatement");
          }
          parseForStatement(i) {
            this.next(), this.state.labels.push(Or);
            let v = null;
            if (this.isContextual(96) && this.recordAwaitIfAllowed() && (v = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13)) return v !== null && this.unexpected(v), this.parseFor(i, null);
            const O = this.isContextual(100);
            {
              const Ce = this.isContextual(96) && this.startsAwaitUsing(), Le = Ce || this.isContextual(107) && this.startsUsingForOf(), Ke = O && this.hasFollowingBindingAtom() || Le;
              if (this.match(74) || this.match(75) || Ke) {
                const ut = this.startNode();
                let At;
                Ce ? (At = "await using", this.recordAwaitIfAllowed() || this.raise(_.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : At = this.state.value, this.next(), this.parseVar(ut, true, At);
                const bt = this.finishNode(ut, "VariableDeclaration"), Nt = this.match(58);
                return Nt && Le && this.raise(_.ForInUsing, bt), (Nt || this.isContextual(102)) && bt.declarations.length === 1 ? this.parseForIn(i, bt, v) : (v !== null && this.unexpected(v), this.parseFor(i, bt));
              }
            }
            const V = this.isContextual(95), ne = new gn(), ce = this.parseExpression(true, ne), ve = this.isContextual(102);
            if (ve && (O && this.raise(_.ForOfLet, ce), v === null && V && ce.type === "Identifier" && this.raise(_.ForOfAsync, ce)), ve || this.match(58)) {
              this.checkDestructuringPrivate(ne), this.toAssignable(ce, true);
              const Ce = ve ? "ForOfStatement" : "ForInStatement";
              return this.checkLVal(ce, { type: Ce }), this.parseForIn(i, ce, v);
            }
            return this.checkExpressionErrors(ne, true), v !== null && this.unexpected(v), this.parseFor(i, ce);
          }
          parseFunctionStatement(i, v, O) {
            return this.next(), this.parseFunction(i, 1 | (O ? 2 : 0) | (v ? 8 : 0));
          }
          parseIfStatement(i) {
            return this.next(), i.test = this.parseHeaderExpression(), i.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), i.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(i, "IfStatement");
          }
          parseReturnStatement(i) {
            return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(_.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? i.argument = null : (i.argument = this.parseExpression(), this.semicolon()), this.finishNode(i, "ReturnStatement");
          }
          parseSwitchStatement(i) {
            this.next(), i.discriminant = this.parseHeaderExpression();
            const v = i.cases = [];
            let O;
            this.expect(5), this.state.labels.push(Rs), this.scope.enter(0);
            for (let V; !this.match(8); ) if (this.match(61) || this.match(65)) {
              const ne = this.match(61);
              O && this.finishNode(O, "SwitchCase"), v.push(O = this.startNode()), O.consequent = [], this.next(), ne ? O.test = this.parseExpression() : (V && this.raise(_.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), V = true, O.test = null), this.expect(14);
            } else O ? O.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), O && this.finishNode(O, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(i, "SwitchStatement");
          }
          parseThrowStatement(i) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(_.NewlineAfterThrow, this.state.lastTokEndLoc), i.argument = this.parseExpression(), this.semicolon(), this.finishNode(i, "ThrowStatement");
          }
          parseCatchClauseParam() {
            const i = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && i.type === "Identifier" ? 8 : 0), this.checkLVal(i, { type: "CatchClause" }, 9), i;
          }
          parseTryStatement(i) {
            if (this.next(), i.block = this.parseBlock(), i.handler = null, this.match(62)) {
              const v = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), v.param = this.parseCatchClauseParam(), this.expect(11)) : (v.param = null, this.scope.enter(0)), v.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), i.handler = this.finishNode(v, "CatchClause");
            }
            return i.finalizer = this.eat(67) ? this.parseBlock() : null, i.handler || i.finalizer || this.raise(_.NoCatchOrFinally, i), this.finishNode(i, "TryStatement");
          }
          parseVarStatement(i, v, O = false) {
            return this.next(), this.parseVar(i, false, v, O), this.semicolon(), this.finishNode(i, "VariableDeclaration");
          }
          parseWhileStatement(i) {
            return this.next(), i.test = this.parseHeaderExpression(), this.state.labels.push(Or), i.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(i, "WhileStatement");
          }
          parseWithStatement(i) {
            return this.state.strict && this.raise(_.StrictWith, this.state.startLoc), this.next(), i.object = this.parseHeaderExpression(), i.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(i, "WithStatement");
          }
          parseEmptyStatement(i) {
            return this.next(), this.finishNode(i, "EmptyStatement");
          }
          parseLabeledStatement(i, v, O, V) {
            for (const ve of this.state.labels) ve.name === v && this.raise(_.LabelRedeclaration, O, { labelName: v });
            const ne = (ce = this.state.type) >= 90 && ce <= 92 ? 1 : this.match(71) ? 2 : null;
            var ce;
            for (let ve = this.state.labels.length - 1; ve >= 0; ve--) {
              const Ce = this.state.labels[ve];
              if (Ce.statementStart !== i.start) break;
              Ce.statementStart = this.sourceToOffsetPos(this.state.start), Ce.kind = ne;
            }
            return this.state.labels.push({ name: v, kind: ne, statementStart: this.sourceToOffsetPos(this.state.start) }), i.body = 8 & V ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), i.label = O, this.finishNode(i, "LabeledStatement");
          }
          parseExpressionStatement(i, v, O) {
            return i.expression = v, this.semicolon(), this.finishNode(i, "ExpressionStatement");
          }
          parseBlock(i = false, v = true, O) {
            const V = this.startNode();
            return i && this.state.strictErrors.clear(), this.expect(5), v && this.scope.enter(0), this.parseBlockBody(V, i, false, 8, O), v && this.scope.exit(), this.finishNode(V, "BlockStatement");
          }
          isValidDirective(i) {
            return i.type === "ExpressionStatement" && i.expression.type === "StringLiteral" && !i.expression.extra.parenthesized;
          }
          parseBlockBody(i, v, O, V, ne) {
            const ce = i.body = [], ve = i.directives = [];
            this.parseBlockOrModuleBlockBody(ce, v ? ve : void 0, O, V, ne);
          }
          parseBlockOrModuleBlockBody(i, v, O, V, ne) {
            const ce = this.state.strict;
            let ve = false, Ce = false;
            for (; !this.match(V); ) {
              const Le = O ? this.parseModuleItem() : this.parseStatementListItem();
              if (v && !Ce) {
                if (this.isValidDirective(Le)) {
                  const Ke = this.stmtToDirective(Le);
                  v.push(Ke), ve || Ke.value.value !== "use strict" || (ve = true, this.setStrict(true));
                  continue;
                }
                Ce = true, this.state.strictErrors.clear();
              }
              i.push(Le);
            }
            ne == null ? void 0 : ne.call(this, ve), ce || this.setStrict(false), this.next();
          }
          parseFor(i, v) {
            return i.init = v, this.semicolon(false), i.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), i.update = this.match(11) ? null : this.parseExpression(), this.expect(11), i.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(i, "ForStatement");
          }
          parseForIn(i, v, O) {
            const V = this.match(58);
            return this.next(), V ? O !== null && this.unexpected(O) : i.await = O !== null, v.type !== "VariableDeclaration" || v.declarations[0].init == null || V && this.options.annexB && !this.state.strict && v.kind === "var" && v.declarations[0].id.type === "Identifier" || this.raise(_.ForInOfLoopInitializer, v, { type: V ? "ForInStatement" : "ForOfStatement" }), v.type === "AssignmentPattern" && this.raise(_.InvalidLhs, v, { ancestor: { type: "ForStatement" } }), i.left = v, i.right = V ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), i.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(i, V ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(i, v, O, V = false) {
            const ne = i.declarations = [];
            for (i.kind = O; ; ) {
              const ce = this.startNode();
              if (this.parseVarId(ce, O), ce.init = this.eat(29) ? v ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, ce.init !== null || V || (ce.id.type === "Identifier" || v && (this.match(58) || this.isContextual(102)) ? O !== "const" && O !== "using" && O !== "await using" || this.match(58) || this.isContextual(102) || this.raise(_.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: O }) : this.raise(_.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" })), ne.push(this.finishNode(ce, "VariableDeclarator")), !this.eat(12)) break;
            }
            return i;
          }
          parseVarId(i, v) {
            const O = this.parseBindingAtom();
            v !== "using" && v !== "await using" || O.type !== "ArrayPattern" && O.type !== "ObjectPattern" || this.raise(_.UsingDeclarationHasBindingPattern, O.loc.start), this.checkLVal(O, { type: "VariableDeclarator" }, v === "var" ? 5 : 8201), i.id = O;
          }
          parseAsyncFunctionExpression(i) {
            return this.parseFunction(i, 8);
          }
          parseFunction(i, v = 0) {
            const O = 2 & v, V = !!(1 & v), ne = V && !(4 & v), ce = !!(8 & v);
            this.initFunction(i, ce), this.match(55) && (O && this.raise(_.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), i.generator = true), V && (i.id = this.parseFunctionId(ne));
            const ve = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(Zn(ce, i.generator)), V || (i.id = this.parseFunctionId()), this.parseFunctionParams(i, false), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(i, V ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), V && !O && this.registerFunctionStatementId(i), this.state.maybeInArrowParameters = ve, i;
          }
          parseFunctionId(i) {
            return i || B(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(i, v) {
            this.expect(10), this.expressionScope.enter(new rr(3)), i.params = this.parseBindingList(11, 41, 2 | (v ? 4 : 0)), this.expressionScope.exit();
          }
          registerFunctionStatementId(i) {
            i.id && this.scope.declareName(i.id.name, !this.options.annexB || this.state.strict || i.generator || i.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, i.id.loc.start);
          }
          parseClass(i, v, O) {
            this.next();
            const V = this.state.strict;
            return this.state.strict = true, this.parseClassId(i, v, O), this.parseClassSuper(i), i.body = this.parseClassBody(!!i.superClass, V), this.finishNode(i, v ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          nameIsConstructor(i) {
            return i.type === "Identifier" && i.name === "constructor" || i.type === "StringLiteral" && i.value === "constructor";
          }
          isNonstaticConstructor(i) {
            return !i.computed && !i.static && this.nameIsConstructor(i.key);
          }
          parseClassBody(i, v) {
            this.classScope.enter();
            const O = { hadConstructor: false, hadSuperClass: i };
            let V = [];
            const ne = this.startNode();
            if (ne.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (V.length > 0) throw this.raise(_.DecoratorSemicolon, this.state.lastTokEndLoc);
                  continue;
                }
                if (this.match(26)) {
                  V.push(this.parseDecorator());
                  continue;
                }
                const ce = this.startNode();
                V.length && (ce.decorators = V, this.resetStartLocationFromNode(ce, V[0]), V = []), this.parseClassMember(ne, ce, O), ce.kind === "constructor" && ce.decorators && ce.decorators.length > 0 && this.raise(_.DecoratorConstructor, ce);
              }
            }), this.state.strict = v, this.next(), V.length) throw this.raise(_.TrailingDecorator, this.state.startLoc);
            return this.classScope.exit(), this.finishNode(ne, "ClassBody");
          }
          parseClassMemberFromModifier(i, v) {
            const O = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              const V = v;
              return V.kind = "method", V.computed = false, V.key = O, V.static = false, this.pushClassMethod(i, V, false, false, false, false), true;
            }
            if (this.isClassProperty()) {
              const V = v;
              return V.computed = false, V.key = O, V.static = false, i.body.push(this.parseClassProperty(V)), true;
            }
            return this.resetPreviousNodeTrailingComments(O), false;
          }
          parseClassMember(i, v, O) {
            const V = this.isContextual(106);
            if (V) {
              if (this.parseClassMemberFromModifier(i, v)) return;
              if (this.eat(5)) return void this.parseClassStaticBlock(i, v);
            }
            this.parseClassMemberWithIsStatic(i, v, O, V);
          }
          parseClassMemberWithIsStatic(i, v, O, V) {
            const ne = v, ce = v, ve = v, Ce = v, Le = v, Ke = ne, ut = ne;
            if (v.static = V, this.parsePropertyNamePrefixOperator(v), this.eat(55)) {
              Ke.kind = "method";
              const en = this.match(139);
              return this.parseClassElementName(Ke), en ? void this.pushClassPrivateMethod(i, ce, true, false) : (this.isNonstaticConstructor(ne) && this.raise(_.ConstructorIsGenerator, ne.key), void this.pushClassMethod(i, ne, true, false, false, false));
            }
            const At = !this.state.containsEsc && B(this.state.type), bt = this.parseClassElementName(v), Nt = At ? bt.name : null, dn = this.isPrivateName(bt), kn = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(ut), this.isClassMethod()) {
              if (Ke.kind = "method", dn) return void this.pushClassPrivateMethod(i, ce, false, false);
              const en = this.isNonstaticConstructor(ne);
              let wn = false;
              en && (ne.kind = "constructor", O.hadConstructor && !this.hasPlugin("typescript") && this.raise(_.DuplicateConstructor, bt), en && this.hasPlugin("typescript") && v.override && this.raise(_.OverrideOnConstructor, bt), O.hadConstructor = true, wn = O.hadSuperClass), this.pushClassMethod(i, ne, false, false, en, wn);
            } else if (this.isClassProperty()) dn ? this.pushClassPrivateProperty(i, Ce) : this.pushClassProperty(i, ve);
            else if (Nt !== "async" || this.isLineTerminator()) if (Nt !== "get" && Nt !== "set" || this.match(55) && this.isLineTerminator()) if (Nt !== "accessor" || this.isLineTerminator()) this.isLineTerminator() ? dn ? this.pushClassPrivateProperty(i, Ce) : this.pushClassProperty(i, ve) : this.unexpected();
            else {
              this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(bt);
              const en = this.match(139);
              this.parseClassElementName(ve), this.pushClassAccessorProperty(i, Le, en);
            }
            else {
              this.resetPreviousNodeTrailingComments(bt), Ke.kind = Nt;
              const en = this.match(139);
              this.parseClassElementName(ne), en ? this.pushClassPrivateMethod(i, ce, false, false) : (this.isNonstaticConstructor(ne) && this.raise(_.ConstructorIsAccessor, ne.key), this.pushClassMethod(i, ne, false, false, false, false)), this.checkGetterSetterParams(ne);
            }
            else {
              this.resetPreviousNodeTrailingComments(bt);
              const en = this.eat(55);
              ut.optional && this.unexpected(kn), Ke.kind = "method";
              const wn = this.match(139);
              this.parseClassElementName(Ke), this.parsePostMemberNameModifiers(ut), wn ? this.pushClassPrivateMethod(i, ce, en, true) : (this.isNonstaticConstructor(ne) && this.raise(_.ConstructorIsAsync, ne.key), this.pushClassMethod(i, ne, en, true, false, false));
            }
          }
          parseClassElementName(i) {
            const { type: v, value: O } = this.state;
            if (v !== 132 && v !== 134 || !i.static || O !== "prototype" || this.raise(_.StaticPrototype, this.state.startLoc), v === 139) {
              O === "constructor" && this.raise(_.ConstructorClassPrivateField, this.state.startLoc);
              const V = this.parsePrivateName();
              return i.key = V, V;
            }
            return this.parsePropertyName(i), i.key;
          }
          parseClassStaticBlock(i, v) {
            var O;
            this.scope.enter(208);
            const V = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            const ne = v.body = [];
            this.parseBlockOrModuleBlockBody(ne, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = V, i.body.push(this.finishNode(v, "StaticBlock")), (O = v.decorators) != null && O.length && this.raise(_.DecoratorStaticBlock, v);
          }
          pushClassProperty(i, v) {
            !v.computed && this.nameIsConstructor(v.key) && this.raise(_.ConstructorClassField, v.key), i.body.push(this.parseClassProperty(v));
          }
          pushClassPrivateProperty(i, v) {
            const O = this.parseClassPrivateProperty(v);
            i.body.push(O), this.classScope.declarePrivateName(this.getPrivateNameSV(O.key), 0, O.key.loc.start);
          }
          pushClassAccessorProperty(i, v, O) {
            O || v.computed || !this.nameIsConstructor(v.key) || this.raise(_.ConstructorClassField, v.key);
            const V = this.parseClassAccessorProperty(v);
            i.body.push(V), O && this.classScope.declarePrivateName(this.getPrivateNameSV(V.key), 0, V.key.loc.start);
          }
          pushClassMethod(i, v, O, V, ne, ce) {
            i.body.push(this.parseMethod(v, O, V, ne, ce, "ClassMethod", true));
          }
          pushClassPrivateMethod(i, v, O, V) {
            const ne = this.parseMethod(v, O, V, false, false, "ClassPrivateMethod", true);
            i.body.push(ne);
            const ce = ne.kind === "get" ? ne.static ? 6 : 2 : ne.kind === "set" ? ne.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(ne, ce);
          }
          declareClassPrivateMethodInScope(i, v) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), v, i.key.loc.start);
          }
          parsePostMemberNameModifiers(i) {
          }
          parseClassPrivateProperty(i) {
            return this.parseInitializer(i), this.semicolon(), this.finishNode(i, "ClassPrivateProperty");
          }
          parseClassProperty(i) {
            return this.parseInitializer(i), this.semicolon(), this.finishNode(i, "ClassProperty");
          }
          parseClassAccessorProperty(i) {
            return this.parseInitializer(i), this.semicolon(), this.finishNode(i, "ClassAccessorProperty");
          }
          parseInitializer(i) {
            this.scope.enter(80), this.expressionScope.enter(Br()), this.prodParam.enter(0), i.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(i, v, O, V = 8331) {
            if (B(this.state.type)) i.id = this.parseIdentifier(), v && this.declareNameFromIdentifier(i.id, V);
            else {
              if (!O && v) throw this.raise(_.MissingClassName, this.state.startLoc);
              i.id = null;
            }
          }
          parseClassSuper(i) {
            i.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
          parseExport(i, v) {
            const O = this.parseMaybeImportPhase(i, true), V = this.maybeParseExportDefaultSpecifier(i, O), ne = !V || this.eat(12), ce = ne && this.eatExportStar(i), ve = ce && this.maybeParseExportNamespaceSpecifier(i), Ce = ne && (!ve || this.eat(12)), Le = V || ce;
            if (ce && !ve) {
              if (V && this.unexpected(), v) throw this.raise(_.UnsupportedDecoratorExport, i);
              return this.parseExportFrom(i, true), this.finishNode(i, "ExportAllDeclaration");
            }
            const Ke = this.maybeParseExportNamedSpecifiers(i);
            let ut;
            if (V && ne && !ce && !Ke && this.unexpected(null, 5), ve && Ce && this.unexpected(null, 98), Le || Ke) {
              if (ut = false, v) throw this.raise(_.UnsupportedDecoratorExport, i);
              this.parseExportFrom(i, Le);
            } else ut = this.maybeParseExportDeclaration(i);
            if (Le || Ke || ut) {
              var At;
              const bt = i;
              if (this.checkExport(bt, true, false, !!bt.source), ((At = bt.declaration) == null ? void 0 : At.type) === "ClassDeclaration") this.maybeTakeDecorators(v, bt.declaration, bt);
              else if (v) throw this.raise(_.UnsupportedDecoratorExport, i);
              return this.finishNode(bt, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              const bt = i, Nt = this.parseExportDefaultExpression();
              if (bt.declaration = Nt, Nt.type === "ClassDeclaration") this.maybeTakeDecorators(v, Nt, bt);
              else if (v) throw this.raise(_.UnsupportedDecoratorExport, i);
              return this.checkExport(bt, true, true), this.finishNode(bt, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
          eatExportStar(i) {
            return this.eat(55);
          }
          maybeParseExportDefaultSpecifier(i, v) {
            if (v || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", v == null ? void 0 : v.loc.start);
              const O = v || this.parseIdentifier(true), V = this.startNodeAtNode(O);
              return V.exported = O, i.specifiers = [this.finishNode(V, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(i) {
            if (this.isContextual(93)) {
              var v;
              (v = i).specifiers != null || (v.specifiers = []);
              const O = this.startNodeAt(this.state.lastTokStartLoc);
              return this.next(), O.exported = this.parseModuleExportName(), i.specifiers.push(this.finishNode(O, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(i) {
            if (this.match(5)) {
              const v = i;
              v.specifiers || (v.specifiers = []);
              const O = v.exportKind === "type";
              return v.specifiers.push(...this.parseExportSpecifiers(O)), v.source = null, v.declaration = null, this.hasPlugin("importAssertions") && (v.assertions = []), true;
            }
            return false;
          }
          maybeParseExportDeclaration(i) {
            return !!this.shouldParseExportDeclaration() && (i.specifiers = [], i.source = null, this.hasPlugin("importAssertions") && (i.assertions = []), i.declaration = this.parseExportDeclaration(i), true);
          }
          isAsyncFunction() {
            if (!this.isContextual(95)) return false;
            const i = this.nextTokenInLineStart();
            return this.isUnparsedContextual(i, "function");
          }
          parseExportDefaultExpression() {
            const i = this.startNode();
            if (this.match(68)) return this.next(), this.parseFunction(i, 5);
            if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(i, 13);
            if (this.match(80)) return this.parseClass(i, true, true);
            if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(_.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
            if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(_.UnsupportedDefaultExport, this.state.startLoc);
            const v = this.parseMaybeAssignAllowIn();
            return this.semicolon(), v;
          }
          parseExportDeclaration(i) {
            return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
          }
          isExportDefaultSpecifier() {
            const { type: i } = this.state;
            if (B(i)) {
              if (i === 95 && !this.state.containsEsc || i === 100) return false;
              if ((i === 130 || i === 129) && !this.state.containsEsc) {
                const { type: V } = this.lookahead();
                if (B(V) && V !== 98 || V === 5) return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(65)) return false;
            const v = this.nextTokenStart(), O = this.isUnparsedContextual(v, "from");
            if (this.input.charCodeAt(v) === 44 || B(this.state.type) && O) return true;
            if (this.match(65) && O) {
              const V = this.input.charCodeAt(this.nextTokenStartSince(v + 4));
              return V === 34 || V === 39;
            }
            return false;
          }
          parseExportFrom(i, v) {
            this.eatContextual(98) ? (i.source = this.parseImportSource(), this.checkExport(i), this.maybeParseImportAttributes(i), this.checkJSONModuleImport(i)) : v && this.unexpected(), this.semicolon();
          }
          shouldParseExportDeclaration() {
            const { type: i } = this.state;
            return i === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(_.DecoratorBeforeExport, this.state.startLoc), true) : this.isContextual(107) || this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(_.UsingDeclarationExport, this.state.startLoc), true) : i === 74 || i === 75 || i === 68 || i === 80 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(i, v, O, V) {
            var ne;
            if (v) {
              if (O) {
                if (this.checkDuplicateExports(i, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var ce;
                  const ve = i.declaration;
                  ve.type !== "Identifier" || ve.name !== "from" || ve.end - ve.start != 4 || (ce = ve.extra) != null && ce.parenthesized || this.raise(_.ExportDefaultFromAsIdentifier, ve);
                }
              } else if ((ne = i.specifiers) != null && ne.length) for (const ve of i.specifiers) {
                const { exported: Ce } = ve, Le = Ce.type === "Identifier" ? Ce.name : Ce.value;
                if (this.checkDuplicateExports(ve, Le), !V && ve.local) {
                  const { local: Ke } = ve;
                  Ke.type !== "Identifier" ? this.raise(_.ExportBindingIsString, ve, { localName: Ke.value, exportName: Le }) : (this.checkReservedWord(Ke.name, Ke.loc.start, true, false), this.scope.checkLocalExport(Ke));
                }
              }
              else if (i.declaration) {
                const ve = i.declaration;
                if (ve.type === "FunctionDeclaration" || ve.type === "ClassDeclaration") {
                  const { id: Ce } = ve;
                  if (!Ce) throw new Error("Assertion failure");
                  this.checkDuplicateExports(i, Ce.name);
                } else if (ve.type === "VariableDeclaration") for (const Ce of ve.declarations) this.checkDeclaration(Ce.id);
              }
            }
          }
          checkDeclaration(i) {
            if (i.type === "Identifier") this.checkDuplicateExports(i, i.name);
            else if (i.type === "ObjectPattern") for (const v of i.properties) this.checkDeclaration(v);
            else if (i.type === "ArrayPattern") for (const v of i.elements) v && this.checkDeclaration(v);
            else i.type === "ObjectProperty" ? this.checkDeclaration(i.value) : i.type === "RestElement" ? this.checkDeclaration(i.argument) : i.type === "AssignmentPattern" && this.checkDeclaration(i.left);
          }
          checkDuplicateExports(i, v) {
            this.exportedIdentifiers.has(v) && (v === "default" ? this.raise(_.DuplicateDefaultExport, i) : this.raise(_.DuplicateExport, i, { exportName: v })), this.exportedIdentifiers.add(v);
          }
          parseExportSpecifiers(i) {
            const v = [];
            let O = true;
            for (this.expect(5); !this.eat(8); ) {
              if (O) O = false;
              else if (this.expect(12), this.eat(8)) break;
              const V = this.isContextual(130), ne = this.match(134), ce = this.startNode();
              ce.local = this.parseModuleExportName(), v.push(this.parseExportSpecifier(ce, ne, i, V));
            }
            return v;
          }
          parseExportSpecifier(i, v, O, V) {
            return this.eatContextual(93) ? i.exported = this.parseModuleExportName() : v ? i.exported = kr(i.local) : i.exported || (i.exported = zn(i.local)), this.finishNode(i, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(134)) {
              const i = this.parseStringLiteral(this.state.value), v = js.exec(i.value);
              return v && this.raise(_.ModuleExportNameHasLoneSurrogate, i, { surrogateCharCode: v[0].charCodeAt(0) }), i;
            }
            return this.parseIdentifier(true);
          }
          isJSONModuleImport(i) {
            return i.assertions != null && i.assertions.some(({ key: v, value: O }) => O.value === "json" && (v.type === "Identifier" ? v.name === "type" : v.value === "type"));
          }
          checkImportReflection(i) {
            const { specifiers: v } = i, O = v.length === 1 ? v[0].type : null;
            if (i.phase === "source") O !== "ImportDefaultSpecifier" && this.raise(_.SourcePhaseImportRequiresDefault, v[0].loc.start);
            else if (i.phase === "defer") O !== "ImportNamespaceSpecifier" && this.raise(_.DeferImportRequiresNamespace, v[0].loc.start);
            else if (i.module) {
              var V;
              O !== "ImportDefaultSpecifier" && this.raise(_.ImportReflectionNotBinding, v[0].loc.start), ((V = i.assertions) == null ? void 0 : V.length) > 0 && this.raise(_.ImportReflectionHasAssertion, v[0].loc.start);
            }
          }
          checkJSONModuleImport(i) {
            if (this.isJSONModuleImport(i) && i.type !== "ExportAllDeclaration") {
              const { specifiers: v } = i;
              if (v != null) {
                const O = v.find((V) => {
                  let ne;
                  if (V.type === "ExportSpecifier" ? ne = V.local : V.type === "ImportSpecifier" && (ne = V.imported), ne !== void 0) return ne.type === "Identifier" ? ne.name !== "default" : ne.value !== "default";
                });
                O !== void 0 && this.raise(_.ImportJSONBindingNotDefault, O.loc.start);
              }
            }
          }
          isPotentialImportPhase(i) {
            return !i && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
          }
          applyImportPhase(i, v, O, V) {
            v || (O === "module" ? (this.expectPlugin("importReflection", V), i.module = true) : this.hasPlugin("importReflection") && (i.module = false), O === "source" ? (this.expectPlugin("sourcePhaseImports", V), i.phase = "source") : O === "defer" ? (this.expectPlugin("deferredImportEvaluation", V), i.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (i.phase = null));
          }
          parseMaybeImportPhase(i, v) {
            if (!this.isPotentialImportPhase(v)) return this.applyImportPhase(i, v, null), null;
            const O = this.parseIdentifier(true), { type: V } = this.state;
            return (z(V) ? V !== 98 || this.lookaheadCharCode() === 102 : V !== 12) ? (this.resetPreviousIdentifierLeadingComments(O), this.applyImportPhase(i, v, O.name, O.loc.start), null) : (this.applyImportPhase(i, v, null), O);
          }
          isPrecedingIdImportPhase(i) {
            const { type: v } = this.state;
            return B(v) ? v !== 98 || this.lookaheadCharCode() === 102 : v !== 12;
          }
          parseImport(i) {
            return this.match(134) ? this.parseImportSourceAndAttributes(i) : this.parseImportSpecifiersAndAfter(i, this.parseMaybeImportPhase(i, false));
          }
          parseImportSpecifiersAndAfter(i, v) {
            i.specifiers = [];
            const O = !this.maybeParseDefaultImportSpecifier(i, v) || this.eat(12), V = O && this.maybeParseStarImportSpecifier(i);
            return O && !V && this.parseNamedImportSpecifiers(i), this.expectContextual(98), this.parseImportSourceAndAttributes(i);
          }
          parseImportSourceAndAttributes(i) {
            return i.specifiers != null || (i.specifiers = []), i.source = this.parseImportSource(), this.maybeParseImportAttributes(i), this.checkImportReflection(i), this.checkJSONModuleImport(i), this.semicolon(), this.finishNode(i, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(134) || this.unexpected(), this.parseExprAtom();
          }
          parseImportSpecifierLocal(i, v, O) {
            v.local = this.parseIdentifier(), i.specifiers.push(this.finishImportSpecifier(v, O));
          }
          finishImportSpecifier(i, v, O = 8201) {
            return this.checkLVal(i.local, { type: v }, O), this.finishNode(i, v);
          }
          parseImportAttributes() {
            this.expect(5);
            const i = [], v = /* @__PURE__ */ new Set();
            do {
              if (this.match(8)) break;
              const O = this.startNode(), V = this.state.value;
              if (v.has(V) && this.raise(_.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: V }), v.add(V), this.match(134) ? O.key = this.parseStringLiteral(V) : O.key = this.parseIdentifier(true), this.expect(14), !this.match(134)) throw this.raise(_.ModuleAttributeInvalidValue, this.state.startLoc);
              O.value = this.parseStringLiteral(this.state.value), i.push(this.finishNode(O, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), i;
          }
          parseModuleAttributes() {
            const i = [], v = /* @__PURE__ */ new Set();
            do {
              const O = this.startNode();
              if (O.key = this.parseIdentifier(true), O.key.name !== "type" && this.raise(_.ModuleAttributeDifferentFromType, O.key), v.has(O.key.name) && this.raise(_.ModuleAttributesWithDuplicateKeys, O.key, { key: O.key.name }), v.add(O.key.name), this.expect(14), !this.match(134)) throw this.raise(_.ModuleAttributeInvalidValue, this.state.startLoc);
              O.value = this.parseStringLiteral(this.state.value), i.push(this.finishNode(O, "ImportAttribute"));
            } while (this.eat(12));
            return i;
          }
          maybeParseImportAttributes(i) {
            let v;
            var O = false;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
              this.next(), v = this.hasPlugin("moduleAttributes") ? this.parseModuleAttributes() : this.parseImportAttributes(), O = true;
            } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (this.hasPlugin("deprecatedImportAssert") || this.hasPlugin("importAssertions") || this.raise(_.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(i, "deprecatedAssertSyntax", true), this.next(), v = this.parseImportAttributes()) : v = [];
            !O && this.hasPlugin("importAssertions") ? i.assertions = v : i.attributes = v;
          }
          maybeParseDefaultImportSpecifier(i, v) {
            if (v) {
              const O = this.startNodeAtNode(v);
              return O.local = v, i.specifiers.push(this.finishImportSpecifier(O, "ImportDefaultSpecifier")), true;
            }
            return !!z(this.state.type) && (this.parseImportSpecifierLocal(i, this.startNode(), "ImportDefaultSpecifier"), true);
          }
          maybeParseStarImportSpecifier(i) {
            if (this.match(55)) {
              const v = this.startNode();
              return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(i, v, "ImportNamespaceSpecifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(i) {
            let v = true;
            for (this.expect(5); !this.eat(8); ) {
              if (v) v = false;
              else {
                if (this.eat(14)) throw this.raise(_.DestructureNamedImport, this.state.startLoc);
                if (this.expect(12), this.eat(8)) break;
              }
              const O = this.startNode(), V = this.match(134), ne = this.isContextual(130);
              O.imported = this.parseModuleExportName();
              const ce = this.parseImportSpecifier(O, V, i.importKind === "type" || i.importKind === "typeof", ne, void 0);
              i.specifiers.push(ce);
            }
          }
          parseImportSpecifier(i, v, O, V, ne) {
            if (this.eatContextual(93)) i.local = this.parseIdentifier();
            else {
              const { imported: ce } = i;
              if (v) throw this.raise(_.ImportBindingIsString, i, { importName: ce.value });
              this.checkReservedWord(ce.name, i.loc.start, true, true), i.local || (i.local = zn(ce));
            }
            return this.finishImportSpecifier(i, "ImportSpecifier", ne);
          }
          isThisParam(i) {
            return i.type === "Identifier" && i.name === "this";
          }
        }
        class Dt extends Wi {
          constructor(i, v, O) {
            super(i = function(V) {
              const ne = { sourceType: "script", sourceFilename: void 0, startIndex: 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createImportExpressions: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
              if (V == null) return ne;
              if (V.annexB != null && V.annexB !== false) throw new Error("The `annexB` option can only be set to `false`.");
              for (const ce of Object.keys(ne)) V[ce] != null && (ne[ce] = V[ce]);
              if (ne.startLine === 1) V.startIndex == null && ne.startColumn > 0 ? ne.startIndex = ne.startColumn : V.startColumn == null && ne.startIndex > 0 && (ne.startColumn = ne.startIndex);
              else if ((V.startColumn == null || V.startIndex == null) && V.startIndex != null) throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
              return ne;
            }(i), v), this.options = i, this.initializeScopes(), this.plugins = O, this.filename = i.sourceFilename, this.startIndex = i.startIndex;
          }
          getScopeHandler() {
            return Ne;
          }
          parse() {
            this.enterInitialScopes();
            const i = this.startNode(), v = this.startNode();
            return this.nextToken(), i.errors = null, this.parseTopLevel(i, v), i.errors = this.state.errors, i.comments.length = this.state.commentsLen, i;
          }
        }
        const Ur = function(de) {
          const i = {};
          for (const v of Object.keys(de)) i[v] = le(de[v]);
          return i;
        }(G);
        function dr(de, i) {
          let v = Dt;
          const O = /* @__PURE__ */ new Map();
          if (de != null && de.plugins) {
            for (const V of de.plugins) {
              let ne, ce;
              typeof V == "string" ? ne = V : [ne, ce] = V, O.has(ne) || O.set(ne, ce || {});
            }
            (function(V) {
              if (V.has("decorators")) {
                if (V.has("decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                const ce = V.get("decorators").decoratorsBeforeExport;
                if (ce != null && typeof ce != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
                const ve = V.get("decorators").allowCallParenthesized;
                if (ve != null && typeof ve != "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
              }
              if (V.has("flow") && V.has("typescript")) throw new Error("Cannot combine flow and typescript plugins.");
              if (V.has("placeholders") && V.has("v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
              if (V.has("pipelineOperator")) {
                var ne;
                const ce = V.get("pipelineOperator").proposal;
                if (!Bn.includes(ce)) {
                  const Ce = Bn.map((Le) => `"${Le}"`).join(", ");
                  throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${Ce}.`);
                }
                const ve = ((ne = V.get("recordAndTuple")) == null ? void 0 : ne.syntaxType) === "hash";
                if (ce === "hack") {
                  if (V.has("placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                  if (V.has("v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                  const Ce = V.get("pipelineOperator").topicToken;
                  if (!Bt.includes(Ce)) {
                    const Le = Bt.map((Ke) => `"${Ke}"`).join(", ");
                    throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${Le}.`);
                  }
                  if (Ce === "#" && ve) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", V.get("recordAndTuple")])}\`.`);
                } else if (ce === "smart" && ve) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", V.get("recordAndTuple")])}\`.`);
              }
              if (V.has("moduleAttributes")) {
                if (V.has("deprecatedImportAssert") || V.has("importAssertions")) throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
                if (V.get("moduleAttributes").version !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
              }
              if (V.has("importAssertions") && V.has("deprecatedImportAssert")) throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
              if (!V.has("deprecatedImportAssert") && V.has("importAttributes") && V.get("importAttributes").deprecatedAssertSyntax && V.set("deprecatedImportAssert", {}), V.has("recordAndTuple")) {
                const ce = V.get("recordAndTuple").syntaxType;
                if (ce != null) {
                  const ve = ["hash", "bar"];
                  if (!ve.includes(ce)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + ve.map((Ce) => `'${Ce}'`).join(", "));
                }
              }
              if (V.has("asyncDoExpressions") && !V.has("doExpressions")) {
                const ce = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
                throw ce.missingPlugins = "doExpressions", ce;
              }
              if (V.has("optionalChainingAssign") && V.get("optionalChainingAssign").version !== "2023-07") throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
            })(O), v = function(V) {
              const ne = [];
              for (const Ce of pr) V.has(Ce) && ne.push(Ce);
              const ce = ne.join("|");
              let ve = Ls.get(ce);
              if (!ve) {
                ve = Dt;
                for (const Ce of ne) ve = Vn[Ce](ve);
                Ls.set(ce, ve);
              }
              return ve;
            }(O);
          }
          return new v(de, i, O);
        }
        const Ls = /* @__PURE__ */ new Map();
        t.parse = function(de, i) {
          var v;
          if (((v = i) == null ? void 0 : v.sourceType) !== "unambiguous") return dr(i, de).parse();
          i = Object.assign({}, i);
          try {
            i.sourceType = "module";
            const O = dr(i, de), V = O.parse();
            if (O.sawUnambiguousESM) return V;
            if (O.ambiguousScriptDifferentAst) try {
              return i.sourceType = "script", dr(i, de).parse();
            } catch {
            }
            else V.program.sourceType = "script";
            return V;
          } catch (O) {
            try {
              return i.sourceType = "script", dr(i, de).parse();
            } catch {
            }
            throw O;
          }
        }, t.parseExpression = function(de, i) {
          const v = dr(i, de);
          return v.options.strictMode && (v.state.strict = true), v.getExpression();
        }, t.tokTypes = Ur;
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-proposal-decorators/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"), u = l("./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-decorators/lib/index.js"), c = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), e = l("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js");
        t.default = (0, n.declare)((r, f) => {
          r.assertVersion(7);
          var { legacy: y } = f;
          const { version: S } = f;
          if (y || S === "legacy") return { name: "proposal-decorators", inherits: u.default, visitor: e.default };
          if (S && S !== "2018-09" && S !== "2021-12" && S !== "2022-03" && S !== "2023-01" && S !== "2023-05" && S !== "2023-11") throw new Error("The '.version' option must be one of 'legacy', '2023-11', '2023-05', '2023-01', '2022-03', or '2021-12'.");
          return r.assertVersion("^7.0.2"), (0, c.createClassFeaturePlugin)({ name: "proposal-decorators", api: r, feature: c.FEATURES.decorators, inherits: u.default, decoratorVersion: S });
        });
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");
        const u = n.template.statement(`
  DECORATOR(CLASS_REF = INNER) || CLASS_REF;
`), c = (0, n.template)(`
  CLASS_REF.prototype;
`), e = (0, n.template)(`
    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);
`), r = (0, n.template)(`
    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function(){
            return TEMP;
        }
    })
`), f = /* @__PURE__ */ new WeakSet();
        function y(m) {
          const E = (m.isClass() ? [m, ...m.get("body.body")] : m.get("properties")).reduce((_, C) => _.concat(C.node.decorators || []), []).filter((_) => !n.types.isIdentifier(_.expression));
          if (E.length !== 0) return n.types.sequenceExpression(E.map((_) => {
            const C = _.expression, w = _.expression = m.scope.generateDeclaredUidIdentifier("dec");
            return n.types.assignmentExpression("=", w, C);
          }).concat([m.node]));
        }
        function S(m) {
          var E;
          return !((E = m.decorators) == null || !E.length);
        }
        function T(m) {
          return m.some((E) => {
            var _;
            return (_ = E.decorators) == null ? void 0 : _.length;
          });
        }
        function d(m, E, _) {
          const C = m.scope.generateDeclaredUidIdentifier(m.isClass() ? "class" : "obj"), w = _.reduce(function(I, D) {
            let j = [];
            if (D.decorators != null && (j = D.decorators, D.decorators = null), j.length === 0) return I;
            if (D.computed) throw m.buildCodeFrameError("Computed method/property decorators are not yet supported.");
            const L = n.types.isLiteral(D.key) ? D.key : n.types.stringLiteral(D.key.name), k = m.isClass() && !D.static ? c({ CLASS_REF: C }).expression : C;
            if (n.types.isClassProperty(D, { static: false })) {
              const N = m.scope.generateDeclaredUidIdentifier("descriptor"), F = D.value ? n.types.functionExpression(null, [], n.types.blockStatement([n.types.returnStatement(D.value)])) : n.types.nullLiteral();
              D.value = n.types.callExpression(E.addHelper("initializerWarningHelper"), [N, n.types.thisExpression()]), f.add(D.value), I.push(n.types.assignmentExpression("=", n.types.cloneNode(N), n.types.callExpression(E.addHelper("applyDecoratedDescriptor"), [n.types.cloneNode(k), n.types.cloneNode(L), n.types.arrayExpression(j.map((W) => n.types.cloneNode(W.expression))), n.types.objectExpression([n.types.objectProperty(n.types.identifier("configurable"), n.types.booleanLiteral(true)), n.types.objectProperty(n.types.identifier("enumerable"), n.types.booleanLiteral(true)), n.types.objectProperty(n.types.identifier("writable"), n.types.booleanLiteral(true)), n.types.objectProperty(n.types.identifier("initializer"), F)])])));
            } else I.push(n.types.callExpression(E.addHelper("applyDecoratedDescriptor"), [n.types.cloneNode(k), n.types.cloneNode(L), n.types.arrayExpression(j.map((N) => n.types.cloneNode(N.expression))), n.types.isObjectProperty(D) || n.types.isClassProperty(D, { static: true }) ? r({ TEMP: m.scope.generateDeclaredUidIdentifier("init"), TARGET: n.types.cloneNode(k), PROPERTY: n.types.cloneNode(L) }).expression : e({ TARGET: n.types.cloneNode(k), PROPERTY: n.types.cloneNode(L) }).expression, n.types.cloneNode(k)]));
            return I;
          }, []);
          return n.types.sequenceExpression([n.types.assignmentExpression("=", n.types.cloneNode(C), m.node), n.types.sequenceExpression(w), n.types.cloneNode(C)]);
        }
        function p({ node: m, scope: E }) {
          if (!S(m) && !T(m.body.body)) return;
          const _ = m.id ? n.types.cloneNode(m.id) : E.generateUidIdentifier("class");
          return n.types.variableDeclaration("let", [n.types.variableDeclarator(_, n.types.toExpression(m))]);
        }
        const h = { ExportDefaultDeclaration(m) {
          const E = m.get("declaration");
          if (!E.isClassDeclaration()) return;
          const _ = p(E);
          if (_) {
            const [C] = m.replaceWithMultiple([_, n.types.exportNamedDeclaration(null, [n.types.exportSpecifier(n.types.cloneNode(_.declarations[0].id), n.types.identifier("default"))])]);
            E.node.id || m.scope.registerDeclaration(C);
          }
        }, ClassDeclaration(m) {
          const E = p(m);
          if (E) {
            const [_] = m.replaceWith(E), C = _.get("declarations.0"), w = C.node.id, I = m.scope.getOwnBinding(w.name);
            I.identifier = w, I.path = C;
          }
        }, ClassExpression(m, E) {
          const _ = y(m) || function(C) {
            if (!S(C.node)) return;
            const w = C.node.decorators || [];
            C.node.decorators = null;
            const I = C.scope.generateDeclaredUidIdentifier("class");
            return w.map((D) => D.expression).reverse().reduce(function(D, j) {
              return u({ CLASS_REF: n.types.cloneNode(I), DECORATOR: n.types.cloneNode(j), INNER: D }).expression;
            }, C.node);
          }(m) || function(C, w) {
            if (T(C.node.body.body)) return d(C, w, C.node.body.body);
          }(m, E);
          _ && m.replaceWith(_);
        }, ObjectExpression(m, E) {
          const _ = y(m) || function(C, w) {
            if (T(C.node.properties)) return d(C, w, C.node.properties.filter((I) => I.type !== "SpreadElement"));
          }(m, E);
          _ && m.replaceWith(_);
        }, AssignmentExpression(m, E) {
          f.has(m.node.right) && m.replaceWith(n.types.callExpression(E.addHelper("initializerDefineProperty"), [n.types.cloneNode(m.get("left.object").node), n.types.stringLiteral(m.get("left.property").node.name || m.get("left.property").node.value), n.types.cloneNode(m.get("right.arguments")[0].node), n.types.cloneNode(m.get("right.arguments")[1].node)]));
        }, CallExpression(m, E) {
          m.node.arguments.length === 3 && f.has(m.node.arguments[2]) && m.node.callee.name === E.addHelper("defineProperty").name && m.replaceWith(n.types.callExpression(E.addHelper("initializerDefineProperty"), [n.types.cloneNode(m.get("arguments")[0].node), n.types.cloneNode(m.get("arguments")[1].node), n.types.cloneNode(m.get("arguments.2.arguments")[0].node), n.types.cloneNode(m.get("arguments.2.arguments")[1].node)]));
        } };
        t.default = h;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-decorators/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js");
        t.default = (0, n.declare)((u, c) => {
          u.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
          let { version: e } = c;
          {
            const { legacy: f } = c;
            if (f !== void 0) {
              if (typeof f != "boolean") throw new Error(".legacy must be a boolean.");
              if (e !== void 0) throw new Error("You can either use the .legacy or the .version option, not both.");
            }
            if (e === void 0) e = f ? "legacy" : "2018-09";
            else if (e !== "2023-11" && e !== "2023-05" && e !== "2023-01" && e !== "2022-03" && e !== "2021-12" && e !== "2018-09" && e !== "legacy") throw new Error("Unsupported decorators version: " + e);
            var { decoratorsBeforeExport: r } = c;
            if (r === void 0) {
              if (e === "2021-12" || e === "2022-03") r = false;
              else if (e === "2018-09") throw new Error("The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean.");
            } else {
              if (e === "legacy" || e === "2022-03" || e === "2023-01") throw new Error(`'decoratorsBeforeExport' can't be used with ${e} decorators.`);
              if (typeof r != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
          }
          return { name: "syntax-decorators", manipulateOptions({ generatorOpts: f }, y) {
            e === "legacy" ? y.plugins.push("decorators-legacy") : e === "2023-01" || e === "2023-05" || e === "2023-11" ? y.plugins.push(["decorators", { allowCallParenthesized: false }], "decoratorAutoAccessors") : e === "2022-03" ? y.plugins.push(["decorators", { decoratorsBeforeExport: false, allowCallParenthesized: false }], "decoratorAutoAccessors") : e === "2021-12" ? (y.plugins.push(["decorators", { decoratorsBeforeExport: r }], "decoratorAutoAccessors"), f.decoratorsBeforeExport = r) : e === "2018-09" && (y.plugins.push(["decorators", { decoratorsBeforeExport: r }]), f.decoratorsBeforeExport = r);
          } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.26.0_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js");
        t.default = (0, n.declare)((u) => {
          u.assertVersion(7);
          const c = (r, f) => f === "plugin" || Array.isArray(r) && r[0] === "plugin", e = (r) => Array.isArray(r) && r.length > 1 ? r[1] : {};
          return { name: "syntax-import-assertions", manipulateOptions(r, { plugins: f }) {
            for (let y = 0; y < f.length; y++) {
              const S = f[y];
              if (c(S, "deprecatedImportAssert")) return;
              if (c(S, "importAttributes")) return void f.splice(y, 1, "deprecatedImportAssert", ["importAttributes", Object.assign({}, e(S), { deprecatedAssertSyntax: true })]);
            }
            f.push("importAssertions");
          } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-jsx/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js");
        t.default = (0, n.declare)((u) => (u.assertVersion(7), { name: "syntax-jsx", manipulateOptions(c, e) {
          e.plugins.some((r) => (Array.isArray(r) ? r[0] : r) === "typescript") || e.plugins.push("jsx");
        } }));
      }, "./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-typescript/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"), u = function(c, e) {
          const r = [];
          c.forEach((f, y) => {
            (Array.isArray(f) ? f[0] : f) === e && r.unshift(y);
          });
          for (const f of r) c.splice(f, 1);
        };
        t.default = (0, n.declare)((c, e) => {
          c.assertVersion(7);
          const { disallowAmbiguousJSXLike: r, dts: f } = e;
          var { isTSX: y } = e;
          return { name: "syntax-typescript", manipulateOptions(S, T) {
            {
              const { plugins: d } = T;
              u(d, "flow"), u(d, "jsx"), d.push("objectRestSpread", "classProperties"), y && d.push("jsx");
            }
            T.plugins.push(["typescript", { disallowAmbiguousJSXLike: r, dts: f }]);
          } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-export-namespace-from@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"), u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");
        t.default = (0, n.declare)((c) => (c.assertVersion(7), { name: "transform-export-namespace-from", manipulateOptions: (e, r) => r.plugins.push("exportNamespaceFrom"), visitor: { ExportNamedDeclaration(e) {
          var r;
          const { node: f, scope: y } = e, { specifiers: S } = f, T = u.types.isExportDefaultSpecifier(S[0]) ? 1 : 0;
          if (!u.types.isExportNamespaceSpecifier(S[T])) return;
          const d = [];
          T === 1 && d.push(u.types.exportNamedDeclaration(null, [S.shift()], f.source));
          const p = S.shift(), { exported: h } = p, m = y.generateUidIdentifier((r = h.name) != null ? r : h.value);
          d.push(u.types.importDeclaration([u.types.importNamespaceSpecifier(m)], u.types.cloneNode(f.source)), u.types.exportNamedDeclaration(null, [u.types.exportSpecifier(u.types.cloneNode(m), h)])), f.specifiers.length >= 1 && d.push(f);
          const [E] = e.replaceWithMultiple(d);
          e.scope.registerDeclaration(E);
        } } }));
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.transformDynamicImport = function(r, f, y) {
          const S = f ? c : e;
          r.replaceWith((0, u.buildDynamicImport)(r.node, true, false, (T) => S(T, y)));
        };
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js");
        const c = (r) => n.template.expression.ast`require(${r})`, e = (r, f) => n.types.callExpression(f.addHelper("interopRequireWildcard"), [c(r)]);
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.defineCommonJSHook = function(u, c) {
          let e = u.get(l);
          e || u.set(l, e = []), e.push(c);
        }, t.makeInvokers = function(u) {
          const c = u.get(l);
          return { getWrapperPayload: (...e) => n(c, (r) => r.getWrapperPayload == null ? void 0 : r.getWrapperPayload(...e)), wrapReference: (...e) => n(c, (r) => r.wrapReference == null ? void 0 : r.wrapReference(...e)), buildRequireWrapper: (...e) => n(c, (r) => r.buildRequireWrapper == null ? void 0 : r.buildRequireWrapper(...e)) };
        };
        const l = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
        function n(u, c) {
          if (u) for (const e of u) {
            const r = c(e);
            if (r != null) return r;
          }
        }
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0, Object.defineProperty(t, "defineCommonJSHook", { enumerable: true, get: function() {
          return f.defineCommonJSHook;
        } });
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"), u = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js"), c = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), e = l("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js"), r = l("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js"), f = l("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js");
        t.default = (0, n.declare)((y, S) => {
          var T, d, p;
          y.assertVersion(7);
          const { strictNamespace: h = false, mjsStrictNamespace: m = h, allowTopLevelThis: E, strict: _, strictMode: C, noInterop: w, importInterop: I, lazy: D = false, allowCommonJSExports: j = true, loose: L = false } = S, k = (T = y.assumption("constantReexports")) != null ? T : L, N = (d = y.assumption("enumerableModuleMeta")) != null ? d : L, F = (p = y.assumption("noIncompleteNsImportDetection")) != null && p;
          if (!(typeof D == "boolean" || typeof D == "function" || Array.isArray(D) && D.every((H) => typeof H == "string"))) throw new Error(".lazy must be a boolean, array of strings, or a function");
          if (typeof h != "boolean") throw new Error(".strictNamespace must be a boolean, or undefined");
          if (typeof m != "boolean") throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
          const W = (H) => c.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${H}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, X = { ReferencedIdentifier(H) {
            const U = H.node.name;
            if (U !== "module" && U !== "exports") return;
            const q = H.scope.getBinding(U);
            this.scope.getBinding(U) !== q || H.parentPath.isObjectProperty({ value: H.node }) && H.parentPath.parentPath.isObjectPattern() || H.parentPath.isAssignmentExpression({ left: H.node }) || H.isAssignmentExpression({ left: H.node }) || H.replaceWith(W(U));
          }, UpdateExpression(H) {
            const U = H.get("argument");
            if (!U.isIdentifier()) return;
            const q = U.node.name;
            if (q !== "module" && q !== "exports") return;
            const ee = H.scope.getBinding(q);
            this.scope.getBinding(q) === ee && H.replaceWith(c.types.assignmentExpression(H.node.operator[0] + "=", U.node, W(q)));
          }, AssignmentExpression(H) {
            const U = H.get("left");
            if (U.isIdentifier()) {
              const q = U.node.name;
              if (q !== "module" && q !== "exports") return;
              const ee = H.scope.getBinding(q);
              if (this.scope.getBinding(q) !== ee) return;
              const re = H.get("right");
              re.replaceWith(c.types.sequenceExpression([re.node, W(q)]));
            } else if (U.isPattern()) {
              const q = U.getOuterBindingIdentifiers(), ee = Object.keys(q).find((re) => (re === "module" || re === "exports") && this.scope.getBinding(re) === H.scope.getBinding(re));
              if (ee) {
                const re = H.get("right");
                re.replaceWith(c.types.sequenceExpression([re.node, W(ee)]));
              }
            }
          } };
          return { name: "transform-modules-commonjs", pre() {
            this.file.set("@babel/plugin-transform-modules-*", "commonjs"), D && (0, f.defineCommonJSHook)(this.file, (0, r.lazyImportsHook)(D));
          }, visitor: { ["CallExpression" + (y.types.importExpression ? "|ImportExpression" : "")](H) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import") || H.isCallExpression() && !c.types.isImport(H.node.callee)) return;
            let { scope: U } = H;
            do
              U.rename("require");
            while (U = U.parent);
            (0, e.transformDynamicImport)(H, w, this.file);
          }, Program: { exit(H, U) {
            if (!(0, u.isModule)(H)) return;
            H.scope.rename("exports"), H.scope.rename("module"), H.scope.rename("require"), H.scope.rename("__filename"), H.scope.rename("__dirname"), j || H.traverse(X, { scope: H.scope });
            let q = (0, u.getModuleName)(this.file.opts, S);
            q && (q = c.types.stringLiteral(q));
            const ee = (0, f.makeInvokers)(this.file), { meta: re, headers: Y } = (0, u.rewriteModuleStatementsAndPrepareHeader)(H, { exportName: "exports", constantReexports: k, enumerableModuleMeta: N, strict: _, strictMode: C, allowTopLevelThis: E, noInterop: w, importInterop: I, wrapReference: ee.wrapReference, getWrapperPayload: ee.getWrapperPayload, esNamespaceOnly: typeof U.filename == "string" && /\.mjs$/.test(U.filename) ? m : h, noIncompleteNsImportDetection: F, filename: this.file.opts.filename });
            for (const [Z, G] of re.source) {
              const B = c.types.callExpression(c.types.identifier("require"), [c.types.stringLiteral(Z)]);
              let z;
              if ((0, u.isSideEffectImport)(G)) {
                if (D && G.wrap === "function") throw new Error("Assertion failure");
                z = c.types.expressionStatement(B);
              } else {
                const M = (0, u.wrapInterop)(H, B, G.interop) || B;
                if (G.wrap) {
                  const K = ee.buildRequireWrapper(G.name, M, G.wrap, G.referenced);
                  if (K === false) continue;
                  z = K;
                }
                z != null || (z = c.template.statement.ast`
                var ${G.name} = ${M};
              `);
              }
              z.loc = G.loc, Y.push(z), Y.push(...(0, u.buildNamespaceInitStatements)(re, G, k, ee.wrapReference));
            }
            (0, u.ensureStatementsHoisted)(Y), H.unshiftContainer("body", Y), H.get("body").forEach((Z) => {
              Y.includes(Z.node) && Z.isVariableDeclaration() && Z.scope.registerDeclaration(Z);
            });
          } } } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.lazyImportsHook = void 0;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("./node_modules/.pnpm/@babel+helper-module-transforms@7.26.0_@babel+core@7.26.0/node_modules/@babel/helper-module-transforms/lib/index.js");
        t.lazyImportsHook = (c) => ({ name: "@babel/plugin-transform-modules-commonjs/lazy", version: "7.26.3", getWrapperPayload: (e, r) => (0, u.isSideEffectImport)(r) || r.reexportAll ? null : c === true ? e.includes(".") ? null : "lazy/function" : Array.isArray(c) ? c.includes(e) ? "lazy/function" : null : typeof c == "function" ? c(e) ? "lazy/function" : null : void 0, buildRequireWrapper(e, r, f, y) {
          if (f === "lazy/function") return !!y && n.template.statement.ast`
        function ${e}() {
          const data = ${r};
          ${e} = function(){ return data; };
          return data;
        }
      `;
        }, wrapReference(e, r) {
          if (r === "lazy/function") return n.types.callExpression(e, []);
        } });
      }, "./node_modules/.pnpm/@babel+plugin-transform-nullish-coalescing-operator@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-nullish-coalescing-operator/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"), u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js");
        t.default = (0, n.declare)((c, { loose: e = false }) => {
          var r;
          c.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
          const f = (r = c.assumption("noDocumentAll")) != null ? r : e;
          return { name: "transform-nullish-coalescing-operator", manipulateOptions: (y, S) => S.plugins.push("nullishCoalescingOperator"), visitor: { LogicalExpression(y) {
            const { node: S, scope: T } = y;
            if (S.operator !== "??") return;
            let d, p;
            if (T.isStatic(S.left)) d = S.left, p = u.types.cloneNode(S.left);
            else {
              if (T.path.isPattern()) return void y.replaceWith(u.template.statement.ast`(() => ${y.node})()`);
              d = T.generateUidIdentifierBasedOnNode(S.left), T.push({ id: u.types.cloneNode(d) }), p = u.types.assignmentExpression("=", d, S.left);
            }
            y.replaceWith(u.types.conditionalExpression(f ? u.types.binaryExpression("!=", p, u.types.nullLiteral()) : u.types.logicalExpression("&&", u.types.binaryExpression("!==", p, u.types.nullLiteral()), u.types.binaryExpression("!==", u.types.cloneNode(d), T.buildUndefinedNode())), u.types.cloneNode(d), S.right));
          } } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-optional-chaining@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-optional-chaining/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true });
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"), u = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), c = l("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.25.9/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js");
        function e(E) {
          const _ = r(E), { node: C, parentPath: w } = _;
          if (w.isLogicalExpression()) {
            const { operator: I, right: D } = w.node;
            if (I === "&&" || I === "||" || I === "??" && C === D) return e(w);
          }
          if (w.isSequenceExpression()) {
            const { expressions: I } = w.node;
            return I[I.length - 1] !== C || e(w);
          }
          return w.isConditional({ test: C }) || w.isUnaryExpression({ operator: "!" }) || w.isLoop({ test: C });
        }
        function r(E) {
          let _ = E;
          return E.findParent((C) => {
            if (!c.isTransparentExprWrapper(C.node)) return true;
            _ = C;
          }), _;
        }
        function f(E) {
          return E = c.skipTransparentExprWrapperNodes(E), u.types.isIdentifier(E) || u.types.isSuper(E) || u.types.isMemberExpression(E) && !E.computed && f(E.object);
        }
        const y = u.template.expression("%%check%% === null || %%ref%% === void 0"), S = u.template.expression("%%check%% == null"), T = u.template.expression("%%check%% !== null && %%ref%% !== void 0"), d = u.template.expression("%%check%% != null");
        function p(E, { pureGetters: _, noDocumentAll: C }, w, I, D) {
          const { scope: j } = E;
          if (j.path.isPattern() && function(G) {
            let B = G;
            const { scope: z } = G;
            for (; B.isOptionalMemberExpression() || B.isOptionalCallExpression(); ) {
              const { node: M } = B, K = c.skipTransparentExprWrappers(B.isOptionalMemberExpression() ? B.get("object") : B.get("callee"));
              if (M.optional) return !z.isStatic(K.node);
              B = K;
            }
          }(E)) return void w.replaceWith(u.template.expression.ast`(() => ${w.node})()`);
          const L = [];
          let k = E;
          for (; k.isOptionalMemberExpression() || k.isOptionalCallExpression(); ) {
            const { node: G } = k;
            G.optional && L.push(G), k.isOptionalMemberExpression() ? (k.node.type = "MemberExpression", k = c.skipTransparentExprWrappers(k.get("object"))) : k.isOptionalCallExpression() && (k.node.type = "CallExpression", k = c.skipTransparentExprWrappers(k.get("callee")));
          }
          if (L.length === 0) return;
          const N = [];
          let F;
          for (let G = L.length - 1; G >= 0; G--) {
            const B = L[G], z = u.types.isCallExpression(B), M = z ? B.callee : B.object, K = c.skipTransparentExprWrapperNodes(M);
            let Q, ie;
            if (z && u.types.isIdentifier(K, { name: "eval" }) ? (ie = Q = K, B.callee = u.types.sequenceExpression([u.types.numericLiteral(0), Q])) : _ && z && f(K) ? ie = Q = B.callee : j.isStatic(K) ? ie = Q = M : (F && !z || (F = j.generateUidIdentifierBasedOnNode(K), j.push({ id: u.types.cloneNode(F) })), Q = F, ie = u.types.assignmentExpression("=", u.types.cloneNode(F), M), z ? B.callee = Q : B.object = Q), z && u.types.isMemberExpression(K)) if (_ && f(K)) B.callee = M;
            else {
              const { object: ge } = K;
              let Te;
              if (u.types.isSuper(ge)) Te = u.types.thisExpression();
              else {
                const le = j.maybeGenerateMemoised(ge);
                le ? (Te = le, K.object = u.types.assignmentExpression("=", le, ge)) : Te = ge;
              }
              B.arguments.unshift(u.types.cloneNode(Te)), B.callee = u.types.memberExpression(B.callee, u.types.identifier("call"));
            }
            const ue = { check: u.types.cloneNode(ie), ref: u.types.cloneNode(Q) };
            Object.defineProperty(ue, "ref", { enumerable: false }), N.push(ue);
          }
          let W = w.node;
          D && (W = D(W));
          const X = u.types.isBooleanLiteral(I), H = X && I.value === false, U = !X && u.types.isUnaryExpression(I, { operator: "void" }), q = u.types.isExpressionStatement(w.parent) && !w.isCompletionRecord() || u.types.isSequenceExpression(w.parent) && (ee = w.parent.expressions)[ee.length - 1] !== w.node;
          var ee;
          const re = H ? C ? d : T : C ? S : y, Y = H ? "&&" : "||", Z = N.map(re).reduce((G, B) => u.types.logicalExpression(Y, G, B));
          w.replaceWith(X || U && q ? u.types.logicalExpression(Y, Z, W) : u.types.conditionalExpression(Z, I, W));
        }
        function h(E, _) {
          const { scope: C } = E, w = r(E), { parentPath: I } = w;
          if (I.isUnaryExpression({ operator: "delete" })) p(E, _, I, u.types.booleanLiteral(true));
          else {
            let D;
            I.isCallExpression({ callee: w.node }) && E.isOptionalMemberExpression() && (D = (j) => {
              var L;
              const k = c.skipTransparentExprWrapperNodes(j.object);
              let N;
              return _.pureGetters && f(k) || (N = C.maybeGenerateMemoised(k), N && (j.object = u.types.assignmentExpression("=", N, k))), u.types.callExpression(u.types.memberExpression(j, u.types.identifier("bind")), [u.types.cloneNode((L = N) != null ? L : k)]);
            }), p(E, _, E, e(w) ? u.types.booleanLiteral(false) : C.buildUndefinedNode(), D);
          }
        }
        var m = n.declare((E, _) => {
          var C, w;
          E.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
          const { loose: I = false } = _, D = (C = E.assumption("noDocumentAll")) != null ? C : I, j = (w = E.assumption("pureGetters")) != null ? w : I;
          return { name: "transform-optional-chaining", manipulateOptions: (L, k) => k.plugins.push("optionalChaining"), visitor: { "OptionalCallExpression|OptionalMemberExpression"(L) {
            h(L, { noDocumentAll: D, pureGetters: j });
          } } };
        });
        t.default = m, t.transform = h, t.transformOptionalChain = p;
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c) {
          const { name: e } = u.node.id, r = u.parentPath.isExportNamedDeclaration();
          let f = r;
          !f && c.isProgram(u.parent) && (f = u.parent.body.some((T) => c.isExportNamedDeclaration(T) && T.exportKind !== "type" && !T.source && T.specifiers.some((d) => c.isExportSpecifier(d) && d.exportKind !== "type" && d.local.name === e)));
          const { enumValues: y } = (0, n.translateEnumValues)(u, c);
          if (f) {
            const T = c.objectExpression(y.map(([d, p]) => c.objectProperty(c.isValidIdentifier(d) ? c.identifier(d) : c.stringLiteral(d), p)));
            return void (u.scope.hasOwnBinding(e) ? (r ? u.parentPath : u).replaceWith(c.expressionStatement(c.callExpression(c.memberExpression(c.identifier("Object"), c.identifier("assign")), [u.node.id, T]))) : (u.replaceWith(c.variableDeclaration("var", [c.variableDeclarator(u.node.id, T)])), u.scope.registerDeclaration(u)));
          }
          const S = new Map(y);
          u.scope.path.traverse({ Scope(T) {
            T.scope.hasOwnBinding(e) && T.skip();
          }, MemberExpression(T) {
            if (!c.isIdentifier(T.node.object, { name: e })) return;
            let d;
            if (T.node.computed) {
              if (!c.isStringLiteral(T.node.property)) return;
              d = T.node.property.value;
            } else {
              if (!c.isIdentifier(T.node.property)) return;
              d = T.node.property.name;
            }
            S.has(d) && T.replaceWith(c.cloneNode(S.get(d)));
          } }), u.remove();
        };
        var n = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/enum.js");
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/enum.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(_, C) {
          const { node: w, parentPath: I } = _;
          if (w.declare) return void _.remove();
          const D = w.id.name, { fill: j, data: L, isPure: k } = function(N, F, W) {
            const { enumValues: X, data: H, isPure: U } = m(N, F), q = X.map(([ee, re]) => T(d(re), { ENUM: F.cloneNode(W), NAME: ee, VALUE: re }));
            return { fill: { ID: F.cloneNode(W), ASSIGNMENTS: q }, data: H, isPure: U };
          }(_, C, w.id);
          switch (I.type) {
            case "BlockStatement":
            case "ExportNamedDeclaration":
            case "Program": {
              const N = C.isProgram(_.parent), F = function H(U) {
                return U.isExportDeclaration() ? H(U.parentPath) : !!U.getData(D) || (U.setData(D, true), false);
              }(I);
              let W = C.objectExpression([]);
              (F || N) && (W = C.logicalExpression("||", C.cloneNode(j.ID), W));
              const X = f(Object.assign({}, j, { INIT: W }));
              k && (0, c.default)(X), F ? (I.isExportDeclaration() ? I : _).replaceWith(C.expressionStatement(C.assignmentExpression("=", C.cloneNode(w.id), X))) : _.scope.registerDeclaration(_.replaceWith(C.variableDeclaration(N ? "var" : "let", [C.variableDeclarator(w.id, X)]))[0]), r.set(_.scope.getBindingIdentifier(D), L);
              break;
            }
            default:
              throw new Error(`Unexpected enum parent '${_.parent.type}`);
          }
        }, t.isSyntacticallyString = d, t.translateEnumValues = m;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("assert"), c = l("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.25.9/node_modules/@babel/helper-annotate-as-pure/lib/index.js"), e = l("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.25.9/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js");
        const r = /* @__PURE__ */ new WeakMap(), f = n.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `), y = (0, n.template)(`
  ENUM["NAME"] = VALUE;
`), S = (0, n.template)(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`), T = (_, C) => (_ ? y : S)(C);
        function d(_) {
          switch ((_ = (0, e.skipTransparentExprWrapperNodes)(_)).type) {
            case "BinaryExpression": {
              const C = _.left, w = _.right;
              return _.operator === "+" && (d(C) || d(w));
            }
            case "TemplateLiteral":
            case "StringLiteral":
              return true;
          }
          return false;
        }
        function p(_, C) {
          const { seen: w, path: I, t: D } = C, j = _.node.name;
          w.has(j) && !_.scope.hasOwnBinding(j) && (_.replaceWith(D.memberExpression(D.cloneNode(I.node.id), D.cloneNode(_.node))), _.skip());
        }
        const h = { ReferencedIdentifier: p };
        function m(_, C) {
          var w;
          const I = _.scope.getBindingIdentifier(_.node.id.name), D = (w = r.get(I)) != null ? w : /* @__PURE__ */ new Map();
          let j, L = -1, k = true;
          const N = _.get("members").map((F) => {
            const W = F.node, X = C.isIdentifier(W.id) ? W.id.name : W.id.value, H = F.get("initializer");
            let U;
            if (W.initializer) L = E(H, D), L !== void 0 ? (D.set(X, L), u(typeof L == "number" || typeof L == "string"), U = L === 1 / 0 || Number.isNaN(L) ? C.identifier(String(L)) : L === -1 / 0 ? C.unaryExpression("-", C.identifier("Infinity")) : C.valueToNode(L)) : (k && (k = H.isPure()), H.isReferencedIdentifier() ? p(H, { t: C, seen: D, path: _ }) : H.traverse(h, { t: C, seen: D, path: _ }), U = H.node, D.set(X, void 0));
            else if (typeof L == "number") L += 1, U = C.numericLiteral(L), D.set(X, L);
            else {
              if (typeof L == "string") throw _.buildCodeFrameError("Enum member must have initializer.");
              {
                const q = C.memberExpression(C.cloneNode(_.node.id), C.stringLiteral(j), true);
                U = C.binaryExpression("+", C.numericLiteral(1), q), D.set(X, void 0);
              }
            }
            return j = X, [X, U];
          });
          return { isPure: k, data: D, enumValues: N };
        }
        function E(_, C, w = /* @__PURE__ */ new Set()) {
          return I(_);
          function I(j) {
            const L = j.node;
            switch (L.type) {
              case "MemberExpression":
              case "Identifier":
                return D(j, C, w);
              case "StringLiteral":
              case "NumericLiteral":
                return L.value;
              case "UnaryExpression":
                return function(k) {
                  const N = I(k.get("argument"));
                  if (N !== void 0) switch (k.node.operator) {
                    case "+":
                      return N;
                    case "-":
                      return -N;
                    case "~":
                      return ~N;
                    default:
                      return;
                  }
                }(j);
              case "BinaryExpression":
                return function(k) {
                  const N = I(k.get("left"));
                  if (N === void 0) return;
                  const F = I(k.get("right"));
                  if (F !== void 0) switch (k.node.operator) {
                    case "|":
                      return N | F;
                    case "&":
                      return N & F;
                    case ">>":
                      return N >> F;
                    case ">>>":
                      return N >>> F;
                    case "<<":
                      return N << F;
                    case "^":
                      return N ^ F;
                    case "*":
                      return N * F;
                    case "/":
                      return N / F;
                    case "+":
                      return N + F;
                    case "-":
                      return N - F;
                    case "%":
                      return N % F;
                    case "**":
                      return Math.pow(N, F);
                    default:
                      return;
                  }
                }(j);
              case "ParenthesizedExpression":
                return I(j.get("expression"));
              case "TemplateLiteral": {
                if (L.quasis.length === 1) return L.quasis[0].value.cooked;
                const k = j.get("expressions"), N = L.quasis;
                let F = "";
                for (let W = 0; W < N.length; W++) if (F += N[W].value.cooked, W + 1 < N.length) {
                  const X = D(k[W], C, w);
                  if (X === void 0) return;
                  F += X;
                }
                return F;
              }
              default:
                return;
            }
          }
          function D(j, L, k) {
            if (j.isMemberExpression()) {
              const N = j.node, F = N.object, W = N.property;
              if (!n.types.isIdentifier(F) || (N.computed ? !n.types.isStringLiteral(W) : !n.types.isIdentifier(W))) return;
              const X = j.scope.getBindingIdentifier(F.name), H = r.get(X);
              return H ? H.get(W.computed ? W.value : W.name) : void 0;
            }
            if (j.isIdentifier()) {
              const N = j.node.name;
              if (["Infinity", "NaN"].includes(N)) return Number(N);
              let F = L == null ? void 0 : L.get(N);
              return F !== void 0 ? F : k.has(j.node) ? void 0 : (k.add(j.node), F = E(j.resolve(), L, k), L == null ? void 0 : L.set(N, F), F);
            }
          }
        }
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/global-types.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.GLOBAL_TYPES = void 0, t.isGlobalType = function({ scope: n }, u) {
          return !n.hasBinding(u) && (!!l.get(n).has(u) || (console.warn(`The exported identifier "${u}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${u}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), false));
        }, t.registerGlobalType = function(n, u) {
          l.get(n).add(u);
        };
        const l = t.GLOBAL_TYPES = /* @__PURE__ */ new WeakMap();
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"), u = l("./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-typescript/lib/index.js"), c = l("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.25.9_@babel+core@7.26.0/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), e = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js"), r = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/enum.js"), f = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/global-types.js"), y = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/namespace.js");
        function S(m) {
          switch (m.parent.type) {
            case "TSTypeReference":
            case "TSExpressionWithTypeArguments":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return true;
            case "TSQualifiedName":
              return m.parentPath.findParent((E) => E.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
            case "ExportSpecifier":
              return m.parent.exportKind === "type" || m.parentPath.parent.exportKind === "type";
            default:
              return false;
          }
        }
        const T = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakSet();
        function p(m) {
          const E = m.getBindingIdentifiers();
          for (const _ of Object.keys(E)) {
            const C = m.scope.getBinding(_);
            C && C.identifier === E[_] && C.scope.removeBinding(_);
          }
          m.opts.noScope = true, m.remove(), m.opts.noScope = false;
        }
        function h(m, E, _, C, w = "") {
          if (E.file.get("@babel/plugin-transform-modules-*") !== "commonjs") throw m.buildCodeFrameError(`\`${_}\` is only supported when compiling modules to CommonJS.
Please consider using \`${C}\`${w}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
        }
        t.default = (0, n.declare)((m, E) => {
          const { types: _, template: C } = m;
          m.assertVersion(7);
          const w = /\*?\s*@jsx((?:Frag)?)\s+(\S+)/, { allowNamespaces: I = true, jsxPragma: D = "React.createElement", jsxPragmaFrag: j = "React.Fragment", onlyRemoveTypeImports: L = false, optimizeConstEnums: k = false } = E;
          var { allowDeclareFields: N = false } = E;
          const F = { field(U) {
            const { node: q } = U;
            if (!N && q.declare) throw U.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
            if (q.declare) {
              if (q.value) throw U.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
              q.decorators || U.remove();
            } else if (q.definite) {
              if (q.value) throw U.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
              N || q.decorators || _.isClassPrivateProperty(q) || U.remove();
            } else q.abstract ? U.remove() : N || q.value || q.decorators || _.isClassPrivateProperty(q) || U.remove();
            q.accessibility && (q.accessibility = null), q.abstract && (q.abstract = null), q.readonly && (q.readonly = null), q.optional && (q.optional = null), q.typeAnnotation && (q.typeAnnotation = null), q.definite && (q.definite = null), q.declare && (q.declare = null), q.override && (q.override = null);
          }, method({ node: U }) {
            U.accessibility && (U.accessibility = null), U.abstract && (U.abstract = null), U.optional && (U.optional = null), U.override && (U.override = null);
          }, constructor(U, q) {
            U.node.accessibility && (U.node.accessibility = null);
            const ee = [], { scope: re } = U;
            for (const Y of U.get("params")) {
              const Z = Y.node;
              if (Z.type === "TSParameterProperty") {
                const G = Z.parameter;
                if (d.has(G)) continue;
                let B;
                if (d.add(G), _.isIdentifier(G)) B = G;
                else {
                  if (!_.isAssignmentPattern(G) || !_.isIdentifier(G.left)) throw Y.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
                  B = G.left;
                }
                ee.push(C.statement.ast`
              this.${_.cloneNode(B)} = ${_.cloneNode(B)}
            `), Y.replaceWith(Y.get("parameter")), re.registerBinding("param", Y);
              }
            }
            (0, c.injectInitialization)(q, U, ee);
          } };
          return { name: "transform-typescript", inherits: u.default, visitor: { Pattern: X, Identifier: X, RestElement: X, Program: { enter(U, q) {
            const { file: ee } = q;
            let re = null, Y = null;
            const Z = U.scope;
            if (f.GLOBAL_TYPES.has(Z) || f.GLOBAL_TYPES.set(Z, /* @__PURE__ */ new Set()), ee.ast.comments) for (const z of ee.ast.comments) {
              const M = w.exec(z.value);
              M && (M[1] ? Y = M[2] : re = M[2]);
            }
            let G = re || D;
            G && ([G] = G.split("."));
            let B = Y || j;
            B && ([B] = B.split("."));
            for (let z of U.get("body")) if (z.isImportDeclaration()) {
              if (T.has(q.file.ast.program) || T.set(q.file.ast.program, true), z.node.importKind === "type") {
                for (const ie of z.node.specifiers) (0, f.registerGlobalType)(Z, ie.local.name);
                z.remove();
                continue;
              }
              const M = /* @__PURE__ */ new Set(), K = z.node.specifiers.length, Q = () => K > 0 && K === M.size;
              for (const ie of z.node.specifiers) if (ie.type === "ImportSpecifier" && ie.importKind === "type") {
                (0, f.registerGlobalType)(Z, ie.local.name);
                const ue = z.scope.getBinding(ie.local.name);
                ue && M.add(ue.path);
              }
              if (L) T.set(U.node, false);
              else {
                if (z.node.specifiers.length === 0) {
                  T.set(U.node, false);
                  continue;
                }
                for (const ie of z.node.specifiers) {
                  const ue = z.scope.getBinding(ie.local.name);
                  ue && !M.has(ue.path) && (H({ binding: ue, programPath: U, pragmaImportName: G, pragmaFragImportName: B }) ? M.add(ue.path) : T.set(U.node, false));
                }
              }
              if (Q() && !L) z.remove();
              else for (const ie of M) ie.remove();
            } else if (z.isExportDeclaration() && (z = z.get("declaration")), z.isVariableDeclaration({ declare: true })) for (const M of Object.keys(z.getBindingIdentifiers())) (0, f.registerGlobalType)(Z, M);
            else (z.isTSTypeAliasDeclaration() || z.isTSDeclareFunction() && z.get("id").isIdentifier() || z.isTSInterfaceDeclaration() || z.isClassDeclaration({ declare: true }) || z.isTSEnumDeclaration({ declare: true }) || z.isTSModuleDeclaration({ declare: true }) && z.get("id").isIdentifier()) && (0, f.registerGlobalType)(Z, z.node.id.name);
          }, exit(U) {
            U.node.sourceType === "module" && T.get(U.node) && U.pushContainer("body", _.exportNamedDeclaration());
          } }, ExportNamedDeclaration(U, q) {
            if (T.has(q.file.ast.program) || T.set(q.file.ast.program, true), U.node.exportKind !== "type") if (U.node.source && U.node.specifiers.length > 0 && U.node.specifiers.every((ee) => ee.type === "ExportSpecifier" && ee.exportKind === "type")) U.remove();
            else if (!U.node.source && U.node.specifiers.length > 0 && U.node.specifiers.every((ee) => _.isExportSpecifier(ee) && (0, f.isGlobalType)(U, ee.local.name))) U.remove();
            else {
              if (_.isTSModuleDeclaration(U.node.declaration)) {
                const ee = U.node.declaration;
                if (!_.isStringLiteral(ee.id)) {
                  const re = (0, y.getFirstIdentifier)(ee.id);
                  if (U.scope.hasOwnBinding(re.name)) U.replaceWith(ee);
                  else {
                    const [Y] = U.replaceWithMultiple([_.exportNamedDeclaration(_.variableDeclaration("let", [_.variableDeclarator(_.cloneNode(re))])), ee]);
                    U.scope.registerDeclaration(Y);
                  }
                }
              }
              T.set(q.file.ast.program, false);
            }
            else U.remove();
          }, ExportAllDeclaration(U) {
            U.node.exportKind === "type" && U.remove();
          }, ExportSpecifier(U) {
            (!U.parent.source && (0, f.isGlobalType)(U, U.node.local.name) || U.node.exportKind === "type") && U.remove();
          }, ExportDefaultDeclaration(U, q) {
            T.has(q.file.ast.program) || T.set(q.file.ast.program, true), _.isIdentifier(U.node.declaration) && (0, f.isGlobalType)(U, U.node.declaration.name) ? U.remove() : T.set(q.file.ast.program, false);
          }, TSDeclareFunction(U) {
            p(U);
          }, TSDeclareMethod(U) {
            p(U);
          }, VariableDeclaration(U) {
            U.node.declare && p(U);
          }, VariableDeclarator({ node: U }) {
            U.definite && (U.definite = null);
          }, TSIndexSignature(U) {
            U.remove();
          }, ClassDeclaration(U) {
            const { node: q } = U;
            q.declare && p(U);
          }, Class(U) {
            const { node: q } = U;
            q.typeParameters && (q.typeParameters = null), q.superTypeParameters && (q.superTypeParameters = null), q.implements && (q.implements = null), q.abstract && (q.abstract = null), U.get("body.body").forEach((ee) => {
              ee.isClassMethod() || ee.isClassPrivateMethod() ? ee.node.kind === "constructor" ? F.constructor(ee, U) : F.method(ee) : (ee.isClassProperty() || ee.isClassPrivateProperty() || ee.isClassAccessorProperty()) && F.field(ee);
            });
          }, Function(U) {
            const { node: q } = U;
            q.typeParameters && (q.typeParameters = null), q.returnType && (q.returnType = null);
            const ee = q.params;
            ee.length > 0 && _.isIdentifier(ee[0], { name: "this" }) && ee.shift();
          }, TSModuleDeclaration(U) {
            (0, y.default)(U, I);
          }, TSInterfaceDeclaration(U) {
            U.remove();
          }, TSTypeAliasDeclaration(U) {
            U.remove();
          }, TSEnumDeclaration(U) {
            k && U.node.const ? (0, e.default)(U, _) : (0, r.default)(U, _);
          }, TSImportEqualsDeclaration(U, q) {
            const { id: ee, moduleReference: re, isExport: Y } = U.node;
            let Z, G;
            _.isTSExternalModuleReference(re) ? (h(U, q, `import ${ee.name} = require(...);`, `import ${ee.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option"), Z = _.callExpression(_.identifier("require"), [re.expression]), G = "const") : (Z = W(re), G = "var");
            const B = _.variableDeclaration(G, [_.variableDeclarator(ee, Z)]);
            U.replaceWith(Y ? _.exportNamedDeclaration(B) : B), U.scope.registerDeclaration(U);
          }, TSExportAssignment(U, q) {
            h(U, q, "export = <value>;", "export default <value>;"), U.replaceWith(C.statement.ast`module.exports = ${U.node.expression}`);
          }, TSTypeAssertion(U) {
            U.replaceWith(U.node.expression);
          }, ["TSAsExpression" + (_.tsSatisfiesExpression ? "|TSSatisfiesExpression" : "")](U) {
            let { node: q } = U;
            do
              q = q.expression;
            while (_.isTSAsExpression(q) || _.isTSSatisfiesExpression != null && _.isTSSatisfiesExpression(q));
            U.replaceWith(q);
          }, [m.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](U) {
            U.replaceWith(U.node.expression);
          }, CallExpression(U) {
            U.node.typeParameters = null;
          }, OptionalCallExpression(U) {
            U.node.typeParameters = null;
          }, NewExpression(U) {
            U.node.typeParameters = null;
          }, JSXOpeningElement(U) {
            U.node.typeParameters = null;
          }, TaggedTemplateExpression(U) {
            U.node.typeParameters = null;
          } } };
          function W(U) {
            return _.isTSQualifiedName(U) ? _.memberExpression(W(U.left), U.right) : U;
          }
          function X({ node: U }) {
            U.typeAnnotation && (U.typeAnnotation = null), _.isIdentifier(U) && U.optional && (U.optional = null);
          }
          function H({ binding: U, programPath: q, pragmaImportName: ee, pragmaFragImportName: re }) {
            for (const Z of U.referencePaths) if (!S(Z)) return false;
            if (U.identifier.name !== ee && U.identifier.name !== re) return true;
            let Y = false;
            return q.traverse({ "JSXElement|JSXFragment"(Z) {
              Y = true, Z.stop();
            } }), !Y;
          }
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/namespace.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(T, d) {
          if (T.node.declare || T.node.id.type === "StringLiteral") return void T.remove();
          if (!d) throw T.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const p = c(T.node.id).name, h = S(T, T.node);
          if (h === null) {
            const m = T.findParent((E) => E.isProgram());
            (0, u.registerGlobalType)(m.scope, p), T.remove();
          } else T.scope.hasOwnBinding(p) ? T.replaceWith(h) : T.scope.registerDeclaration(T.replaceWithMultiple([e(p), h])[0]);
        }, t.getFirstIdentifier = c;
        var n = l("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), u = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/global-types.js");
        function c(T) {
          return n.types.isIdentifier(T) ? T : c(T.left);
        }
        function e(T) {
          return n.types.variableDeclaration("let", [n.types.variableDeclarator(n.types.identifier(T))]);
        }
        function r(T, d) {
          return n.types.memberExpression(n.types.identifier(T), n.types.identifier(d));
        }
        function f(T, d, p) {
          if (T.kind !== "const") throw p.file.buildCodeFrameError(T, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const { declarations: h } = T;
          if (h.every((_) => n.types.isIdentifier(_.id))) {
            for (const _ of h) _.init = n.types.assignmentExpression("=", r(d, _.id.name), _.init);
            return [T];
          }
          const m = n.types.getBindingIdentifiers(T), E = [];
          for (const _ in m) E.push(n.types.assignmentExpression("=", r(d, _), n.types.cloneNode(m[_])));
          return [T, n.types.expressionStatement(n.types.sequenceExpression(E))];
        }
        function y(T, d) {
          return T.hub.buildError(d, "Ambient modules cannot be nested in other modules or namespaces.", Error);
        }
        function S(T, d, p) {
          const h = /* @__PURE__ */ new Set(), m = d.id, E = T.scope.generateUid(m.name), _ = d.body;
          let C;
          d.id, C = n.types.isTSModuleBlock(_) ? _.body : [n.types.exportNamedDeclaration(_)];
          let w = true;
          for (let D = 0; D < C.length; D++) {
            const j = C[D];
            switch (j.type) {
              case "TSModuleDeclaration": {
                if (!n.types.isIdentifier(j.id)) throw y(T, j);
                const L = S(T, j);
                if (L !== null) {
                  w = false;
                  const k = j.id.name;
                  h.has(k) ? C[D] = L : (h.add(k), C.splice(D++, 1, e(k), L));
                }
                continue;
              }
              case "TSEnumDeclaration":
              case "FunctionDeclaration":
              case "ClassDeclaration":
                w = false, h.add(j.id.name);
                continue;
              case "VariableDeclaration":
                w = false;
                for (const L in n.types.getBindingIdentifiers(j)) h.add(L);
                continue;
              default:
                w && (w = n.types.isTypeScript(j));
                continue;
              case "ExportNamedDeclaration":
            }
            if (!("declare" in j.declaration) || !j.declaration.declare) switch (j.declaration.type) {
              case "TSEnumDeclaration":
              case "FunctionDeclaration":
              case "ClassDeclaration": {
                w = false;
                const L = j.declaration.id.name;
                h.add(L), C.splice(D++, 1, j.declaration, n.types.expressionStatement(n.types.assignmentExpression("=", r(E, L), n.types.identifier(L))));
                break;
              }
              case "VariableDeclaration": {
                w = false;
                const L = f(j.declaration, E, T.hub);
                C.splice(D, L.length, ...L), D += L.length - 1;
                break;
              }
              case "TSModuleDeclaration": {
                if (!n.types.isIdentifier(j.declaration.id)) throw y(T, j.declaration);
                const L = S(T, j.declaration, n.types.identifier(E));
                if (L !== null) {
                  w = false;
                  const k = j.declaration.id.name;
                  h.has(k) ? C[D] = L : (h.add(k), C.splice(D++, 1, e(k), L));
                } else C.splice(D, 1), D--;
              }
            }
          }
          if (w) return null;
          let I = n.types.objectExpression([]);
          if (p) {
            const D = n.types.memberExpression(p, m);
            I = n.template.expression.ast`
      ${n.types.cloneNode(D)} ||
        (${n.types.cloneNode(D)} = ${I})
    `;
          }
          return n.template.statement.ast`
    (function (${n.types.identifier(E)}) {
      ${C}
    })(${m} || (${n.types.cloneNode(m)} = ${I}));
  `;
        }
      }, "./node_modules/.pnpm/@babel+preset-typescript@7.26.0_@babel+core@7.26.0/node_modules/@babel/preset-typescript/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true });
        var n = l("./node_modules/.pnpm/@babel+helper-plugin-utils@7.25.9/node_modules/@babel/helper-plugin-utils/lib/index.js"), u = l("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/index.js");
        l("./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-jsx/lib/index.js");
        var c = l("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"), e = l("./node_modules/.pnpm/@babel+helper-validator-option@7.25.9/node_modules/@babel/helper-validator-option/lib/index.js");
        function r(p) {
          return p && p.__esModule ? p : { default: p };
        }
        var f = r(u), y = r(c);
        const S = new e.OptionValidator("@babel/preset-typescript");
        var T = n.declare(function({ types: p, template: h }) {
          function m(E, _) {
            E && (p.isStringLiteral(E) ? /[\\/]/.test(E.value) && (E.value = E.value.replace(/(\.[mc]?)ts$/, "$1js").replace(/\.tsx$/, ".js")) : _.replaceWith(h.expression.ast`(${E} + "").replace(/([\\/].*\.[mc]?)tsx?$/, "$1js")`));
          }
          return { name: "preset-typescript/plugin-rewrite-ts-imports", visitor: { "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"(E) {
            const _ = E.node;
            (p.isImportDeclaration(_) ? _.importKind : _.exportKind) === "value" && m(_.source, E.get("source"));
          }, CallExpression(E) {
            p.isImport(E.node.callee) && m(E.node.arguments[0], E.get("arguments.0"));
          }, ImportExpression(E) {
            m(E.node.source, E.get("source"));
          } } };
        }), d = n.declarePreset((p, h) => {
          p.assertVersion(7);
          const { allExtensions: m, ignoreExtensions: E, allowNamespaces: _, disallowAmbiguousJSXLike: C, isTSX: w, jsxPragma: I, jsxPragmaFrag: D, onlyRemoveTypeImports: j, optimizeConstEnums: L, rewriteImportExtensions: k } = function(W = {}) {
            let { allowNamespaces: X = true, jsxPragma: H, onlyRemoveTypeImports: U } = W;
            const q = "ignoreExtensions", ee = "disallowAmbiguousJSXLike", re = "jsxPragmaFrag", Y = "optimizeConstEnums", Z = "rewriteImportExtensions", G = "allExtensions", B = "isTSX", z = S.validateStringOption(re, W.jsxPragmaFrag, "React.Fragment");
            var M = S.validateBooleanOption(G, W.allExtensions, false), K = S.validateBooleanOption(B, W.isTSX, false);
            K && S.invariant(M, "isTSX:true requires allExtensions:true");
            const Q = S.validateBooleanOption(q, W.ignoreExtensions, false), ie = S.validateBooleanOption(ee, W.disallowAmbiguousJSXLike, false);
            ie && S.invariant(M, "disallowAmbiguousJSXLike:true requires allExtensions:true");
            const ue = { ignoreExtensions: Q, allowNamespaces: X, disallowAmbiguousJSXLike: ie, jsxPragma: H, jsxPragmaFrag: z, onlyRemoveTypeImports: U, optimizeConstEnums: S.validateBooleanOption(Y, W.optimizeConstEnums, false), rewriteImportExtensions: S.validateBooleanOption(Z, W.rewriteImportExtensions, false) };
            return ue.allExtensions = M, ue.isTSX = K, ue;
          }(h), N = (W) => ({ allowDeclareFields: h.allowDeclareFields, allowNamespaces: _, disallowAmbiguousJSXLike: W, jsxPragma: I, jsxPragmaFrag: D, onlyRemoveTypeImports: j, optimizeConstEnums: L }), F = (W, X) => [[f.default, Object.assign({ isTSX: W }, N(X))]];
          return { plugins: k ? [T] : [], overrides: m || E ? [{ plugins: F(w, C) }] : [{ test: /\.ts$/, plugins: F(false, false) }, { test: /\.mts$/, sourceType: "module", plugins: F(false, true) }, { test: /\.cts$/, sourceType: "unambiguous", plugins: [[y.default, { allowTopLevelThis: true }], [f.default, N(true)]] }, { test: /\.tsx$/, plugins: F(true, false) }] };
        });
        t.default = d;
      }, "./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/builder.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function f(y, S) {
          const T = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), p = S || (0, n.validate)(null);
          return Object.assign((h, ...m) => {
            if (typeof h == "string") {
              if (m.length > 1) throw new Error("Unexpected extra params.");
              return r((0, u.default)(y, h, (0, n.merge)(p, (0, n.validate)(m[0]))));
            }
            if (Array.isArray(h)) {
              let E = T.get(h);
              return E || (E = (0, c.default)(y, h, p), T.set(h, E)), r(E(m));
            }
            if (typeof h == "object" && h) {
              if (m.length > 0) throw new Error("Unexpected extra params.");
              return f(y, (0, n.merge)(p, (0, n.validate)(h)));
            }
            throw new Error("Unexpected template param " + typeof h);
          }, { ast: (h, ...m) => {
            if (typeof h == "string") {
              if (m.length > 1) throw new Error("Unexpected extra params.");
              return (0, u.default)(y, h, (0, n.merge)((0, n.merge)(p, (0, n.validate)(m[0])), e))();
            }
            if (Array.isArray(h)) {
              let E = d.get(h);
              return E || (E = (0, c.default)(y, h, (0, n.merge)(p, e)), d.set(h, E)), E(m)();
            }
            throw new Error("Unexpected template param " + typeof h);
          } });
        };
        var n = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/options.js"), u = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/string.js"), c = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/literal.js");
        const e = (0, n.validate)({ placeholderPattern: false });
        function r(f) {
          let y = "";
          try {
            throw new Error();
          } catch (S) {
            S.stack && (y = S.stack.split(`
`).slice(3).join(`
`));
          }
          return (S) => {
            try {
              return f(S);
            } catch (T) {
              throw T.stack += `
    =============
${y}`, T;
            }
          };
        }
      }, "./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/formatters.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.statements = t.statement = t.smart = t.program = t.expression = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { assertExpressionStatement: u } = n;
        function c(r) {
          return { code: (f) => `/* @babel/template */;
${f}`, validate: () => {
          }, unwrap: (f) => r(f.program.body.slice(1)) };
        }
        t.smart = c((r) => r.length > 1 ? r : r[0]), t.statements = c((r) => r), t.statement = c((r) => {
          if (r.length === 0) throw new Error("Found nothing to return.");
          if (r.length > 1) throw new Error("Found multiple statements but wanted one");
          return r[0];
        });
        const e = t.expression = { code: (r) => `(
${r}
)`, validate: (r) => {
          if (r.program.body.length > 1) throw new Error("Found multiple statements but wanted one");
          if (e.unwrap(r).start === 0) throw new Error("Parse result included parens.");
        }, unwrap: ({ program: r }) => {
          const [f] = r.body;
          return u(f), f.expression;
        } };
        t.program = { code: (r) => r, validate: () => {
        }, unwrap: (r) => r.program };
      }, "./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.statements = t.statement = t.smart = t.program = t.expression = t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/formatters.js"), u = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/builder.js");
        const c = t.smart = (0, u.default)(n.smart), e = t.statement = (0, u.default)(n.statement), r = t.statements = (0, u.default)(n.statements), f = t.expression = (0, u.default)(n.expression), y = t.program = (0, u.default)(n.program);
        t.default = Object.assign(c.bind(void 0), { smart: c, statement: e, statements: r, expression: f, program: y, ast: c.ast });
      }, "./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/literal.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(e, r, f) {
          const { metadata: y, names: S } = function(T, d, p) {
            let h = "BABEL_TPL$";
            const m = d.join("");
            do
              h = "$$" + h;
            while (m.includes(h));
            const { names: E, code: _ } = function(w, I) {
              const D = [];
              let j = w[0];
              for (let L = 1; L < w.length; L++) {
                const k = `${I}${L - 1}`;
                D.push(k), j += k + w[L];
              }
              return { names: D, code: j };
            }(d, h);
            return { metadata: (0, u.default)(T, T.code(_), { parser: p.parser, placeholderWhitelist: new Set(E.concat(p.placeholderWhitelist ? Array.from(p.placeholderWhitelist) : [])), placeholderPattern: p.placeholderPattern, preserveComments: p.preserveComments, syntacticPlaceholders: p.syntacticPlaceholders }), names: E };
          }(e, r, f);
          return (T) => {
            const d = {};
            return T.forEach((p, h) => {
              d[S[h]] = p;
            }), (p) => {
              const h = (0, n.normalizeReplacements)(p);
              return h && Object.keys(h).forEach((m) => {
                if (hasOwnProperty.call(d, m)) throw new Error("Unexpected replacement overlap.");
              }), e.unwrap((0, c.default)(y, h ? Object.assign(h, d) : d));
            };
          };
        };
        var n = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/options.js"), u = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/parse.js"), c = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/options.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.merge = function(n, u) {
          const { placeholderWhitelist: c = n.placeholderWhitelist, placeholderPattern: e = n.placeholderPattern, preserveComments: r = n.preserveComments, syntacticPlaceholders: f = n.syntacticPlaceholders } = u;
          return { parser: Object.assign({}, n.parser, u.parser), placeholderWhitelist: c, placeholderPattern: e, preserveComments: r, syntacticPlaceholders: f };
        }, t.normalizeReplacements = function(n) {
          if (Array.isArray(n)) return n.reduce((u, c, e) => (u["$" + e] = c, u), {});
          if (typeof n == "object" || n == null) return n || void 0;
          throw new Error("Template replacements must be an array, object, null, or undefined");
        }, t.validate = function(n) {
          if (n != null && typeof n != "object") throw new Error("Unknown template options.");
          const u = n || {}, { placeholderWhitelist: c, placeholderPattern: e, preserveComments: r, syntacticPlaceholders: f } = u, y = function(S, T) {
            if (S == null) return {};
            var d = {};
            for (var p in S) if ({}.hasOwnProperty.call(S, p)) {
              if (T.includes(p)) continue;
              d[p] = S[p];
            }
            return d;
          }(u, l);
          if (c != null && !(c instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
          if (e != null && !(e instanceof RegExp) && e !== false) throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
          if (r != null && typeof r != "boolean") throw new Error("'.preserveComments' must be a boolean, null, or undefined");
          if (f != null && typeof f != "boolean") throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
          if (f === true && (c != null || e != null)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          return { parser: y, placeholderWhitelist: c || void 0, placeholderPattern: e ?? void 0, preserveComments: r ?? void 0, syntacticPlaceholders: f ?? void 0 };
        };
        const l = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
      }, "./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/parse.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(w, I, D) {
          const { placeholderWhitelist: j, placeholderPattern: L, preserveComments: k, syntacticPlaceholders: N } = D, F = function(X, H, U) {
            const q = (H.plugins || []).slice();
            U !== false && q.push("placeholders"), H = Object.assign({ allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, sourceType: "module" }, H, { plugins: q });
            try {
              return (0, u.parse)(X, H);
            } catch (ee) {
              const re = ee.loc;
              throw re && (ee.message += `
` + (0, c.codeFrameColumns)(X, { start: re }), ee.code = "BABEL_TEMPLATE_PARSE_ERROR"), ee;
            }
          }(I, D.parser, N);
          m(F, { preserveComments: k }), w.validate(F);
          const W = { syntactic: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, legacy: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, placeholderWhitelist: j, placeholderPattern: L, syntacticPlaceholders: N };
          return E(F, C, W), Object.assign({ ast: F }, W.syntactic.placeholders.length ? W.syntactic : W.legacy);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+parser@7.26.3/node_modules/@babel/parser/lib/index.js"), c = l("./stubs/babel-codeframe.js");
        const { isCallExpression: e, isExpressionStatement: r, isFunction: f, isIdentifier: y, isJSXIdentifier: S, isNewExpression: T, isPlaceholder: d, isStatement: p, isStringLiteral: h, removePropertiesDeep: m, traverse: E } = n, _ = /^[_$A-Z0-9]+$/;
        function C(w, I, D) {
          var j;
          let L, k = D.syntactic.placeholders.length > 0;
          if (d(w)) {
            if (D.syntacticPlaceholders === false) throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
            L = w.name.name, k = true;
          } else {
            if (k || D.syntacticPlaceholders) return;
            if (y(w) || S(w)) L = w.name;
            else {
              if (!h(w)) return;
              L = w.value;
            }
          }
          if (k && (D.placeholderPattern != null || D.placeholderWhitelist != null)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          if (!(k || D.placeholderPattern !== false && (D.placeholderPattern || _).test(L) || (j = D.placeholderWhitelist) != null && j.has(L))) return;
          I = I.slice();
          const { node: N, key: F } = I[I.length - 1];
          let W;
          h(w) || d(w, { expectedNode: "StringLiteral" }) ? W = "string" : T(N) && F === "arguments" || e(N) && F === "arguments" || f(N) && F === "params" ? W = "param" : r(N) && !d(w) ? (W = "statement", I = I.slice(0, -1)) : W = p(w) && d(w) ? "statement" : "other";
          const { placeholders: X, placeholderNames: H } = k ? D.syntactic : D.legacy;
          X.push({ name: L, type: W, resolve: (U) => function(q, ee) {
            let re = q;
            for (let G = 0; G < ee.length - 1; G++) {
              const { key: B, index: z } = ee[G];
              re = z === void 0 ? re[B] : re[B][z];
            }
            const { key: Y, index: Z } = ee[ee.length - 1];
            return { parent: re, key: Y, index: Z };
          }(U, I), isDuplicate: H.has(L) }), H.add(L);
        }
      }, "./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/populate.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(p, h) {
          const m = c(p.ast);
          return h && (p.placeholders.forEach((E) => {
            if (!hasOwnProperty.call(h, E.name)) {
              const _ = E.name;
              throw new Error(`Error: No substitution given for "${_}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${_}'])}
            - { placeholderPattern: /^${_}$/ }`);
            }
          }), Object.keys(h).forEach((E) => {
            if (!p.placeholderNames.has(E)) throw new Error(`Unknown substitution "${E}" given`);
          })), p.placeholders.slice().reverse().forEach((E) => {
            try {
              (function(_, C, w) {
                _.isDuplicate && (Array.isArray(w) ? w = w.map((k) => c(k)) : typeof w == "object" && (w = c(w)));
                const { parent: I, key: D, index: j } = _.resolve(C);
                if (_.type === "string") {
                  if (typeof w == "string" && (w = T(w)), !w || !S(w)) throw new Error("Expected string substitution");
                } else if (_.type === "statement") j === void 0 ? w ? Array.isArray(w) ? w = u(w) : typeof w == "string" ? w = r(f(w)) : y(w) || (w = r(w)) : w = e() : w && !Array.isArray(w) && (typeof w == "string" && (w = f(w)), y(w) || (w = r(w)));
                else if (_.type === "param") {
                  if (typeof w == "string" && (w = f(w)), j === void 0) throw new Error("Assertion failure.");
                } else if (typeof w == "string" && (w = f(w)), Array.isArray(w)) throw new Error("Cannot replace single expression with an array.");
                function L(k, N, F) {
                  const W = k[N];
                  k[N] = F, W.type !== "Identifier" && W.type !== "Placeholder" || (W.typeAnnotation && (F.typeAnnotation = W.typeAnnotation), W.optional && (F.optional = W.optional), W.decorators && (F.decorators = W.decorators));
                }
                if (j === void 0) d(I, D, w), L(I, D, w);
                else {
                  const k = I[D].slice();
                  _.type === "statement" || _.type === "param" ? w == null ? k.splice(j, 1) : Array.isArray(w) ? k.splice(j, 1, ...w) : L(k, j, w) : L(k, j, w), d(I, D, k), I[D] = k;
                }
              })(E, m, h && h[E.name] || null);
            } catch (_) {
              throw _.message = `@babel/template placeholder "${E.name}": ${_.message}`, _;
            }
          }), m;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { blockStatement: u, cloneNode: c, emptyStatement: e, expressionStatement: r, identifier: f, isStatement: y, isStringLiteral: S, stringLiteral: T, validate: d } = n;
      }, "./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/string.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(e, r, f) {
          let y;
          return r = e.code(r), (S) => {
            const T = (0, n.normalizeReplacements)(S);
            return y || (y = (0, u.default)(e, r, f)), e.unwrap((0, c.default)(y, T));
          };
        };
        var n = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/options.js"), u = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/parse.js"), c = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.clear = function() {
          u(), c();
        }, t.clearPath = u, t.clearScope = c, t.getCachedPaths = function(r, f) {
          var y;
          return (y = l.get(e)) == null ? void 0 : y.get(f);
        }, t.getOrCreateCachedPaths = function(r, f) {
          let y = l.get(e);
          y || l.set(e, y = /* @__PURE__ */ new WeakMap());
          let S = y.get(f);
          return S || y.set(f, S = /* @__PURE__ */ new Map()), S;
        }, t.scope = t.path = void 0;
        let l = t.path = /* @__PURE__ */ new WeakMap(), n = t.scope = /* @__PURE__ */ new WeakMap();
        function u() {
          t.path = l = /* @__PURE__ */ new WeakMap();
        }
        function c() {
          t.scope = n = /* @__PURE__ */ new WeakMap();
        }
        const e = Object.freeze({});
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/context.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");
        const { VISITOR_KEYS: e } = u;
        t.default = class {
          constructor(r, f, y, S) {
            this.queue = null, this.priorityQueue = null, this.parentPath = S, this.scope = r, this.state = y, this.opts = f;
          }
          shouldVisit(r) {
            const f = this.opts;
            if (f.enter || f.exit || f[r.type]) return true;
            const y = e[r.type];
            if (y == null || !y.length) return false;
            for (const S of y) if (r[S]) return true;
            return false;
          }
          create(r, f, y, S) {
            return n.default.get({ parentPath: this.parentPath, parent: r, container: f, key: y, listKey: S });
          }
          maybeQueue(r, f) {
            this.queue && (f ? this.queue.push(r) : this.priorityQueue.push(r));
          }
          visitMultiple(r, f, y) {
            if (r.length === 0) return false;
            const S = [];
            for (let T = 0; T < r.length; T++) {
              const d = r[T];
              d && this.shouldVisit(d) && S.push(this.create(f, r, T, y));
            }
            return this.visitQueue(S);
          }
          visitSingle(r, f) {
            return !!this.shouldVisit(r[f]) && this.visitQueue([this.create(r, r, f)]);
          }
          visitQueue(r) {
            this.queue = r, this.priorityQueue = [];
            const f = /* @__PURE__ */ new WeakSet();
            let y = false, S = 0;
            for (; S < r.length; ) {
              const T = r[S];
              if (S++, c.resync.call(T), T.contexts.length !== 0 && T.contexts[T.contexts.length - 1] === this || c.pushContext.call(T, this), T.key === null) continue;
              const { node: d } = T;
              if (!f.has(d)) {
                if (d && f.add(d), T.visit()) {
                  y = true;
                  break;
                }
                if (this.priorityQueue.length && (y = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = r, y)) break;
              }
            }
            for (let T = 0; T < S; T++) c.popContext.call(r[T]);
            return this.queue = null, y;
          }
          visit(r, f) {
            const y = r[f];
            return !!y && (Array.isArray(y) ? this.visitMultiple(y, r, f) : this.visitSingle(r, f));
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/hub.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0, t.default = class {
          getCode() {
          }
          getScope() {
          }
          addHelper() {
            throw new Error("Helpers are not supported by the default hub.");
          }
          buildError(l, n, u = TypeError) {
            return new u(n);
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), Object.defineProperty(t, "Hub", { enumerable: true, get: function() {
          return y.default;
        } }), Object.defineProperty(t, "NodePath", { enumerable: true, get: function() {
          return r.default;
        } }), Object.defineProperty(t, "Scope", { enumerable: true, get: function() {
          return f.default;
        } }), t.visitors = t.default = void 0, l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/visitors.js");
        t.visitors = n;
        var u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"), e = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/traverse-node.js"), r = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"), f = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/index.js"), y = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/hub.js");
        const { VISITOR_KEYS: S, removeProperties: T, traverseFast: d } = u;
        function p(m, E = {}, _, C, w, I) {
          if (m) {
            if (!E.noScope && !_ && m.type !== "Program" && m.type !== "File") throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${m.type} node without passing scope and parentPath.`);
            if (!w && I) throw new Error("visitSelf can only be used when providing a NodePath.");
            S[m.type] && (n.explode(E), (0, e.traverseNode)(m, E, _, C, w, null, I));
          }
        }
        t.default = p;
        function h(m, E) {
          m.node.type === E.type && (E.has = true, m.stop());
        }
        p.visitors = n, p.verify = n.verify, p.explode = n.explode, p.cheap = function(m, E) {
          d(m, E);
        }, p.node = function(m, E, _, C, w, I) {
          (0, e.traverseNode)(m, E, _, C, w, I);
        }, p.clearNode = function(m, E) {
          T(m, E);
        }, p.removeProperties = function(m, E) {
          return d(m, p.clearNode, E), m;
        }, p.hasType = function(m, E, _) {
          if (_ != null && _.includes(m.type)) return false;
          if (m.type === E) return true;
          const C = { has: false, type: E };
          return p(m, { noScope: true, denylist: _, enter: h }, null, C), C.has;
        }, p.cache = c;
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/ancestry.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.find = function(c) {
          let e = this;
          do
            if (c(e)) return e;
          while (e = e.parentPath);
          return null;
        }, t.findParent = function(c) {
          let e = this;
          for (; e = e.parentPath; ) if (c(e)) return e;
          return null;
        }, t.getAncestry = function() {
          let c = this;
          const e = [];
          do
            e.push(c);
          while (c = c.parentPath);
          return e;
        }, t.getDeepestCommonAncestorFrom = function(c, e) {
          if (!c.length) return this;
          if (c.length === 1) return c[0];
          let r, f, y = 1 / 0;
          const S = c.map((d) => {
            const p = [];
            do
              p.unshift(d);
            while ((d = d.parentPath) && d !== this);
            return p.length < y && (y = p.length), p;
          }), T = S[0];
          e: for (let d = 0; d < y; d++) {
            const p = T[d];
            for (const h of S) if (h[d] !== p) break e;
            r = d, f = p;
          }
          if (f) return e ? e(f, r, S) : f;
          throw new Error("Couldn't find intersection");
        }, t.getEarliestCommonAncestorFrom = function(c) {
          return this.getDeepestCommonAncestorFrom(c, function(e, r, f) {
            let y;
            const S = u[e.type];
            for (const T of f) {
              const d = T[r + 1];
              if (!y) {
                y = d;
                continue;
              }
              if (d.listKey && y.listKey === d.listKey && d.key < y.key) {
                y = d;
                continue;
              }
              S.indexOf(y.parentKey) > S.indexOf(d.parentKey) && (y = d);
            }
            return y;
          });
        }, t.getFunctionParent = function() {
          return this.findParent((c) => c.isFunction());
        }, t.getStatementParent = function() {
          let c = this;
          do {
            if (!c.parentPath || Array.isArray(c.container) && c.isStatement()) break;
            c = c.parentPath;
          } while (c);
          if (c && (c.isProgram() || c.isFile())) throw new Error("File/Program node, we can't possibly find a statement parent to this");
          return c;
        }, t.inType = function(...c) {
          let e = this;
          for (; e; ) {
            for (const r of c) if (e.node.type === r) return true;
            e = e.parentPath;
          }
          return false;
        }, t.isAncestor = function(c) {
          return c.isDescendant(this);
        }, t.isDescendant = function(c) {
          return !!this.findParent((e) => e === c);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS: u } = n;
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/comments.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.addComment = function(r, f, y) {
          u(this.node, r, f, y);
        }, t.addComments = function(r, f) {
          c(this.node, r, f);
        }, t.shareCommentsWithSiblings = function() {
          if (typeof this.key == "string") return;
          const r = this.node;
          if (!r) return;
          const f = r.trailingComments, y = r.leadingComments;
          if (!f && !y) return;
          const S = this.getSibling(this.key - 1), T = this.getSibling(this.key + 1), d = !!S.node, p = !!T.node;
          d && (y && S.addComments("trailing", e(y, S.node.trailingComments)), f && !p && S.addComments("trailing", f)), p && (f && T.addComments("leading", e(f, T.node.leadingComments)), y && !d && T.addComments("leading", y));
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { addComment: u, addComments: c } = n;
        function e(r, f) {
          if (f == null || !f.length) return r;
          const y = new Set(f);
          return r.filter((S) => !y.has(S));
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t._call = f, t._getQueueContexts = function() {
          let E = this, _ = this.contexts;
          for (; !_.length && (E = E.parentPath, E); ) _ = E.contexts;
          return _;
        }, t._resyncKey = p, t._resyncList = h, t._resyncParent = d, t._resyncRemoved = function() {
          this.key != null && this.container && this.container[this.key] === this.node || c._markRemoved.call(this);
        }, t.call = r, t.isDenylisted = y, t.popContext = function() {
          this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
        }, t.pushContext = function(E) {
          this.contexts.push(E), this.setContext(E);
        }, t.requeue = function(E = this) {
          if (E.removed) return;
          const _ = this.contexts;
          for (const C of _) C.maybeQueue(E);
        }, t.requeueComputedKeyAndDecorators = function() {
          const { context: E, node: _ } = this;
          if (!e.isPrivate(_) && _.computed && E.maybeQueue(this.get("key")), _.decorators) for (const C of this.get("decorators")) E.maybeQueue(C);
        }, t.resync = function() {
          this.removed || (d.call(this), h.call(this), p.call(this));
        }, t.setContext = function(E) {
          return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, E && (this.context = E, this.state = E.state, this.opts = E.opts), T.call(this), this;
        }, t.setKey = m, t.setScope = T, t.setup = function(E, _, C, w) {
          this.listKey = C, this.container = _, this.parentPath = E || this.parentPath, m.call(this, w);
        }, t.skip = function() {
          this.shouldSkip = true;
        }, t.skipKey = function(E) {
          this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[E] = true;
        }, t.stop = function() {
          this._traverseFlags |= u.SHOULD_SKIP | u.SHOULD_STOP;
        }, t.visit = function() {
          var E, _;
          if (!this.node || this.isDenylisted() || (E = (_ = this.opts).shouldSkip) != null && E.call(_, this)) return false;
          const C = this.context;
          return this.shouldSkip || r.call(this, "enter") ? (this.debug("Skip..."), this.shouldStop) : (S(this, C), this.debug("Recursing into..."), this.shouldStop = (0, n.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), S(this, C), r.call(this, "exit"), this.shouldStop);
        };
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/traverse-node.js"), u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"), c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/removal.js"), e = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        function r(E) {
          const _ = this.opts;
          return this.debug(E), !(!this.node || !f.call(this, _[E])) || !!this.node && f.call(this, (C = _[this.node.type]) == null ? void 0 : C[E]);
          var C;
        }
        function f(E) {
          if (!E) return false;
          for (const _ of E) {
            if (!_) continue;
            const C = this.node;
            if (!C) return true;
            const w = _.call(this.state, this, this.state);
            if (w && typeof w == "object" && typeof w.then == "function") throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            if (w) throw new Error(`Unexpected return value from visitor method ${_}`);
            if (this.node !== C || this._traverseFlags > 0) return true;
          }
          return false;
        }
        function y() {
          var E;
          const _ = (E = this.opts.denylist) != null ? E : this.opts.blacklist;
          return _ == null ? void 0 : _.includes(this.node.type);
        }
        function S(E, _) {
          E.context !== _ && (E.context = _, E.state = _.state, E.opts = _.opts);
        }
        function T() {
          var E, _;
          if ((E = this.opts) != null && E.noScope) return;
          let C, w = this.parentPath;
          for (((this.key === "key" || this.listKey === "decorators") && w.isMethod() || this.key === "discriminant" && w.isSwitchStatement()) && (w = w.parentPath); w && !C; ) {
            var I;
            if ((I = w.opts) != null && I.noScope) return;
            C = w.scope, w = w.parentPath;
          }
          this.scope = this.getScope(C), (_ = this.scope) == null || _.init();
        }
        function d() {
          this.parentPath && (this.parent = this.parentPath.node);
        }
        function p() {
          if (this.container && this.node !== this.container[this.key]) {
            if (Array.isArray(this.container)) {
              for (let E = 0; E < this.container.length; E++) if (this.container[E] === this.node) return void m.call(this, E);
            } else for (const E of Object.keys(this.container)) if (this.container[E] === this.node) return void m.call(this, E);
            this.key = null;
          }
        }
        function h() {
          if (!this.parent || !this.inList) return;
          const E = this.parent[this.listKey];
          this.container !== E && (this.container = E || null);
        }
        function m(E) {
          var _;
          this.key = E, this.node = this.container[this.key], this.type = (_ = this.node) == null ? void 0 : _.type;
        }
        t.isBlacklisted = y;
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/conversion.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.arrowFunctionToExpression = function({ allowInsertArrow: we = true, allowInsertArrowWithRest: me = we, noNewArrows: ye = !((pe) => (pe = arguments[0]) == null ? void 0 : pe.specCompliant)() } = {}) {
          if (!this.isArrowFunctionExpression()) throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
          let pe = this;
          var J;
          ye || (pe = (J = pe.ensureFunctionName(false)) != null ? J : pe);
          const { thisBinding: Ee, fnPath: Me } = ge(pe, ye, we, me);
          if (Me.ensureBlock(), function(Ue, qe) {
            Ue.node.type = qe;
          }(Me, "FunctionExpression"), !ye) {
            const Ue = Ee ? null : Me.scope.generateUidIdentifier("arrowCheckId");
            return Ue && Me.parentPath.scope.push({ id: Ue, init: j([]) }), Me.get("body").unshiftContainer("body", p(T(this.hub.addHelper("newArrowCheck"), [H(), h(Ue ? Ue.name : Ee)]))), Me.replaceWith(T(w(Me.node, h("bind")), [Ue ? h(Ue.name) : H()])), Me.get("callee.object");
          }
          return Me;
        }, t.ensureBlock = function() {
          const we = this.get("body"), me = we.node;
          if (Array.isArray(we)) throw new Error("Can't convert array path to a block statement");
          if (!me) throw new Error("Can't convert node without a body");
          if (we.isBlockStatement()) return me;
          const ye = [];
          let pe, J, Ee = "body";
          we.isStatement() ? (J = "body", pe = 0, ye.push(we.node)) : (Ee += ".body.0", this.isFunction() ? (pe = "argument", ye.push(k(we.node))) : (pe = "expression", ye.push(p(we.node)))), this.node.body = S(ye);
          const Me = this.get(Ee);
          return e.setup.call(we, Me, J ? Me.node[J] : Me.node, J, pe), this.node;
        }, t.ensureFunctionName = function(we) {
          if (this.node.id) return this;
          const me = G(this.node, this.parent);
          if (me == null) return this;
          let { name: ye } = me;
          if (!we && /[\uD800-\uDFFF]/.test(ye) || ye.startsWith("get ") || ye.startsWith("set ")) return null;
          ye = ee(ye.replace(/[/ ]/g, "_"));
          const pe = h(ye);
          ie(pe, me.originalNode);
          const J = { needsRename: false, name: ye }, { scope: Ee } = this, Me = Ee.getOwnBinding(ye);
          if (Me ? Me.kind === "param" && (J.needsRename = true) : (Ee.parent.hasBinding(ye) || Ee.hasGlobal(ye)) && this.traverse(xe, J), !J.needsRename) return this.node.id = pe, Ee.getProgramParent().references[pe.name] = true, this;
          if (Ee.hasBinding(pe.name) && !Ee.hasGlobal(pe.name)) return Ee.rename(pe.name), this.node.id = pe, Ee.getProgramParent().references[pe.name] = true, this;
          if (!re(this.node)) return null;
          const Ue = Ee.generateUidIdentifier(pe.name), qe = [];
          for (let Ie = 0, Re = function(Be) {
            const je = Be.params.findIndex((he) => Y(he) || Z(he));
            return je === -1 ? Be.params.length : je;
          }(this.node); Ie < Re; Ie++) qe.push(Ee.generateUidIdentifier("x"));
          const He = u.default.expression.ast`
    (function (${Ue}) {
      function ${pe}(${qe}) {
        return ${B(Ue)}.apply(this, arguments);
      }

      ${B(pe)}.toString = function () {
        return ${B(Ue)}.toString();
      }

      return ${B(pe)};
    })(${U(this.node)})
  `;
          return this.replaceWith(He)[0].get("arguments.0");
        }, t.splitExportDeclaration = function() {
          if (!this.isExportDeclaration() || this.isExportAllDeclaration()) throw new Error("Only default and named export declarations can be split.");
          if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
          const we = this.get("declaration");
          if (this.isExportDefaultDeclaration()) {
            const J = we.isFunctionDeclaration() || we.isClassDeclaration(), Ee = we.isFunctionExpression() || we.isClassExpression(), Me = we.isScope() ? we.scope.parent : we.scope;
            let Ue = we.node.id, qe = false;
            Ue ? Ee && Me.hasBinding(Ue.name) && (qe = true, Ue = Me.generateUidIdentifier(Ue.name)) : (qe = true, Ue = Me.generateUidIdentifier("default"), (J || Ee) && (we.node.id = B(Ue)));
            const He = J ? we.node : z("var", [M(B(Ue), we.node)]), Ie = K(null, [Q(B(Ue), h("default"))]);
            return this.insertAfter(Ie), this.replaceWith(He), qe && Me.registerDeclaration(this), this;
          }
          if (this.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
          const me = we.getOuterBindingIdentifiers(), ye = Object.keys(me).map((J) => Q(h(J), h(J))), pe = K(null, ye);
          return this.insertAfter(pe), this.replaceWith(we.node), this;
        }, t.toComputedKey = function() {
          let we;
          if (this.isMemberExpression()) we = this.node.property;
          else {
            if (!this.isProperty() && !this.isMethod()) throw new ReferenceError("todo");
            we = this.node.key;
          }
          return this.node.computed || m(we) && (we = W(we.name)), we;
        }, t.unwrapFunctionEnvironment = function() {
          if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
          ge(this);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js"), c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/visitors.js"), e = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");
        const { arrowFunctionExpression: r, assignmentExpression: f, binaryExpression: y, blockStatement: S, callExpression: T, conditionalExpression: d, expressionStatement: p, identifier: h, isIdentifier: m, jsxIdentifier: E, logicalExpression: _, LOGICAL_OPERATORS: C, memberExpression: w, metaProperty: I, numericLiteral: D, objectExpression: j, restElement: L, returnStatement: k, sequenceExpression: N, spreadElement: F, stringLiteral: W, super: X, thisExpression: H, toExpression: U, unaryExpression: q, toBindingIdentifierName: ee, isFunction: re, isAssignmentPattern: Y, isRestElement: Z, getFunctionName: G, cloneNode: B, variableDeclaration: z, variableDeclarator: M, exportNamedDeclaration: K, exportSpecifier: Q, inherits: ie } = n;
        t.arrowFunctionToShadowed = function() {
          this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
        };
        const ue = (0, c.environmentVisitor)({ CallExpression(we, { allSuperCalls: me }) {
          we.get("callee").isSuper() && me.push(we);
        } });
        function ge(we, me = true, ye = true, pe = true) {
          let J, Ee = we.findParent((je) => je.isArrowFunctionExpression() ? (J != null || (J = je), false) : je.isFunction() || je.isProgram() || je.isClassProperty({ static: false }) || je.isClassPrivateProperty({ static: false }));
          const Me = Ee.isClassMethod({ kind: "constructor" });
          if (Ee.isClassProperty() || Ee.isClassPrivateProperty()) if (J) Ee = J;
          else {
            if (!ye) throw we.buildCodeFrameError("Unable to transform arrow inside class property");
            we.replaceWith(T(r([], U(we.node)), [])), Ee = we.get("callee"), we = Ee.get("body");
          }
          const { thisPaths: Ue, argumentsPaths: qe, newTargetPaths: He, superProps: Ie, superCalls: Re } = function(je) {
            const he = [], oe = [], _e = [], Ne = [], $e = [];
            return je.traverse(Pe, { thisPaths: he, argumentsPaths: oe, newTargetPaths: _e, superProps: Ne, superCalls: $e }), { thisPaths: he, argumentsPaths: oe, newTargetPaths: _e, superProps: Ne, superCalls: $e };
          }(we);
          if (Me && Re.length > 0) {
            if (!ye) throw Re[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            if (!pe) throw Re[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            const je = [];
            Ee.traverse(ue, { allSuperCalls: je });
            const he = function(oe) {
              return fe(oe, "supercall", () => {
                const _e = oe.scope.generateUidIdentifier("args");
                return r([L(_e)], T(X(), [F(h(_e.name))]));
              });
            }(Ee);
            je.forEach((oe) => {
              const _e = h(he);
              _e.loc = oe.node.callee.loc, oe.get("callee").replaceWith(_e);
            });
          }
          if (qe.length > 0) {
            const je = fe(Ee, "arguments", () => {
              const he = () => h("arguments");
              return Ee.scope.path.isProgram() ? d(y("===", q("typeof", he()), W("undefined")), Ee.scope.buildUndefinedNode(), he()) : he();
            });
            qe.forEach((he) => {
              const oe = h(je);
              oe.loc = he.node.loc, he.replaceWith(oe);
            });
          }
          if (He.length > 0) {
            const je = fe(Ee, "newtarget", () => I(h("new"), h("target")));
            He.forEach((he) => {
              const oe = h(je);
              oe.loc = he.node.loc, he.replaceWith(oe);
            });
          }
          if (Ie.length > 0) {
            if (!ye) throw Ie[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            Ie.reduce((je, he) => je.concat(function(oe) {
              if (oe.parentPath.isAssignmentExpression() && oe.parentPath.node.operator !== "=") {
                const Ne = oe.parentPath, $e = Ne.node.operator.slice(0, -1), Xe = Ne.node.right, Je = function(st) {
                  return C.includes(st);
                }($e);
                if (oe.node.computed) {
                  const st = oe.scope.generateDeclaredUidIdentifier("tmp"), be = oe.node.object, ke = oe.node.property;
                  Ne.get("left").replaceWith(w(be, f("=", st, ke), true)), Ne.get("right").replaceWith(_e(Je ? "=" : $e, w(be, h(st.name), true), Xe));
                } else {
                  const st = oe.node.object, be = oe.node.property;
                  Ne.get("left").replaceWith(w(st, be)), Ne.get("right").replaceWith(_e(Je ? "=" : $e, w(st, h(be.name)), Xe));
                }
                return Je ? Ne.replaceWith(_($e, Ne.node.left, Ne.node.right)) : Ne.node.operator = "=", [Ne.get("left"), Ne.get("right").get("left")];
              }
              if (oe.parentPath.isUpdateExpression()) {
                const Ne = oe.parentPath, $e = oe.scope.generateDeclaredUidIdentifier("tmp"), Xe = oe.node.computed ? oe.scope.generateDeclaredUidIdentifier("prop") : null, Je = [f("=", $e, w(oe.node.object, Xe ? f("=", Xe, oe.node.property) : oe.node.property, oe.node.computed)), f("=", w(oe.node.object, Xe ? h(Xe.name) : oe.node.property, oe.node.computed), y(oe.parentPath.node.operator[0], h($e.name), D(1)))];
                return oe.parentPath.node.prefix || Je.push(h($e.name)), Ne.replaceWith(N(Je)), [Ne.get("expressions.0.right"), Ne.get("expressions.1.left")];
              }
              return [oe];
              function _e(Ne, $e, Xe) {
                return Ne === "=" ? f("=", $e, Xe) : y(Ne, $e, Xe);
              }
            }(he)), []).forEach((je) => {
              const he = je.node.computed ? "" : je.get("property").node.name, oe = je.parentPath, _e = oe.isAssignmentExpression({ left: je.node }), Ne = oe.isCallExpression({ callee: je.node }), $e = oe.isTaggedTemplateExpression({ tag: je.node }), Xe = function(be, ke, Ve) {
                return fe(be, `superprop_${ke ? "set" : "get"}:${Ve || ""}`, () => {
                  const rt = [];
                  let it;
                  if (Ve) it = w(X(), h(Ve));
                  else {
                    const Ye = be.scope.generateUidIdentifier("prop");
                    rt.unshift(Ye), it = w(X(), h(Ye.name), true);
                  }
                  if (ke) {
                    const Ye = be.scope.generateUidIdentifier("value");
                    rt.push(Ye), it = f("=", it, h(Ye.name));
                  }
                  return r(rt, it);
                });
              }(Ee, _e, he), Je = [];
              if (je.node.computed && Je.push(je.get("property").node), _e) {
                const be = oe.node.right;
                Je.push(be);
              }
              const st = T(h(Xe), Je);
              Ne ? (oe.unshiftContainer("arguments", H()), je.replaceWith(w(st, h("call"))), Ue.push(oe.get("arguments.0"))) : _e ? oe.replaceWith(st) : $e ? (je.replaceWith(T(w(st, h("bind"), false), [H()])), Ue.push(je.get("arguments.0"))) : je.replaceWith(st);
            });
          }
          let Be;
          return (Ue.length > 0 || !me) && (Be = function(je, he) {
            return fe(je, "this", (oe) => {
              if (!he || !Te(je)) return H();
              je.traverse(le, { supers: /* @__PURE__ */ new WeakSet(), thisBinding: oe });
            });
          }(Ee, Me), (me || Me && Te(Ee)) && (Ue.forEach((je) => {
            const he = je.isJSX() ? E(Be) : h(Be);
            he.loc = je.node.loc, je.replaceWith(he);
          }), me || (Be = null))), { thisBinding: Be, fnPath: we };
        }
        function Te(we) {
          return we.isClassMethod() && !!we.parentPath.parentPath.node.superClass;
        }
        const le = (0, c.environmentVisitor)({ CallExpression(we, { supers: me, thisBinding: ye }) {
          we.get("callee").isSuper() && (me.has(we.node) || (me.add(we.node), we.replaceWithMultiple([we.node, f("=", h(ye), h("this"))])));
        } });
        function fe(we, me, ye) {
          const pe = "binding:" + me;
          let J = we.getData(pe);
          if (!J) {
            const Ee = we.scope.generateUidIdentifier(me);
            J = Ee.name, we.setData(pe, J), we.scope.push({ id: Ee, init: ye(J) });
          }
          return J;
        }
        const Pe = (0, c.environmentVisitor)({ ThisExpression(we, { thisPaths: me }) {
          me.push(we);
        }, JSXIdentifier(we, { thisPaths: me }) {
          we.node.name === "this" && (we.parentPath.isJSXMemberExpression({ object: we.node }) || we.parentPath.isJSXOpeningElement({ name: we.node })) && me.push(we);
        }, CallExpression(we, { superCalls: me }) {
          we.get("callee").isSuper() && me.push(we);
        }, MemberExpression(we, { superProps: me }) {
          we.get("object").isSuper() && me.push(we);
        }, Identifier(we, { argumentsPaths: me }) {
          if (!we.isReferencedIdentifier({ name: "arguments" })) return;
          let ye = we.scope;
          do {
            if (ye.hasOwnBinding("arguments")) return void ye.rename("arguments");
            if (ye.path.isFunction() && !ye.path.isArrowFunctionExpression()) break;
          } while (ye = ye.parent);
          me.push(we);
        }, MetaProperty(we, { newTargetPaths: me }) {
          we.get("meta").isIdentifier({ name: "new" }) && we.get("property").isIdentifier({ name: "target" }) && me.push(we);
        } }), xe = { "ReferencedIdentifier|BindingIdentifier"(we, me) {
          we.node.name === me.name && (me.needsRename = true, we.stop());
        }, Scope(we, me) {
          we.scope.hasOwnBinding(me.name) && we.skip();
        } };
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/evaluation.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.evaluate = function() {
          const S = { confident: true, deoptPath: null, seen: /* @__PURE__ */ new Map() };
          let T = f(this, S);
          return S.confident || (T = void 0), { confident: S.confident, deopt: S.deoptPath, value: T };
        }, t.evaluateTruthy = function() {
          const S = this.evaluate();
          if (S.confident) return !!S.value;
        };
        const l = ["Number", "String", "Math"], n = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null], u = ["random"];
        function c(S) {
          return l.includes(S);
        }
        function e(S, T) {
          T.confident && (T.deoptPath = S, T.confident = false);
        }
        const r = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
        function f(S, T) {
          const { node: d } = S, { seen: p } = T;
          if (p.has(d)) {
            const h = p.get(d);
            return h.resolved ? h.value : void e(S, T);
          }
          {
            const h = { resolved: false };
            p.set(d, h);
            const m = function(E, _) {
              if (_.confident) {
                if (E.isSequenceExpression()) {
                  const C = E.get("expressions");
                  return f(C[C.length - 1], _);
                }
                if (E.isStringLiteral() || E.isNumericLiteral() || E.isBooleanLiteral()) return E.node.value;
                if (E.isNullLiteral()) return null;
                if (E.isTemplateLiteral()) return y(E, E.node.quasis, _);
                if (E.isTaggedTemplateExpression() && E.get("tag").isMemberExpression()) {
                  const C = E.get("tag.object"), { node: { name: w } } = C, I = E.get("tag.property");
                  if (C.isIdentifier() && w === "String" && !E.scope.getBinding(w) && I.isIdentifier() && I.node.name === "raw") return y(E, E.node.quasi.quasis, _, true);
                }
                if (E.isConditionalExpression()) {
                  const C = f(E.get("test"), _);
                  return _.confident ? f(C ? E.get("consequent") : E.get("alternate"), _) : void 0;
                }
                if (E.isExpressionWrapper()) return f(E.get("expression"), _);
                if (E.isMemberExpression() && !E.parentPath.isCallExpression({ callee: E.node })) {
                  const C = E.get("property"), w = E.get("object");
                  if (w.isLiteral()) {
                    const I = w.node.value, D = typeof I;
                    let j = null;
                    if (E.node.computed) {
                      if (j = f(C, _), !_.confident) return;
                    } else C.isIdentifier() && (j = C.node.name);
                    if (!(D !== "number" && D !== "string" || j == null || typeof j != "number" && typeof j != "string")) return I[j];
                  }
                }
                if (E.isReferencedIdentifier()) {
                  const C = E.scope.getBinding(E.node.name);
                  if (C) {
                    if (C.constantViolations.length > 0 || E.node.start < C.path.node.end) return void e(C.path, _);
                    if (C.hasValue) return C.value;
                  }
                  const w = E.node.name;
                  if (r.has(w)) return C ? void e(C.path, _) : r.get(w);
                  const I = E.resolve();
                  return I === E ? void e(E, _) : f(I, _);
                }
                if (E.isUnaryExpression({ prefix: true })) {
                  if (E.node.operator === "void") return;
                  const C = E.get("argument");
                  if (E.node.operator === "typeof" && (C.isFunction() || C.isClass())) return "function";
                  const w = f(C, _);
                  if (!_.confident) return;
                  switch (E.node.operator) {
                    case "!":
                      return !w;
                    case "+":
                      return +w;
                    case "-":
                      return -w;
                    case "~":
                      return ~w;
                    case "typeof":
                      return typeof w;
                  }
                }
                if (E.isArrayExpression()) {
                  const C = [], w = E.get("elements");
                  for (const I of w) {
                    const D = I.evaluate();
                    if (!D.confident) return void e(D.deopt, _);
                    C.push(D.value);
                  }
                  return C;
                }
                if (E.isObjectExpression()) {
                  const C = {}, w = E.get("properties");
                  for (const I of w) {
                    if (I.isObjectMethod() || I.isSpreadElement()) return void e(I, _);
                    const D = I.get("key");
                    let j;
                    if (I.node.computed) {
                      if (j = D.evaluate(), !j.confident) return void e(j.deopt, _);
                      j = j.value;
                    } else j = D.isIdentifier() ? D.node.name : D.node.value;
                    let L = I.get("value").evaluate();
                    if (!L.confident) return void e(L.deopt, _);
                    L = L.value, C[j] = L;
                  }
                  return C;
                }
                if (E.isLogicalExpression()) {
                  const C = _.confident, w = f(E.get("left"), _), I = _.confident;
                  _.confident = C;
                  const D = f(E.get("right"), _), j = _.confident;
                  switch (E.node.operator) {
                    case "||":
                      return _.confident = I && (!!w || j), _.confident ? w || D : void 0;
                    case "&&":
                      return _.confident = I && (!w || j), _.confident ? w && D : void 0;
                    case "??":
                      return _.confident = I && (w != null || j), _.confident ? w ?? D : void 0;
                  }
                }
                if (E.isBinaryExpression()) {
                  const C = f(E.get("left"), _);
                  if (!_.confident) return;
                  const w = f(E.get("right"), _);
                  if (!_.confident) return;
                  switch (E.node.operator) {
                    case "-":
                      return C - w;
                    case "+":
                      return C + w;
                    case "/":
                      return C / w;
                    case "*":
                      return C * w;
                    case "%":
                      return C % w;
                    case "**":
                      return Math.pow(C, w);
                    case "<":
                      return C < w;
                    case ">":
                      return C > w;
                    case "<=":
                      return C <= w;
                    case ">=":
                      return C >= w;
                    case "==":
                      return C == w;
                    case "!=":
                      return C != w;
                    case "===":
                      return C === w;
                    case "!==":
                      return C !== w;
                    case "|":
                      return C | w;
                    case "&":
                      return C & w;
                    case "^":
                      return C ^ w;
                    case "<<":
                      return C << w;
                    case ">>":
                      return C >> w;
                    case ">>>":
                      return C >>> w;
                  }
                }
                if (E.isCallExpression()) {
                  const C = E.get("callee");
                  let w, I;
                  if (C.isIdentifier() && !E.scope.getBinding(C.node.name) && (c(C.node.name) || function(D) {
                    return n.includes(D);
                  }(C.node.name)) && (I = Yn[C.node.name]), C.isMemberExpression()) {
                    const D = C.get("object"), j = C.get("property");
                    if (D.isIdentifier() && j.isIdentifier() && c(D.node.name) && !function(L) {
                      return u.includes(L);
                    }(j.node.name)) {
                      w = Yn[D.node.name];
                      const L = j.node.name;
                      hasOwnProperty.call(w, L) && (I = w[L]);
                    }
                    if (D.isLiteral() && j.isIdentifier()) {
                      const L = typeof D.node.value;
                      L !== "string" && L !== "number" || (w = D.node.value, I = w[j.node.name]);
                    }
                  }
                  if (I) {
                    const D = E.get("arguments").map((j) => f(j, _));
                    return _.confident ? I.apply(w, D) : void 0;
                  }
                }
                e(E, _);
              }
            }(S, T);
            return T.confident && (h.resolved = true, h.value = m), m;
          }
        }
        function y(S, T, d, p = false) {
          let h = "", m = 0;
          const E = S.isTemplateLiteral() ? S.get("expressions") : S.get("quasi.expressions");
          for (const _ of T) {
            if (!d.confident) break;
            h += p ? _.value.raw : _.value.cooked;
            const C = E[m++];
            C && (h += String(f(C, d)));
          }
          if (d.confident) return h;
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/family.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t._getKey = _, t._getPattern = C, t.get = function(w, I = true) {
          I === true && (I = this.context);
          const D = w.split(".");
          return D.length === 1 ? _.call(this, w, I) : C.call(this, D, I);
        }, t.getAllNextSiblings = function() {
          let w = this.key, I = this.getSibling(++w);
          const D = [];
          for (; I.node; ) D.push(I), I = this.getSibling(++w);
          return D;
        }, t.getAllPrevSiblings = function() {
          let w = this.key, I = this.getSibling(--w);
          const D = [];
          for (; I.node; ) D.push(I), I = this.getSibling(--w);
          return D;
        }, t.getAssignmentIdentifiers = function() {
          return c(this.node);
        }, t.getBindingIdentifierPaths = function(w = false, I = false) {
          const D = [this], j = /* @__PURE__ */ Object.create(null);
          for (; D.length; ) {
            const L = D.shift();
            if (!L || !L.node) continue;
            const k = e.keys[L.node.type];
            if (L.isIdentifier()) w ? (j[L.node.name] = j[L.node.name] || []).push(L) : j[L.node.name] = L;
            else if (L.isExportDeclaration()) {
              const N = L.get("declaration");
              N.isDeclaration() && D.push(N);
            } else {
              if (I) {
                if (L.isFunctionDeclaration()) {
                  D.push(L.get("id"));
                  continue;
                }
                if (L.isFunctionExpression()) continue;
              }
              if (k) for (let N = 0; N < k.length; N++) {
                const F = k[N], W = L.get(F);
                Array.isArray(W) ? D.push(...W) : W.node && D.push(W);
              }
            }
          }
          return j;
        }, t.getBindingIdentifiers = function(w) {
          return e(this.node, w);
        }, t.getCompletionRecords = function() {
          return E(this, { canHaveBreak: false, shouldPopulateBreak: false, inCaseClause: false }).map((w) => w.path);
        }, t.getNextSibling = function() {
          return this.getSibling(this.key + 1);
        }, t.getOpposite = function() {
          return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
        }, t.getOuterBindingIdentifierPaths = function(w = false) {
          return this.getBindingIdentifierPaths(w, true);
        }, t.getOuterBindingIdentifiers = function(w) {
          return r(this.node, w);
        }, t.getPrevSibling = function() {
          return this.getSibling(this.key - 1);
        }, t.getSibling = function(w) {
          return n.default.get({ parentPath: this.parentPath, parent: this.parent, container: this.container, listKey: this.listKey, key: w }).setContext(this.context);
        };
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { getAssignmentIdentifiers: c, getBindingIdentifiers: e, getOuterBindingIdentifiers: r, numericLiteral: f, unaryExpression: y } = u, S = 0, T = 1;
        function d(w, I, D) {
          return w && I.push(...E(w, D)), I;
        }
        function p(w) {
          w.forEach((I) => {
            I.type = T;
          });
        }
        function h(w, I) {
          w.forEach((D) => {
            D.path.isBreakStatement({ label: null }) && (I ? D.path.replaceWith(y("void", f(0))) : D.path.remove());
          });
        }
        function m(w, I) {
          const D = [];
          if (I.canHaveBreak) {
            let j = [];
            for (let L = 0; L < w.length; L++) {
              const k = w[L], N = Object.assign({}, I, { inCaseClause: false });
              k.isBlockStatement() && (I.inCaseClause || I.shouldPopulateBreak) ? N.shouldPopulateBreak = true : N.shouldPopulateBreak = false;
              const F = E(k, N);
              if (F.length > 0 && F.every((W) => W.type === T)) {
                j.length > 0 && F.every((W) => W.path.isBreakStatement({ label: null })) ? (p(j), D.push(...j), j.some((W) => W.path.isDeclaration()) && (D.push(...F), h(F, true)), h(F, false)) : (D.push(...F), I.shouldPopulateBreak || h(F, true));
                break;
              }
              if (L === w.length - 1) D.push(...F);
              else {
                j = [];
                for (let W = 0; W < F.length; W++) {
                  const X = F[W];
                  X.type === T && D.push(X), X.type === S && j.push(X);
                }
              }
            }
          } else if (w.length) for (let j = w.length - 1; j >= 0; j--) {
            const L = E(w[j], I);
            if (L.length > 1 || L.length === 1 && !L[0].path.isVariableDeclaration()) {
              D.push(...L);
              break;
            }
          }
          return D;
        }
        function E(w, I) {
          let D = [];
          if (w.isIfStatement()) D = d(w.get("consequent"), D, I), D = d(w.get("alternate"), D, I);
          else {
            if (w.isDoExpression() || w.isFor() || w.isWhile() || w.isLabeledStatement()) return d(w.get("body"), D, I);
            if (w.isProgram() || w.isBlockStatement()) return m(w.get("body"), I);
            if (w.isFunction()) return E(w.get("body"), I);
            if (w.isTryStatement()) D = d(w.get("block"), D, I), D = d(w.get("handler"), D, I);
            else {
              if (w.isCatchClause()) return d(w.get("body"), D, I);
              if (w.isSwitchStatement()) return function(j, L, k) {
                let N = [];
                for (let F = 0; F < j.length; F++) {
                  const W = E(j[F], k), X = [], H = [];
                  for (const U of W) U.type === S && X.push(U), U.type === T && H.push(U);
                  X.length && (N = X), L.push(...H);
                }
                return L.push(...N), L;
              }(w.get("cases"), D, I);
              if (w.isSwitchCase()) return m(w.get("consequent"), { canHaveBreak: true, shouldPopulateBreak: false, inCaseClause: true });
              w.isBreakStatement() ? D.push(/* @__PURE__ */ function(j) {
                return { type: T, path: j };
              }(w)) : D.push(/* @__PURE__ */ function(j) {
                return { type: S, path: j };
              }(w));
            }
          }
          return D;
        }
        function _(w, I) {
          const D = this.node, j = D[w];
          return Array.isArray(j) ? j.map((L, k) => n.default.get({ listKey: w, parentPath: this, parent: D, container: j, key: k }).setContext(I)) : n.default.get({ parentPath: this, parent: D, container: D, key: w }).setContext(I);
        }
        function C(w, I) {
          let D = this;
          for (const j of w) D = j === "." ? D.parentPath : Array.isArray(D) ? D[j] : D.get(j, I);
          return D;
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = t.SHOULD_STOP = t.SHOULD_SKIP = t.REMOVED = void 0;
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), u = l("./node_modules/.pnpm/debug@4.4.0/node_modules/debug/src/index.js"), c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js"), e = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/index.js"), r = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), f = r, y = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"), S = l("./node_modules/.pnpm/@babel+generator@7.26.3/node_modules/@babel/generator/lib/index.js"), T = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/ancestry.js"), d = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/index.js"), p = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/replacement.js"), h = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/evaluation.js"), m = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/conversion.js"), E = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/introspection.js"), _ = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js"), C = _, w = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/removal.js"), I = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/modification.js"), D = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/family.js"), j = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/comments.js"), L = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js");
        const { validate: k } = r, N = u("babel"), F = (t.REMOVED = 1, t.SHOULD_STOP = 2, t.SHOULD_SKIP = 4, t.default = class Um {
          constructor(H, U) {
            this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = U, this.hub = H, this.data = null, this.context = null, this.scope = null;
          }
          get removed() {
            return (1 & this._traverseFlags) > 0;
          }
          set removed(H) {
            H ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
          }
          get shouldStop() {
            return (2 & this._traverseFlags) > 0;
          }
          set shouldStop(H) {
            H ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
          }
          get shouldSkip() {
            return (4 & this._traverseFlags) > 0;
          }
          set shouldSkip(H) {
            H ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
          }
          static get({ hub: H, parentPath: U, parent: q, container: ee, listKey: re, key: Y }) {
            if (!H && U && (H = U.hub), !q) throw new Error("To get a node path the parent needs to exist");
            const Z = ee[Y], G = y.getOrCreateCachedPaths(H, q);
            let B = G.get(Z);
            return B || (B = new Um(H, q), Z && G.set(Z, B)), _.setup.call(B, U, ee, re, Y), B;
          }
          getScope(H) {
            return this.isScope() ? new e.default(this) : H;
          }
          setData(H, U) {
            return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[H] = U;
          }
          getData(H, U) {
            this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
            let q = this.data[H];
            return q === void 0 && U !== void 0 && (q = this.data[H] = U), q;
          }
          hasNode() {
            return this.node != null;
          }
          buildCodeFrameError(H, U = SyntaxError) {
            return this.hub.buildError(this.node, H, U);
          }
          traverse(H, U) {
            (0, c.default)(this.node, H, this.scope, U, this);
          }
          set(H, U) {
            k(this.node, H, U), this.node[H] = U;
          }
          getPathLocation() {
            const H = [];
            let U = this;
            do {
              let q = U.key;
              U.inList && (q = `${U.listKey}[${q}]`), H.unshift(q);
            } while (U = U.parentPath);
            return H.join(".");
          }
          debug(H) {
            N.enabled && N(`${this.getPathLocation()} ${this.type}: ${H}`);
          }
          toString() {
            return (0, S.default)(this.node).code;
          }
          get inList() {
            return !!this.listKey;
          }
          set inList(H) {
            H || (this.listKey = null);
          }
          get parentKey() {
            return this.listKey || this.key;
          }
        }), W = { findParent: T.findParent, find: T.find, getFunctionParent: T.getFunctionParent, getStatementParent: T.getStatementParent, getEarliestCommonAncestorFrom: T.getEarliestCommonAncestorFrom, getDeepestCommonAncestorFrom: T.getDeepestCommonAncestorFrom, getAncestry: T.getAncestry, isAncestor: T.isAncestor, isDescendant: T.isDescendant, inType: T.inType, getTypeAnnotation: d.getTypeAnnotation, isBaseType: d.isBaseType, couldBeBaseType: d.couldBeBaseType, baseTypeStrictlyMatches: d.baseTypeStrictlyMatches, isGenericType: d.isGenericType, replaceWithMultiple: p.replaceWithMultiple, replaceWithSourceString: p.replaceWithSourceString, replaceWith: p.replaceWith, replaceExpressionWithStatements: p.replaceExpressionWithStatements, replaceInline: p.replaceInline, evaluateTruthy: h.evaluateTruthy, evaluate: h.evaluate, toComputedKey: m.toComputedKey, ensureBlock: m.ensureBlock, unwrapFunctionEnvironment: m.unwrapFunctionEnvironment, arrowFunctionToExpression: m.arrowFunctionToExpression, splitExportDeclaration: m.splitExportDeclaration, ensureFunctionName: m.ensureFunctionName, matchesPattern: E.matchesPattern, isStatic: E.isStatic, isNodeType: E.isNodeType, canHaveVariableDeclarationOrExpression: E.canHaveVariableDeclarationOrExpression, canSwapBetweenExpressionAndStatement: E.canSwapBetweenExpressionAndStatement, isCompletionRecord: E.isCompletionRecord, isStatementOrBlock: E.isStatementOrBlock, referencesImport: E.referencesImport, getSource: E.getSource, willIMaybeExecuteBefore: E.willIMaybeExecuteBefore, _guessExecutionStatusRelativeTo: E._guessExecutionStatusRelativeTo, resolve: E.resolve, isConstantExpression: E.isConstantExpression, isInStrictMode: E.isInStrictMode, isDenylisted: C.isDenylisted, visit: C.visit, skip: C.skip, skipKey: C.skipKey, stop: C.stop, setContext: C.setContext, requeue: C.requeue, requeueComputedKeyAndDecorators: C.requeueComputedKeyAndDecorators, remove: w.remove, insertBefore: I.insertBefore, insertAfter: I.insertAfter, unshiftContainer: I.unshiftContainer, pushContainer: I.pushContainer, getOpposite: D.getOpposite, getCompletionRecords: D.getCompletionRecords, getSibling: D.getSibling, getPrevSibling: D.getPrevSibling, getNextSibling: D.getNextSibling, getAllNextSiblings: D.getAllNextSiblings, getAllPrevSiblings: D.getAllPrevSiblings, get: D.get, getAssignmentIdentifiers: D.getAssignmentIdentifiers, getBindingIdentifiers: D.getBindingIdentifiers, getOuterBindingIdentifiers: D.getOuterBindingIdentifiers, getBindingIdentifierPaths: D.getBindingIdentifierPaths, getOuterBindingIdentifierPaths: D.getOuterBindingIdentifierPaths, shareCommentsWithSiblings: j.shareCommentsWithSiblings, addComment: j.addComment, addComments: j.addComments };
        Object.assign(F.prototype, W), F.prototype.arrowFunctionToShadowed = m.arrowFunctionToShadowed, Object.assign(F.prototype, { has: E.has, is: E.is, isnt: E.isnt, equals: E.equals, hoist: I.hoist, updateSiblingKeys: I.updateSiblingKeys, call: C.call, isBlacklisted: C.isBlacklisted, setScope: C.setScope, resync: C.resync, popContext: C.popContext, pushContext: C.pushContext, setup: C.setup, setKey: C.setKey }), F.prototype._guessExecutionStatusRelativeToDifferentFunctions = E._guessExecutionStatusRelativeTo, F.prototype._guessExecutionStatusRelativeToDifferentFunctions = E._guessExecutionStatusRelativeTo, Object.assign(F.prototype, { _getTypeAnnotation: d._getTypeAnnotation, _replaceWith: p._replaceWith, _resolve: E._resolve, _call: C._call, _resyncParent: C._resyncParent, _resyncKey: C._resyncKey, _resyncList: C._resyncList, _resyncRemoved: C._resyncRemoved, _getQueueContexts: C._getQueueContexts, _removeFromScope: w._removeFromScope, _callRemovalHooks: w._callRemovalHooks, _remove: w._remove, _markRemoved: w._markRemoved, _assertUnremoved: w._assertUnremoved, _containerInsert: I._containerInsert, _containerInsertBefore: I._containerInsertBefore, _containerInsertAfter: I._containerInsertAfter, _verifyNodeList: I._verifyNodeList, _getKey: D._getKey, _getPattern: D._getPattern });
        for (const X of f.TYPES) {
          const H = `is${X}`, U = f[H];
          F.prototype[H] = function(q) {
            return U(this.node, q);
          }, F.prototype[`assert${X}`] = function(q) {
            if (!U(this.node, q)) throw new TypeError(`Expected node path of type ${X}`);
          };
        }
        Object.assign(F.prototype, L);
        for (const X of Object.keys(n)) X[0] !== "_" && (f.TYPES.includes(X) || f.TYPES.push(X));
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t._getTypeAnnotation = F, t.baseTypeStrictlyMatches = function(X) {
          const H = this.getTypeAnnotation(), U = X.getTypeAnnotation();
          return !e(H) && S(H) ? U.type === H.type : false;
        }, t.couldBeBaseType = function(X) {
          const H = this.getTypeAnnotation();
          if (e(H)) return true;
          if (D(H)) {
            for (const U of H.types) if (e(U) || W(X, U, true)) return true;
            return false;
          }
          return W(X, H, true);
        }, t.getTypeAnnotation = function() {
          let X = this.getData("typeAnnotation");
          return X ?? (X = F.call(this) || c(), (I(X) || _(X)) && (X = X.typeAnnotation), this.setData("typeAnnotation", X), X);
        }, t.isBaseType = function(X, H) {
          return W(X, this.getTypeAnnotation(), H);
        }, t.isGenericType = function(X) {
          const H = this.getTypeAnnotation();
          return X === "Array" && (E(H) || r(H) || w(H)) ? true : T(H) && d(H.id, { name: X }) || C(H) && d(H.typeName, { name: X });
        };
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/inferers.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { anyTypeAnnotation: c, isAnyTypeAnnotation: e, isArrayTypeAnnotation: r, isBooleanTypeAnnotation: f, isEmptyTypeAnnotation: y, isFlowBaseAnnotation: S, isGenericTypeAnnotation: T, isIdentifier: d, isMixedTypeAnnotation: p, isNumberTypeAnnotation: h, isStringTypeAnnotation: m, isTSArrayType: E, isTSTypeAnnotation: _, isTSTypeReference: C, isTupleTypeAnnotation: w, isTypeAnnotation: I, isUnionTypeAnnotation: D, isVoidTypeAnnotation: j, stringTypeAnnotation: L, voidTypeAnnotation: k } = u, N = /* @__PURE__ */ new WeakSet();
        function F() {
          const X = this.node;
          if (X) {
            if (X.typeAnnotation) return X.typeAnnotation;
            if (!N.has(X)) {
              N.add(X);
              try {
                var H;
                let U = n[X.type];
                if (U) return U.call(this, X);
                if (U = n[this.parentPath.type], (H = U) != null && H.validParent) return this.parentPath.getTypeAnnotation();
              } finally {
                N.delete(X);
              }
            }
          } else if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
            const U = this.parentPath.parentPath, q = U.parentPath;
            return U.key === "left" && q.isForInStatement() ? L() : U.key === "left" && q.isForOfStatement() ? c() : k();
          }
        }
        function W(X, H, U) {
          if (X === "string") return m(H);
          if (X === "number") return h(H);
          if (X === "boolean") return f(H);
          if (X === "any") return e(H);
          if (X === "mixed") return p(H);
          if (X === "empty") return y(H);
          if (X === "void") return j(H);
          if (U) return false;
          throw new Error(`Unknown base type ${X}`);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(d) {
          if (!this.isReferenced()) return;
          const p = this.scope.getBinding(d.name);
          if (p) return p.identifier.typeAnnotation ? p.identifier.typeAnnotation : function(h, m, E) {
            const _ = [], C = [];
            let w = y(h, m, C);
            const I = T(h, m, E);
            if (I) {
              const D = y(h, I.ifStatement);
              w = w.filter((j) => !D.includes(j)), _.push(I.typeAnnotation);
            }
            if (w.length) {
              w.push(...C);
              for (const D of w) _.push(D.getTypeAnnotation());
            }
            if (_.length) return (0, u.createUnionType)(_);
          }(p, this, d.name);
          if (d.name === "undefined") return f();
          if (d.name === "NaN" || d.name === "Infinity") return r();
          d.name;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/util.js");
        const { BOOLEAN_NUMBER_BINARY_OPERATORS: c, createTypeAnnotationBasedOnTypeof: e, numberTypeAnnotation: r, voidTypeAnnotation: f } = n;
        function y(d, p, h) {
          const m = d.constantViolations.slice();
          return m.unshift(d.path), m.filter((E) => {
            const _ = (E = E.resolve())._guessExecutionStatusRelativeTo(p);
            return h && _ === "unknown" && h.push(E), _ === "before";
          });
        }
        function S(d, p) {
          const h = p.node.operator, m = p.get("right").resolve(), E = p.get("left").resolve();
          let _, C, w;
          if (E.isIdentifier({ name: d }) ? _ = m : m.isIdentifier({ name: d }) && (_ = E), _) return h === "===" ? _.getTypeAnnotation() : c.includes(h) ? r() : void 0;
          if (h !== "===" && h !== "==" || (E.isUnaryExpression({ operator: "typeof" }) ? (C = E, w = m) : m.isUnaryExpression({ operator: "typeof" }) && (C = m, w = E), !C) || !C.get("argument").isIdentifier({ name: d }) || (w = w.resolve(), !w.isLiteral())) return;
          const I = w.node.value;
          return typeof I == "string" ? e(I) : void 0;
        }
        function T(d, p, h) {
          const m = function(C, w, I) {
            let D;
            for (; D = w.parentPath; ) {
              if (D.isIfStatement() || D.isConditionalExpression()) return w.key === "test" ? void 0 : D;
              if (D.isFunction() && D.parentPath.scope.getBinding(I) !== C) return;
              w = D;
            }
          }(d, p, h);
          if (!m) return;
          const E = [m.get("test")], _ = [];
          for (let C = 0; C < E.length; C++) {
            const w = E[C];
            if (w.isLogicalExpression()) w.node.operator === "&&" && (E.push(w.get("left")), E.push(w.get("right")));
            else if (w.isBinaryExpression()) {
              const I = S(h, w);
              I && _.push(I);
            }
          }
          return _.length ? { typeAnnotation: (0, u.createUnionType)(_), ifStatement: m } : T(d, m, h);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/inferers.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.ArrayExpression = F, t.AssignmentExpression = function() {
          return this.get("right").getTypeAnnotation();
        }, t.BinaryExpression = function(re) {
          const Y = re.operator;
          if (f.includes(Y)) return C();
          if (e.includes(Y)) return p();
          if (Y === "+") {
            const Z = this.get("right"), G = this.get("left");
            return G.isBaseType("number") && Z.isBaseType("number") ? C() : G.isBaseType("string") || Z.isBaseType("string") ? w() : D([w(), C()]);
          }
        }, t.BooleanLiteral = function() {
          return p();
        }, t.CallExpression = function() {
          const { callee: re } = this.node;
          return H(re) ? d(w()) : X(re) || U(re) || L(re, { name: "Array" }) ? d(T()) : q(re) ? d(I([w(), T()])) : ee(this.get("callee"));
        }, t.ConditionalExpression = function() {
          const re = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
          return (0, c.createUnionType)(re);
        }, t.ClassDeclaration = t.ClassExpression = t.FunctionDeclaration = t.ArrowFunctionExpression = t.FunctionExpression = function() {
          return m(E("Function"));
        }, Object.defineProperty(t, "Identifier", { enumerable: true, get: function() {
          return u.default;
        } }), t.LogicalExpression = function() {
          const re = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
          return (0, c.createUnionType)(re);
        }, t.NewExpression = function(re) {
          if (re.callee.type === "Identifier") return m(re.callee);
        }, t.NullLiteral = function() {
          return _();
        }, t.NumericLiteral = function() {
          return C();
        }, t.ObjectExpression = function() {
          return m(E("Object"));
        }, t.ParenthesizedExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, t.RegExpLiteral = function() {
          return m(E("RegExp"));
        }, t.RestElement = W, t.SequenceExpression = function() {
          return this.get("expressions").pop().getTypeAnnotation();
        }, t.StringLiteral = function() {
          return w();
        }, t.TSAsExpression = N, t.TSNonNullExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, t.TaggedTemplateExpression = function() {
          return ee(this.get("tag"));
        }, t.TemplateLiteral = function() {
          return w();
        }, t.TypeCastExpression = k, t.UnaryExpression = function(re) {
          const Y = re.operator;
          if (Y === "void") return j();
          if (y.includes(Y)) return C();
          if (S.includes(Y)) return w();
          if (r.includes(Y)) return p();
        }, t.UpdateExpression = function(re) {
          const Y = re.operator;
          if (Y === "++" || Y === "--") return C();
        }, t.VariableDeclarator = function() {
          if (this.get("id").isIdentifier()) return this.get("init").getTypeAnnotation();
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"), c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/util.js");
        const { BOOLEAN_BINARY_OPERATORS: e, BOOLEAN_UNARY_OPERATORS: r, NUMBER_BINARY_OPERATORS: f, NUMBER_UNARY_OPERATORS: y, STRING_UNARY_OPERATORS: S, anyTypeAnnotation: T, arrayTypeAnnotation: d, booleanTypeAnnotation: p, buildMatchMemberExpression: h, genericTypeAnnotation: m, identifier: E, nullLiteralTypeAnnotation: _, numberTypeAnnotation: C, stringTypeAnnotation: w, tupleTypeAnnotation: I, unionTypeAnnotation: D, voidTypeAnnotation: j, isIdentifier: L } = n;
        function k(re) {
          return re.typeAnnotation;
        }
        function N(re) {
          return re.typeAnnotation;
        }
        function F() {
          return m(E("Array"));
        }
        function W() {
          return F();
        }
        k.validParent = true, N.validParent = true, W.validParent = true;
        const X = h("Array.from"), H = h("Object.keys"), U = h("Object.values"), q = h("Object.entries");
        function ee(re) {
          if ((re = re.resolve()).isFunction()) {
            const { node: Y } = re;
            if (Y.async) return Y.generator ? m(E("AsyncIterator")) : m(E("Promise"));
            if (Y.generator) return m(E("Iterator"));
            if (re.node.returnType) return re.node.returnType;
          }
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/inference/util.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.createUnionType = function(y) {
          if (y.every((S) => r(S))) return u ? u(y) : e(y);
          if (y.every((S) => f(S)) && c) return c(y);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { createFlowUnionType: u, createTSUnionType: c, createUnionTypeAnnotation: e, isFlowType: r, isTSType: f } = n;
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/introspection.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t._guessExecutionStatusRelativeTo = function(w) {
          return _(this, w, /* @__PURE__ */ new Map());
        }, t._resolve = C, t.canHaveVariableDeclarationOrExpression = function() {
          return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
        }, t.canSwapBetweenExpressionAndStatement = function(w) {
          return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? false : this.isExpression() ? e(w) : this.isBlockStatement() ? r(w) : false;
        }, t.getSource = function() {
          const w = this.node;
          if (w.end) {
            const I = this.hub.getCode();
            if (I) return I.slice(w.start, w.end);
          }
          return "";
        }, t.isCompletionRecord = function(w) {
          let I = this, D = true;
          do {
            const { type: j, container: L } = I;
            if (!D && (I.isFunction() || j === "StaticBlock")) return !!w;
            if (D = false, Array.isArray(L) && I.key !== L.length - 1) return false;
          } while ((I = I.parentPath) && !I.isProgram() && !I.isDoExpression());
          return true;
        }, t.isConstantExpression = function() {
          if (this.isIdentifier()) {
            const w = this.scope.getBinding(this.node.name);
            return !!w && w.constant;
          }
          if (this.isLiteral()) return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((w) => w.isConstantExpression()));
          if (this.isUnaryExpression()) return this.node.operator === "void" && this.get("argument").isConstantExpression();
          if (this.isBinaryExpression()) {
            const { operator: w } = this.node;
            return w !== "in" && w !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
          }
          return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({ name: "Symbol" }) && !this.scope.hasBinding("Symbol", { noGlobals: true }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", { noGlobals: true }) && this.get("arguments")[0].isStringLiteral() : false;
        }, t.isInStrictMode = function() {
          return !!(this.isProgram() ? this : this.parentPath).find((I) => {
            if (I.isProgram({ sourceType: "module" }) || I.isClass()) return true;
            if (I.isArrowFunctionExpression() && !I.get("body").isBlockStatement()) return false;
            let D;
            if (I.isFunction()) D = I.node.body;
            else {
              if (!I.isProgram()) return false;
              D = I.node;
            }
            for (const j of D.directives) if (j.value.value === "use strict") return true;
          });
        }, t.isNodeType = function(w) {
          return T(this.type, w);
        }, t.isStatementOrBlock = function() {
          return !this.parentPath.isLabeledStatement() && !e(this.container) && u.includes(this.key);
        }, t.isStatic = function() {
          return this.scope.isStatic(this.node);
        }, t.matchesPattern = function(w, I) {
          return d(this.node, w, I);
        }, t.referencesImport = function(w, I) {
          if (!this.isReferencedIdentifier()) {
            if (this.isJSXMemberExpression() && this.node.property.name === I || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? S(this.node.property, { value: I }) : this.node.property.name === I)) {
              const k = this.get("object");
              return k.isReferencedIdentifier() && k.referencesImport(w, "*");
            }
            return false;
          }
          const D = this.scope.getBinding(this.node.name);
          if (!D || D.kind !== "module") return false;
          const j = D.path, L = j.parentPath;
          return !L.isImportDeclaration() || L.node.source.value !== w ? false : !!(!I || j.isImportDefaultSpecifier() && I === "default" || j.isImportNamespaceSpecifier() && I === "*" || j.isImportSpecifier() && f(j.node.imported, { name: I }));
        }, t.resolve = function(w, I) {
          return C.call(this, w, I) || this;
        }, t.willIMaybeExecuteBefore = function(w) {
          return this._guessExecutionStatusRelativeTo(w) !== "after";
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { STATEMENT_OR_BLOCK_KEYS: u, VISITOR_KEYS: c, isBlockStatement: e, isExpression: r, isIdentifier: f, isLiteral: y, isStringLiteral: S, isType: T, matchesPattern: d } = n;
        function p(w) {
          return w.isProgram() ? w : (w.parentPath.scope.getFunctionParent() || w.parentPath.scope.getProgramParent()).path;
        }
        function h(w, I) {
          switch (w) {
            case "LogicalExpression":
            case "AssignmentPattern":
              return I === "right";
            case "ConditionalExpression":
            case "IfStatement":
              return I === "consequent" || I === "alternate";
            case "WhileStatement":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForOfStatement":
              return I === "body";
            case "ForStatement":
              return I === "body" || I === "update";
            case "SwitchStatement":
              return I === "cases";
            case "TryStatement":
              return I === "handler";
            case "OptionalMemberExpression":
              return I === "property";
            case "OptionalCallExpression":
              return I === "arguments";
            default:
              return false;
          }
        }
        function m(w, I) {
          for (let D = 0; D < I; D++) {
            const j = w[D];
            if (h(j.parent.type, j.parentKey)) return true;
          }
          return false;
        }
        t.has = function(w) {
          var I;
          const D = (I = this.node) == null ? void 0 : I[w];
          return D && Array.isArray(D) ? !!D.length : !!D;
        }, t.is = t.has, t.isnt = function(w) {
          return !this.has(w);
        }, t.equals = function(w, I) {
          return this.node[w] === I;
        };
        const E = Symbol();
        function _(w, I, D) {
          const j = { this: p(w), target: p(I) };
          if (j.target.node !== j.this.node) return function(H, U, q) {
            let ee, re = q.get(H.node);
            if (re) {
              if (ee = re.get(U.node)) return ee === E ? "unknown" : ee;
            } else q.set(H.node, re = /* @__PURE__ */ new Map());
            re.set(U.node, E);
            const Y = function(Z, G, B) {
              if (!G.isFunctionDeclaration()) return _(Z, G, B) === "before" ? "before" : "unknown";
              if (G.parentPath.isExportDeclaration()) return "unknown";
              const z = G.scope.getBinding(G.node.id.name);
              if (!z.references) return "before";
              const M = z.referencePaths;
              let K;
              for (const Q of M) {
                if (Q.find((ue) => ue.node === G.node)) continue;
                if (Q.key !== "callee" || !Q.parentPath.isCallExpression()) return "unknown";
                const ie = _(Z, Q, B);
                if (K && K !== ie) return "unknown";
                K = ie;
              }
              return K;
            }(H, U, q);
            return re.set(U.node, Y), Y;
          }(w, j.target, D);
          const L = { target: I.getAncestry(), this: w.getAncestry() };
          if (L.target.includes(w)) return "after";
          if (L.this.includes(I)) return "before";
          let k;
          const N = { target: 0, this: 0 };
          for (; !k && N.this < L.this.length; ) {
            const H = L.this[N.this];
            N.target = L.target.indexOf(H), N.target >= 0 ? k = H : N.this++;
          }
          if (!k) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
          if (m(L.this, N.this - 1) || m(L.target, N.target - 1)) return "unknown";
          const F = { this: L.this[N.this - 1], target: L.target[N.target - 1] };
          if (F.target.listKey && F.this.listKey && F.target.container === F.this.container) return F.target.key > F.this.key ? "before" : "after";
          const W = c[k.type], X = W.indexOf(F.this.parentKey);
          return W.indexOf(F.target.parentKey) > X ? "before" : "after";
        }
        function C(w, I) {
          var D;
          if ((D = I) == null || !D.includes(this)) if ((I = I || []).push(this), this.isVariableDeclarator()) {
            if (this.get("id").isIdentifier()) return this.get("init").resolve(w, I);
          } else if (this.isReferencedIdentifier()) {
            const j = this.scope.getBinding(this.node.name);
            if (!j || !j.constant || j.kind === "module") return;
            if (j.path !== this) {
              const L = j.path.resolve(w, I);
              return this.find((k) => k.node === L.node) ? void 0 : L;
            }
          } else {
            if (this.isTypeCastExpression()) return this.get("expression").resolve(w, I);
            if (w && this.isMemberExpression()) {
              const j = this.toComputedKey();
              if (!y(j)) return;
              const L = j.value, k = this.get("object").resolve(w, I);
              if (k.isObjectExpression()) {
                const N = k.get("properties");
                for (const F of N) {
                  if (!F.isProperty()) continue;
                  const W = F.get("key");
                  let X = F.isnt("computed") && W.isIdentifier({ name: L });
                  if (X = X || W.isLiteral({ value: L }), X) return F.get("value").resolve(w, I);
                }
              } else if (k.isArrayExpression() && !isNaN(+L)) {
                const N = k.get("elements")[L];
                if (N) return N.resolve(w, I);
              }
            }
          }
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/hoister.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = n;
        const { react: c } = n, { cloneNode: e, jsxExpressionContainer: r, variableDeclaration: f, variableDeclarator: y } = u, S = { ReferencedIdentifier(T, d) {
          if (T.isJSXIdentifier() && c.isCompatTag(T.node.name) && !T.parentPath.isJSXMemberExpression()) return;
          if (T.node.name === "this") {
            let h = T.scope;
            do
              if (h.path.isFunction() && !h.path.isArrowFunctionExpression()) break;
            while (h = h.parent);
            h && d.breakOnScopePaths.push(h.path);
          }
          const p = T.scope.getBinding(T.node.name);
          if (p) {
            for (const h of p.constantViolations) if (h.scope !== p.path.scope) return d.mutableBinding = true, void T.stop();
            p === d.scope.getBinding(T.node.name) && (d.bindings[T.node.name] = p);
          }
        } };
        t.default = class {
          constructor(T, d) {
            this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = false, this.scopes = [], this.scope = d, this.path = T, this.attachAfter = false;
          }
          isCompatibleScope(T) {
            for (const d of Object.keys(this.bindings)) {
              const p = this.bindings[d];
              if (!T.bindingIdentifierEquals(d, p.identifier)) return false;
            }
            return true;
          }
          getCompatibleScopes() {
            let T = this.path.scope;
            do
              if (!this.isCompatibleScope(T) || (this.scopes.push(T), this.breakOnScopePaths.includes(T.path))) break;
            while (T = T.parent);
          }
          getAttachmentPath() {
            let T = this._getAttachmentPath();
            if (!T) return;
            let d = T.scope;
            if (d.path === T && (d = T.scope.parent), d.path.isProgram() || d.path.isFunction()) for (const p of Object.keys(this.bindings)) {
              if (!d.hasOwnBinding(p)) continue;
              const h = this.bindings[p];
              if (!(h.kind === "param" || h.path.parentKey === "params") && this.getAttachmentParentForPath(h.path).key >= T.key) {
                this.attachAfter = true, T = h.path;
                for (const m of h.constantViolations) this.getAttachmentParentForPath(m).key > T.key && (T = m);
              }
            }
            return T;
          }
          _getAttachmentPath() {
            const T = this.scopes.pop();
            if (T) {
              if (T.path.isFunction()) {
                if (!this.hasOwnParamBindings(T)) return this.getNextScopeAttachmentParent();
                {
                  if (this.scope === T) return;
                  const d = T.path.get("body").get("body");
                  for (let p = 0; p < d.length; p++) if (!d[p].node._blockHoist) return d[p];
                }
              } else if (T.path.isProgram()) return this.getNextScopeAttachmentParent();
            }
          }
          getNextScopeAttachmentParent() {
            const T = this.scopes.pop();
            if (T) return this.getAttachmentParentForPath(T.path);
          }
          getAttachmentParentForPath(T) {
            do
              if (!T.parentPath || Array.isArray(T.container) && T.isStatement()) return T;
            while (T = T.parentPath);
          }
          hasOwnParamBindings(T) {
            for (const d of Object.keys(this.bindings)) {
              if (!T.hasOwnBinding(d)) continue;
              const p = this.bindings[d];
              if (p.kind === "param" && p.constant) return true;
            }
            return false;
          }
          run() {
            if (this.path.traverse(S, this), this.mutableBinding) return;
            this.getCompatibleScopes();
            const T = this.getAttachmentPath();
            if (!T || T.getFunctionParent() === this.path.getFunctionParent()) return;
            let d = T.scope.generateUidIdentifier("ref");
            const p = y(d, this.path.node), h = this.attachAfter ? "insertAfter" : "insertBefore", [m] = T[h]([T.isVariableDeclarator() ? p : f("var", [p])]), E = this.path.parentPath;
            return E.isJSXElement() && this.path.container === E.node.children && (d = r(d)), this.path.replaceWith(e(d)), T.isVariableDeclarator() ? m.get("init") : m.get("declarations.0.init");
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.hooks = void 0, t.hooks = [function(l, n) {
          if (l.key === "test" && (n.isWhile() || n.isSwitchCase()) || l.key === "declaration" && n.isExportDeclaration() || l.key === "body" && n.isLabeledStatement() || l.listKey === "declarations" && n.isVariableDeclaration() && n.node.declarations.length === 1 || l.key === "expression" && n.isExpressionStatement()) return n.remove(), true;
        }, function(l, n) {
          if (n.isSequenceExpression() && n.node.expressions.length === 1) return n.replaceWith(n.node.expressions[0]), true;
        }, function(l, n) {
          if (n.isBinary()) return l.key === "left" ? n.replaceWith(n.node.right) : n.replaceWith(n.node.left), true;
        }, function(l, n) {
          if (n.isIfStatement() && l.key === "consequent" || l.key === "body" && (n.isLoop() || n.isArrowFunctionExpression())) return l.replaceWith({ type: "BlockStatement", body: [] }), true;
        }];
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.isBindingIdentifier = function() {
          const { node: F, parent: W } = this, X = this.parentPath.parent;
          return T(F) && u(F, W, X);
        }, t.isBlockScoped = function() {
          return c(this.node);
        }, t.isExpression = function() {
          return this.isIdentifier() ? this.isReferencedIdentifier() : r(this.node);
        }, t.isFlow = function() {
          const { node: F } = this;
          return !!f(F) || (d(F) ? F.importKind === "type" || F.importKind === "typeof" : e(F) ? F.exportKind === "type" : !!p(F) && (F.importKind === "type" || F.importKind === "typeof"));
        }, t.isForAwaitStatement = function() {
          return k(this.node, { await: true });
        }, t.isGenerated = function() {
          return !this.isUser();
        }, t.isPure = function(F) {
          return this.scope.isPure(this.node, F);
        }, t.isReferenced = function() {
          return C(this.node, this.parent);
        }, t.isReferencedIdentifier = function(F) {
          const { node: W, parent: X } = this;
          return !T(W, F) && !m(X, F) && (!h(W, F) || N(W.name)) ? false : C(W, X, this.parentPath.parent);
        }, t.isReferencedMemberExpression = function() {
          const { node: F, parent: W } = this;
          return E(F) && C(F, W);
        }, t.isRestProperty = function() {
          var F;
          return _(this.node) && ((F = this.parentPath) == null ? void 0 : F.isObjectPattern());
        }, t.isScope = function() {
          return w(this.node, this.parent);
        }, t.isSpreadProperty = function() {
          var F;
          return _(this.node) && ((F = this.parentPath) == null ? void 0 : F.isObjectExpression());
        }, t.isStatement = function() {
          const { node: F, parent: W } = this;
          return I(F) ? !(j(F) && (S(W, { left: F }) || y(W, { init: F }))) : false;
        }, t.isUser = function() {
          return this.node && !!this.node.loc;
        }, t.isVar = function() {
          return D(this.node);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { isBinding: u, isBlockScoped: c, isExportDeclaration: e, isExpression: r, isFlow: f, isForStatement: y, isForXStatement: S, isIdentifier: T, isImportDeclaration: d, isImportSpecifier: p, isJSXIdentifier: h, isJSXMemberExpression: m, isMemberExpression: E, isRestElement: _, isReferenced: C, isScope: w, isStatement: I, isVar: D, isVariableDeclaration: j, react: L, isForOfStatement: k } = n, { isCompatTag: N } = L;
        t.isExistentialTypeParam = function() {
          throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
        }, t.isNumericLiteralTypeAnnotation = function() {
          throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.Var = t.User = t.Statement = t.SpreadProperty = t.Scope = t.RestProperty = t.ReferencedMemberExpression = t.ReferencedIdentifier = t.Referenced = t.Pure = t.NumericLiteralTypeAnnotation = t.Generated = t.ForAwaitStatement = t.Flow = t.Expression = t.ExistentialTypeParam = t.BlockScoped = t.BindingIdentifier = void 0, t.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], t.ReferencedMemberExpression = ["MemberExpression"], t.BindingIdentifier = ["Identifier"], t.Statement = ["Statement"], t.Expression = ["Expression"], t.Scope = ["Scopable", "Pattern"], t.Referenced = null, t.BlockScoped = null, t.Var = ["VariableDeclaration"], t.User = null, t.Generated = null, t.Pure = null, t.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], t.RestProperty = ["RestElement"], t.SpreadProperty = ["RestElement"], t.ExistentialTypeParam = ["ExistsTypeAnnotation"], t.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], t.ForAwaitStatement = ["ForOfStatement"];
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/modification.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t._containerInsert = k, t._containerInsertAfter = F, t._containerInsertBefore = N, t._verifyNodeList = U, t.insertAfter = function(q) {
          if (r._assertUnremoved.call(this), this.isSequenceExpression()) return W(this.get("expressions")).insertAfter(q);
          const ee = U.call(this, q), { parentPath: re, parent: Y } = this;
          if (re.isExpressionStatement() || re.isLabeledStatement() || C(Y) || re.isExportDefaultDeclaration() && this.isDeclaration()) return re.insertAfter(ee.map((Z) => w(Z) ? m(Z) : Z));
          if (this.isNodeType("Expression") && !this.isJSXElement() && !re.isJSXElement() || re.isForStatement() && this.key === "init") {
            const Z = this;
            if (Z.node) {
              const G = Z.node;
              let { scope: B } = this;
              if (B.path.isPattern()) return S(G), Z.replaceWith(p(y([], G), [])), Z.get("callee.body").insertAfter(ee), [Z];
              if (X(Z)) ee.unshift(G);
              else if (_(G) && j(G.callee)) ee.unshift(G), ee.push(L());
              else if (function(z, M) {
                if (!E(z) || !I(z.left)) return false;
                const K = M.getBlockParent();
                return K.hasOwnBinding(z.left.name) && K.getOwnBinding(z.left.name).constantViolations.length <= 1;
              }(G, B)) ee.unshift(G), ee.push(h(G.left));
              else if (B.isPure(G, true)) ee.push(G);
              else {
                re.isMethod({ computed: true, key: G }) && (B = B.parent);
                const z = B.generateDeclaredUidIdentifier();
                ee.unshift(m(T("=", h(z), G))), ee.push(m(h(z)));
              }
            }
            return this.replaceExpressionWithStatements(ee);
          }
          if (Array.isArray(this.container)) return F.call(this, ee);
          if (this.isStatementOrBlock()) {
            const Z = this.node, G = Z && (!this.isExpressionStatement() || Z.expression != null);
            return this.replaceWith(d(G ? [Z] : [])), this.pushContainer("body", ee);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, t.insertBefore = function(q) {
          r._assertUnremoved.call(this);
          const ee = U.call(this, q), { parentPath: re, parent: Y } = this;
          if (re.isExpressionStatement() || re.isLabeledStatement() || C(Y) || re.isExportDefaultDeclaration() && this.isDeclaration()) return re.insertBefore(ee);
          if (this.isNodeType("Expression") && !this.isJSXElement() || re.isForStatement() && this.key === "init") return this.node && ee.push(this.node), this.replaceExpressionWithStatements(ee);
          if (Array.isArray(this.container)) return N.call(this, ee);
          if (this.isStatementOrBlock()) {
            const Z = this.node, G = Z && (!this.isExpressionStatement() || Z.expression != null);
            return this.replaceWith(d(G ? [Z] : [])), this.unshiftContainer("body", ee);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, t.pushContainer = function(q, ee) {
          r._assertUnremoved.call(this);
          const re = U.call(this, ee), Y = this.node[q];
          return c.default.get({ parentPath: this, parent: this.node, container: Y, listKey: q, key: Y.length }).setContext(this.context).replaceWithMultiple(re);
        }, t.unshiftContainer = function(q, ee) {
          r._assertUnremoved.call(this), ee = U.call(this, ee);
          const re = c.default.get({ parentPath: this, parent: this.node, container: this.node[q], listKey: q, key: 0 }).setContext(this.context);
          return N.call(re, ee);
        }, t.updateSiblingKeys = H;
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"), u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/hoister.js"), c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"), e = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js"), r = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/removal.js"), f = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { arrowFunctionExpression: y, assertExpression: S, assignmentExpression: T, blockStatement: d, callExpression: p, cloneNode: h, expressionStatement: m, isAssignmentExpression: E, isCallExpression: _, isExportNamedDeclaration: C, isExpression: w, isIdentifier: I, isSequenceExpression: D, isSuper: j, thisExpression: L } = f;
        function k(q, ee) {
          H.call(this, q, ee.length);
          const re = [];
          this.container.splice(q, 0, ...ee);
          for (let G = 0; G < ee.length; G++) {
            var Y;
            const B = q + G, z = this.getSibling(B);
            re.push(z), (Y = this.context) != null && Y.queue && e.pushContext.call(z, this.context);
          }
          const Z = e._getQueueContexts.call(this);
          for (const G of re) {
            e.setScope.call(G), G.debug("Inserted.");
            for (const B of Z) B.maybeQueue(G, true);
          }
          return re;
        }
        function N(q) {
          return k.call(this, this.key, q);
        }
        function F(q) {
          return k.call(this, this.key + 1, q);
        }
        const W = (q) => q[q.length - 1];
        function X(q) {
          return D(q.parent) && (W(q.parent.expressions) !== q.node || X(q.parentPath));
        }
        function H(q, ee) {
          if (!this.parent) return;
          const re = (0, n.getCachedPaths)(this.hub, this.parent) || [];
          for (const [, Y] of re) typeof Y.key == "number" && Y.container === this.container && Y.key >= q && (Y.key += ee);
        }
        function U(q) {
          if (!q) return [];
          Array.isArray(q) || (q = [q]);
          for (let ee = 0; ee < q.length; ee++) {
            const re = q[ee];
            let Y;
            if (re ? typeof re != "object" ? Y = "contains a non-object node" : re.type ? re instanceof c.default && (Y = "has a NodePath when it expected a raw object") : Y = "without a type" : Y = "has falsy node", Y) {
              const Z = Array.isArray(re) ? "array" : typeof re;
              throw new Error(`Node list ${Y} with the index of ${ee} and type of ${Z}`);
            }
          }
          return q;
        }
        t.hoist = function(q = this.scope) {
          return new u.default(this, q).run();
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/removal.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t._assertUnremoved = m, t._callRemovalHooks = d, t._markRemoved = h, t._remove = p, t._removeFromScope = T, t.remove = function() {
          var E;
          if (m.call(this), y.resync.call(this), d.call(this)) return void h.call(this);
          (E = this.opts) != null && E.noScope || T.call(this), this.shareCommentsWithSiblings(), p.call(this), h.call(this);
        };
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"), u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"), c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/replacement.js"), e = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"), r = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), f = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/modification.js"), y = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");
        const { getBindingIdentifiers: S } = r;
        function T() {
          const E = S(this.node, false, false, true);
          Object.keys(E).forEach((_) => this.scope.removeBinding(_));
        }
        function d() {
          if (this.parentPath) {
            for (const E of n.hooks) if (E(this, this.parentPath)) return true;
          }
        }
        function p() {
          Array.isArray(this.container) ? (this.container.splice(this.key, 1), f.updateSiblingKeys.call(this, this.key, -1)) : c._replaceWith.call(this, null);
        }
        function h() {
          this._traverseFlags |= e.SHOULD_SKIP | e.REMOVED, this.parent && (0, u.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
        }
        function m() {
          if (this.removed) throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/replacement.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t._replaceWith = M, t.replaceExpressionWithStatements = function(Q) {
          S.resync.call(this);
          const ie = [], ue = K(Q, ie);
          if (ue) {
            for (const pe of ie) this.scope.push({ id: pe });
            return this.replaceWith(ue)[0].get("expressions");
          }
          const ge = this.getFunctionParent(), Te = ge == null ? void 0 : ge.node.async, le = ge == null ? void 0 : ge.node.generator, fe = d([], m(Q));
          this.replaceWith(_(fe, []));
          const Pe = this.get("callee");
          Pe.get("body").scope.hoistVariables((pe) => this.scope.push({ id: pe }));
          const xe = Pe.getCompletionRecords();
          for (const pe of xe) {
            if (!pe.isExpressionStatement()) continue;
            const J = pe.findParent((Ee) => Ee.isLoop());
            if (J) {
              let Ee = J.getData("expressionReplacementReturnUid");
              Ee ? Ee = j(Ee.name) : (Ee = Pe.scope.generateDeclaredUidIdentifier("ret"), Pe.get("body").pushContainer("body", Z(C(Ee))), J.setData("expressionReplacementReturnUid", Ee)), pe.get("expression").replaceWith(p("=", C(Ee), pe.node.expression));
            } else pe.replaceWith(Z(pe.node.expression));
          }
          Pe.arrowFunctionToExpression();
          const we = Pe, me = Te && u.default.hasType(this.get("callee.body").node, "AwaitExpression", T), ye = le && u.default.hasType(this.get("callee.body").node, "YieldExpression", T);
          return me && (we.set("async", true), ye || this.replaceWith(h(this.node))), ye && (we.set("generator", true), this.replaceWith(z(this.node, true))), we.get("body.body");
        }, t.replaceInline = function(Q) {
          if (S.resync.call(this), Array.isArray(Q)) {
            if (Array.isArray(this.container)) {
              Q = r._verifyNodeList.call(this, Q);
              const ie = r._containerInsertAfter.call(this, Q);
              return this.remove(), ie;
            }
            return this.replaceWithMultiple(Q);
          }
          return this.replaceWith(Q);
        }, t.replaceWith = function(Q) {
          if (S.resync.call(this), this.removed) throw new Error("You can't replace this node, we've already removed it");
          let ie = Q instanceof c.default ? Q.node : Q;
          if (!ie) throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
          if (this.node === ie) return [this];
          if (this.isProgram() && !q(ie)) throw new Error("You can only replace a Program root node with another Program node");
          if (Array.isArray(ie)) throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
          if (typeof ie == "string") throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
          let ue = "";
          if (this.isNodeType("Statement") && X(ie) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(ie) || this.parentPath.isExportDefaultDeclaration() || (ie = I(ie), ue = "expression")), this.isNodeType("Expression") && ee(ie) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(ie)) return this.replaceExpressionWithStatements([ie]);
          const ge = this.node;
          return ge && (N(ie, ge), Y(ge)), M.call(this, ie), this.type = ie.type, S.setScope.call(this), this.requeue(), [ue ? this.get(ue) : this];
        }, t.replaceWithMultiple = function(Q) {
          var ie;
          S.resync.call(this), Q = r._verifyNodeList.call(this, Q), L(Q[0], this.node), k(Q[Q.length - 1], this.node), (ie = (0, e.getCachedPaths)(this.hub, this.parent)) == null || ie.delete(this.node), this.node = this.container[this.key] = null;
          const ue = this.insertAfter(Q);
          return this.node ? this.requeue() : this.remove(), ue;
        }, t.replaceWithSourceString = function(Q) {
          let ie;
          S.resync.call(this);
          try {
            Q = `(${Q})`, ie = (0, f.parse)(Q);
          } catch (ge) {
            const Te = ge.loc;
            throw Te && (ge.message += ` - make sure this is an expression.
` + (0, n.codeFrameColumns)(Q, { start: { line: Te.line, column: Te.column + 1 } }), ge.code = "BABEL_REPLACE_SOURCE_ERROR"), ge;
          }
          const ue = ie.program.body[0].expression;
          return u.default.removeProperties(ue), this.replaceWith(ue);
        };
        var n = l("./stubs/babel-codeframe.js"), u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js"), c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/index.js"), e = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"), r = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/modification.js"), f = l("./node_modules/.pnpm/@babel+parser@7.26.3/node_modules/@babel/parser/lib/index.js"), y = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), S = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");
        const { FUNCTION_TYPES: T, arrowFunctionExpression: d, assignmentExpression: p, awaitExpression: h, blockStatement: m, buildUndefinedNode: E, callExpression: _, cloneNode: C, conditionalExpression: w, expressionStatement: I, getBindingIdentifiers: D, identifier: j, inheritLeadingComments: L, inheritTrailingComments: k, inheritsComments: N, isBlockStatement: F, isEmptyStatement: W, isExpression: X, isExpressionStatement: H, isIfStatement: U, isProgram: q, isStatement: ee, isVariableDeclaration: re, removeComments: Y, returnStatement: Z, sequenceExpression: G, validate: B, yieldExpression: z } = y;
        function M(Q) {
          var ie;
          if (!this.container) throw new ReferenceError("Container is falsy");
          this.inList ? B(this.parent, this.key, [Q]) : B(this.parent, this.key, Q), this.debug(`Replace with ${Q == null ? void 0 : Q.type}`), (ie = (0, e.getCachedPaths)(this.hub, this.parent)) == null || ie.set(Q, this).delete(this.node), this.node = this.container[this.key] = Q;
        }
        function K(Q, ie) {
          const ue = [];
          let ge = true;
          for (const Te of Q) if (W(Te) || (ge = false), X(Te)) ue.push(Te);
          else if (H(Te)) ue.push(Te.expression);
          else if (re(Te)) {
            if (Te.kind !== "var") return;
            for (const le of Te.declarations) {
              const fe = D(le);
              for (const Pe of Object.keys(fe)) ie.push(C(fe[Pe]));
              le.init && ue.push(p("=", le.id, le.init));
            }
            ge = true;
          } else if (U(Te)) {
            const le = Te.consequent ? K([Te.consequent], ie) : E(), fe = Te.alternate ? K([Te.alternate], ie) : E();
            if (!le || !fe) return;
            ue.push(w(Te.test, le, fe));
          } else if (F(Te)) {
            const le = K(Te.body, ie);
            if (!le) return;
            ue.push(le);
          } else {
            if (!W(Te)) return;
            Q.indexOf(Te) === 0 && (ge = true);
          }
          return ge && ue.push(E()), ue.length === 1 ? ue[0] : G(ue);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/binding.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0, t.default = class {
          constructor({ identifier: l, scope: n, path: u, kind: c }) {
            this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = true, this.referencePaths = [], this.referenced = false, this.references = 0, this.identifier = l, this.scope = n, this.path = u, this.kind = c, c !== "var" && c !== "hoisted" || !function(e) {
              for (let { parentPath: r, key: f } = e; r; { parentPath: r, key: f } = r) {
                if (r.isFunctionParent()) return false;
                if (r.isWhile() || r.isForXStatement() || r.isForStatement() && f === "body") return true;
              }
              return false;
            }(u) || this.reassign(u), this.clearValue();
          }
          deoptValue() {
            this.clearValue(), this.hasDeoptedValue = true;
          }
          setValue(l) {
            this.hasDeoptedValue || (this.hasValue = true, this.value = l);
          }
          clearValue() {
            this.hasDeoptedValue = false, this.hasValue = false, this.value = null;
          }
          reassign(l) {
            this.constant = false, this.constantViolations.includes(l) || this.constantViolations.push(l);
          }
          reference(l) {
            this.referencePaths.includes(l) || (this.referenced = true, this.references++, this.referencePaths.push(l));
          }
          dereference() {
            this.references--, this.referenced = !!this.references;
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/lib/renamer.js"), u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/index.js"), c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/binding.js"), e = l("./node_modules/.pnpm/globals@11.12.0/node_modules/globals/index.js"), r = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), f = r, y = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/cache.js"), S = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/visitors.js");
        const { NOT_LOCAL_BINDING: T, assignmentExpression: d, callExpression: p, cloneNode: h, getBindingIdentifiers: m, identifier: E, isArrayExpression: _, isBinary: C, isCallExpression: w, isClass: I, isClassBody: D, isClassDeclaration: j, isExportAllDeclaration: L, isExportDefaultDeclaration: k, isExportNamedDeclaration: N, isFunctionDeclaration: F, isIdentifier: W, isImportDeclaration: X, isLiteral: H, isMemberExpression: U, isMethod: q, isModuleSpecifier: ee, isNullLiteral: re, isObjectExpression: Y, isProperty: Z, isPureish: G, isRegExpLiteral: B, isSuper: z, isTaggedTemplateExpression: M, isTemplateLiteral: K, isThisExpression: Q, isUnaryExpression: ie, isVariableDeclaration: ue, expressionStatement: ge, matchesPattern: Te, memberExpression: le, numericLiteral: fe, toIdentifier: Pe, variableDeclaration: xe, variableDeclarator: we, isRecordExpression: me, isTupleExpression: ye, isObjectProperty: pe, isTopicReference: J, isMetaProperty: Ee, isPrivateName: Me, isExportDeclaration: Ue, buildUndefinedNode: qe, sequenceExpression: He } = r;
        function Ie(he, oe) {
          switch (he == null ? void 0 : he.type) {
            default:
              var _e;
              if (X(he) || Ue(he)) if ((L(he) || N(he) || X(he)) && he.source) Ie(he.source, oe);
              else if ((N(he) || X(he)) && (_e = he.specifiers) != null && _e.length) for (const Ne of he.specifiers) Ie(Ne, oe);
              else (k(he) || N(he)) && he.declaration && Ie(he.declaration, oe);
              else ee(he) ? Ie(he.local, oe) : !H(he) || re(he) || B(he) || K(he) || oe.push(he.value);
              break;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "JSXMemberExpression":
              Ie(he.object, oe), Ie(he.property, oe);
              break;
            case "Identifier":
            case "JSXIdentifier":
              oe.push(he.name);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              Ie(he.callee, oe);
              break;
            case "ObjectExpression":
            case "ObjectPattern":
              for (const Ne of he.properties) Ie(Ne, oe);
              break;
            case "SpreadElement":
            case "RestElement":
            case "UnaryExpression":
            case "UpdateExpression":
              Ie(he.argument, oe);
              break;
            case "ObjectProperty":
            case "ObjectMethod":
            case "ClassProperty":
            case "ClassMethod":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
              Ie(he.key, oe);
              break;
            case "ThisExpression":
              oe.push("this");
              break;
            case "Super":
              oe.push("super");
              break;
            case "Import":
              oe.push("import");
              break;
            case "DoExpression":
              oe.push("do");
              break;
            case "YieldExpression":
              oe.push("yield"), Ie(he.argument, oe);
              break;
            case "AwaitExpression":
              oe.push("await"), Ie(he.argument, oe);
              break;
            case "AssignmentExpression":
              Ie(he.left, oe);
              break;
            case "VariableDeclarator":
            case "FunctionExpression":
            case "FunctionDeclaration":
            case "ClassExpression":
            case "ClassDeclaration":
            case "PrivateName":
              Ie(he.id, oe);
              break;
            case "ParenthesizedExpression":
              Ie(he.expression, oe);
              break;
            case "MetaProperty":
              Ie(he.meta, oe), Ie(he.property, oe);
              break;
            case "JSXElement":
              Ie(he.openingElement, oe);
              break;
            case "JSXOpeningElement":
              Ie(he.name, oe);
              break;
            case "JSXFragment":
              Ie(he.openingFragment, oe);
              break;
            case "JSXOpeningFragment":
              oe.push("Fragment");
              break;
            case "JSXNamespacedName":
              Ie(he.namespace, oe), Ie(he.name, oe);
          }
        }
        const Re = { ForStatement(he) {
          const oe = he.get("init");
          if (oe.isVar()) {
            const { scope: _e } = he;
            (_e.getFunctionParent() || _e.getProgramParent()).registerBinding("var", oe);
          }
        }, Declaration(he) {
          he.isBlockScoped() || he.isImportDeclaration() || he.isExportDeclaration() || (he.scope.getFunctionParent() || he.scope.getProgramParent()).registerDeclaration(he);
        }, ImportDeclaration(he) {
          he.scope.getBlockParent().registerDeclaration(he);
        }, ReferencedIdentifier(he, oe) {
          oe.references.push(he);
        }, ForXStatement(he, oe) {
          const _e = he.get("left");
          if (_e.isPattern() || _e.isIdentifier()) oe.constantViolations.push(he);
          else if (_e.isVar()) {
            const { scope: Ne } = he;
            (Ne.getFunctionParent() || Ne.getProgramParent()).registerBinding("var", _e);
          }
        }, ExportDeclaration: { exit(he) {
          const { node: oe, scope: _e } = he;
          if (L(oe)) return;
          const Ne = oe.declaration;
          if (j(Ne) || F(Ne)) {
            const $e = Ne.id;
            if (!$e) return;
            const Xe = _e.getBinding($e.name);
            Xe == null ? void 0 : Xe.reference(he);
          } else if (ue(Ne)) for (const $e of Ne.declarations) for (const Xe of Object.keys(m($e))) {
            const Je = _e.getBinding(Xe);
            Je == null ? void 0 : Je.reference(he);
          }
        } }, LabeledStatement(he) {
          he.scope.getBlockParent().registerDeclaration(he);
        }, AssignmentExpression(he, oe) {
          oe.assignments.push(he);
        }, UpdateExpression(he, oe) {
          oe.constantViolations.push(he);
        }, UnaryExpression(he, oe) {
          he.node.operator === "delete" && oe.constantViolations.push(he);
        }, BlockScoped(he) {
          let oe = he.scope;
          if (oe.path === he && (oe = oe.parent), oe.getBlockParent().registerDeclaration(he), he.isClassDeclaration() && he.node.id) {
            const _e = he.node.id.name;
            he.scope.bindings[_e] = he.scope.parent.getBinding(_e);
          }
        }, CatchClause(he) {
          he.scope.registerBinding("let", he);
        }, Function(he) {
          const oe = he.get("params");
          for (const _e of oe) he.scope.registerBinding("param", _e);
          he.isFunctionExpression() && he.node.id && !he.node.id[T] && he.scope.registerBinding("local", he.get("id"), he);
        }, ClassExpression(he) {
          he.node.id && !he.node.id[T] && he.scope.registerBinding("local", he.get("id"), he);
        }, TSTypeAnnotation(he) {
          he.skip();
        } };
        let Be = 0;
        class je {
          constructor(oe) {
            this.uid = void 0, this.path = void 0, this.block = void 0, this.inited = void 0, this.labels = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
            const { node: _e } = oe, Ne = y.scope.get(_e);
            if ((Ne == null ? void 0 : Ne.path) === oe) return Ne;
            y.scope.set(_e, this), this.uid = Be++, this.block = _e, this.path = oe, this.labels = /* @__PURE__ */ new Map(), this.inited = false;
          }
          get parent() {
            var oe;
            let _e, Ne = this.path;
            do {
              var $e;
              const Xe = Ne.key === "key" || Ne.listKey === "decorators";
              Ne = Ne.parentPath, Xe && Ne.isMethod() && (Ne = Ne.parentPath), ($e = Ne) != null && $e.isScope() && (_e = Ne);
            } while (Ne && !_e);
            return (oe = _e) == null ? void 0 : oe.scope;
          }
          generateDeclaredUidIdentifier(oe) {
            const _e = this.generateUidIdentifier(oe);
            return this.push({ id: _e }), h(_e);
          }
          generateUidIdentifier(oe) {
            return E(this.generateUid(oe));
          }
          generateUid(oe = "temp") {
            let _e;
            oe = Pe(oe).replace(/^_+/, "").replace(/\d+$/g, "");
            let Ne = 1;
            do
              _e = `_${oe}`, Ne > 1 && (_e += Ne), Ne++;
            while (this.hasLabel(_e) || this.hasBinding(_e) || this.hasGlobal(_e) || this.hasReference(_e));
            const $e = this.getProgramParent();
            return $e.references[_e] = true, $e.uids[_e] = true, _e;
          }
          generateUidBasedOnNode(oe, _e) {
            const Ne = [];
            Ie(oe, Ne);
            let $e = Ne.join("$");
            return $e = $e.replace(/^_/, "") || _e || "ref", this.generateUid($e.slice(0, 20));
          }
          generateUidIdentifierBasedOnNode(oe, _e) {
            return E(this.generateUidBasedOnNode(oe, _e));
          }
          isStatic(oe) {
            if (Q(oe) || z(oe) || J(oe)) return true;
            if (W(oe)) {
              const _e = this.getBinding(oe.name);
              return _e ? _e.constant : this.hasBinding(oe.name);
            }
            return false;
          }
          maybeGenerateMemoised(oe, _e) {
            if (this.isStatic(oe)) return null;
            {
              const Ne = this.generateUidIdentifierBasedOnNode(oe);
              return _e ? Ne : (this.push({ id: Ne }), h(Ne));
            }
          }
          checkBlockScopedCollisions(oe, _e, Ne, $e) {
            if (_e !== "param" && oe.kind !== "local" && (_e === "let" || oe.kind === "let" || oe.kind === "const" || oe.kind === "module" || oe.kind === "param" && _e === "const")) throw this.path.hub.buildError($e, `Duplicate declaration "${Ne}"`, TypeError);
          }
          rename(oe, _e) {
            const Ne = this.getBinding(oe);
            Ne && (_e || (_e = this.generateUidIdentifier(oe).name), new n.default(Ne, oe, _e).rename(arguments[2]));
          }
          dump() {
            const oe = "-".repeat(60);
            console.log(oe);
            let _e = this;
            do {
              console.log("#", _e.block.type);
              for (const Ne of Object.keys(_e.bindings)) {
                const $e = _e.bindings[Ne];
                console.log(" -", Ne, { constant: $e.constant, references: $e.references, violations: $e.constantViolations.length, kind: $e.kind });
              }
            } while (_e = _e.parent);
            console.log(oe);
          }
          hasLabel(oe) {
            return !!this.getLabel(oe);
          }
          getLabel(oe) {
            return this.labels.get(oe);
          }
          registerLabel(oe) {
            this.labels.set(oe.node.label.name, oe);
          }
          registerDeclaration(oe) {
            if (oe.isLabeledStatement()) this.registerLabel(oe);
            else if (oe.isFunctionDeclaration()) this.registerBinding("hoisted", oe.get("id"), oe);
            else if (oe.isVariableDeclaration()) {
              const _e = oe.get("declarations"), { kind: Ne } = oe.node;
              for (const $e of _e) this.registerBinding(Ne === "using" || Ne === "await using" ? "const" : Ne, $e);
            } else if (oe.isClassDeclaration()) {
              if (oe.node.declare) return;
              this.registerBinding("let", oe);
            } else if (oe.isImportDeclaration()) {
              const _e = oe.node.importKind === "type" || oe.node.importKind === "typeof", Ne = oe.get("specifiers");
              for (const $e of Ne) {
                const Xe = _e || $e.isImportSpecifier() && ($e.node.importKind === "type" || $e.node.importKind === "typeof");
                this.registerBinding(Xe ? "unknown" : "module", $e);
              }
            } else if (oe.isExportDeclaration()) {
              const _e = oe.get("declaration");
              (_e.isClassDeclaration() || _e.isFunctionDeclaration() || _e.isVariableDeclaration()) && this.registerDeclaration(_e);
            } else this.registerBinding("unknown", oe);
          }
          buildUndefinedNode() {
            return qe();
          }
          registerConstantViolation(oe) {
            const _e = oe.getAssignmentIdentifiers();
            for (const $e of Object.keys(_e)) {
              var Ne;
              (Ne = this.getBinding($e)) == null || Ne.reassign(oe);
            }
          }
          registerBinding(oe, _e, Ne = _e) {
            if (!oe) throw new ReferenceError("no `kind`");
            if (_e.isVariableDeclaration()) {
              const Je = _e.get("declarations");
              for (const st of Je) this.registerBinding(oe, st);
              return;
            }
            const $e = this.getProgramParent(), Xe = _e.getOuterBindingIdentifiers(true);
            for (const Je of Object.keys(Xe)) {
              $e.references[Je] = true;
              for (const st of Xe[Je]) {
                const be = this.getOwnBinding(Je);
                if (be) {
                  if (be.identifier === st) continue;
                  this.checkBlockScopedCollisions(be, oe, Je, st);
                }
                be ? be.reassign(Ne) : this.bindings[Je] = new c.default({ identifier: st, scope: this, path: Ne, kind: oe });
              }
            }
          }
          addGlobal(oe) {
            this.globals[oe.name] = oe;
          }
          hasUid(oe) {
            let _e = this;
            do
              if (_e.uids[oe]) return true;
            while (_e = _e.parent);
            return false;
          }
          hasGlobal(oe) {
            let _e = this;
            do
              if (_e.globals[oe]) return true;
            while (_e = _e.parent);
            return false;
          }
          hasReference(oe) {
            return !!this.getProgramParent().references[oe];
          }
          isPure(oe, _e) {
            if (W(oe)) {
              const Je = this.getBinding(oe.name);
              return !!Je && (!_e || Je.constant);
            }
            if (Q(oe) || Ee(oe) || J(oe) || Me(oe)) return true;
            var Ne, $e, Xe;
            if (I(oe)) return !(oe.superClass && !this.isPure(oe.superClass, _e)) && !(((Ne = oe.decorators) == null ? void 0 : Ne.length) > 0) && this.isPure(oe.body, _e);
            if (D(oe)) {
              for (const Je of oe.body) if (!this.isPure(Je, _e)) return false;
              return true;
            }
            if (C(oe)) return this.isPure(oe.left, _e) && this.isPure(oe.right, _e);
            if (_(oe) || ye(oe)) {
              for (const Je of oe.elements) if (Je !== null && !this.isPure(Je, _e)) return false;
              return true;
            }
            if (Y(oe) || me(oe)) {
              for (const Je of oe.properties) if (!this.isPure(Je, _e)) return false;
              return true;
            }
            if (q(oe)) return !(oe.computed && !this.isPure(oe.key, _e)) && !((($e = oe.decorators) == null ? void 0 : $e.length) > 0);
            if (Z(oe)) return !(oe.computed && !this.isPure(oe.key, _e)) && !(((Xe = oe.decorators) == null ? void 0 : Xe.length) > 0) && !((pe(oe) || oe.static) && oe.value !== null && !this.isPure(oe.value, _e));
            if (ie(oe)) return this.isPure(oe.argument, _e);
            if (K(oe)) {
              for (const Je of oe.expressions) if (!this.isPure(Je, _e)) return false;
              return true;
            }
            return M(oe) ? Te(oe.tag, "String.raw") && !this.hasBinding("String", { noGlobals: true }) && this.isPure(oe.quasi, _e) : U(oe) ? !oe.computed && W(oe.object) && oe.object.name === "Symbol" && W(oe.property) && oe.property.name !== "for" && !this.hasBinding("Symbol", { noGlobals: true }) : w(oe) ? Te(oe.callee, "Symbol.for") && !this.hasBinding("Symbol", { noGlobals: true }) && oe.arguments.length === 1 && f.isStringLiteral(oe.arguments[0]) : G(oe);
          }
          setData(oe, _e) {
            return this.data[oe] = _e;
          }
          getData(oe) {
            let _e = this;
            do {
              const Ne = _e.data[oe];
              if (Ne != null) return Ne;
            } while (_e = _e.parent);
          }
          removeData(oe) {
            let _e = this;
            do
              _e.data[oe] != null && (_e.data[oe] = null);
            while (_e = _e.parent);
          }
          init() {
            this.inited || (this.inited = true, this.crawl());
          }
          crawl() {
            const oe = this.path;
            this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
            let _e = this;
            do {
              if (_e.crawling) return;
              if (_e.path.isProgram()) break;
            } while (_e = _e.parent);
            const Ne = _e, $e = { references: [], constantViolations: [], assignments: [] };
            if (this.crawling = true, oe.type !== "Program" && (0, S.isExplodedVisitor)(Re)) {
              for (const Je of Re.enter) Je.call($e, oe, $e);
              const Xe = Re[oe.type];
              if (Xe) for (const Je of Xe.enter) Je.call($e, oe, $e);
            }
            oe.traverse(Re, $e), this.crawling = false;
            for (const Xe of $e.assignments) {
              const Je = Xe.getAssignmentIdentifiers();
              for (const st of Object.keys(Je)) Xe.scope.getBinding(st) || Ne.addGlobal(Je[st]);
              Xe.scope.registerConstantViolation(Xe);
            }
            for (const Xe of $e.references) {
              const Je = Xe.scope.getBinding(Xe.node.name);
              Je ? Je.reference(Xe) : Ne.addGlobal(Xe.node);
            }
            for (const Xe of $e.constantViolations) Xe.scope.registerConstantViolation(Xe);
          }
          push(oe) {
            let _e = this.path;
            _e.isPattern() ? _e = this.getPatternParent().path : _e.isBlockStatement() || _e.isProgram() || (_e = this.getBlockParent().path), _e.isSwitchStatement() && (_e = (this.getFunctionParent() || this.getProgramParent()).path);
            const { init: Ne, unique: $e, kind: Xe = "var", id: Je } = oe;
            if (!Ne && !$e && (Xe === "var" || Xe === "let") && _e.isFunction() && !_e.node.name && w(_e.parent, { callee: _e.node }) && _e.parent.arguments.length <= _e.node.params.length && W(Je)) return _e.pushContainer("params", Je), void _e.scope.registerBinding("param", _e.get("params")[_e.node.params.length - 1]);
            (_e.isLoop() || _e.isCatchClause() || _e.isFunction()) && (_e.ensureBlock(), _e = _e.get("body"));
            const st = oe._blockHoist == null ? 2 : oe._blockHoist, be = `declaration:${Xe}:${st}`;
            let ke = !$e && _e.getData(be);
            if (!ke) {
              const rt = xe(Xe, []);
              rt._blockHoist = st, [ke] = _e.unshiftContainer("body", [rt]), $e || _e.setData(be, ke);
            }
            const Ve = we(Je, Ne), ze = ke.node.declarations.push(Ve);
            _e.scope.registerBinding(Xe, ke.get("declarations")[ze - 1]);
          }
          getProgramParent() {
            let oe = this;
            do
              if (oe.path.isProgram()) return oe;
            while (oe = oe.parent);
            throw new Error("Couldn't find a Program");
          }
          getFunctionParent() {
            let oe = this;
            do
              if (oe.path.isFunctionParent()) return oe;
            while (oe = oe.parent);
            return null;
          }
          getBlockParent() {
            let oe = this;
            do
              if (oe.path.isBlockParent()) return oe;
            while (oe = oe.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getPatternParent() {
            let oe = this;
            do
              if (!oe.path.isPattern()) return oe.getBlockParent();
            while (oe = oe.parent.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getAllBindings() {
            const oe = /* @__PURE__ */ Object.create(null);
            let _e = this;
            do {
              for (const Ne of Object.keys(_e.bindings)) !(Ne in oe) && (oe[Ne] = _e.bindings[Ne]);
              _e = _e.parent;
            } while (_e);
            return oe;
          }
          bindingIdentifierEquals(oe, _e) {
            return this.getBindingIdentifier(oe) === _e;
          }
          getBinding(oe) {
            let _e, Ne = this;
            do {
              const Xe = Ne.getOwnBinding(oe);
              var $e;
              if (Xe) {
                if (($e = _e) == null || !$e.isPattern() || Xe.kind === "param" || Xe.kind === "local") return Xe;
              } else if (!Xe && oe === "arguments" && Ne.path.isFunction() && !Ne.path.isArrowFunctionExpression()) break;
              _e = Ne.path;
            } while (Ne = Ne.parent);
          }
          getOwnBinding(oe) {
            return this.bindings[oe];
          }
          getBindingIdentifier(oe) {
            var _e;
            return (_e = this.getBinding(oe)) == null ? void 0 : _e.identifier;
          }
          getOwnBindingIdentifier(oe) {
            const _e = this.bindings[oe];
            return _e == null ? void 0 : _e.identifier;
          }
          hasOwnBinding(oe) {
            return !!this.getOwnBinding(oe);
          }
          hasBinding(oe, _e) {
            if (!oe) return false;
            let Ne, $e, Xe = this;
            do
              if (Xe.hasOwnBinding(oe)) return true;
            while (Xe = Xe.parent);
            return typeof _e == "object" ? (Ne = _e.noGlobals, $e = _e.noUids) : typeof _e == "boolean" && (Ne = _e), !($e || !this.hasUid(oe)) || !(Ne || !je.globals.includes(oe)) || !(Ne || !je.contextVariables.includes(oe));
          }
          parentHasBinding(oe, _e) {
            var Ne;
            return (Ne = this.parent) == null ? void 0 : Ne.hasBinding(oe, _e);
          }
          moveBindingTo(oe, _e) {
            const Ne = this.getBinding(oe);
            Ne && (Ne.scope.removeOwnBinding(oe), Ne.scope = _e, _e.bindings[oe] = Ne);
          }
          removeOwnBinding(oe) {
            delete this.bindings[oe];
          }
          removeBinding(oe) {
            var _e;
            (_e = this.getBinding(oe)) == null || _e.scope.removeOwnBinding(oe);
            let Ne = this;
            do
              Ne.uids[oe] && (Ne.uids[oe] = false);
            while (Ne = Ne.parent);
          }
          hoistVariables(oe = (_e) => this.push({ id: _e })) {
            this.crawl();
            const _e = /* @__PURE__ */ new Set();
            for (const Ne of Object.keys(this.bindings)) {
              const $e = this.bindings[Ne];
              if (!$e) continue;
              const { path: Xe } = $e;
              if (!Xe.isVariableDeclarator()) continue;
              const { parent: Je, parentPath: st } = Xe;
              if (Je.kind !== "var" || _e.has(Je)) continue;
              let be;
              _e.add(Xe.parent);
              const ke = [];
              for (const Ve of Je.declarations) {
                be != null || (be = Ve.id), Ve.init && ke.push(d("=", Ve.id, Ve.init));
                const ze = Object.keys(m(Ve, false, true, true));
                for (const rt of ze) oe(E(rt), Ve.init != null);
              }
              if (st.parentPath.isFor({ left: Je })) st.replaceWith(be);
              else if (ke.length === 0) st.remove();
              else {
                const Ve = ke.length === 1 ? ke[0] : He(ke);
                st.parentPath.isForStatement({ init: Je }) ? st.replaceWith(Ve) : st.replaceWith(ge(Ve));
              }
            }
          }
        }
        t.default = je, je.globals = Object.keys(e.builtin), je.contextVariables = ["arguments", "undefined", "Infinity", "NaN"], je.prototype._renameFromMap = function(he, oe, _e, Ne) {
          he[oe] && (he[_e] = Ne, he[oe] = null);
        }, je.prototype.traverse = function(he, oe, _e) {
          (0, u.default)(he, oe, this, _e, this.path);
        }, je.prototype._generateUid = function(he, oe) {
          let _e = he;
          return oe > 1 && (_e += oe), `_${_e}`;
        }, je.prototype.toArray = function(he, oe, _e) {
          if (W(he)) {
            const Xe = this.getBinding(he.name);
            if (Xe != null && Xe.constant && Xe.path.isGenericType("Array")) return he;
          }
          if (_(he)) return he;
          if (W(he, { name: "arguments" })) return p(le(le(le(E("Array"), E("prototype")), E("slice")), E("call")), [he]);
          let Ne;
          const $e = [he];
          return oe === true ? Ne = "toConsumableArray" : typeof oe == "number" ? ($e.push(fe(oe)), Ne = "slicedToArray") : Ne = "toArray", _e && ($e.unshift(this.path.hub.addHelper(Ne)), Ne = "maybeArrayLike"), p(this.path.hub.addHelper(Ne), $e);
        }, je.prototype.getAllBindingsOfKind = function(...he) {
          const oe = /* @__PURE__ */ Object.create(null);
          for (const _e of he) {
            let Ne = this;
            do {
              for (const $e of Object.keys(Ne.bindings)) {
                const Xe = Ne.bindings[$e];
                Xe.kind === _e && (oe[$e] = Xe);
              }
              Ne = Ne.parent;
            } while (Ne);
          }
          return oe;
        }, Object.defineProperties(je.prototype, { parentBlock: { configurable: true, enumerable: true, get() {
          return this.path.parent;
        } }, hub: { configurable: true, enumerable: true, get() {
          return this.path.hub;
        } } });
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/scope/lib/renamer.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), u = n, c = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/traverse-node.js"), e = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/visitors.js"), r = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");
        const { getAssignmentIdentifiers: f } = u, y = { ReferencedIdentifier({ node: S }, T) {
          S.name === T.oldName && (S.name = T.newName);
        }, Scope(S, T) {
          S.scope.bindingIdentifierEquals(T.oldName, T.binding.identifier) || (S.skip(), S.isMethod() && (S.requeueComputedKeyAndDecorators ? S.requeueComputedKeyAndDecorators() : r.requeueComputedKeyAndDecorators.call(S)));
        }, ObjectProperty({ node: S, scope: T }, d) {
          const { name: p } = S.key;
          var h;
          !S.shorthand || p !== d.oldName && p !== d.newName || T.getBindingIdentifier(p) !== d.binding.identifier || (S.shorthand = false, (h = S.extra) != null && h.shorthand && (S.extra.shorthand = false));
        }, "AssignmentExpression|Declaration|VariableDeclarator"(S, T) {
          if (S.isVariableDeclaration()) return;
          const d = S.isAssignmentExpression() ? f(S.node) : S.getOuterBindingIdentifiers();
          for (const p in d) p === T.oldName && (d[p].name = T.newName);
        } };
        t.default = class {
          constructor(S, T, d) {
            this.newName = d, this.oldName = T, this.binding = S;
          }
          maybeConvertFromExportDeclaration(S) {
            const T = S.parentPath;
            if (T.isExportDeclaration()) {
              if (T.isExportDefaultDeclaration()) {
                const { declaration: d } = T.node;
                if (n.isDeclaration(d) && !d.id) return;
              }
              T.isExportAllDeclaration() || T.splitExportDeclaration();
            }
          }
          maybeConvertFromClassFunctionDeclaration(S) {
            return S;
          }
          maybeConvertFromClassFunctionExpression(S) {
            return S;
          }
          rename() {
            const { binding: S, oldName: T, newName: d } = this, { scope: p, path: h } = S, m = h.find((C) => C.isDeclaration() || C.isFunctionExpression() || C.isClassExpression());
            m && m.getOuterBindingIdentifiers()[T] === S.identifier && this.maybeConvertFromExportDeclaration(m);
            const E = arguments[0] || p.block, _ = { discriminant: true };
            n.isMethod(E) && (E.computed && (_.key = true), n.isObjectMethod(E) || (_.decorators = true)), (0, c.traverseNode)(E, (0, e.explode)(y), p, this, p.path, _), arguments[0] || (p.removeOwnBinding(T), p.bindings[d] = S, this.binding.identifier.name = d), m && (this.maybeConvertFromClassFunctionDeclaration(h), this.maybeConvertFromClassFunctionExpression(h));
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/traverse-node.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.traverseNode = function(e, r, f, y, S, T, d) {
          const p = c[e.type];
          if (!p) return false;
          const h = new n.default(f, r, y, S);
          if (d) return (T == null || !T[S.parentKey]) && h.visitQueue([S]);
          for (const m of p) if ((T == null || !T[m]) && h.visit(e, m)) return true;
          return false;
        };
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/context.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS: c } = u;
      }, "./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/visitors.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.environmentVisitor = function(L) {
          return E([j, L]);
        }, t.explode = p, t.isExplodedVisitor = d, t.merge = E, t.verify = h;
        var n = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), u = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js"), e = l("./node_modules/.pnpm/@babel+traverse@7.26.4/node_modules/@babel/traverse/lib/path/context.js");
        const { DEPRECATED_KEYS: r, DEPRECATED_ALIASES: f, FLIPPED_ALIAS_KEYS: y, TYPES: S, __internal__deprecationWarning: T } = c;
        function d(L) {
          return L == null ? void 0 : L._exploded;
        }
        function p(L) {
          if (d(L)) return L;
          L._exploded = true;
          for (const k of Object.keys(L)) {
            if (I(k)) continue;
            const N = k.split("|");
            if (N.length === 1) continue;
            const F = L[k];
            delete L[k];
            for (const W of N) L[W] = F;
          }
          h(L), delete L.__esModule, function(k) {
            for (const N of Object.keys(k)) {
              if (I(N)) continue;
              const F = k[N];
              typeof F == "function" && (k[N] = { enter: F });
            }
          }(L), C(L);
          for (const k of Object.keys(L)) {
            if (I(k) || !(k in n)) continue;
            const N = L[k];
            for (const W of Object.keys(N)) N[W] = w(k, N[W]);
            delete L[k];
            const F = n[k];
            if (F !== null) for (const W of F) L[W] ? D(L[W], N) : L[W] = N;
            else D(L, N);
          }
          for (const k of Object.keys(L)) {
            if (I(k)) continue;
            let N = y[k];
            if (k in r) {
              const W = r[k];
              T(k, W, "Visitor "), N = [W];
            } else if (k in f) {
              const W = f[k];
              T(k, W, "Visitor "), N = y[W];
            }
            if (!N) continue;
            const F = L[k];
            delete L[k];
            for (const W of N) {
              const X = L[W];
              X ? D(X, F) : L[W] = Object.assign({}, F);
            }
          }
          for (const k of Object.keys(L)) I(k) || C(L[k]);
          return L;
        }
        function h(L) {
          if (!L._verified) {
            if (typeof L == "function") throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
            for (const k of Object.keys(L)) {
              if (k !== "enter" && k !== "exit" || m(k, L[k]), I(k)) continue;
              if (!S.includes(k)) throw new Error(`You gave us a visitor for the node type ${k} but it's not a valid type in @babel/traverse 7.26.4`);
              const N = L[k];
              if (typeof N == "object") for (const F of Object.keys(N)) {
                if (F !== "enter" && F !== "exit") throw new Error(`You passed \`traverse()\` a visitor object with the property ${k} that has the invalid property ${F}`);
                m(`${k}.${F}`, N[F]);
              }
            }
            L._verified = true;
          }
        }
        function m(L, k) {
          const N = [].concat(k);
          for (const F of N) if (typeof F != "function") throw new TypeError(`Non-function found defined in ${L} with type ${typeof F}`);
        }
        function E(L, k = [], N) {
          const F = { _verified: true, _exploded: true };
          Object.defineProperty(F, "_exploded", { enumerable: false }), Object.defineProperty(F, "_verified", { enumerable: false });
          for (let W = 0; W < L.length; W++) {
            const X = p(L[W]), H = k[W];
            let U = X;
            (H || N) && (U = _(U, H, N)), D(F, U);
            for (const q of Object.keys(X)) {
              if (I(q)) continue;
              let ee = X[q];
              (H || N) && (ee = _(ee, H, N)), D(F[q] || (F[q] = {}), ee);
            }
          }
          return F;
        }
        function _(L, k, N) {
          const F = {};
          for (const W of ["enter", "exit"]) {
            let X = L[W];
            Array.isArray(X) && (X = X.map(function(H) {
              let U = H;
              return k && (U = function(q) {
                H.call(k, q, k);
              }), N && (U = N(k == null ? void 0 : k.key, W, U)), U !== H && (U.toString = () => H.toString()), U;
            }), F[W] = X);
          }
          return F;
        }
        function C(L) {
          L.enter && !Array.isArray(L.enter) && (L.enter = [L.enter]), L.exit && !Array.isArray(L.exit) && (L.exit = [L.exit]);
        }
        function w(L, k) {
          const N = u[`is${L}`], F = function(W) {
            if (N.call(W)) return k.apply(this, arguments);
          };
          return F.toString = () => k.toString(), F;
        }
        function I(L) {
          return L[0] === "_" || L === "enter" || L === "exit" || L === "shouldSkip" || L === "denylist" || L === "noScope" || L === "skipKeys" || L === "blacklist";
        }
        function D(L, k) {
          for (const N of ["enter", "exit"]) k[N] && (L[N] = [].concat(L[N] || [], k[N]));
        }
        const j = { FunctionParent(L) {
          L.isArrowFunctionExpression() || (L.skip(), L.isMethod() && (L.requeueComputedKeyAndDecorators ? L.requeueComputedKeyAndDecorators() : e.requeueComputedKeyAndDecorators.call(L)));
        }, Property(L) {
          L.isObjectProperty() || (L.skip(), L.requeueComputedKeyAndDecorators ? L.requeueComputedKeyAndDecorators() : e.requeueComputedKeyAndDecorators.call(L));
        } };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/asserts/assertNode.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          if (!(0, n.default)(u)) {
            var c;
            const e = (c = u == null ? void 0 : u.type) != null ? c : JSON.stringify(u);
            throw new TypeError(`Not a valid node of type "${e}"`);
          }
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/asserts/generated/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.assertAccessor = function(e, r) {
          c("Accessor", e, r);
        }, t.assertAnyTypeAnnotation = function(e, r) {
          c("AnyTypeAnnotation", e, r);
        }, t.assertArgumentPlaceholder = function(e, r) {
          c("ArgumentPlaceholder", e, r);
        }, t.assertArrayExpression = function(e, r) {
          c("ArrayExpression", e, r);
        }, t.assertArrayPattern = function(e, r) {
          c("ArrayPattern", e, r);
        }, t.assertArrayTypeAnnotation = function(e, r) {
          c("ArrayTypeAnnotation", e, r);
        }, t.assertArrowFunctionExpression = function(e, r) {
          c("ArrowFunctionExpression", e, r);
        }, t.assertAssignmentExpression = function(e, r) {
          c("AssignmentExpression", e, r);
        }, t.assertAssignmentPattern = function(e, r) {
          c("AssignmentPattern", e, r);
        }, t.assertAwaitExpression = function(e, r) {
          c("AwaitExpression", e, r);
        }, t.assertBigIntLiteral = function(e, r) {
          c("BigIntLiteral", e, r);
        }, t.assertBinary = function(e, r) {
          c("Binary", e, r);
        }, t.assertBinaryExpression = function(e, r) {
          c("BinaryExpression", e, r);
        }, t.assertBindExpression = function(e, r) {
          c("BindExpression", e, r);
        }, t.assertBlock = function(e, r) {
          c("Block", e, r);
        }, t.assertBlockParent = function(e, r) {
          c("BlockParent", e, r);
        }, t.assertBlockStatement = function(e, r) {
          c("BlockStatement", e, r);
        }, t.assertBooleanLiteral = function(e, r) {
          c("BooleanLiteral", e, r);
        }, t.assertBooleanLiteralTypeAnnotation = function(e, r) {
          c("BooleanLiteralTypeAnnotation", e, r);
        }, t.assertBooleanTypeAnnotation = function(e, r) {
          c("BooleanTypeAnnotation", e, r);
        }, t.assertBreakStatement = function(e, r) {
          c("BreakStatement", e, r);
        }, t.assertCallExpression = function(e, r) {
          c("CallExpression", e, r);
        }, t.assertCatchClause = function(e, r) {
          c("CatchClause", e, r);
        }, t.assertClass = function(e, r) {
          c("Class", e, r);
        }, t.assertClassAccessorProperty = function(e, r) {
          c("ClassAccessorProperty", e, r);
        }, t.assertClassBody = function(e, r) {
          c("ClassBody", e, r);
        }, t.assertClassDeclaration = function(e, r) {
          c("ClassDeclaration", e, r);
        }, t.assertClassExpression = function(e, r) {
          c("ClassExpression", e, r);
        }, t.assertClassImplements = function(e, r) {
          c("ClassImplements", e, r);
        }, t.assertClassMethod = function(e, r) {
          c("ClassMethod", e, r);
        }, t.assertClassPrivateMethod = function(e, r) {
          c("ClassPrivateMethod", e, r);
        }, t.assertClassPrivateProperty = function(e, r) {
          c("ClassPrivateProperty", e, r);
        }, t.assertClassProperty = function(e, r) {
          c("ClassProperty", e, r);
        }, t.assertCompletionStatement = function(e, r) {
          c("CompletionStatement", e, r);
        }, t.assertConditional = function(e, r) {
          c("Conditional", e, r);
        }, t.assertConditionalExpression = function(e, r) {
          c("ConditionalExpression", e, r);
        }, t.assertContinueStatement = function(e, r) {
          c("ContinueStatement", e, r);
        }, t.assertDebuggerStatement = function(e, r) {
          c("DebuggerStatement", e, r);
        }, t.assertDecimalLiteral = function(e, r) {
          c("DecimalLiteral", e, r);
        }, t.assertDeclaration = function(e, r) {
          c("Declaration", e, r);
        }, t.assertDeclareClass = function(e, r) {
          c("DeclareClass", e, r);
        }, t.assertDeclareExportAllDeclaration = function(e, r) {
          c("DeclareExportAllDeclaration", e, r);
        }, t.assertDeclareExportDeclaration = function(e, r) {
          c("DeclareExportDeclaration", e, r);
        }, t.assertDeclareFunction = function(e, r) {
          c("DeclareFunction", e, r);
        }, t.assertDeclareInterface = function(e, r) {
          c("DeclareInterface", e, r);
        }, t.assertDeclareModule = function(e, r) {
          c("DeclareModule", e, r);
        }, t.assertDeclareModuleExports = function(e, r) {
          c("DeclareModuleExports", e, r);
        }, t.assertDeclareOpaqueType = function(e, r) {
          c("DeclareOpaqueType", e, r);
        }, t.assertDeclareTypeAlias = function(e, r) {
          c("DeclareTypeAlias", e, r);
        }, t.assertDeclareVariable = function(e, r) {
          c("DeclareVariable", e, r);
        }, t.assertDeclaredPredicate = function(e, r) {
          c("DeclaredPredicate", e, r);
        }, t.assertDecorator = function(e, r) {
          c("Decorator", e, r);
        }, t.assertDirective = function(e, r) {
          c("Directive", e, r);
        }, t.assertDirectiveLiteral = function(e, r) {
          c("DirectiveLiteral", e, r);
        }, t.assertDoExpression = function(e, r) {
          c("DoExpression", e, r);
        }, t.assertDoWhileStatement = function(e, r) {
          c("DoWhileStatement", e, r);
        }, t.assertEmptyStatement = function(e, r) {
          c("EmptyStatement", e, r);
        }, t.assertEmptyTypeAnnotation = function(e, r) {
          c("EmptyTypeAnnotation", e, r);
        }, t.assertEnumBody = function(e, r) {
          c("EnumBody", e, r);
        }, t.assertEnumBooleanBody = function(e, r) {
          c("EnumBooleanBody", e, r);
        }, t.assertEnumBooleanMember = function(e, r) {
          c("EnumBooleanMember", e, r);
        }, t.assertEnumDeclaration = function(e, r) {
          c("EnumDeclaration", e, r);
        }, t.assertEnumDefaultedMember = function(e, r) {
          c("EnumDefaultedMember", e, r);
        }, t.assertEnumMember = function(e, r) {
          c("EnumMember", e, r);
        }, t.assertEnumNumberBody = function(e, r) {
          c("EnumNumberBody", e, r);
        }, t.assertEnumNumberMember = function(e, r) {
          c("EnumNumberMember", e, r);
        }, t.assertEnumStringBody = function(e, r) {
          c("EnumStringBody", e, r);
        }, t.assertEnumStringMember = function(e, r) {
          c("EnumStringMember", e, r);
        }, t.assertEnumSymbolBody = function(e, r) {
          c("EnumSymbolBody", e, r);
        }, t.assertExistsTypeAnnotation = function(e, r) {
          c("ExistsTypeAnnotation", e, r);
        }, t.assertExportAllDeclaration = function(e, r) {
          c("ExportAllDeclaration", e, r);
        }, t.assertExportDeclaration = function(e, r) {
          c("ExportDeclaration", e, r);
        }, t.assertExportDefaultDeclaration = function(e, r) {
          c("ExportDefaultDeclaration", e, r);
        }, t.assertExportDefaultSpecifier = function(e, r) {
          c("ExportDefaultSpecifier", e, r);
        }, t.assertExportNamedDeclaration = function(e, r) {
          c("ExportNamedDeclaration", e, r);
        }, t.assertExportNamespaceSpecifier = function(e, r) {
          c("ExportNamespaceSpecifier", e, r);
        }, t.assertExportSpecifier = function(e, r) {
          c("ExportSpecifier", e, r);
        }, t.assertExpression = function(e, r) {
          c("Expression", e, r);
        }, t.assertExpressionStatement = function(e, r) {
          c("ExpressionStatement", e, r);
        }, t.assertExpressionWrapper = function(e, r) {
          c("ExpressionWrapper", e, r);
        }, t.assertFile = function(e, r) {
          c("File", e, r);
        }, t.assertFlow = function(e, r) {
          c("Flow", e, r);
        }, t.assertFlowBaseAnnotation = function(e, r) {
          c("FlowBaseAnnotation", e, r);
        }, t.assertFlowDeclaration = function(e, r) {
          c("FlowDeclaration", e, r);
        }, t.assertFlowPredicate = function(e, r) {
          c("FlowPredicate", e, r);
        }, t.assertFlowType = function(e, r) {
          c("FlowType", e, r);
        }, t.assertFor = function(e, r) {
          c("For", e, r);
        }, t.assertForInStatement = function(e, r) {
          c("ForInStatement", e, r);
        }, t.assertForOfStatement = function(e, r) {
          c("ForOfStatement", e, r);
        }, t.assertForStatement = function(e, r) {
          c("ForStatement", e, r);
        }, t.assertForXStatement = function(e, r) {
          c("ForXStatement", e, r);
        }, t.assertFunction = function(e, r) {
          c("Function", e, r);
        }, t.assertFunctionDeclaration = function(e, r) {
          c("FunctionDeclaration", e, r);
        }, t.assertFunctionExpression = function(e, r) {
          c("FunctionExpression", e, r);
        }, t.assertFunctionParent = function(e, r) {
          c("FunctionParent", e, r);
        }, t.assertFunctionTypeAnnotation = function(e, r) {
          c("FunctionTypeAnnotation", e, r);
        }, t.assertFunctionTypeParam = function(e, r) {
          c("FunctionTypeParam", e, r);
        }, t.assertGenericTypeAnnotation = function(e, r) {
          c("GenericTypeAnnotation", e, r);
        }, t.assertIdentifier = function(e, r) {
          c("Identifier", e, r);
        }, t.assertIfStatement = function(e, r) {
          c("IfStatement", e, r);
        }, t.assertImmutable = function(e, r) {
          c("Immutable", e, r);
        }, t.assertImport = function(e, r) {
          c("Import", e, r);
        }, t.assertImportAttribute = function(e, r) {
          c("ImportAttribute", e, r);
        }, t.assertImportDeclaration = function(e, r) {
          c("ImportDeclaration", e, r);
        }, t.assertImportDefaultSpecifier = function(e, r) {
          c("ImportDefaultSpecifier", e, r);
        }, t.assertImportExpression = function(e, r) {
          c("ImportExpression", e, r);
        }, t.assertImportNamespaceSpecifier = function(e, r) {
          c("ImportNamespaceSpecifier", e, r);
        }, t.assertImportOrExportDeclaration = function(e, r) {
          c("ImportOrExportDeclaration", e, r);
        }, t.assertImportSpecifier = function(e, r) {
          c("ImportSpecifier", e, r);
        }, t.assertIndexedAccessType = function(e, r) {
          c("IndexedAccessType", e, r);
        }, t.assertInferredPredicate = function(e, r) {
          c("InferredPredicate", e, r);
        }, t.assertInterfaceDeclaration = function(e, r) {
          c("InterfaceDeclaration", e, r);
        }, t.assertInterfaceExtends = function(e, r) {
          c("InterfaceExtends", e, r);
        }, t.assertInterfaceTypeAnnotation = function(e, r) {
          c("InterfaceTypeAnnotation", e, r);
        }, t.assertInterpreterDirective = function(e, r) {
          c("InterpreterDirective", e, r);
        }, t.assertIntersectionTypeAnnotation = function(e, r) {
          c("IntersectionTypeAnnotation", e, r);
        }, t.assertJSX = function(e, r) {
          c("JSX", e, r);
        }, t.assertJSXAttribute = function(e, r) {
          c("JSXAttribute", e, r);
        }, t.assertJSXClosingElement = function(e, r) {
          c("JSXClosingElement", e, r);
        }, t.assertJSXClosingFragment = function(e, r) {
          c("JSXClosingFragment", e, r);
        }, t.assertJSXElement = function(e, r) {
          c("JSXElement", e, r);
        }, t.assertJSXEmptyExpression = function(e, r) {
          c("JSXEmptyExpression", e, r);
        }, t.assertJSXExpressionContainer = function(e, r) {
          c("JSXExpressionContainer", e, r);
        }, t.assertJSXFragment = function(e, r) {
          c("JSXFragment", e, r);
        }, t.assertJSXIdentifier = function(e, r) {
          c("JSXIdentifier", e, r);
        }, t.assertJSXMemberExpression = function(e, r) {
          c("JSXMemberExpression", e, r);
        }, t.assertJSXNamespacedName = function(e, r) {
          c("JSXNamespacedName", e, r);
        }, t.assertJSXOpeningElement = function(e, r) {
          c("JSXOpeningElement", e, r);
        }, t.assertJSXOpeningFragment = function(e, r) {
          c("JSXOpeningFragment", e, r);
        }, t.assertJSXSpreadAttribute = function(e, r) {
          c("JSXSpreadAttribute", e, r);
        }, t.assertJSXSpreadChild = function(e, r) {
          c("JSXSpreadChild", e, r);
        }, t.assertJSXText = function(e, r) {
          c("JSXText", e, r);
        }, t.assertLVal = function(e, r) {
          c("LVal", e, r);
        }, t.assertLabeledStatement = function(e, r) {
          c("LabeledStatement", e, r);
        }, t.assertLiteral = function(e, r) {
          c("Literal", e, r);
        }, t.assertLogicalExpression = function(e, r) {
          c("LogicalExpression", e, r);
        }, t.assertLoop = function(e, r) {
          c("Loop", e, r);
        }, t.assertMemberExpression = function(e, r) {
          c("MemberExpression", e, r);
        }, t.assertMetaProperty = function(e, r) {
          c("MetaProperty", e, r);
        }, t.assertMethod = function(e, r) {
          c("Method", e, r);
        }, t.assertMiscellaneous = function(e, r) {
          c("Miscellaneous", e, r);
        }, t.assertMixedTypeAnnotation = function(e, r) {
          c("MixedTypeAnnotation", e, r);
        }, t.assertModuleDeclaration = function(e, r) {
          (0, u.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), c("ModuleDeclaration", e, r);
        }, t.assertModuleExpression = function(e, r) {
          c("ModuleExpression", e, r);
        }, t.assertModuleSpecifier = function(e, r) {
          c("ModuleSpecifier", e, r);
        }, t.assertNewExpression = function(e, r) {
          c("NewExpression", e, r);
        }, t.assertNoop = function(e, r) {
          c("Noop", e, r);
        }, t.assertNullLiteral = function(e, r) {
          c("NullLiteral", e, r);
        }, t.assertNullLiteralTypeAnnotation = function(e, r) {
          c("NullLiteralTypeAnnotation", e, r);
        }, t.assertNullableTypeAnnotation = function(e, r) {
          c("NullableTypeAnnotation", e, r);
        }, t.assertNumberLiteral = function(e, r) {
          (0, u.default)("assertNumberLiteral", "assertNumericLiteral"), c("NumberLiteral", e, r);
        }, t.assertNumberLiteralTypeAnnotation = function(e, r) {
          c("NumberLiteralTypeAnnotation", e, r);
        }, t.assertNumberTypeAnnotation = function(e, r) {
          c("NumberTypeAnnotation", e, r);
        }, t.assertNumericLiteral = function(e, r) {
          c("NumericLiteral", e, r);
        }, t.assertObjectExpression = function(e, r) {
          c("ObjectExpression", e, r);
        }, t.assertObjectMember = function(e, r) {
          c("ObjectMember", e, r);
        }, t.assertObjectMethod = function(e, r) {
          c("ObjectMethod", e, r);
        }, t.assertObjectPattern = function(e, r) {
          c("ObjectPattern", e, r);
        }, t.assertObjectProperty = function(e, r) {
          c("ObjectProperty", e, r);
        }, t.assertObjectTypeAnnotation = function(e, r) {
          c("ObjectTypeAnnotation", e, r);
        }, t.assertObjectTypeCallProperty = function(e, r) {
          c("ObjectTypeCallProperty", e, r);
        }, t.assertObjectTypeIndexer = function(e, r) {
          c("ObjectTypeIndexer", e, r);
        }, t.assertObjectTypeInternalSlot = function(e, r) {
          c("ObjectTypeInternalSlot", e, r);
        }, t.assertObjectTypeProperty = function(e, r) {
          c("ObjectTypeProperty", e, r);
        }, t.assertObjectTypeSpreadProperty = function(e, r) {
          c("ObjectTypeSpreadProperty", e, r);
        }, t.assertOpaqueType = function(e, r) {
          c("OpaqueType", e, r);
        }, t.assertOptionalCallExpression = function(e, r) {
          c("OptionalCallExpression", e, r);
        }, t.assertOptionalIndexedAccessType = function(e, r) {
          c("OptionalIndexedAccessType", e, r);
        }, t.assertOptionalMemberExpression = function(e, r) {
          c("OptionalMemberExpression", e, r);
        }, t.assertParenthesizedExpression = function(e, r) {
          c("ParenthesizedExpression", e, r);
        }, t.assertPattern = function(e, r) {
          c("Pattern", e, r);
        }, t.assertPatternLike = function(e, r) {
          c("PatternLike", e, r);
        }, t.assertPipelineBareFunction = function(e, r) {
          c("PipelineBareFunction", e, r);
        }, t.assertPipelinePrimaryTopicReference = function(e, r) {
          c("PipelinePrimaryTopicReference", e, r);
        }, t.assertPipelineTopicExpression = function(e, r) {
          c("PipelineTopicExpression", e, r);
        }, t.assertPlaceholder = function(e, r) {
          c("Placeholder", e, r);
        }, t.assertPrivate = function(e, r) {
          c("Private", e, r);
        }, t.assertPrivateName = function(e, r) {
          c("PrivateName", e, r);
        }, t.assertProgram = function(e, r) {
          c("Program", e, r);
        }, t.assertProperty = function(e, r) {
          c("Property", e, r);
        }, t.assertPureish = function(e, r) {
          c("Pureish", e, r);
        }, t.assertQualifiedTypeIdentifier = function(e, r) {
          c("QualifiedTypeIdentifier", e, r);
        }, t.assertRecordExpression = function(e, r) {
          c("RecordExpression", e, r);
        }, t.assertRegExpLiteral = function(e, r) {
          c("RegExpLiteral", e, r);
        }, t.assertRegexLiteral = function(e, r) {
          (0, u.default)("assertRegexLiteral", "assertRegExpLiteral"), c("RegexLiteral", e, r);
        }, t.assertRestElement = function(e, r) {
          c("RestElement", e, r);
        }, t.assertRestProperty = function(e, r) {
          (0, u.default)("assertRestProperty", "assertRestElement"), c("RestProperty", e, r);
        }, t.assertReturnStatement = function(e, r) {
          c("ReturnStatement", e, r);
        }, t.assertScopable = function(e, r) {
          c("Scopable", e, r);
        }, t.assertSequenceExpression = function(e, r) {
          c("SequenceExpression", e, r);
        }, t.assertSpreadElement = function(e, r) {
          c("SpreadElement", e, r);
        }, t.assertSpreadProperty = function(e, r) {
          (0, u.default)("assertSpreadProperty", "assertSpreadElement"), c("SpreadProperty", e, r);
        }, t.assertStandardized = function(e, r) {
          c("Standardized", e, r);
        }, t.assertStatement = function(e, r) {
          c("Statement", e, r);
        }, t.assertStaticBlock = function(e, r) {
          c("StaticBlock", e, r);
        }, t.assertStringLiteral = function(e, r) {
          c("StringLiteral", e, r);
        }, t.assertStringLiteralTypeAnnotation = function(e, r) {
          c("StringLiteralTypeAnnotation", e, r);
        }, t.assertStringTypeAnnotation = function(e, r) {
          c("StringTypeAnnotation", e, r);
        }, t.assertSuper = function(e, r) {
          c("Super", e, r);
        }, t.assertSwitchCase = function(e, r) {
          c("SwitchCase", e, r);
        }, t.assertSwitchStatement = function(e, r) {
          c("SwitchStatement", e, r);
        }, t.assertSymbolTypeAnnotation = function(e, r) {
          c("SymbolTypeAnnotation", e, r);
        }, t.assertTSAnyKeyword = function(e, r) {
          c("TSAnyKeyword", e, r);
        }, t.assertTSArrayType = function(e, r) {
          c("TSArrayType", e, r);
        }, t.assertTSAsExpression = function(e, r) {
          c("TSAsExpression", e, r);
        }, t.assertTSBaseType = function(e, r) {
          c("TSBaseType", e, r);
        }, t.assertTSBigIntKeyword = function(e, r) {
          c("TSBigIntKeyword", e, r);
        }, t.assertTSBooleanKeyword = function(e, r) {
          c("TSBooleanKeyword", e, r);
        }, t.assertTSCallSignatureDeclaration = function(e, r) {
          c("TSCallSignatureDeclaration", e, r);
        }, t.assertTSConditionalType = function(e, r) {
          c("TSConditionalType", e, r);
        }, t.assertTSConstructSignatureDeclaration = function(e, r) {
          c("TSConstructSignatureDeclaration", e, r);
        }, t.assertTSConstructorType = function(e, r) {
          c("TSConstructorType", e, r);
        }, t.assertTSDeclareFunction = function(e, r) {
          c("TSDeclareFunction", e, r);
        }, t.assertTSDeclareMethod = function(e, r) {
          c("TSDeclareMethod", e, r);
        }, t.assertTSEntityName = function(e, r) {
          c("TSEntityName", e, r);
        }, t.assertTSEnumDeclaration = function(e, r) {
          c("TSEnumDeclaration", e, r);
        }, t.assertTSEnumMember = function(e, r) {
          c("TSEnumMember", e, r);
        }, t.assertTSExportAssignment = function(e, r) {
          c("TSExportAssignment", e, r);
        }, t.assertTSExpressionWithTypeArguments = function(e, r) {
          c("TSExpressionWithTypeArguments", e, r);
        }, t.assertTSExternalModuleReference = function(e, r) {
          c("TSExternalModuleReference", e, r);
        }, t.assertTSFunctionType = function(e, r) {
          c("TSFunctionType", e, r);
        }, t.assertTSImportEqualsDeclaration = function(e, r) {
          c("TSImportEqualsDeclaration", e, r);
        }, t.assertTSImportType = function(e, r) {
          c("TSImportType", e, r);
        }, t.assertTSIndexSignature = function(e, r) {
          c("TSIndexSignature", e, r);
        }, t.assertTSIndexedAccessType = function(e, r) {
          c("TSIndexedAccessType", e, r);
        }, t.assertTSInferType = function(e, r) {
          c("TSInferType", e, r);
        }, t.assertTSInstantiationExpression = function(e, r) {
          c("TSInstantiationExpression", e, r);
        }, t.assertTSInterfaceBody = function(e, r) {
          c("TSInterfaceBody", e, r);
        }, t.assertTSInterfaceDeclaration = function(e, r) {
          c("TSInterfaceDeclaration", e, r);
        }, t.assertTSIntersectionType = function(e, r) {
          c("TSIntersectionType", e, r);
        }, t.assertTSIntrinsicKeyword = function(e, r) {
          c("TSIntrinsicKeyword", e, r);
        }, t.assertTSLiteralType = function(e, r) {
          c("TSLiteralType", e, r);
        }, t.assertTSMappedType = function(e, r) {
          c("TSMappedType", e, r);
        }, t.assertTSMethodSignature = function(e, r) {
          c("TSMethodSignature", e, r);
        }, t.assertTSModuleBlock = function(e, r) {
          c("TSModuleBlock", e, r);
        }, t.assertTSModuleDeclaration = function(e, r) {
          c("TSModuleDeclaration", e, r);
        }, t.assertTSNamedTupleMember = function(e, r) {
          c("TSNamedTupleMember", e, r);
        }, t.assertTSNamespaceExportDeclaration = function(e, r) {
          c("TSNamespaceExportDeclaration", e, r);
        }, t.assertTSNeverKeyword = function(e, r) {
          c("TSNeverKeyword", e, r);
        }, t.assertTSNonNullExpression = function(e, r) {
          c("TSNonNullExpression", e, r);
        }, t.assertTSNullKeyword = function(e, r) {
          c("TSNullKeyword", e, r);
        }, t.assertTSNumberKeyword = function(e, r) {
          c("TSNumberKeyword", e, r);
        }, t.assertTSObjectKeyword = function(e, r) {
          c("TSObjectKeyword", e, r);
        }, t.assertTSOptionalType = function(e, r) {
          c("TSOptionalType", e, r);
        }, t.assertTSParameterProperty = function(e, r) {
          c("TSParameterProperty", e, r);
        }, t.assertTSParenthesizedType = function(e, r) {
          c("TSParenthesizedType", e, r);
        }, t.assertTSPropertySignature = function(e, r) {
          c("TSPropertySignature", e, r);
        }, t.assertTSQualifiedName = function(e, r) {
          c("TSQualifiedName", e, r);
        }, t.assertTSRestType = function(e, r) {
          c("TSRestType", e, r);
        }, t.assertTSSatisfiesExpression = function(e, r) {
          c("TSSatisfiesExpression", e, r);
        }, t.assertTSStringKeyword = function(e, r) {
          c("TSStringKeyword", e, r);
        }, t.assertTSSymbolKeyword = function(e, r) {
          c("TSSymbolKeyword", e, r);
        }, t.assertTSThisType = function(e, r) {
          c("TSThisType", e, r);
        }, t.assertTSTupleType = function(e, r) {
          c("TSTupleType", e, r);
        }, t.assertTSType = function(e, r) {
          c("TSType", e, r);
        }, t.assertTSTypeAliasDeclaration = function(e, r) {
          c("TSTypeAliasDeclaration", e, r);
        }, t.assertTSTypeAnnotation = function(e, r) {
          c("TSTypeAnnotation", e, r);
        }, t.assertTSTypeAssertion = function(e, r) {
          c("TSTypeAssertion", e, r);
        }, t.assertTSTypeElement = function(e, r) {
          c("TSTypeElement", e, r);
        }, t.assertTSTypeLiteral = function(e, r) {
          c("TSTypeLiteral", e, r);
        }, t.assertTSTypeOperator = function(e, r) {
          c("TSTypeOperator", e, r);
        }, t.assertTSTypeParameter = function(e, r) {
          c("TSTypeParameter", e, r);
        }, t.assertTSTypeParameterDeclaration = function(e, r) {
          c("TSTypeParameterDeclaration", e, r);
        }, t.assertTSTypeParameterInstantiation = function(e, r) {
          c("TSTypeParameterInstantiation", e, r);
        }, t.assertTSTypePredicate = function(e, r) {
          c("TSTypePredicate", e, r);
        }, t.assertTSTypeQuery = function(e, r) {
          c("TSTypeQuery", e, r);
        }, t.assertTSTypeReference = function(e, r) {
          c("TSTypeReference", e, r);
        }, t.assertTSUndefinedKeyword = function(e, r) {
          c("TSUndefinedKeyword", e, r);
        }, t.assertTSUnionType = function(e, r) {
          c("TSUnionType", e, r);
        }, t.assertTSUnknownKeyword = function(e, r) {
          c("TSUnknownKeyword", e, r);
        }, t.assertTSVoidKeyword = function(e, r) {
          c("TSVoidKeyword", e, r);
        }, t.assertTaggedTemplateExpression = function(e, r) {
          c("TaggedTemplateExpression", e, r);
        }, t.assertTemplateElement = function(e, r) {
          c("TemplateElement", e, r);
        }, t.assertTemplateLiteral = function(e, r) {
          c("TemplateLiteral", e, r);
        }, t.assertTerminatorless = function(e, r) {
          c("Terminatorless", e, r);
        }, t.assertThisExpression = function(e, r) {
          c("ThisExpression", e, r);
        }, t.assertThisTypeAnnotation = function(e, r) {
          c("ThisTypeAnnotation", e, r);
        }, t.assertThrowStatement = function(e, r) {
          c("ThrowStatement", e, r);
        }, t.assertTopicReference = function(e, r) {
          c("TopicReference", e, r);
        }, t.assertTryStatement = function(e, r) {
          c("TryStatement", e, r);
        }, t.assertTupleExpression = function(e, r) {
          c("TupleExpression", e, r);
        }, t.assertTupleTypeAnnotation = function(e, r) {
          c("TupleTypeAnnotation", e, r);
        }, t.assertTypeAlias = function(e, r) {
          c("TypeAlias", e, r);
        }, t.assertTypeAnnotation = function(e, r) {
          c("TypeAnnotation", e, r);
        }, t.assertTypeCastExpression = function(e, r) {
          c("TypeCastExpression", e, r);
        }, t.assertTypeParameter = function(e, r) {
          c("TypeParameter", e, r);
        }, t.assertTypeParameterDeclaration = function(e, r) {
          c("TypeParameterDeclaration", e, r);
        }, t.assertTypeParameterInstantiation = function(e, r) {
          c("TypeParameterInstantiation", e, r);
        }, t.assertTypeScript = function(e, r) {
          c("TypeScript", e, r);
        }, t.assertTypeofTypeAnnotation = function(e, r) {
          c("TypeofTypeAnnotation", e, r);
        }, t.assertUnaryExpression = function(e, r) {
          c("UnaryExpression", e, r);
        }, t.assertUnaryLike = function(e, r) {
          c("UnaryLike", e, r);
        }, t.assertUnionTypeAnnotation = function(e, r) {
          c("UnionTypeAnnotation", e, r);
        }, t.assertUpdateExpression = function(e, r) {
          c("UpdateExpression", e, r);
        }, t.assertUserWhitespacable = function(e, r) {
          c("UserWhitespacable", e, r);
        }, t.assertV8IntrinsicIdentifier = function(e, r) {
          c("V8IntrinsicIdentifier", e, r);
        }, t.assertVariableDeclaration = function(e, r) {
          c("VariableDeclaration", e, r);
        }, t.assertVariableDeclarator = function(e, r) {
          c("VariableDeclarator", e, r);
        }, t.assertVariance = function(e, r) {
          c("Variance", e, r);
        }, t.assertVoidTypeAnnotation = function(e, r) {
          c("VoidTypeAnnotation", e, r);
        }, t.assertWhile = function(e, r) {
          c("While", e, r);
        }, t.assertWhileStatement = function(e, r) {
          c("WhileStatement", e, r);
        }, t.assertWithStatement = function(e, r) {
          c("WithStatement", e, r);
        }, t.assertYieldExpression = function(e, r) {
          c("YieldExpression", e, r);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function c(e, r, f) {
          if (!(0, n.default)(e, r, f)) throw new Error(`Expected type "${e}" with option ${JSON.stringify(f)}, but instead got "${r.type}".`);
        }
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c) {
          const e = (0, u.default)(c);
          return e.length === 1 ? e[0] : (0, n.unionTypeAnnotation)(e);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");
        t.default = function(u) {
          switch (u) {
            case "string":
              return (0, n.stringTypeAnnotation)();
            case "number":
              return (0, n.numberTypeAnnotation)();
            case "undefined":
              return (0, n.voidTypeAnnotation)();
            case "boolean":
              return (0, n.booleanTypeAnnotation)();
            case "function":
              return (0, n.genericTypeAnnotation)((0, n.identifier)("Function"));
            case "object":
              return (0, n.genericTypeAnnotation)((0, n.identifier)("Object"));
            case "symbol":
              return (0, n.genericTypeAnnotation)((0, n.identifier)("Symbol"));
            case "bigint":
              return (0, n.anyTypeAnnotation)();
          }
          throw new Error("Invalid typeof value: " + u);
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.anyTypeAnnotation = function() {
          return { type: "AnyTypeAnnotation" };
        }, t.argumentPlaceholder = function() {
          return { type: "ArgumentPlaceholder" };
        }, t.arrayExpression = function(d = []) {
          const p = { type: "ArrayExpression", elements: d }, h = r.ArrayExpression;
          return e(h.elements, p, "elements", d, 1), p;
        }, t.arrayPattern = function(d) {
          const p = { type: "ArrayPattern", elements: d }, h = r.ArrayPattern;
          return e(h.elements, p, "elements", d, 1), p;
        }, t.arrayTypeAnnotation = function(d) {
          const p = { type: "ArrayTypeAnnotation", elementType: d }, h = r.ArrayTypeAnnotation;
          return e(h.elementType, p, "elementType", d, 1), p;
        }, t.arrowFunctionExpression = function(d, p, h = false) {
          const m = { type: "ArrowFunctionExpression", params: d, body: p, async: h, expression: null }, E = r.ArrowFunctionExpression;
          return e(E.params, m, "params", d, 1), e(E.body, m, "body", p, 1), e(E.async, m, "async", h), m;
        }, t.assignmentExpression = function(d, p, h) {
          const m = { type: "AssignmentExpression", operator: d, left: p, right: h }, E = r.AssignmentExpression;
          return e(E.operator, m, "operator", d), e(E.left, m, "left", p, 1), e(E.right, m, "right", h, 1), m;
        }, t.assignmentPattern = function(d, p) {
          const h = { type: "AssignmentPattern", left: d, right: p }, m = r.AssignmentPattern;
          return e(m.left, h, "left", d, 1), e(m.right, h, "right", p, 1), h;
        }, t.awaitExpression = function(d) {
          const p = { type: "AwaitExpression", argument: d }, h = r.AwaitExpression;
          return e(h.argument, p, "argument", d, 1), p;
        }, t.bigIntLiteral = function(d) {
          const p = { type: "BigIntLiteral", value: d }, h = r.BigIntLiteral;
          return e(h.value, p, "value", d), p;
        }, t.binaryExpression = function(d, p, h) {
          const m = { type: "BinaryExpression", operator: d, left: p, right: h }, E = r.BinaryExpression;
          return e(E.operator, m, "operator", d), e(E.left, m, "left", p, 1), e(E.right, m, "right", h, 1), m;
        }, t.bindExpression = function(d, p) {
          const h = { type: "BindExpression", object: d, callee: p }, m = r.BindExpression;
          return e(m.object, h, "object", d, 1), e(m.callee, h, "callee", p, 1), h;
        }, t.blockStatement = function(d, p = []) {
          const h = { type: "BlockStatement", body: d, directives: p }, m = r.BlockStatement;
          return e(m.body, h, "body", d, 1), e(m.directives, h, "directives", p, 1), h;
        }, t.booleanLiteral = function(d) {
          const p = { type: "BooleanLiteral", value: d }, h = r.BooleanLiteral;
          return e(h.value, p, "value", d), p;
        }, t.booleanLiteralTypeAnnotation = function(d) {
          const p = { type: "BooleanLiteralTypeAnnotation", value: d }, h = r.BooleanLiteralTypeAnnotation;
          return e(h.value, p, "value", d), p;
        }, t.booleanTypeAnnotation = function() {
          return { type: "BooleanTypeAnnotation" };
        }, t.breakStatement = function(d = null) {
          const p = { type: "BreakStatement", label: d }, h = r.BreakStatement;
          return e(h.label, p, "label", d, 1), p;
        }, t.callExpression = function(d, p) {
          const h = { type: "CallExpression", callee: d, arguments: p }, m = r.CallExpression;
          return e(m.callee, h, "callee", d, 1), e(m.arguments, h, "arguments", p, 1), h;
        }, t.catchClause = function(d = null, p) {
          const h = { type: "CatchClause", param: d, body: p }, m = r.CatchClause;
          return e(m.param, h, "param", d, 1), e(m.body, h, "body", p, 1), h;
        }, t.classAccessorProperty = function(d, p = null, h = null, m = null, E = false, _ = false) {
          const C = { type: "ClassAccessorProperty", key: d, value: p, typeAnnotation: h, decorators: m, computed: E, static: _ }, w = r.ClassAccessorProperty;
          return e(w.key, C, "key", d, 1), e(w.value, C, "value", p, 1), e(w.typeAnnotation, C, "typeAnnotation", h, 1), e(w.decorators, C, "decorators", m, 1), e(w.computed, C, "computed", E), e(w.static, C, "static", _), C;
        }, t.classBody = function(d) {
          const p = { type: "ClassBody", body: d }, h = r.ClassBody;
          return e(h.body, p, "body", d, 1), p;
        }, t.classDeclaration = function(d = null, p = null, h, m = null) {
          const E = { type: "ClassDeclaration", id: d, superClass: p, body: h, decorators: m }, _ = r.ClassDeclaration;
          return e(_.id, E, "id", d, 1), e(_.superClass, E, "superClass", p, 1), e(_.body, E, "body", h, 1), e(_.decorators, E, "decorators", m, 1), E;
        }, t.classExpression = function(d = null, p = null, h, m = null) {
          const E = { type: "ClassExpression", id: d, superClass: p, body: h, decorators: m }, _ = r.ClassExpression;
          return e(_.id, E, "id", d, 1), e(_.superClass, E, "superClass", p, 1), e(_.body, E, "body", h, 1), e(_.decorators, E, "decorators", m, 1), E;
        }, t.classImplements = function(d, p = null) {
          const h = { type: "ClassImplements", id: d, typeParameters: p }, m = r.ClassImplements;
          return e(m.id, h, "id", d, 1), e(m.typeParameters, h, "typeParameters", p, 1), h;
        }, t.classMethod = function(d = "method", p, h, m, E = false, _ = false, C = false, w = false) {
          const I = { type: "ClassMethod", kind: d, key: p, params: h, body: m, computed: E, static: _, generator: C, async: w }, D = r.ClassMethod;
          return e(D.kind, I, "kind", d), e(D.key, I, "key", p, 1), e(D.params, I, "params", h, 1), e(D.body, I, "body", m, 1), e(D.computed, I, "computed", E), e(D.static, I, "static", _), e(D.generator, I, "generator", C), e(D.async, I, "async", w), I;
        }, t.classPrivateMethod = function(d = "method", p, h, m, E = false) {
          const _ = { type: "ClassPrivateMethod", kind: d, key: p, params: h, body: m, static: E }, C = r.ClassPrivateMethod;
          return e(C.kind, _, "kind", d), e(C.key, _, "key", p, 1), e(C.params, _, "params", h, 1), e(C.body, _, "body", m, 1), e(C.static, _, "static", E), _;
        }, t.classPrivateProperty = function(d, p = null, h = null, m = false) {
          const E = { type: "ClassPrivateProperty", key: d, value: p, decorators: h, static: m }, _ = r.ClassPrivateProperty;
          return e(_.key, E, "key", d, 1), e(_.value, E, "value", p, 1), e(_.decorators, E, "decorators", h, 1), e(_.static, E, "static", m), E;
        }, t.classProperty = function(d, p = null, h = null, m = null, E = false, _ = false) {
          const C = { type: "ClassProperty", key: d, value: p, typeAnnotation: h, decorators: m, computed: E, static: _ }, w = r.ClassProperty;
          return e(w.key, C, "key", d, 1), e(w.value, C, "value", p, 1), e(w.typeAnnotation, C, "typeAnnotation", h, 1), e(w.decorators, C, "decorators", m, 1), e(w.computed, C, "computed", E), e(w.static, C, "static", _), C;
        }, t.conditionalExpression = function(d, p, h) {
          const m = { type: "ConditionalExpression", test: d, consequent: p, alternate: h }, E = r.ConditionalExpression;
          return e(E.test, m, "test", d, 1), e(E.consequent, m, "consequent", p, 1), e(E.alternate, m, "alternate", h, 1), m;
        }, t.continueStatement = function(d = null) {
          const p = { type: "ContinueStatement", label: d }, h = r.ContinueStatement;
          return e(h.label, p, "label", d, 1), p;
        }, t.debuggerStatement = function() {
          return { type: "DebuggerStatement" };
        }, t.decimalLiteral = function(d) {
          const p = { type: "DecimalLiteral", value: d }, h = r.DecimalLiteral;
          return e(h.value, p, "value", d), p;
        }, t.declareClass = function(d, p = null, h = null, m) {
          const E = { type: "DeclareClass", id: d, typeParameters: p, extends: h, body: m }, _ = r.DeclareClass;
          return e(_.id, E, "id", d, 1), e(_.typeParameters, E, "typeParameters", p, 1), e(_.extends, E, "extends", h, 1), e(_.body, E, "body", m, 1), E;
        }, t.declareExportAllDeclaration = function(d, p = null) {
          const h = { type: "DeclareExportAllDeclaration", source: d, attributes: p }, m = r.DeclareExportAllDeclaration;
          return e(m.source, h, "source", d, 1), e(m.attributes, h, "attributes", p, 1), h;
        }, t.declareExportDeclaration = function(d = null, p = null, h = null, m = null) {
          const E = { type: "DeclareExportDeclaration", declaration: d, specifiers: p, source: h, attributes: m }, _ = r.DeclareExportDeclaration;
          return e(_.declaration, E, "declaration", d, 1), e(_.specifiers, E, "specifiers", p, 1), e(_.source, E, "source", h, 1), e(_.attributes, E, "attributes", m, 1), E;
        }, t.declareFunction = function(d) {
          const p = { type: "DeclareFunction", id: d }, h = r.DeclareFunction;
          return e(h.id, p, "id", d, 1), p;
        }, t.declareInterface = function(d, p = null, h = null, m) {
          const E = { type: "DeclareInterface", id: d, typeParameters: p, extends: h, body: m }, _ = r.DeclareInterface;
          return e(_.id, E, "id", d, 1), e(_.typeParameters, E, "typeParameters", p, 1), e(_.extends, E, "extends", h, 1), e(_.body, E, "body", m, 1), E;
        }, t.declareModule = function(d, p, h = null) {
          const m = { type: "DeclareModule", id: d, body: p, kind: h }, E = r.DeclareModule;
          return e(E.id, m, "id", d, 1), e(E.body, m, "body", p, 1), e(E.kind, m, "kind", h), m;
        }, t.declareModuleExports = function(d) {
          const p = { type: "DeclareModuleExports", typeAnnotation: d }, h = r.DeclareModuleExports;
          return e(h.typeAnnotation, p, "typeAnnotation", d, 1), p;
        }, t.declareOpaqueType = function(d, p = null, h = null) {
          const m = { type: "DeclareOpaqueType", id: d, typeParameters: p, supertype: h }, E = r.DeclareOpaqueType;
          return e(E.id, m, "id", d, 1), e(E.typeParameters, m, "typeParameters", p, 1), e(E.supertype, m, "supertype", h, 1), m;
        }, t.declareTypeAlias = function(d, p = null, h) {
          const m = { type: "DeclareTypeAlias", id: d, typeParameters: p, right: h }, E = r.DeclareTypeAlias;
          return e(E.id, m, "id", d, 1), e(E.typeParameters, m, "typeParameters", p, 1), e(E.right, m, "right", h, 1), m;
        }, t.declareVariable = function(d) {
          const p = { type: "DeclareVariable", id: d }, h = r.DeclareVariable;
          return e(h.id, p, "id", d, 1), p;
        }, t.declaredPredicate = function(d) {
          const p = { type: "DeclaredPredicate", value: d }, h = r.DeclaredPredicate;
          return e(h.value, p, "value", d, 1), p;
        }, t.decorator = function(d) {
          const p = { type: "Decorator", expression: d }, h = r.Decorator;
          return e(h.expression, p, "expression", d, 1), p;
        }, t.directive = function(d) {
          const p = { type: "Directive", value: d }, h = r.Directive;
          return e(h.value, p, "value", d, 1), p;
        }, t.directiveLiteral = function(d) {
          const p = { type: "DirectiveLiteral", value: d }, h = r.DirectiveLiteral;
          return e(h.value, p, "value", d), p;
        }, t.doExpression = function(d, p = false) {
          const h = { type: "DoExpression", body: d, async: p }, m = r.DoExpression;
          return e(m.body, h, "body", d, 1), e(m.async, h, "async", p), h;
        }, t.doWhileStatement = function(d, p) {
          const h = { type: "DoWhileStatement", test: d, body: p }, m = r.DoWhileStatement;
          return e(m.test, h, "test", d, 1), e(m.body, h, "body", p, 1), h;
        }, t.emptyStatement = function() {
          return { type: "EmptyStatement" };
        }, t.emptyTypeAnnotation = function() {
          return { type: "EmptyTypeAnnotation" };
        }, t.enumBooleanBody = function(d) {
          const p = { type: "EnumBooleanBody", members: d, explicitType: null, hasUnknownMembers: null }, h = r.EnumBooleanBody;
          return e(h.members, p, "members", d, 1), p;
        }, t.enumBooleanMember = function(d) {
          const p = { type: "EnumBooleanMember", id: d, init: null }, h = r.EnumBooleanMember;
          return e(h.id, p, "id", d, 1), p;
        }, t.enumDeclaration = function(d, p) {
          const h = { type: "EnumDeclaration", id: d, body: p }, m = r.EnumDeclaration;
          return e(m.id, h, "id", d, 1), e(m.body, h, "body", p, 1), h;
        }, t.enumDefaultedMember = function(d) {
          const p = { type: "EnumDefaultedMember", id: d }, h = r.EnumDefaultedMember;
          return e(h.id, p, "id", d, 1), p;
        }, t.enumNumberBody = function(d) {
          const p = { type: "EnumNumberBody", members: d, explicitType: null, hasUnknownMembers: null }, h = r.EnumNumberBody;
          return e(h.members, p, "members", d, 1), p;
        }, t.enumNumberMember = function(d, p) {
          const h = { type: "EnumNumberMember", id: d, init: p }, m = r.EnumNumberMember;
          return e(m.id, h, "id", d, 1), e(m.init, h, "init", p, 1), h;
        }, t.enumStringBody = function(d) {
          const p = { type: "EnumStringBody", members: d, explicitType: null, hasUnknownMembers: null }, h = r.EnumStringBody;
          return e(h.members, p, "members", d, 1), p;
        }, t.enumStringMember = function(d, p) {
          const h = { type: "EnumStringMember", id: d, init: p }, m = r.EnumStringMember;
          return e(m.id, h, "id", d, 1), e(m.init, h, "init", p, 1), h;
        }, t.enumSymbolBody = function(d) {
          const p = { type: "EnumSymbolBody", members: d, hasUnknownMembers: null }, h = r.EnumSymbolBody;
          return e(h.members, p, "members", d, 1), p;
        }, t.existsTypeAnnotation = function() {
          return { type: "ExistsTypeAnnotation" };
        }, t.exportAllDeclaration = function(d) {
          const p = { type: "ExportAllDeclaration", source: d }, h = r.ExportAllDeclaration;
          return e(h.source, p, "source", d, 1), p;
        }, t.exportDefaultDeclaration = function(d) {
          const p = { type: "ExportDefaultDeclaration", declaration: d }, h = r.ExportDefaultDeclaration;
          return e(h.declaration, p, "declaration", d, 1), p;
        }, t.exportDefaultSpecifier = function(d) {
          const p = { type: "ExportDefaultSpecifier", exported: d }, h = r.ExportDefaultSpecifier;
          return e(h.exported, p, "exported", d, 1), p;
        }, t.exportNamedDeclaration = function(d = null, p = [], h = null) {
          const m = { type: "ExportNamedDeclaration", declaration: d, specifiers: p, source: h }, E = r.ExportNamedDeclaration;
          return e(E.declaration, m, "declaration", d, 1), e(E.specifiers, m, "specifiers", p, 1), e(E.source, m, "source", h, 1), m;
        }, t.exportNamespaceSpecifier = function(d) {
          const p = { type: "ExportNamespaceSpecifier", exported: d }, h = r.ExportNamespaceSpecifier;
          return e(h.exported, p, "exported", d, 1), p;
        }, t.exportSpecifier = function(d, p) {
          const h = { type: "ExportSpecifier", local: d, exported: p }, m = r.ExportSpecifier;
          return e(m.local, h, "local", d, 1), e(m.exported, h, "exported", p, 1), h;
        }, t.expressionStatement = function(d) {
          const p = { type: "ExpressionStatement", expression: d }, h = r.ExpressionStatement;
          return e(h.expression, p, "expression", d, 1), p;
        }, t.file = function(d, p = null, h = null) {
          const m = { type: "File", program: d, comments: p, tokens: h }, E = r.File;
          return e(E.program, m, "program", d, 1), e(E.comments, m, "comments", p, 1), e(E.tokens, m, "tokens", h), m;
        }, t.forInStatement = function(d, p, h) {
          const m = { type: "ForInStatement", left: d, right: p, body: h }, E = r.ForInStatement;
          return e(E.left, m, "left", d, 1), e(E.right, m, "right", p, 1), e(E.body, m, "body", h, 1), m;
        }, t.forOfStatement = function(d, p, h, m = false) {
          const E = { type: "ForOfStatement", left: d, right: p, body: h, await: m }, _ = r.ForOfStatement;
          return e(_.left, E, "left", d, 1), e(_.right, E, "right", p, 1), e(_.body, E, "body", h, 1), e(_.await, E, "await", m), E;
        }, t.forStatement = function(d = null, p = null, h = null, m) {
          const E = { type: "ForStatement", init: d, test: p, update: h, body: m }, _ = r.ForStatement;
          return e(_.init, E, "init", d, 1), e(_.test, E, "test", p, 1), e(_.update, E, "update", h, 1), e(_.body, E, "body", m, 1), E;
        }, t.functionDeclaration = function(d = null, p, h, m = false, E = false) {
          const _ = { type: "FunctionDeclaration", id: d, params: p, body: h, generator: m, async: E }, C = r.FunctionDeclaration;
          return e(C.id, _, "id", d, 1), e(C.params, _, "params", p, 1), e(C.body, _, "body", h, 1), e(C.generator, _, "generator", m), e(C.async, _, "async", E), _;
        }, t.functionExpression = function(d = null, p, h, m = false, E = false) {
          const _ = { type: "FunctionExpression", id: d, params: p, body: h, generator: m, async: E }, C = r.FunctionExpression;
          return e(C.id, _, "id", d, 1), e(C.params, _, "params", p, 1), e(C.body, _, "body", h, 1), e(C.generator, _, "generator", m), e(C.async, _, "async", E), _;
        }, t.functionTypeAnnotation = function(d = null, p, h = null, m) {
          const E = { type: "FunctionTypeAnnotation", typeParameters: d, params: p, rest: h, returnType: m }, _ = r.FunctionTypeAnnotation;
          return e(_.typeParameters, E, "typeParameters", d, 1), e(_.params, E, "params", p, 1), e(_.rest, E, "rest", h, 1), e(_.returnType, E, "returnType", m, 1), E;
        }, t.functionTypeParam = function(d = null, p) {
          const h = { type: "FunctionTypeParam", name: d, typeAnnotation: p }, m = r.FunctionTypeParam;
          return e(m.name, h, "name", d, 1), e(m.typeAnnotation, h, "typeAnnotation", p, 1), h;
        }, t.genericTypeAnnotation = function(d, p = null) {
          const h = { type: "GenericTypeAnnotation", id: d, typeParameters: p }, m = r.GenericTypeAnnotation;
          return e(m.id, h, "id", d, 1), e(m.typeParameters, h, "typeParameters", p, 1), h;
        }, t.identifier = function(d) {
          const p = { type: "Identifier", name: d }, h = r.Identifier;
          return e(h.name, p, "name", d), p;
        }, t.ifStatement = function(d, p, h = null) {
          const m = { type: "IfStatement", test: d, consequent: p, alternate: h }, E = r.IfStatement;
          return e(E.test, m, "test", d, 1), e(E.consequent, m, "consequent", p, 1), e(E.alternate, m, "alternate", h, 1), m;
        }, t.import = function() {
          return { type: "Import" };
        }, t.importAttribute = function(d, p) {
          const h = { type: "ImportAttribute", key: d, value: p }, m = r.ImportAttribute;
          return e(m.key, h, "key", d, 1), e(m.value, h, "value", p, 1), h;
        }, t.importDeclaration = function(d, p) {
          const h = { type: "ImportDeclaration", specifiers: d, source: p }, m = r.ImportDeclaration;
          return e(m.specifiers, h, "specifiers", d, 1), e(m.source, h, "source", p, 1), h;
        }, t.importDefaultSpecifier = function(d) {
          const p = { type: "ImportDefaultSpecifier", local: d }, h = r.ImportDefaultSpecifier;
          return e(h.local, p, "local", d, 1), p;
        }, t.importExpression = function(d, p = null) {
          const h = { type: "ImportExpression", source: d, options: p }, m = r.ImportExpression;
          return e(m.source, h, "source", d, 1), e(m.options, h, "options", p, 1), h;
        }, t.importNamespaceSpecifier = function(d) {
          const p = { type: "ImportNamespaceSpecifier", local: d }, h = r.ImportNamespaceSpecifier;
          return e(h.local, p, "local", d, 1), p;
        }, t.importSpecifier = function(d, p) {
          const h = { type: "ImportSpecifier", local: d, imported: p }, m = r.ImportSpecifier;
          return e(m.local, h, "local", d, 1), e(m.imported, h, "imported", p, 1), h;
        }, t.indexedAccessType = function(d, p) {
          const h = { type: "IndexedAccessType", objectType: d, indexType: p }, m = r.IndexedAccessType;
          return e(m.objectType, h, "objectType", d, 1), e(m.indexType, h, "indexType", p, 1), h;
        }, t.inferredPredicate = function() {
          return { type: "InferredPredicate" };
        }, t.interfaceDeclaration = function(d, p = null, h = null, m) {
          const E = { type: "InterfaceDeclaration", id: d, typeParameters: p, extends: h, body: m }, _ = r.InterfaceDeclaration;
          return e(_.id, E, "id", d, 1), e(_.typeParameters, E, "typeParameters", p, 1), e(_.extends, E, "extends", h, 1), e(_.body, E, "body", m, 1), E;
        }, t.interfaceExtends = function(d, p = null) {
          const h = { type: "InterfaceExtends", id: d, typeParameters: p }, m = r.InterfaceExtends;
          return e(m.id, h, "id", d, 1), e(m.typeParameters, h, "typeParameters", p, 1), h;
        }, t.interfaceTypeAnnotation = function(d = null, p) {
          const h = { type: "InterfaceTypeAnnotation", extends: d, body: p }, m = r.InterfaceTypeAnnotation;
          return e(m.extends, h, "extends", d, 1), e(m.body, h, "body", p, 1), h;
        }, t.interpreterDirective = function(d) {
          const p = { type: "InterpreterDirective", value: d }, h = r.InterpreterDirective;
          return e(h.value, p, "value", d), p;
        }, t.intersectionTypeAnnotation = function(d) {
          const p = { type: "IntersectionTypeAnnotation", types: d }, h = r.IntersectionTypeAnnotation;
          return e(h.types, p, "types", d, 1), p;
        }, t.jSXAttribute = t.jsxAttribute = function(d, p = null) {
          const h = { type: "JSXAttribute", name: d, value: p }, m = r.JSXAttribute;
          return e(m.name, h, "name", d, 1), e(m.value, h, "value", p, 1), h;
        }, t.jSXClosingElement = t.jsxClosingElement = function(d) {
          const p = { type: "JSXClosingElement", name: d }, h = r.JSXClosingElement;
          return e(h.name, p, "name", d, 1), p;
        }, t.jSXClosingFragment = t.jsxClosingFragment = function() {
          return { type: "JSXClosingFragment" };
        }, t.jSXElement = t.jsxElement = function(d, p = null, h, m = null) {
          const E = { type: "JSXElement", openingElement: d, closingElement: p, children: h, selfClosing: m }, _ = r.JSXElement;
          return e(_.openingElement, E, "openingElement", d, 1), e(_.closingElement, E, "closingElement", p, 1), e(_.children, E, "children", h, 1), e(_.selfClosing, E, "selfClosing", m), E;
        }, t.jSXEmptyExpression = t.jsxEmptyExpression = function() {
          return { type: "JSXEmptyExpression" };
        }, t.jSXExpressionContainer = t.jsxExpressionContainer = function(d) {
          const p = { type: "JSXExpressionContainer", expression: d }, h = r.JSXExpressionContainer;
          return e(h.expression, p, "expression", d, 1), p;
        }, t.jSXFragment = t.jsxFragment = function(d, p, h) {
          const m = { type: "JSXFragment", openingFragment: d, closingFragment: p, children: h }, E = r.JSXFragment;
          return e(E.openingFragment, m, "openingFragment", d, 1), e(E.closingFragment, m, "closingFragment", p, 1), e(E.children, m, "children", h, 1), m;
        }, t.jSXIdentifier = t.jsxIdentifier = function(d) {
          const p = { type: "JSXIdentifier", name: d }, h = r.JSXIdentifier;
          return e(h.name, p, "name", d), p;
        }, t.jSXMemberExpression = t.jsxMemberExpression = function(d, p) {
          const h = { type: "JSXMemberExpression", object: d, property: p }, m = r.JSXMemberExpression;
          return e(m.object, h, "object", d, 1), e(m.property, h, "property", p, 1), h;
        }, t.jSXNamespacedName = t.jsxNamespacedName = function(d, p) {
          const h = { type: "JSXNamespacedName", namespace: d, name: p }, m = r.JSXNamespacedName;
          return e(m.namespace, h, "namespace", d, 1), e(m.name, h, "name", p, 1), h;
        }, t.jSXOpeningElement = t.jsxOpeningElement = function(d, p, h = false) {
          const m = { type: "JSXOpeningElement", name: d, attributes: p, selfClosing: h }, E = r.JSXOpeningElement;
          return e(E.name, m, "name", d, 1), e(E.attributes, m, "attributes", p, 1), e(E.selfClosing, m, "selfClosing", h), m;
        }, t.jSXOpeningFragment = t.jsxOpeningFragment = function() {
          return { type: "JSXOpeningFragment" };
        }, t.jSXSpreadAttribute = t.jsxSpreadAttribute = function(d) {
          const p = { type: "JSXSpreadAttribute", argument: d }, h = r.JSXSpreadAttribute;
          return e(h.argument, p, "argument", d, 1), p;
        }, t.jSXSpreadChild = t.jsxSpreadChild = function(d) {
          const p = { type: "JSXSpreadChild", expression: d }, h = r.JSXSpreadChild;
          return e(h.expression, p, "expression", d, 1), p;
        }, t.jSXText = t.jsxText = function(d) {
          const p = { type: "JSXText", value: d }, h = r.JSXText;
          return e(h.value, p, "value", d), p;
        }, t.labeledStatement = function(d, p) {
          const h = { type: "LabeledStatement", label: d, body: p }, m = r.LabeledStatement;
          return e(m.label, h, "label", d, 1), e(m.body, h, "body", p, 1), h;
        }, t.logicalExpression = function(d, p, h) {
          const m = { type: "LogicalExpression", operator: d, left: p, right: h }, E = r.LogicalExpression;
          return e(E.operator, m, "operator", d), e(E.left, m, "left", p, 1), e(E.right, m, "right", h, 1), m;
        }, t.memberExpression = function(d, p, h = false, m = null) {
          const E = { type: "MemberExpression", object: d, property: p, computed: h, optional: m }, _ = r.MemberExpression;
          return e(_.object, E, "object", d, 1), e(_.property, E, "property", p, 1), e(_.computed, E, "computed", h), e(_.optional, E, "optional", m), E;
        }, t.metaProperty = function(d, p) {
          const h = { type: "MetaProperty", meta: d, property: p }, m = r.MetaProperty;
          return e(m.meta, h, "meta", d, 1), e(m.property, h, "property", p, 1), h;
        }, t.mixedTypeAnnotation = function() {
          return { type: "MixedTypeAnnotation" };
        }, t.moduleExpression = function(d) {
          const p = { type: "ModuleExpression", body: d }, h = r.ModuleExpression;
          return e(h.body, p, "body", d, 1), p;
        }, t.newExpression = function(d, p) {
          const h = { type: "NewExpression", callee: d, arguments: p }, m = r.NewExpression;
          return e(m.callee, h, "callee", d, 1), e(m.arguments, h, "arguments", p, 1), h;
        }, t.noop = function() {
          return { type: "Noop" };
        }, t.nullLiteral = function() {
          return { type: "NullLiteral" };
        }, t.nullLiteralTypeAnnotation = function() {
          return { type: "NullLiteralTypeAnnotation" };
        }, t.nullableTypeAnnotation = function(d) {
          const p = { type: "NullableTypeAnnotation", typeAnnotation: d }, h = r.NullableTypeAnnotation;
          return e(h.typeAnnotation, p, "typeAnnotation", d, 1), p;
        }, t.numberLiteral = function(d) {
          return (0, u.default)("NumberLiteral", "NumericLiteral", "The node type "), f(d);
        }, t.numberLiteralTypeAnnotation = function(d) {
          const p = { type: "NumberLiteralTypeAnnotation", value: d }, h = r.NumberLiteralTypeAnnotation;
          return e(h.value, p, "value", d), p;
        }, t.numberTypeAnnotation = function() {
          return { type: "NumberTypeAnnotation" };
        }, t.numericLiteral = f, t.objectExpression = function(d) {
          const p = { type: "ObjectExpression", properties: d }, h = r.ObjectExpression;
          return e(h.properties, p, "properties", d, 1), p;
        }, t.objectMethod = function(d = "method", p, h, m, E = false, _ = false, C = false) {
          const w = { type: "ObjectMethod", kind: d, key: p, params: h, body: m, computed: E, generator: _, async: C }, I = r.ObjectMethod;
          return e(I.kind, w, "kind", d), e(I.key, w, "key", p, 1), e(I.params, w, "params", h, 1), e(I.body, w, "body", m, 1), e(I.computed, w, "computed", E), e(I.generator, w, "generator", _), e(I.async, w, "async", C), w;
        }, t.objectPattern = function(d) {
          const p = { type: "ObjectPattern", properties: d }, h = r.ObjectPattern;
          return e(h.properties, p, "properties", d, 1), p;
        }, t.objectProperty = function(d, p, h = false, m = false, E = null) {
          const _ = { type: "ObjectProperty", key: d, value: p, computed: h, shorthand: m, decorators: E }, C = r.ObjectProperty;
          return e(C.key, _, "key", d, 1), e(C.value, _, "value", p, 1), e(C.computed, _, "computed", h), e(C.shorthand, _, "shorthand", m), e(C.decorators, _, "decorators", E, 1), _;
        }, t.objectTypeAnnotation = function(d, p = [], h = [], m = [], E = false) {
          const _ = { type: "ObjectTypeAnnotation", properties: d, indexers: p, callProperties: h, internalSlots: m, exact: E }, C = r.ObjectTypeAnnotation;
          return e(C.properties, _, "properties", d, 1), e(C.indexers, _, "indexers", p, 1), e(C.callProperties, _, "callProperties", h, 1), e(C.internalSlots, _, "internalSlots", m, 1), e(C.exact, _, "exact", E), _;
        }, t.objectTypeCallProperty = function(d) {
          const p = { type: "ObjectTypeCallProperty", value: d, static: null }, h = r.ObjectTypeCallProperty;
          return e(h.value, p, "value", d, 1), p;
        }, t.objectTypeIndexer = function(d = null, p, h, m = null) {
          const E = { type: "ObjectTypeIndexer", id: d, key: p, value: h, variance: m, static: null }, _ = r.ObjectTypeIndexer;
          return e(_.id, E, "id", d, 1), e(_.key, E, "key", p, 1), e(_.value, E, "value", h, 1), e(_.variance, E, "variance", m, 1), E;
        }, t.objectTypeInternalSlot = function(d, p, h, m, E) {
          const _ = { type: "ObjectTypeInternalSlot", id: d, value: p, optional: h, static: m, method: E }, C = r.ObjectTypeInternalSlot;
          return e(C.id, _, "id", d, 1), e(C.value, _, "value", p, 1), e(C.optional, _, "optional", h), e(C.static, _, "static", m), e(C.method, _, "method", E), _;
        }, t.objectTypeProperty = function(d, p, h = null) {
          const m = { type: "ObjectTypeProperty", key: d, value: p, variance: h, kind: null, method: null, optional: null, proto: null, static: null }, E = r.ObjectTypeProperty;
          return e(E.key, m, "key", d, 1), e(E.value, m, "value", p, 1), e(E.variance, m, "variance", h, 1), m;
        }, t.objectTypeSpreadProperty = function(d) {
          const p = { type: "ObjectTypeSpreadProperty", argument: d }, h = r.ObjectTypeSpreadProperty;
          return e(h.argument, p, "argument", d, 1), p;
        }, t.opaqueType = function(d, p = null, h = null, m) {
          const E = { type: "OpaqueType", id: d, typeParameters: p, supertype: h, impltype: m }, _ = r.OpaqueType;
          return e(_.id, E, "id", d, 1), e(_.typeParameters, E, "typeParameters", p, 1), e(_.supertype, E, "supertype", h, 1), e(_.impltype, E, "impltype", m, 1), E;
        }, t.optionalCallExpression = function(d, p, h) {
          const m = { type: "OptionalCallExpression", callee: d, arguments: p, optional: h }, E = r.OptionalCallExpression;
          return e(E.callee, m, "callee", d, 1), e(E.arguments, m, "arguments", p, 1), e(E.optional, m, "optional", h), m;
        }, t.optionalIndexedAccessType = function(d, p) {
          const h = { type: "OptionalIndexedAccessType", objectType: d, indexType: p, optional: null }, m = r.OptionalIndexedAccessType;
          return e(m.objectType, h, "objectType", d, 1), e(m.indexType, h, "indexType", p, 1), h;
        }, t.optionalMemberExpression = function(d, p, h = false, m) {
          const E = { type: "OptionalMemberExpression", object: d, property: p, computed: h, optional: m }, _ = r.OptionalMemberExpression;
          return e(_.object, E, "object", d, 1), e(_.property, E, "property", p, 1), e(_.computed, E, "computed", h), e(_.optional, E, "optional", m), E;
        }, t.parenthesizedExpression = function(d) {
          const p = { type: "ParenthesizedExpression", expression: d }, h = r.ParenthesizedExpression;
          return e(h.expression, p, "expression", d, 1), p;
        }, t.pipelineBareFunction = function(d) {
          const p = { type: "PipelineBareFunction", callee: d }, h = r.PipelineBareFunction;
          return e(h.callee, p, "callee", d, 1), p;
        }, t.pipelinePrimaryTopicReference = function() {
          return { type: "PipelinePrimaryTopicReference" };
        }, t.pipelineTopicExpression = function(d) {
          const p = { type: "PipelineTopicExpression", expression: d }, h = r.PipelineTopicExpression;
          return e(h.expression, p, "expression", d, 1), p;
        }, t.placeholder = function(d, p) {
          const h = { type: "Placeholder", expectedNode: d, name: p }, m = r.Placeholder;
          return e(m.expectedNode, h, "expectedNode", d), e(m.name, h, "name", p, 1), h;
        }, t.privateName = function(d) {
          const p = { type: "PrivateName", id: d }, h = r.PrivateName;
          return e(h.id, p, "id", d, 1), p;
        }, t.program = function(d, p = [], h = "script", m = null) {
          const E = { type: "Program", body: d, directives: p, sourceType: h, interpreter: m }, _ = r.Program;
          return e(_.body, E, "body", d, 1), e(_.directives, E, "directives", p, 1), e(_.sourceType, E, "sourceType", h), e(_.interpreter, E, "interpreter", m, 1), E;
        }, t.qualifiedTypeIdentifier = function(d, p) {
          const h = { type: "QualifiedTypeIdentifier", id: d, qualification: p }, m = r.QualifiedTypeIdentifier;
          return e(m.id, h, "id", d, 1), e(m.qualification, h, "qualification", p, 1), h;
        }, t.recordExpression = function(d) {
          const p = { type: "RecordExpression", properties: d }, h = r.RecordExpression;
          return e(h.properties, p, "properties", d, 1), p;
        }, t.regExpLiteral = y, t.regexLiteral = function(d, p = "") {
          return (0, u.default)("RegexLiteral", "RegExpLiteral", "The node type "), y(d, p);
        }, t.restElement = S, t.restProperty = function(d) {
          return (0, u.default)("RestProperty", "RestElement", "The node type "), S(d);
        }, t.returnStatement = function(d = null) {
          const p = { type: "ReturnStatement", argument: d }, h = r.ReturnStatement;
          return e(h.argument, p, "argument", d, 1), p;
        }, t.sequenceExpression = function(d) {
          const p = { type: "SequenceExpression", expressions: d }, h = r.SequenceExpression;
          return e(h.expressions, p, "expressions", d, 1), p;
        }, t.spreadElement = T, t.spreadProperty = function(d) {
          return (0, u.default)("SpreadProperty", "SpreadElement", "The node type "), T(d);
        }, t.staticBlock = function(d) {
          const p = { type: "StaticBlock", body: d }, h = r.StaticBlock;
          return e(h.body, p, "body", d, 1), p;
        }, t.stringLiteral = function(d) {
          const p = { type: "StringLiteral", value: d }, h = r.StringLiteral;
          return e(h.value, p, "value", d), p;
        }, t.stringLiteralTypeAnnotation = function(d) {
          const p = { type: "StringLiteralTypeAnnotation", value: d }, h = r.StringLiteralTypeAnnotation;
          return e(h.value, p, "value", d), p;
        }, t.stringTypeAnnotation = function() {
          return { type: "StringTypeAnnotation" };
        }, t.super = function() {
          return { type: "Super" };
        }, t.switchCase = function(d = null, p) {
          const h = { type: "SwitchCase", test: d, consequent: p }, m = r.SwitchCase;
          return e(m.test, h, "test", d, 1), e(m.consequent, h, "consequent", p, 1), h;
        }, t.switchStatement = function(d, p) {
          const h = { type: "SwitchStatement", discriminant: d, cases: p }, m = r.SwitchStatement;
          return e(m.discriminant, h, "discriminant", d, 1), e(m.cases, h, "cases", p, 1), h;
        }, t.symbolTypeAnnotation = function() {
          return { type: "SymbolTypeAnnotation" };
        }, t.taggedTemplateExpression = function(d, p) {
          const h = { type: "TaggedTemplateExpression", tag: d, quasi: p }, m = r.TaggedTemplateExpression;
          return e(m.tag, h, "tag", d, 1), e(m.quasi, h, "quasi", p, 1), h;
        }, t.templateElement = function(d, p = false) {
          const h = { type: "TemplateElement", value: d, tail: p }, m = r.TemplateElement;
          return e(m.value, h, "value", d), e(m.tail, h, "tail", p), h;
        }, t.templateLiteral = function(d, p) {
          const h = { type: "TemplateLiteral", quasis: d, expressions: p }, m = r.TemplateLiteral;
          return e(m.quasis, h, "quasis", d, 1), e(m.expressions, h, "expressions", p, 1), h;
        }, t.thisExpression = function() {
          return { type: "ThisExpression" };
        }, t.thisTypeAnnotation = function() {
          return { type: "ThisTypeAnnotation" };
        }, t.throwStatement = function(d) {
          const p = { type: "ThrowStatement", argument: d }, h = r.ThrowStatement;
          return e(h.argument, p, "argument", d, 1), p;
        }, t.topicReference = function() {
          return { type: "TopicReference" };
        }, t.tryStatement = function(d, p = null, h = null) {
          const m = { type: "TryStatement", block: d, handler: p, finalizer: h }, E = r.TryStatement;
          return e(E.block, m, "block", d, 1), e(E.handler, m, "handler", p, 1), e(E.finalizer, m, "finalizer", h, 1), m;
        }, t.tSAnyKeyword = t.tsAnyKeyword = function() {
          return { type: "TSAnyKeyword" };
        }, t.tSArrayType = t.tsArrayType = function(d) {
          const p = { type: "TSArrayType", elementType: d }, h = r.TSArrayType;
          return e(h.elementType, p, "elementType", d, 1), p;
        }, t.tSAsExpression = t.tsAsExpression = function(d, p) {
          const h = { type: "TSAsExpression", expression: d, typeAnnotation: p }, m = r.TSAsExpression;
          return e(m.expression, h, "expression", d, 1), e(m.typeAnnotation, h, "typeAnnotation", p, 1), h;
        }, t.tSBigIntKeyword = t.tsBigIntKeyword = function() {
          return { type: "TSBigIntKeyword" };
        }, t.tSBooleanKeyword = t.tsBooleanKeyword = function() {
          return { type: "TSBooleanKeyword" };
        }, t.tSCallSignatureDeclaration = t.tsCallSignatureDeclaration = function(d = null, p, h = null) {
          const m = { type: "TSCallSignatureDeclaration", typeParameters: d, parameters: p, typeAnnotation: h }, E = r.TSCallSignatureDeclaration;
          return e(E.typeParameters, m, "typeParameters", d, 1), e(E.parameters, m, "parameters", p, 1), e(E.typeAnnotation, m, "typeAnnotation", h, 1), m;
        }, t.tSConditionalType = t.tsConditionalType = function(d, p, h, m) {
          const E = { type: "TSConditionalType", checkType: d, extendsType: p, trueType: h, falseType: m }, _ = r.TSConditionalType;
          return e(_.checkType, E, "checkType", d, 1), e(_.extendsType, E, "extendsType", p, 1), e(_.trueType, E, "trueType", h, 1), e(_.falseType, E, "falseType", m, 1), E;
        }, t.tSConstructSignatureDeclaration = t.tsConstructSignatureDeclaration = function(d = null, p, h = null) {
          const m = { type: "TSConstructSignatureDeclaration", typeParameters: d, parameters: p, typeAnnotation: h }, E = r.TSConstructSignatureDeclaration;
          return e(E.typeParameters, m, "typeParameters", d, 1), e(E.parameters, m, "parameters", p, 1), e(E.typeAnnotation, m, "typeAnnotation", h, 1), m;
        }, t.tSConstructorType = t.tsConstructorType = function(d = null, p, h = null) {
          const m = { type: "TSConstructorType", typeParameters: d, parameters: p, typeAnnotation: h }, E = r.TSConstructorType;
          return e(E.typeParameters, m, "typeParameters", d, 1), e(E.parameters, m, "parameters", p, 1), e(E.typeAnnotation, m, "typeAnnotation", h, 1), m;
        }, t.tSDeclareFunction = t.tsDeclareFunction = function(d = null, p = null, h, m = null) {
          const E = { type: "TSDeclareFunction", id: d, typeParameters: p, params: h, returnType: m }, _ = r.TSDeclareFunction;
          return e(_.id, E, "id", d, 1), e(_.typeParameters, E, "typeParameters", p, 1), e(_.params, E, "params", h, 1), e(_.returnType, E, "returnType", m, 1), E;
        }, t.tSDeclareMethod = t.tsDeclareMethod = function(d = null, p, h = null, m, E = null) {
          const _ = { type: "TSDeclareMethod", decorators: d, key: p, typeParameters: h, params: m, returnType: E }, C = r.TSDeclareMethod;
          return e(C.decorators, _, "decorators", d, 1), e(C.key, _, "key", p, 1), e(C.typeParameters, _, "typeParameters", h, 1), e(C.params, _, "params", m, 1), e(C.returnType, _, "returnType", E, 1), _;
        }, t.tSEnumDeclaration = t.tsEnumDeclaration = function(d, p) {
          const h = { type: "TSEnumDeclaration", id: d, members: p }, m = r.TSEnumDeclaration;
          return e(m.id, h, "id", d, 1), e(m.members, h, "members", p, 1), h;
        }, t.tSEnumMember = t.tsEnumMember = function(d, p = null) {
          const h = { type: "TSEnumMember", id: d, initializer: p }, m = r.TSEnumMember;
          return e(m.id, h, "id", d, 1), e(m.initializer, h, "initializer", p, 1), h;
        }, t.tSExportAssignment = t.tsExportAssignment = function(d) {
          const p = { type: "TSExportAssignment", expression: d }, h = r.TSExportAssignment;
          return e(h.expression, p, "expression", d, 1), p;
        }, t.tSExpressionWithTypeArguments = t.tsExpressionWithTypeArguments = function(d, p = null) {
          const h = { type: "TSExpressionWithTypeArguments", expression: d, typeParameters: p }, m = r.TSExpressionWithTypeArguments;
          return e(m.expression, h, "expression", d, 1), e(m.typeParameters, h, "typeParameters", p, 1), h;
        }, t.tSExternalModuleReference = t.tsExternalModuleReference = function(d) {
          const p = { type: "TSExternalModuleReference", expression: d }, h = r.TSExternalModuleReference;
          return e(h.expression, p, "expression", d, 1), p;
        }, t.tSFunctionType = t.tsFunctionType = function(d = null, p, h = null) {
          const m = { type: "TSFunctionType", typeParameters: d, parameters: p, typeAnnotation: h }, E = r.TSFunctionType;
          return e(E.typeParameters, m, "typeParameters", d, 1), e(E.parameters, m, "parameters", p, 1), e(E.typeAnnotation, m, "typeAnnotation", h, 1), m;
        }, t.tSImportEqualsDeclaration = t.tsImportEqualsDeclaration = function(d, p) {
          const h = { type: "TSImportEqualsDeclaration", id: d, moduleReference: p, isExport: null }, m = r.TSImportEqualsDeclaration;
          return e(m.id, h, "id", d, 1), e(m.moduleReference, h, "moduleReference", p, 1), h;
        }, t.tSImportType = t.tsImportType = function(d, p = null, h = null) {
          const m = { type: "TSImportType", argument: d, qualifier: p, typeParameters: h }, E = r.TSImportType;
          return e(E.argument, m, "argument", d, 1), e(E.qualifier, m, "qualifier", p, 1), e(E.typeParameters, m, "typeParameters", h, 1), m;
        }, t.tSIndexSignature = t.tsIndexSignature = function(d, p = null) {
          const h = { type: "TSIndexSignature", parameters: d, typeAnnotation: p }, m = r.TSIndexSignature;
          return e(m.parameters, h, "parameters", d, 1), e(m.typeAnnotation, h, "typeAnnotation", p, 1), h;
        }, t.tSIndexedAccessType = t.tsIndexedAccessType = function(d, p) {
          const h = { type: "TSIndexedAccessType", objectType: d, indexType: p }, m = r.TSIndexedAccessType;
          return e(m.objectType, h, "objectType", d, 1), e(m.indexType, h, "indexType", p, 1), h;
        }, t.tSInferType = t.tsInferType = function(d) {
          const p = { type: "TSInferType", typeParameter: d }, h = r.TSInferType;
          return e(h.typeParameter, p, "typeParameter", d, 1), p;
        }, t.tSInstantiationExpression = t.tsInstantiationExpression = function(d, p = null) {
          const h = { type: "TSInstantiationExpression", expression: d, typeParameters: p }, m = r.TSInstantiationExpression;
          return e(m.expression, h, "expression", d, 1), e(m.typeParameters, h, "typeParameters", p, 1), h;
        }, t.tSInterfaceBody = t.tsInterfaceBody = function(d) {
          const p = { type: "TSInterfaceBody", body: d }, h = r.TSInterfaceBody;
          return e(h.body, p, "body", d, 1), p;
        }, t.tSInterfaceDeclaration = t.tsInterfaceDeclaration = function(d, p = null, h = null, m) {
          const E = { type: "TSInterfaceDeclaration", id: d, typeParameters: p, extends: h, body: m }, _ = r.TSInterfaceDeclaration;
          return e(_.id, E, "id", d, 1), e(_.typeParameters, E, "typeParameters", p, 1), e(_.extends, E, "extends", h, 1), e(_.body, E, "body", m, 1), E;
        }, t.tSIntersectionType = t.tsIntersectionType = function(d) {
          const p = { type: "TSIntersectionType", types: d }, h = r.TSIntersectionType;
          return e(h.types, p, "types", d, 1), p;
        }, t.tSIntrinsicKeyword = t.tsIntrinsicKeyword = function() {
          return { type: "TSIntrinsicKeyword" };
        }, t.tSLiteralType = t.tsLiteralType = function(d) {
          const p = { type: "TSLiteralType", literal: d }, h = r.TSLiteralType;
          return e(h.literal, p, "literal", d, 1), p;
        }, t.tSMappedType = t.tsMappedType = function(d, p = null, h = null) {
          const m = { type: "TSMappedType", typeParameter: d, typeAnnotation: p, nameType: h }, E = r.TSMappedType;
          return e(E.typeParameter, m, "typeParameter", d, 1), e(E.typeAnnotation, m, "typeAnnotation", p, 1), e(E.nameType, m, "nameType", h, 1), m;
        }, t.tSMethodSignature = t.tsMethodSignature = function(d, p = null, h, m = null) {
          const E = { type: "TSMethodSignature", key: d, typeParameters: p, parameters: h, typeAnnotation: m, kind: null }, _ = r.TSMethodSignature;
          return e(_.key, E, "key", d, 1), e(_.typeParameters, E, "typeParameters", p, 1), e(_.parameters, E, "parameters", h, 1), e(_.typeAnnotation, E, "typeAnnotation", m, 1), E;
        }, t.tSModuleBlock = t.tsModuleBlock = function(d) {
          const p = { type: "TSModuleBlock", body: d }, h = r.TSModuleBlock;
          return e(h.body, p, "body", d, 1), p;
        }, t.tSModuleDeclaration = t.tsModuleDeclaration = function(d, p) {
          const h = { type: "TSModuleDeclaration", id: d, body: p, kind: null }, m = r.TSModuleDeclaration;
          return e(m.id, h, "id", d, 1), e(m.body, h, "body", p, 1), h;
        }, t.tSNamedTupleMember = t.tsNamedTupleMember = function(d, p, h = false) {
          const m = { type: "TSNamedTupleMember", label: d, elementType: p, optional: h }, E = r.TSNamedTupleMember;
          return e(E.label, m, "label", d, 1), e(E.elementType, m, "elementType", p, 1), e(E.optional, m, "optional", h), m;
        }, t.tSNamespaceExportDeclaration = t.tsNamespaceExportDeclaration = function(d) {
          const p = { type: "TSNamespaceExportDeclaration", id: d }, h = r.TSNamespaceExportDeclaration;
          return e(h.id, p, "id", d, 1), p;
        }, t.tSNeverKeyword = t.tsNeverKeyword = function() {
          return { type: "TSNeverKeyword" };
        }, t.tSNonNullExpression = t.tsNonNullExpression = function(d) {
          const p = { type: "TSNonNullExpression", expression: d }, h = r.TSNonNullExpression;
          return e(h.expression, p, "expression", d, 1), p;
        }, t.tSNullKeyword = t.tsNullKeyword = function() {
          return { type: "TSNullKeyword" };
        }, t.tSNumberKeyword = t.tsNumberKeyword = function() {
          return { type: "TSNumberKeyword" };
        }, t.tSObjectKeyword = t.tsObjectKeyword = function() {
          return { type: "TSObjectKeyword" };
        }, t.tSOptionalType = t.tsOptionalType = function(d) {
          const p = { type: "TSOptionalType", typeAnnotation: d }, h = r.TSOptionalType;
          return e(h.typeAnnotation, p, "typeAnnotation", d, 1), p;
        }, t.tSParameterProperty = t.tsParameterProperty = function(d) {
          const p = { type: "TSParameterProperty", parameter: d }, h = r.TSParameterProperty;
          return e(h.parameter, p, "parameter", d, 1), p;
        }, t.tSParenthesizedType = t.tsParenthesizedType = function(d) {
          const p = { type: "TSParenthesizedType", typeAnnotation: d }, h = r.TSParenthesizedType;
          return e(h.typeAnnotation, p, "typeAnnotation", d, 1), p;
        }, t.tSPropertySignature = t.tsPropertySignature = function(d, p = null) {
          const h = { type: "TSPropertySignature", key: d, typeAnnotation: p, kind: null }, m = r.TSPropertySignature;
          return e(m.key, h, "key", d, 1), e(m.typeAnnotation, h, "typeAnnotation", p, 1), h;
        }, t.tSQualifiedName = t.tsQualifiedName = function(d, p) {
          const h = { type: "TSQualifiedName", left: d, right: p }, m = r.TSQualifiedName;
          return e(m.left, h, "left", d, 1), e(m.right, h, "right", p, 1), h;
        }, t.tSRestType = t.tsRestType = function(d) {
          const p = { type: "TSRestType", typeAnnotation: d }, h = r.TSRestType;
          return e(h.typeAnnotation, p, "typeAnnotation", d, 1), p;
        }, t.tSSatisfiesExpression = t.tsSatisfiesExpression = function(d, p) {
          const h = { type: "TSSatisfiesExpression", expression: d, typeAnnotation: p }, m = r.TSSatisfiesExpression;
          return e(m.expression, h, "expression", d, 1), e(m.typeAnnotation, h, "typeAnnotation", p, 1), h;
        }, t.tSStringKeyword = t.tsStringKeyword = function() {
          return { type: "TSStringKeyword" };
        }, t.tSSymbolKeyword = t.tsSymbolKeyword = function() {
          return { type: "TSSymbolKeyword" };
        }, t.tSThisType = t.tsThisType = function() {
          return { type: "TSThisType" };
        }, t.tSTupleType = t.tsTupleType = function(d) {
          const p = { type: "TSTupleType", elementTypes: d }, h = r.TSTupleType;
          return e(h.elementTypes, p, "elementTypes", d, 1), p;
        }, t.tSTypeAliasDeclaration = t.tsTypeAliasDeclaration = function(d, p = null, h) {
          const m = { type: "TSTypeAliasDeclaration", id: d, typeParameters: p, typeAnnotation: h }, E = r.TSTypeAliasDeclaration;
          return e(E.id, m, "id", d, 1), e(E.typeParameters, m, "typeParameters", p, 1), e(E.typeAnnotation, m, "typeAnnotation", h, 1), m;
        }, t.tSTypeAnnotation = t.tsTypeAnnotation = function(d) {
          const p = { type: "TSTypeAnnotation", typeAnnotation: d }, h = r.TSTypeAnnotation;
          return e(h.typeAnnotation, p, "typeAnnotation", d, 1), p;
        }, t.tSTypeAssertion = t.tsTypeAssertion = function(d, p) {
          const h = { type: "TSTypeAssertion", typeAnnotation: d, expression: p }, m = r.TSTypeAssertion;
          return e(m.typeAnnotation, h, "typeAnnotation", d, 1), e(m.expression, h, "expression", p, 1), h;
        }, t.tSTypeLiteral = t.tsTypeLiteral = function(d) {
          const p = { type: "TSTypeLiteral", members: d }, h = r.TSTypeLiteral;
          return e(h.members, p, "members", d, 1), p;
        }, t.tSTypeOperator = t.tsTypeOperator = function(d) {
          const p = { type: "TSTypeOperator", typeAnnotation: d, operator: null }, h = r.TSTypeOperator;
          return e(h.typeAnnotation, p, "typeAnnotation", d, 1), p;
        }, t.tSTypeParameter = t.tsTypeParameter = function(d = null, p = null, h) {
          const m = { type: "TSTypeParameter", constraint: d, default: p, name: h }, E = r.TSTypeParameter;
          return e(E.constraint, m, "constraint", d, 1), e(E.default, m, "default", p, 1), e(E.name, m, "name", h), m;
        }, t.tSTypeParameterDeclaration = t.tsTypeParameterDeclaration = function(d) {
          const p = { type: "TSTypeParameterDeclaration", params: d }, h = r.TSTypeParameterDeclaration;
          return e(h.params, p, "params", d, 1), p;
        }, t.tSTypeParameterInstantiation = t.tsTypeParameterInstantiation = function(d) {
          const p = { type: "TSTypeParameterInstantiation", params: d }, h = r.TSTypeParameterInstantiation;
          return e(h.params, p, "params", d, 1), p;
        }, t.tSTypePredicate = t.tsTypePredicate = function(d, p = null, h = null) {
          const m = { type: "TSTypePredicate", parameterName: d, typeAnnotation: p, asserts: h }, E = r.TSTypePredicate;
          return e(E.parameterName, m, "parameterName", d, 1), e(E.typeAnnotation, m, "typeAnnotation", p, 1), e(E.asserts, m, "asserts", h), m;
        }, t.tSTypeQuery = t.tsTypeQuery = function(d, p = null) {
          const h = { type: "TSTypeQuery", exprName: d, typeParameters: p }, m = r.TSTypeQuery;
          return e(m.exprName, h, "exprName", d, 1), e(m.typeParameters, h, "typeParameters", p, 1), h;
        }, t.tSTypeReference = t.tsTypeReference = function(d, p = null) {
          const h = { type: "TSTypeReference", typeName: d, typeParameters: p }, m = r.TSTypeReference;
          return e(m.typeName, h, "typeName", d, 1), e(m.typeParameters, h, "typeParameters", p, 1), h;
        }, t.tSUndefinedKeyword = t.tsUndefinedKeyword = function() {
          return { type: "TSUndefinedKeyword" };
        }, t.tSUnionType = t.tsUnionType = function(d) {
          const p = { type: "TSUnionType", types: d }, h = r.TSUnionType;
          return e(h.types, p, "types", d, 1), p;
        }, t.tSUnknownKeyword = t.tsUnknownKeyword = function() {
          return { type: "TSUnknownKeyword" };
        }, t.tSVoidKeyword = t.tsVoidKeyword = function() {
          return { type: "TSVoidKeyword" };
        }, t.tupleExpression = function(d = []) {
          const p = { type: "TupleExpression", elements: d }, h = r.TupleExpression;
          return e(h.elements, p, "elements", d, 1), p;
        }, t.tupleTypeAnnotation = function(d) {
          const p = { type: "TupleTypeAnnotation", types: d }, h = r.TupleTypeAnnotation;
          return e(h.types, p, "types", d, 1), p;
        }, t.typeAlias = function(d, p = null, h) {
          const m = { type: "TypeAlias", id: d, typeParameters: p, right: h }, E = r.TypeAlias;
          return e(E.id, m, "id", d, 1), e(E.typeParameters, m, "typeParameters", p, 1), e(E.right, m, "right", h, 1), m;
        }, t.typeAnnotation = function(d) {
          const p = { type: "TypeAnnotation", typeAnnotation: d }, h = r.TypeAnnotation;
          return e(h.typeAnnotation, p, "typeAnnotation", d, 1), p;
        }, t.typeCastExpression = function(d, p) {
          const h = { type: "TypeCastExpression", expression: d, typeAnnotation: p }, m = r.TypeCastExpression;
          return e(m.expression, h, "expression", d, 1), e(m.typeAnnotation, h, "typeAnnotation", p, 1), h;
        }, t.typeParameter = function(d = null, p = null, h = null) {
          const m = { type: "TypeParameter", bound: d, default: p, variance: h, name: null }, E = r.TypeParameter;
          return e(E.bound, m, "bound", d, 1), e(E.default, m, "default", p, 1), e(E.variance, m, "variance", h, 1), m;
        }, t.typeParameterDeclaration = function(d) {
          const p = { type: "TypeParameterDeclaration", params: d }, h = r.TypeParameterDeclaration;
          return e(h.params, p, "params", d, 1), p;
        }, t.typeParameterInstantiation = function(d) {
          const p = { type: "TypeParameterInstantiation", params: d }, h = r.TypeParameterInstantiation;
          return e(h.params, p, "params", d, 1), p;
        }, t.typeofTypeAnnotation = function(d) {
          const p = { type: "TypeofTypeAnnotation", argument: d }, h = r.TypeofTypeAnnotation;
          return e(h.argument, p, "argument", d, 1), p;
        }, t.unaryExpression = function(d, p, h = true) {
          const m = { type: "UnaryExpression", operator: d, argument: p, prefix: h }, E = r.UnaryExpression;
          return e(E.operator, m, "operator", d), e(E.argument, m, "argument", p, 1), e(E.prefix, m, "prefix", h), m;
        }, t.unionTypeAnnotation = function(d) {
          const p = { type: "UnionTypeAnnotation", types: d }, h = r.UnionTypeAnnotation;
          return e(h.types, p, "types", d, 1), p;
        }, t.updateExpression = function(d, p, h = false) {
          const m = { type: "UpdateExpression", operator: d, argument: p, prefix: h }, E = r.UpdateExpression;
          return e(E.operator, m, "operator", d), e(E.argument, m, "argument", p, 1), e(E.prefix, m, "prefix", h), m;
        }, t.v8IntrinsicIdentifier = function(d) {
          const p = { type: "V8IntrinsicIdentifier", name: d }, h = r.V8IntrinsicIdentifier;
          return e(h.name, p, "name", d), p;
        }, t.variableDeclaration = function(d, p) {
          const h = { type: "VariableDeclaration", kind: d, declarations: p }, m = r.VariableDeclaration;
          return e(m.kind, h, "kind", d), e(m.declarations, h, "declarations", p, 1), h;
        }, t.variableDeclarator = function(d, p = null) {
          const h = { type: "VariableDeclarator", id: d, init: p }, m = r.VariableDeclarator;
          return e(m.id, h, "id", d, 1), e(m.init, h, "init", p, 1), h;
        }, t.variance = function(d) {
          const p = { type: "Variance", kind: d }, h = r.Variance;
          return e(h.kind, p, "kind", d), p;
        }, t.voidTypeAnnotation = function() {
          return { type: "VoidTypeAnnotation" };
        }, t.whileStatement = function(d, p) {
          const h = { type: "WhileStatement", test: d, body: p }, m = r.WhileStatement;
          return e(m.test, h, "test", d, 1), e(m.body, h, "body", p, 1), h;
        }, t.withStatement = function(d, p) {
          const h = { type: "WithStatement", object: d, body: p }, m = r.WithStatement;
          return e(m.object, h, "object", d, 1), e(m.body, h, "body", p, 1), h;
        }, t.yieldExpression = function(d = null, p = false) {
          const h = { type: "YieldExpression", argument: d, delegate: p }, m = r.YieldExpression;
          return e(m.argument, h, "argument", d, 1), e(m.delegate, h, "delegate", p), h;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/validate.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/deprecationWarning.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");
        const { validateInternal: e } = n, { NODE_FIELDS: r } = c;
        function f(d) {
          const p = { type: "NumericLiteral", value: d }, h = r.NumericLiteral;
          return e(h.value, p, "value", d), p;
        }
        function y(d, p = "") {
          const h = { type: "RegExpLiteral", pattern: d, flags: p }, m = r.RegExpLiteral;
          return e(m.pattern, h, "pattern", d), e(m.flags, h, "flags", p), h;
        }
        function S(d) {
          const p = { type: "RestElement", argument: d }, h = r.RestElement;
          return e(h.argument, p, "argument", d, 1), p;
        }
        function T(d) {
          const p = { type: "SpreadElement", argument: d }, h = r.SpreadElement;
          return e(h.argument, p, "argument", d, 1), p;
        }
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/uppercase.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), Object.defineProperty(t, "AnyTypeAnnotation", { enumerable: true, get: function() {
          return n.anyTypeAnnotation;
        } }), Object.defineProperty(t, "ArgumentPlaceholder", { enumerable: true, get: function() {
          return n.argumentPlaceholder;
        } }), Object.defineProperty(t, "ArrayExpression", { enumerable: true, get: function() {
          return n.arrayExpression;
        } }), Object.defineProperty(t, "ArrayPattern", { enumerable: true, get: function() {
          return n.arrayPattern;
        } }), Object.defineProperty(t, "ArrayTypeAnnotation", { enumerable: true, get: function() {
          return n.arrayTypeAnnotation;
        } }), Object.defineProperty(t, "ArrowFunctionExpression", { enumerable: true, get: function() {
          return n.arrowFunctionExpression;
        } }), Object.defineProperty(t, "AssignmentExpression", { enumerable: true, get: function() {
          return n.assignmentExpression;
        } }), Object.defineProperty(t, "AssignmentPattern", { enumerable: true, get: function() {
          return n.assignmentPattern;
        } }), Object.defineProperty(t, "AwaitExpression", { enumerable: true, get: function() {
          return n.awaitExpression;
        } }), Object.defineProperty(t, "BigIntLiteral", { enumerable: true, get: function() {
          return n.bigIntLiteral;
        } }), Object.defineProperty(t, "BinaryExpression", { enumerable: true, get: function() {
          return n.binaryExpression;
        } }), Object.defineProperty(t, "BindExpression", { enumerable: true, get: function() {
          return n.bindExpression;
        } }), Object.defineProperty(t, "BlockStatement", { enumerable: true, get: function() {
          return n.blockStatement;
        } }), Object.defineProperty(t, "BooleanLiteral", { enumerable: true, get: function() {
          return n.booleanLiteral;
        } }), Object.defineProperty(t, "BooleanLiteralTypeAnnotation", { enumerable: true, get: function() {
          return n.booleanLiteralTypeAnnotation;
        } }), Object.defineProperty(t, "BooleanTypeAnnotation", { enumerable: true, get: function() {
          return n.booleanTypeAnnotation;
        } }), Object.defineProperty(t, "BreakStatement", { enumerable: true, get: function() {
          return n.breakStatement;
        } }), Object.defineProperty(t, "CallExpression", { enumerable: true, get: function() {
          return n.callExpression;
        } }), Object.defineProperty(t, "CatchClause", { enumerable: true, get: function() {
          return n.catchClause;
        } }), Object.defineProperty(t, "ClassAccessorProperty", { enumerable: true, get: function() {
          return n.classAccessorProperty;
        } }), Object.defineProperty(t, "ClassBody", { enumerable: true, get: function() {
          return n.classBody;
        } }), Object.defineProperty(t, "ClassDeclaration", { enumerable: true, get: function() {
          return n.classDeclaration;
        } }), Object.defineProperty(t, "ClassExpression", { enumerable: true, get: function() {
          return n.classExpression;
        } }), Object.defineProperty(t, "ClassImplements", { enumerable: true, get: function() {
          return n.classImplements;
        } }), Object.defineProperty(t, "ClassMethod", { enumerable: true, get: function() {
          return n.classMethod;
        } }), Object.defineProperty(t, "ClassPrivateMethod", { enumerable: true, get: function() {
          return n.classPrivateMethod;
        } }), Object.defineProperty(t, "ClassPrivateProperty", { enumerable: true, get: function() {
          return n.classPrivateProperty;
        } }), Object.defineProperty(t, "ClassProperty", { enumerable: true, get: function() {
          return n.classProperty;
        } }), Object.defineProperty(t, "ConditionalExpression", { enumerable: true, get: function() {
          return n.conditionalExpression;
        } }), Object.defineProperty(t, "ContinueStatement", { enumerable: true, get: function() {
          return n.continueStatement;
        } }), Object.defineProperty(t, "DebuggerStatement", { enumerable: true, get: function() {
          return n.debuggerStatement;
        } }), Object.defineProperty(t, "DecimalLiteral", { enumerable: true, get: function() {
          return n.decimalLiteral;
        } }), Object.defineProperty(t, "DeclareClass", { enumerable: true, get: function() {
          return n.declareClass;
        } }), Object.defineProperty(t, "DeclareExportAllDeclaration", { enumerable: true, get: function() {
          return n.declareExportAllDeclaration;
        } }), Object.defineProperty(t, "DeclareExportDeclaration", { enumerable: true, get: function() {
          return n.declareExportDeclaration;
        } }), Object.defineProperty(t, "DeclareFunction", { enumerable: true, get: function() {
          return n.declareFunction;
        } }), Object.defineProperty(t, "DeclareInterface", { enumerable: true, get: function() {
          return n.declareInterface;
        } }), Object.defineProperty(t, "DeclareModule", { enumerable: true, get: function() {
          return n.declareModule;
        } }), Object.defineProperty(t, "DeclareModuleExports", { enumerable: true, get: function() {
          return n.declareModuleExports;
        } }), Object.defineProperty(t, "DeclareOpaqueType", { enumerable: true, get: function() {
          return n.declareOpaqueType;
        } }), Object.defineProperty(t, "DeclareTypeAlias", { enumerable: true, get: function() {
          return n.declareTypeAlias;
        } }), Object.defineProperty(t, "DeclareVariable", { enumerable: true, get: function() {
          return n.declareVariable;
        } }), Object.defineProperty(t, "DeclaredPredicate", { enumerable: true, get: function() {
          return n.declaredPredicate;
        } }), Object.defineProperty(t, "Decorator", { enumerable: true, get: function() {
          return n.decorator;
        } }), Object.defineProperty(t, "Directive", { enumerable: true, get: function() {
          return n.directive;
        } }), Object.defineProperty(t, "DirectiveLiteral", { enumerable: true, get: function() {
          return n.directiveLiteral;
        } }), Object.defineProperty(t, "DoExpression", { enumerable: true, get: function() {
          return n.doExpression;
        } }), Object.defineProperty(t, "DoWhileStatement", { enumerable: true, get: function() {
          return n.doWhileStatement;
        } }), Object.defineProperty(t, "EmptyStatement", { enumerable: true, get: function() {
          return n.emptyStatement;
        } }), Object.defineProperty(t, "EmptyTypeAnnotation", { enumerable: true, get: function() {
          return n.emptyTypeAnnotation;
        } }), Object.defineProperty(t, "EnumBooleanBody", { enumerable: true, get: function() {
          return n.enumBooleanBody;
        } }), Object.defineProperty(t, "EnumBooleanMember", { enumerable: true, get: function() {
          return n.enumBooleanMember;
        } }), Object.defineProperty(t, "EnumDeclaration", { enumerable: true, get: function() {
          return n.enumDeclaration;
        } }), Object.defineProperty(t, "EnumDefaultedMember", { enumerable: true, get: function() {
          return n.enumDefaultedMember;
        } }), Object.defineProperty(t, "EnumNumberBody", { enumerable: true, get: function() {
          return n.enumNumberBody;
        } }), Object.defineProperty(t, "EnumNumberMember", { enumerable: true, get: function() {
          return n.enumNumberMember;
        } }), Object.defineProperty(t, "EnumStringBody", { enumerable: true, get: function() {
          return n.enumStringBody;
        } }), Object.defineProperty(t, "EnumStringMember", { enumerable: true, get: function() {
          return n.enumStringMember;
        } }), Object.defineProperty(t, "EnumSymbolBody", { enumerable: true, get: function() {
          return n.enumSymbolBody;
        } }), Object.defineProperty(t, "ExistsTypeAnnotation", { enumerable: true, get: function() {
          return n.existsTypeAnnotation;
        } }), Object.defineProperty(t, "ExportAllDeclaration", { enumerable: true, get: function() {
          return n.exportAllDeclaration;
        } }), Object.defineProperty(t, "ExportDefaultDeclaration", { enumerable: true, get: function() {
          return n.exportDefaultDeclaration;
        } }), Object.defineProperty(t, "ExportDefaultSpecifier", { enumerable: true, get: function() {
          return n.exportDefaultSpecifier;
        } }), Object.defineProperty(t, "ExportNamedDeclaration", { enumerable: true, get: function() {
          return n.exportNamedDeclaration;
        } }), Object.defineProperty(t, "ExportNamespaceSpecifier", { enumerable: true, get: function() {
          return n.exportNamespaceSpecifier;
        } }), Object.defineProperty(t, "ExportSpecifier", { enumerable: true, get: function() {
          return n.exportSpecifier;
        } }), Object.defineProperty(t, "ExpressionStatement", { enumerable: true, get: function() {
          return n.expressionStatement;
        } }), Object.defineProperty(t, "File", { enumerable: true, get: function() {
          return n.file;
        } }), Object.defineProperty(t, "ForInStatement", { enumerable: true, get: function() {
          return n.forInStatement;
        } }), Object.defineProperty(t, "ForOfStatement", { enumerable: true, get: function() {
          return n.forOfStatement;
        } }), Object.defineProperty(t, "ForStatement", { enumerable: true, get: function() {
          return n.forStatement;
        } }), Object.defineProperty(t, "FunctionDeclaration", { enumerable: true, get: function() {
          return n.functionDeclaration;
        } }), Object.defineProperty(t, "FunctionExpression", { enumerable: true, get: function() {
          return n.functionExpression;
        } }), Object.defineProperty(t, "FunctionTypeAnnotation", { enumerable: true, get: function() {
          return n.functionTypeAnnotation;
        } }), Object.defineProperty(t, "FunctionTypeParam", { enumerable: true, get: function() {
          return n.functionTypeParam;
        } }), Object.defineProperty(t, "GenericTypeAnnotation", { enumerable: true, get: function() {
          return n.genericTypeAnnotation;
        } }), Object.defineProperty(t, "Identifier", { enumerable: true, get: function() {
          return n.identifier;
        } }), Object.defineProperty(t, "IfStatement", { enumerable: true, get: function() {
          return n.ifStatement;
        } }), Object.defineProperty(t, "Import", { enumerable: true, get: function() {
          return n.import;
        } }), Object.defineProperty(t, "ImportAttribute", { enumerable: true, get: function() {
          return n.importAttribute;
        } }), Object.defineProperty(t, "ImportDeclaration", { enumerable: true, get: function() {
          return n.importDeclaration;
        } }), Object.defineProperty(t, "ImportDefaultSpecifier", { enumerable: true, get: function() {
          return n.importDefaultSpecifier;
        } }), Object.defineProperty(t, "ImportExpression", { enumerable: true, get: function() {
          return n.importExpression;
        } }), Object.defineProperty(t, "ImportNamespaceSpecifier", { enumerable: true, get: function() {
          return n.importNamespaceSpecifier;
        } }), Object.defineProperty(t, "ImportSpecifier", { enumerable: true, get: function() {
          return n.importSpecifier;
        } }), Object.defineProperty(t, "IndexedAccessType", { enumerable: true, get: function() {
          return n.indexedAccessType;
        } }), Object.defineProperty(t, "InferredPredicate", { enumerable: true, get: function() {
          return n.inferredPredicate;
        } }), Object.defineProperty(t, "InterfaceDeclaration", { enumerable: true, get: function() {
          return n.interfaceDeclaration;
        } }), Object.defineProperty(t, "InterfaceExtends", { enumerable: true, get: function() {
          return n.interfaceExtends;
        } }), Object.defineProperty(t, "InterfaceTypeAnnotation", { enumerable: true, get: function() {
          return n.interfaceTypeAnnotation;
        } }), Object.defineProperty(t, "InterpreterDirective", { enumerable: true, get: function() {
          return n.interpreterDirective;
        } }), Object.defineProperty(t, "IntersectionTypeAnnotation", { enumerable: true, get: function() {
          return n.intersectionTypeAnnotation;
        } }), Object.defineProperty(t, "JSXAttribute", { enumerable: true, get: function() {
          return n.jsxAttribute;
        } }), Object.defineProperty(t, "JSXClosingElement", { enumerable: true, get: function() {
          return n.jsxClosingElement;
        } }), Object.defineProperty(t, "JSXClosingFragment", { enumerable: true, get: function() {
          return n.jsxClosingFragment;
        } }), Object.defineProperty(t, "JSXElement", { enumerable: true, get: function() {
          return n.jsxElement;
        } }), Object.defineProperty(t, "JSXEmptyExpression", { enumerable: true, get: function() {
          return n.jsxEmptyExpression;
        } }), Object.defineProperty(t, "JSXExpressionContainer", { enumerable: true, get: function() {
          return n.jsxExpressionContainer;
        } }), Object.defineProperty(t, "JSXFragment", { enumerable: true, get: function() {
          return n.jsxFragment;
        } }), Object.defineProperty(t, "JSXIdentifier", { enumerable: true, get: function() {
          return n.jsxIdentifier;
        } }), Object.defineProperty(t, "JSXMemberExpression", { enumerable: true, get: function() {
          return n.jsxMemberExpression;
        } }), Object.defineProperty(t, "JSXNamespacedName", { enumerable: true, get: function() {
          return n.jsxNamespacedName;
        } }), Object.defineProperty(t, "JSXOpeningElement", { enumerable: true, get: function() {
          return n.jsxOpeningElement;
        } }), Object.defineProperty(t, "JSXOpeningFragment", { enumerable: true, get: function() {
          return n.jsxOpeningFragment;
        } }), Object.defineProperty(t, "JSXSpreadAttribute", { enumerable: true, get: function() {
          return n.jsxSpreadAttribute;
        } }), Object.defineProperty(t, "JSXSpreadChild", { enumerable: true, get: function() {
          return n.jsxSpreadChild;
        } }), Object.defineProperty(t, "JSXText", { enumerable: true, get: function() {
          return n.jsxText;
        } }), Object.defineProperty(t, "LabeledStatement", { enumerable: true, get: function() {
          return n.labeledStatement;
        } }), Object.defineProperty(t, "LogicalExpression", { enumerable: true, get: function() {
          return n.logicalExpression;
        } }), Object.defineProperty(t, "MemberExpression", { enumerable: true, get: function() {
          return n.memberExpression;
        } }), Object.defineProperty(t, "MetaProperty", { enumerable: true, get: function() {
          return n.metaProperty;
        } }), Object.defineProperty(t, "MixedTypeAnnotation", { enumerable: true, get: function() {
          return n.mixedTypeAnnotation;
        } }), Object.defineProperty(t, "ModuleExpression", { enumerable: true, get: function() {
          return n.moduleExpression;
        } }), Object.defineProperty(t, "NewExpression", { enumerable: true, get: function() {
          return n.newExpression;
        } }), Object.defineProperty(t, "Noop", { enumerable: true, get: function() {
          return n.noop;
        } }), Object.defineProperty(t, "NullLiteral", { enumerable: true, get: function() {
          return n.nullLiteral;
        } }), Object.defineProperty(t, "NullLiteralTypeAnnotation", { enumerable: true, get: function() {
          return n.nullLiteralTypeAnnotation;
        } }), Object.defineProperty(t, "NullableTypeAnnotation", { enumerable: true, get: function() {
          return n.nullableTypeAnnotation;
        } }), Object.defineProperty(t, "NumberLiteral", { enumerable: true, get: function() {
          return n.numberLiteral;
        } }), Object.defineProperty(t, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
          return n.numberLiteralTypeAnnotation;
        } }), Object.defineProperty(t, "NumberTypeAnnotation", { enumerable: true, get: function() {
          return n.numberTypeAnnotation;
        } }), Object.defineProperty(t, "NumericLiteral", { enumerable: true, get: function() {
          return n.numericLiteral;
        } }), Object.defineProperty(t, "ObjectExpression", { enumerable: true, get: function() {
          return n.objectExpression;
        } }), Object.defineProperty(t, "ObjectMethod", { enumerable: true, get: function() {
          return n.objectMethod;
        } }), Object.defineProperty(t, "ObjectPattern", { enumerable: true, get: function() {
          return n.objectPattern;
        } }), Object.defineProperty(t, "ObjectProperty", { enumerable: true, get: function() {
          return n.objectProperty;
        } }), Object.defineProperty(t, "ObjectTypeAnnotation", { enumerable: true, get: function() {
          return n.objectTypeAnnotation;
        } }), Object.defineProperty(t, "ObjectTypeCallProperty", { enumerable: true, get: function() {
          return n.objectTypeCallProperty;
        } }), Object.defineProperty(t, "ObjectTypeIndexer", { enumerable: true, get: function() {
          return n.objectTypeIndexer;
        } }), Object.defineProperty(t, "ObjectTypeInternalSlot", { enumerable: true, get: function() {
          return n.objectTypeInternalSlot;
        } }), Object.defineProperty(t, "ObjectTypeProperty", { enumerable: true, get: function() {
          return n.objectTypeProperty;
        } }), Object.defineProperty(t, "ObjectTypeSpreadProperty", { enumerable: true, get: function() {
          return n.objectTypeSpreadProperty;
        } }), Object.defineProperty(t, "OpaqueType", { enumerable: true, get: function() {
          return n.opaqueType;
        } }), Object.defineProperty(t, "OptionalCallExpression", { enumerable: true, get: function() {
          return n.optionalCallExpression;
        } }), Object.defineProperty(t, "OptionalIndexedAccessType", { enumerable: true, get: function() {
          return n.optionalIndexedAccessType;
        } }), Object.defineProperty(t, "OptionalMemberExpression", { enumerable: true, get: function() {
          return n.optionalMemberExpression;
        } }), Object.defineProperty(t, "ParenthesizedExpression", { enumerable: true, get: function() {
          return n.parenthesizedExpression;
        } }), Object.defineProperty(t, "PipelineBareFunction", { enumerable: true, get: function() {
          return n.pipelineBareFunction;
        } }), Object.defineProperty(t, "PipelinePrimaryTopicReference", { enumerable: true, get: function() {
          return n.pipelinePrimaryTopicReference;
        } }), Object.defineProperty(t, "PipelineTopicExpression", { enumerable: true, get: function() {
          return n.pipelineTopicExpression;
        } }), Object.defineProperty(t, "Placeholder", { enumerable: true, get: function() {
          return n.placeholder;
        } }), Object.defineProperty(t, "PrivateName", { enumerable: true, get: function() {
          return n.privateName;
        } }), Object.defineProperty(t, "Program", { enumerable: true, get: function() {
          return n.program;
        } }), Object.defineProperty(t, "QualifiedTypeIdentifier", { enumerable: true, get: function() {
          return n.qualifiedTypeIdentifier;
        } }), Object.defineProperty(t, "RecordExpression", { enumerable: true, get: function() {
          return n.recordExpression;
        } }), Object.defineProperty(t, "RegExpLiteral", { enumerable: true, get: function() {
          return n.regExpLiteral;
        } }), Object.defineProperty(t, "RegexLiteral", { enumerable: true, get: function() {
          return n.regexLiteral;
        } }), Object.defineProperty(t, "RestElement", { enumerable: true, get: function() {
          return n.restElement;
        } }), Object.defineProperty(t, "RestProperty", { enumerable: true, get: function() {
          return n.restProperty;
        } }), Object.defineProperty(t, "ReturnStatement", { enumerable: true, get: function() {
          return n.returnStatement;
        } }), Object.defineProperty(t, "SequenceExpression", { enumerable: true, get: function() {
          return n.sequenceExpression;
        } }), Object.defineProperty(t, "SpreadElement", { enumerable: true, get: function() {
          return n.spreadElement;
        } }), Object.defineProperty(t, "SpreadProperty", { enumerable: true, get: function() {
          return n.spreadProperty;
        } }), Object.defineProperty(t, "StaticBlock", { enumerable: true, get: function() {
          return n.staticBlock;
        } }), Object.defineProperty(t, "StringLiteral", { enumerable: true, get: function() {
          return n.stringLiteral;
        } }), Object.defineProperty(t, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
          return n.stringLiteralTypeAnnotation;
        } }), Object.defineProperty(t, "StringTypeAnnotation", { enumerable: true, get: function() {
          return n.stringTypeAnnotation;
        } }), Object.defineProperty(t, "Super", { enumerable: true, get: function() {
          return n.super;
        } }), Object.defineProperty(t, "SwitchCase", { enumerable: true, get: function() {
          return n.switchCase;
        } }), Object.defineProperty(t, "SwitchStatement", { enumerable: true, get: function() {
          return n.switchStatement;
        } }), Object.defineProperty(t, "SymbolTypeAnnotation", { enumerable: true, get: function() {
          return n.symbolTypeAnnotation;
        } }), Object.defineProperty(t, "TSAnyKeyword", { enumerable: true, get: function() {
          return n.tsAnyKeyword;
        } }), Object.defineProperty(t, "TSArrayType", { enumerable: true, get: function() {
          return n.tsArrayType;
        } }), Object.defineProperty(t, "TSAsExpression", { enumerable: true, get: function() {
          return n.tsAsExpression;
        } }), Object.defineProperty(t, "TSBigIntKeyword", { enumerable: true, get: function() {
          return n.tsBigIntKeyword;
        } }), Object.defineProperty(t, "TSBooleanKeyword", { enumerable: true, get: function() {
          return n.tsBooleanKeyword;
        } }), Object.defineProperty(t, "TSCallSignatureDeclaration", { enumerable: true, get: function() {
          return n.tsCallSignatureDeclaration;
        } }), Object.defineProperty(t, "TSConditionalType", { enumerable: true, get: function() {
          return n.tsConditionalType;
        } }), Object.defineProperty(t, "TSConstructSignatureDeclaration", { enumerable: true, get: function() {
          return n.tsConstructSignatureDeclaration;
        } }), Object.defineProperty(t, "TSConstructorType", { enumerable: true, get: function() {
          return n.tsConstructorType;
        } }), Object.defineProperty(t, "TSDeclareFunction", { enumerable: true, get: function() {
          return n.tsDeclareFunction;
        } }), Object.defineProperty(t, "TSDeclareMethod", { enumerable: true, get: function() {
          return n.tsDeclareMethod;
        } }), Object.defineProperty(t, "TSEnumDeclaration", { enumerable: true, get: function() {
          return n.tsEnumDeclaration;
        } }), Object.defineProperty(t, "TSEnumMember", { enumerable: true, get: function() {
          return n.tsEnumMember;
        } }), Object.defineProperty(t, "TSExportAssignment", { enumerable: true, get: function() {
          return n.tsExportAssignment;
        } }), Object.defineProperty(t, "TSExpressionWithTypeArguments", { enumerable: true, get: function() {
          return n.tsExpressionWithTypeArguments;
        } }), Object.defineProperty(t, "TSExternalModuleReference", { enumerable: true, get: function() {
          return n.tsExternalModuleReference;
        } }), Object.defineProperty(t, "TSFunctionType", { enumerable: true, get: function() {
          return n.tsFunctionType;
        } }), Object.defineProperty(t, "TSImportEqualsDeclaration", { enumerable: true, get: function() {
          return n.tsImportEqualsDeclaration;
        } }), Object.defineProperty(t, "TSImportType", { enumerable: true, get: function() {
          return n.tsImportType;
        } }), Object.defineProperty(t, "TSIndexSignature", { enumerable: true, get: function() {
          return n.tsIndexSignature;
        } }), Object.defineProperty(t, "TSIndexedAccessType", { enumerable: true, get: function() {
          return n.tsIndexedAccessType;
        } }), Object.defineProperty(t, "TSInferType", { enumerable: true, get: function() {
          return n.tsInferType;
        } }), Object.defineProperty(t, "TSInstantiationExpression", { enumerable: true, get: function() {
          return n.tsInstantiationExpression;
        } }), Object.defineProperty(t, "TSInterfaceBody", { enumerable: true, get: function() {
          return n.tsInterfaceBody;
        } }), Object.defineProperty(t, "TSInterfaceDeclaration", { enumerable: true, get: function() {
          return n.tsInterfaceDeclaration;
        } }), Object.defineProperty(t, "TSIntersectionType", { enumerable: true, get: function() {
          return n.tsIntersectionType;
        } }), Object.defineProperty(t, "TSIntrinsicKeyword", { enumerable: true, get: function() {
          return n.tsIntrinsicKeyword;
        } }), Object.defineProperty(t, "TSLiteralType", { enumerable: true, get: function() {
          return n.tsLiteralType;
        } }), Object.defineProperty(t, "TSMappedType", { enumerable: true, get: function() {
          return n.tsMappedType;
        } }), Object.defineProperty(t, "TSMethodSignature", { enumerable: true, get: function() {
          return n.tsMethodSignature;
        } }), Object.defineProperty(t, "TSModuleBlock", { enumerable: true, get: function() {
          return n.tsModuleBlock;
        } }), Object.defineProperty(t, "TSModuleDeclaration", { enumerable: true, get: function() {
          return n.tsModuleDeclaration;
        } }), Object.defineProperty(t, "TSNamedTupleMember", { enumerable: true, get: function() {
          return n.tsNamedTupleMember;
        } }), Object.defineProperty(t, "TSNamespaceExportDeclaration", { enumerable: true, get: function() {
          return n.tsNamespaceExportDeclaration;
        } }), Object.defineProperty(t, "TSNeverKeyword", { enumerable: true, get: function() {
          return n.tsNeverKeyword;
        } }), Object.defineProperty(t, "TSNonNullExpression", { enumerable: true, get: function() {
          return n.tsNonNullExpression;
        } }), Object.defineProperty(t, "TSNullKeyword", { enumerable: true, get: function() {
          return n.tsNullKeyword;
        } }), Object.defineProperty(t, "TSNumberKeyword", { enumerable: true, get: function() {
          return n.tsNumberKeyword;
        } }), Object.defineProperty(t, "TSObjectKeyword", { enumerable: true, get: function() {
          return n.tsObjectKeyword;
        } }), Object.defineProperty(t, "TSOptionalType", { enumerable: true, get: function() {
          return n.tsOptionalType;
        } }), Object.defineProperty(t, "TSParameterProperty", { enumerable: true, get: function() {
          return n.tsParameterProperty;
        } }), Object.defineProperty(t, "TSParenthesizedType", { enumerable: true, get: function() {
          return n.tsParenthesizedType;
        } }), Object.defineProperty(t, "TSPropertySignature", { enumerable: true, get: function() {
          return n.tsPropertySignature;
        } }), Object.defineProperty(t, "TSQualifiedName", { enumerable: true, get: function() {
          return n.tsQualifiedName;
        } }), Object.defineProperty(t, "TSRestType", { enumerable: true, get: function() {
          return n.tsRestType;
        } }), Object.defineProperty(t, "TSSatisfiesExpression", { enumerable: true, get: function() {
          return n.tsSatisfiesExpression;
        } }), Object.defineProperty(t, "TSStringKeyword", { enumerable: true, get: function() {
          return n.tsStringKeyword;
        } }), Object.defineProperty(t, "TSSymbolKeyword", { enumerable: true, get: function() {
          return n.tsSymbolKeyword;
        } }), Object.defineProperty(t, "TSThisType", { enumerable: true, get: function() {
          return n.tsThisType;
        } }), Object.defineProperty(t, "TSTupleType", { enumerable: true, get: function() {
          return n.tsTupleType;
        } }), Object.defineProperty(t, "TSTypeAliasDeclaration", { enumerable: true, get: function() {
          return n.tsTypeAliasDeclaration;
        } }), Object.defineProperty(t, "TSTypeAnnotation", { enumerable: true, get: function() {
          return n.tsTypeAnnotation;
        } }), Object.defineProperty(t, "TSTypeAssertion", { enumerable: true, get: function() {
          return n.tsTypeAssertion;
        } }), Object.defineProperty(t, "TSTypeLiteral", { enumerable: true, get: function() {
          return n.tsTypeLiteral;
        } }), Object.defineProperty(t, "TSTypeOperator", { enumerable: true, get: function() {
          return n.tsTypeOperator;
        } }), Object.defineProperty(t, "TSTypeParameter", { enumerable: true, get: function() {
          return n.tsTypeParameter;
        } }), Object.defineProperty(t, "TSTypeParameterDeclaration", { enumerable: true, get: function() {
          return n.tsTypeParameterDeclaration;
        } }), Object.defineProperty(t, "TSTypeParameterInstantiation", { enumerable: true, get: function() {
          return n.tsTypeParameterInstantiation;
        } }), Object.defineProperty(t, "TSTypePredicate", { enumerable: true, get: function() {
          return n.tsTypePredicate;
        } }), Object.defineProperty(t, "TSTypeQuery", { enumerable: true, get: function() {
          return n.tsTypeQuery;
        } }), Object.defineProperty(t, "TSTypeReference", { enumerable: true, get: function() {
          return n.tsTypeReference;
        } }), Object.defineProperty(t, "TSUndefinedKeyword", { enumerable: true, get: function() {
          return n.tsUndefinedKeyword;
        } }), Object.defineProperty(t, "TSUnionType", { enumerable: true, get: function() {
          return n.tsUnionType;
        } }), Object.defineProperty(t, "TSUnknownKeyword", { enumerable: true, get: function() {
          return n.tsUnknownKeyword;
        } }), Object.defineProperty(t, "TSVoidKeyword", { enumerable: true, get: function() {
          return n.tsVoidKeyword;
        } }), Object.defineProperty(t, "TaggedTemplateExpression", { enumerable: true, get: function() {
          return n.taggedTemplateExpression;
        } }), Object.defineProperty(t, "TemplateElement", { enumerable: true, get: function() {
          return n.templateElement;
        } }), Object.defineProperty(t, "TemplateLiteral", { enumerable: true, get: function() {
          return n.templateLiteral;
        } }), Object.defineProperty(t, "ThisExpression", { enumerable: true, get: function() {
          return n.thisExpression;
        } }), Object.defineProperty(t, "ThisTypeAnnotation", { enumerable: true, get: function() {
          return n.thisTypeAnnotation;
        } }), Object.defineProperty(t, "ThrowStatement", { enumerable: true, get: function() {
          return n.throwStatement;
        } }), Object.defineProperty(t, "TopicReference", { enumerable: true, get: function() {
          return n.topicReference;
        } }), Object.defineProperty(t, "TryStatement", { enumerable: true, get: function() {
          return n.tryStatement;
        } }), Object.defineProperty(t, "TupleExpression", { enumerable: true, get: function() {
          return n.tupleExpression;
        } }), Object.defineProperty(t, "TupleTypeAnnotation", { enumerable: true, get: function() {
          return n.tupleTypeAnnotation;
        } }), Object.defineProperty(t, "TypeAlias", { enumerable: true, get: function() {
          return n.typeAlias;
        } }), Object.defineProperty(t, "TypeAnnotation", { enumerable: true, get: function() {
          return n.typeAnnotation;
        } }), Object.defineProperty(t, "TypeCastExpression", { enumerable: true, get: function() {
          return n.typeCastExpression;
        } }), Object.defineProperty(t, "TypeParameter", { enumerable: true, get: function() {
          return n.typeParameter;
        } }), Object.defineProperty(t, "TypeParameterDeclaration", { enumerable: true, get: function() {
          return n.typeParameterDeclaration;
        } }), Object.defineProperty(t, "TypeParameterInstantiation", { enumerable: true, get: function() {
          return n.typeParameterInstantiation;
        } }), Object.defineProperty(t, "TypeofTypeAnnotation", { enumerable: true, get: function() {
          return n.typeofTypeAnnotation;
        } }), Object.defineProperty(t, "UnaryExpression", { enumerable: true, get: function() {
          return n.unaryExpression;
        } }), Object.defineProperty(t, "UnionTypeAnnotation", { enumerable: true, get: function() {
          return n.unionTypeAnnotation;
        } }), Object.defineProperty(t, "UpdateExpression", { enumerable: true, get: function() {
          return n.updateExpression;
        } }), Object.defineProperty(t, "V8IntrinsicIdentifier", { enumerable: true, get: function() {
          return n.v8IntrinsicIdentifier;
        } }), Object.defineProperty(t, "VariableDeclaration", { enumerable: true, get: function() {
          return n.variableDeclaration;
        } }), Object.defineProperty(t, "VariableDeclarator", { enumerable: true, get: function() {
          return n.variableDeclarator;
        } }), Object.defineProperty(t, "Variance", { enumerable: true, get: function() {
          return n.variance;
        } }), Object.defineProperty(t, "VoidTypeAnnotation", { enumerable: true, get: function() {
          return n.voidTypeAnnotation;
        } }), Object.defineProperty(t, "WhileStatement", { enumerable: true, get: function() {
          return n.whileStatement;
        } }), Object.defineProperty(t, "WithStatement", { enumerable: true, get: function() {
          return n.withStatement;
        } }), Object.defineProperty(t, "YieldExpression", { enumerable: true, get: function() {
          return n.yieldExpression;
        } });
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/productions.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.buildUndefinedNode = function() {
          return (0, n.unaryExpression)("void", (0, n.numericLiteral)(0), true);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/react/buildChildren.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c) {
          const e = [];
          for (let r = 0; r < c.children.length; r++) {
            let f = c.children[r];
            (0, n.isJSXText)(f) ? (0, u.default)(f, e) : ((0, n.isJSXExpressionContainer)(f) && (f = f.expression), (0, n.isJSXEmptyExpression)(f) || e.push(f));
          }
          return e;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(e) {
          const r = e.map((y) => (0, c.isTSTypeAnnotation)(y) ? y.typeAnnotation : y), f = (0, u.default)(r);
          return f.length === 1 ? f[0] : (0, n.tsUnionType)(f);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/clone.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          return (0, n.default)(u, false);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneDeep.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          return (0, n.default)(u);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          return (0, n.default)(u, true, true);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(S, T = true, d = false) {
          return f(S, T, d, /* @__PURE__ */ new Map());
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
        const { hasOwn: c } = { hasOwn: Function.call.bind(Object.prototype.hasOwnProperty) };
        function e(S, T, d, p) {
          return S && typeof S.type == "string" ? f(S, T, d, p) : S;
        }
        function r(S, T, d, p) {
          return Array.isArray(S) ? S.map((h) => e(h, T, d, p)) : e(S, T, d, p);
        }
        function f(S, T = true, d = false, p) {
          if (!S) return S;
          const { type: h } = S, m = { type: S.type };
          if ((0, u.isIdentifier)(S)) m.name = S.name, c(S, "optional") && typeof S.optional == "boolean" && (m.optional = S.optional), c(S, "typeAnnotation") && (m.typeAnnotation = T ? r(S.typeAnnotation, true, d, p) : S.typeAnnotation), c(S, "decorators") && (m.decorators = T ? r(S.decorators, true, d, p) : S.decorators);
          else {
            if (!c(n.NODE_FIELDS, h)) throw new Error(`Unknown node type: "${h}"`);
            for (const E of Object.keys(n.NODE_FIELDS[h])) c(S, E) && (m[E] = T ? (0, u.isFile)(S) && E === "comments" ? y(S.comments, T, d, p) : r(S[E], true, d, p) : S[E]);
          }
          return c(S, "loc") && (m.loc = d ? null : S.loc), c(S, "leadingComments") && (m.leadingComments = y(S.leadingComments, T, d, p)), c(S, "innerComments") && (m.innerComments = y(S.innerComments, T, d, p)), c(S, "trailingComments") && (m.trailingComments = y(S.trailingComments, T, d, p)), c(S, "extra") && (m.extra = Object.assign({}, S.extra)), m;
        }
        function y(S, T, d, p) {
          return S && T ? S.map((h) => {
            const m = p.get(h);
            if (m) return m;
            const { type: E, value: _, loc: C } = h, w = { type: E, value: _, loc: C };
            return d && (w.loc = null), p.set(h, w), w;
          }) : S;
        }
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          return (0, n.default)(u, false, true);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/addComment.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c, e, r) {
          return (0, n.default)(u, c, [{ type: r ? "CommentLine" : "CommentBlock", value: e }]);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/addComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/addComments.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(l, n, u) {
          if (!u || !l) return l;
          const c = `${n}Comments`;
          return l[c] ? n === "leading" ? l[c] = u.concat(l[c]) : l[c].push(...u) : l[c] = u, l;
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritInnerComments.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c) {
          (0, n.default)("innerComments", u, c);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritLeadingComments.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c) {
          (0, n.default)("leadingComments", u, c);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritTrailingComments.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c) {
          (0, n.default)("trailingComments", u, c);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritsComments.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(e, r) {
          return (0, n.default)(e, r), (0, u.default)(e, r), (0, c.default)(e, r), e;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritInnerComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/removeComments.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          return n.COMMENT_KEYS.forEach((c) => {
            u[c] = null;
          }), u;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/generated/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.WHILE_TYPES = t.USERWHITESPACABLE_TYPES = t.UNARYLIKE_TYPES = t.TYPESCRIPT_TYPES = t.TSTYPE_TYPES = t.TSTYPEELEMENT_TYPES = t.TSENTITYNAME_TYPES = t.TSBASETYPE_TYPES = t.TERMINATORLESS_TYPES = t.STATEMENT_TYPES = t.STANDARDIZED_TYPES = t.SCOPABLE_TYPES = t.PUREISH_TYPES = t.PROPERTY_TYPES = t.PRIVATE_TYPES = t.PATTERN_TYPES = t.PATTERNLIKE_TYPES = t.OBJECTMEMBER_TYPES = t.MODULESPECIFIER_TYPES = t.MODULEDECLARATION_TYPES = t.MISCELLANEOUS_TYPES = t.METHOD_TYPES = t.LVAL_TYPES = t.LOOP_TYPES = t.LITERAL_TYPES = t.JSX_TYPES = t.IMPORTOREXPORTDECLARATION_TYPES = t.IMMUTABLE_TYPES = t.FUNCTION_TYPES = t.FUNCTIONPARENT_TYPES = t.FOR_TYPES = t.FORXSTATEMENT_TYPES = t.FLOW_TYPES = t.FLOWTYPE_TYPES = t.FLOWPREDICATE_TYPES = t.FLOWDECLARATION_TYPES = t.FLOWBASEANNOTATION_TYPES = t.EXPRESSION_TYPES = t.EXPRESSIONWRAPPER_TYPES = t.EXPORTDECLARATION_TYPES = t.ENUMMEMBER_TYPES = t.ENUMBODY_TYPES = t.DECLARATION_TYPES = t.CONDITIONAL_TYPES = t.COMPLETIONSTATEMENT_TYPES = t.CLASS_TYPES = t.BLOCK_TYPES = t.BLOCKPARENT_TYPES = t.BINARY_TYPES = t.ACCESSOR_TYPES = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");
        t.STANDARDIZED_TYPES = n.FLIPPED_ALIAS_KEYS.Standardized, t.EXPRESSION_TYPES = n.FLIPPED_ALIAS_KEYS.Expression, t.BINARY_TYPES = n.FLIPPED_ALIAS_KEYS.Binary, t.SCOPABLE_TYPES = n.FLIPPED_ALIAS_KEYS.Scopable, t.BLOCKPARENT_TYPES = n.FLIPPED_ALIAS_KEYS.BlockParent, t.BLOCK_TYPES = n.FLIPPED_ALIAS_KEYS.Block, t.STATEMENT_TYPES = n.FLIPPED_ALIAS_KEYS.Statement, t.TERMINATORLESS_TYPES = n.FLIPPED_ALIAS_KEYS.Terminatorless, t.COMPLETIONSTATEMENT_TYPES = n.FLIPPED_ALIAS_KEYS.CompletionStatement, t.CONDITIONAL_TYPES = n.FLIPPED_ALIAS_KEYS.Conditional, t.LOOP_TYPES = n.FLIPPED_ALIAS_KEYS.Loop, t.WHILE_TYPES = n.FLIPPED_ALIAS_KEYS.While, t.EXPRESSIONWRAPPER_TYPES = n.FLIPPED_ALIAS_KEYS.ExpressionWrapper, t.FOR_TYPES = n.FLIPPED_ALIAS_KEYS.For, t.FORXSTATEMENT_TYPES = n.FLIPPED_ALIAS_KEYS.ForXStatement, t.FUNCTION_TYPES = n.FLIPPED_ALIAS_KEYS.Function, t.FUNCTIONPARENT_TYPES = n.FLIPPED_ALIAS_KEYS.FunctionParent, t.PUREISH_TYPES = n.FLIPPED_ALIAS_KEYS.Pureish, t.DECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS.Declaration, t.PATTERNLIKE_TYPES = n.FLIPPED_ALIAS_KEYS.PatternLike, t.LVAL_TYPES = n.FLIPPED_ALIAS_KEYS.LVal, t.TSENTITYNAME_TYPES = n.FLIPPED_ALIAS_KEYS.TSEntityName, t.LITERAL_TYPES = n.FLIPPED_ALIAS_KEYS.Literal, t.IMMUTABLE_TYPES = n.FLIPPED_ALIAS_KEYS.Immutable, t.USERWHITESPACABLE_TYPES = n.FLIPPED_ALIAS_KEYS.UserWhitespacable, t.METHOD_TYPES = n.FLIPPED_ALIAS_KEYS.Method, t.OBJECTMEMBER_TYPES = n.FLIPPED_ALIAS_KEYS.ObjectMember, t.PROPERTY_TYPES = n.FLIPPED_ALIAS_KEYS.Property, t.UNARYLIKE_TYPES = n.FLIPPED_ALIAS_KEYS.UnaryLike, t.PATTERN_TYPES = n.FLIPPED_ALIAS_KEYS.Pattern, t.CLASS_TYPES = n.FLIPPED_ALIAS_KEYS.Class;
        const u = t.IMPORTOREXPORTDECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
        t.EXPORTDECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS.ExportDeclaration, t.MODULESPECIFIER_TYPES = n.FLIPPED_ALIAS_KEYS.ModuleSpecifier, t.ACCESSOR_TYPES = n.FLIPPED_ALIAS_KEYS.Accessor, t.PRIVATE_TYPES = n.FLIPPED_ALIAS_KEYS.Private, t.FLOW_TYPES = n.FLIPPED_ALIAS_KEYS.Flow, t.FLOWTYPE_TYPES = n.FLIPPED_ALIAS_KEYS.FlowType, t.FLOWBASEANNOTATION_TYPES = n.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, t.FLOWDECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS.FlowDeclaration, t.FLOWPREDICATE_TYPES = n.FLIPPED_ALIAS_KEYS.FlowPredicate, t.ENUMBODY_TYPES = n.FLIPPED_ALIAS_KEYS.EnumBody, t.ENUMMEMBER_TYPES = n.FLIPPED_ALIAS_KEYS.EnumMember, t.JSX_TYPES = n.FLIPPED_ALIAS_KEYS.JSX, t.MISCELLANEOUS_TYPES = n.FLIPPED_ALIAS_KEYS.Miscellaneous, t.TYPESCRIPT_TYPES = n.FLIPPED_ALIAS_KEYS.TypeScript, t.TSTYPEELEMENT_TYPES = n.FLIPPED_ALIAS_KEYS.TSTypeElement, t.TSTYPE_TYPES = n.FLIPPED_ALIAS_KEYS.TSType, t.TSBASETYPE_TYPES = n.FLIPPED_ALIAS_KEYS.TSBaseType, t.MODULEDECLARATION_TYPES = u;
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.UPDATE_OPERATORS = t.UNARY_OPERATORS = t.STRING_UNARY_OPERATORS = t.STATEMENT_OR_BLOCK_KEYS = t.NUMBER_UNARY_OPERATORS = t.NUMBER_BINARY_OPERATORS = t.NOT_LOCAL_BINDING = t.LOGICAL_OPERATORS = t.INHERIT_KEYS = t.FOR_INIT_KEYS = t.FLATTENABLE_KEYS = t.EQUALITY_BINARY_OPERATORS = t.COMPARISON_BINARY_OPERATORS = t.COMMENT_KEYS = t.BOOLEAN_UNARY_OPERATORS = t.BOOLEAN_NUMBER_BINARY_OPERATORS = t.BOOLEAN_BINARY_OPERATORS = t.BLOCK_SCOPED_SYMBOL = t.BINARY_OPERATORS = t.ASSIGNMENT_OPERATORS = void 0, t.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], t.FLATTENABLE_KEYS = ["body", "expressions"], t.FOR_INIT_KEYS = ["left", "init"], t.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
        const l = t.LOGICAL_OPERATORS = ["||", "&&", "??"], n = (t.UPDATE_OPERATORS = ["++", "--"], t.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="]), u = t.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], c = t.COMPARISON_BINARY_OPERATORS = [...u, "in", "instanceof"], e = t.BOOLEAN_BINARY_OPERATORS = [...c, ...n], r = t.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], f = (t.BINARY_OPERATORS = ["+", ...r, ...e, "|>"], t.ASSIGNMENT_OPERATORS = ["=", "+=", ...r.map((T) => T + "="), ...l.map((T) => T + "=")], t.BOOLEAN_UNARY_OPERATORS = ["delete", "!"]), y = t.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], S = t.STRING_UNARY_OPERATORS = ["typeof"];
        t.UNARY_OPERATORS = ["void", "throw", ...f, ...y, ...S], t.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] }, t.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), t.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/ensureBlock.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c = "body") {
          const e = (0, n.default)(u[c], u);
          return u[c] = e, e;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toBlock.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function f(y, S) {
          const T = [];
          let d = true;
          for (const p of y) if ((0, u.isEmptyStatement)(p) || (d = false), (0, u.isExpression)(p)) T.push(p);
          else if ((0, u.isExpressionStatement)(p)) T.push(p.expression);
          else if ((0, u.isVariableDeclaration)(p)) {
            if (p.kind !== "var") return;
            for (const h of p.declarations) {
              const m = (0, n.default)(h);
              for (const E of Object.keys(m)) S.push({ kind: p.kind, id: (0, r.default)(m[E]) });
              h.init && T.push((0, c.assignmentExpression)("=", h.id, h.init));
            }
            d = true;
          } else if ((0, u.isIfStatement)(p)) {
            const h = p.consequent ? f([p.consequent], S) : (0, e.buildUndefinedNode)(), m = p.alternate ? f([p.alternate], S) : (0, e.buildUndefinedNode)();
            if (!h || !m) return;
            T.push((0, c.conditionalExpression)(p.test, h, m));
          } else if ((0, u.isBlockStatement)(p)) {
            const h = f(p.body, S);
            if (!h) return;
            T.push(h);
          } else {
            if (!(0, u.isEmptyStatement)(p)) return;
            y.indexOf(p) === 0 && (d = true);
          }
          return d && T.push((0, e.buildUndefinedNode)()), T.length === 1 ? T[0] : (0, c.sequenceExpression)(T);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js"), e = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/productions.js"), r = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          return (u = (0, n.default)(u)) !== "eval" && u !== "arguments" || (u = "_" + u), u;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toIdentifier.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toBlock.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c, e) {
          if ((0, n.isBlockStatement)(c)) return c;
          let r = [];
          return (0, n.isEmptyStatement)(c) ? r = [] : ((0, n.isStatement)(c) || (c = (0, n.isFunction)(e) ? (0, u.returnStatement)(c) : (0, u.expressionStatement)(c)), r = [c]), (0, u.blockStatement)(r);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toComputedKey.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c, e = c.key || c.property) {
          return !c.computed && (0, n.isIdentifier)(e) && (e = (0, u.stringLiteral)(e.name)), e;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toExpression.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
        t.default = function(u) {
          if ((0, n.isExpressionStatement)(u) && (u = u.expression), (0, n.isExpression)(u)) return u;
          if ((0, n.isClass)(u) ? u.type = "ClassExpression" : (0, n.isFunction)(u) && (u.type = "FunctionExpression"), !(0, n.isExpression)(u)) throw new Error(`cannot turn ${u.type} to an expression`);
          return u;
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toIdentifier.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c) {
          c += "";
          let e = "";
          for (const r of c) e += (0, u.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
          return e = e.replace(/^[-0-9]+/, ""), e = e.replace(/[-\s]+(.)?/g, function(r, f) {
            return f ? f.toUpperCase() : "";
          }), (0, n.default)(e) || (e = `_${e}`), e || "_";
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), u = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toKeyAlias.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = e;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js");
        function e(r, f = r.key) {
          let y;
          return r.kind === "method" ? e.increment() + "" : (y = (0, n.isIdentifier)(f) ? f.name : (0, n.isStringLiteral)(f) ? JSON.stringify(f.value) : JSON.stringify((0, c.default)((0, u.default)(f))), r.computed && (y = `[${y}]`), r.static && (y = `static:${y}`), y);
        }
        e.uid = 0, e.increment = function() {
          return e.uid >= Number.MAX_SAFE_INTEGER ? e.uid = 0 : e.uid++;
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toSequenceExpression.js": (P, t, l) => {
        t.default = function(u, c) {
          if (u == null || !u.length) return;
          const e = [], r = (0, n.default)(u, e);
          if (r) {
            for (const f of e) c.push(f);
            return r;
          }
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toStatement.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");
        t.default = function(c, e) {
          if ((0, n.isStatement)(c)) return c;
          let r, f = false;
          if ((0, n.isClass)(c)) f = true, r = "ClassDeclaration";
          else if ((0, n.isFunction)(c)) f = true, r = "FunctionDeclaration";
          else if ((0, n.isAssignmentExpression)(c)) return (0, u.expressionStatement)(c);
          if (f && !c.id && (r = false), !r) {
            if (e) return false;
            throw new Error(`cannot turn ${c.type} to a statement`);
          }
          return c.type = r, c;
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/valueToNode.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");
        t.default = function e(r) {
          if (r === void 0) return (0, u.identifier)("undefined");
          if (r === true || r === false) return (0, u.booleanLiteral)(r);
          if (r === null) return (0, u.nullLiteral)();
          if (typeof r == "string") return (0, u.stringLiteral)(r);
          if (typeof r == "number") {
            let f;
            if (Number.isFinite(r)) f = (0, u.numericLiteral)(Math.abs(r));
            else {
              let y;
              y = Number.isNaN(r) ? (0, u.numericLiteral)(0) : (0, u.numericLiteral)(1), f = (0, u.binaryExpression)("/", y, (0, u.numericLiteral)(0));
            }
            return (r < 0 || Object.is(r, -0)) && (f = (0, u.unaryExpression)("-", f)), f;
          }
          if (function(f) {
            return c(f) === "[object RegExp]";
          }(r)) {
            const f = r.source, y = /\/([a-z]*)$/.exec(r.toString())[1];
            return (0, u.regExpLiteral)(f, y);
          }
          if (Array.isArray(r)) return (0, u.arrayExpression)(r.map(e));
          if (function(f) {
            if (typeof f != "object" || f === null || Object.prototype.toString.call(f) !== "[object Object]") return false;
            const y = Object.getPrototypeOf(f);
            return y === null || Object.getPrototypeOf(y) === null;
          }(r)) {
            const f = [];
            for (const y of Object.keys(r)) {
              let S;
              S = (0, n.default)(y) ? (0, u.identifier)(y) : (0, u.stringLiteral)(y), f.push((0, u.objectProperty)(S, e(r[y])));
            }
            return (0, u.objectExpression)(f);
          }
          throw new Error("don't know how to turn this value into a node");
        };
        const c = Function.call.bind(Object.prototype.toString);
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/core.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.patternLikeCommon = t.importAttributes = t.functionTypeAnnotationCommon = t.functionDeclarationCommon = t.functionCommon = t.classMethodOrPropertyCommon = t.classMethodOrDeclareMethodCommon = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), c = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js"), e = l("./node_modules/.pnpm/@babel+helper-string-parser@7.25.9/node_modules/@babel/helper-string-parser/lib/index.js"), r = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js"), f = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");
        const y = (0, f.defineAliasedType)("Standardized");
        y("ArrayExpression", { fields: { elements: { validate: (0, f.arrayOf)((0, f.assertNodeOrValueType)("null", "Expression", "SpreadElement")), default: s.BABEL_TYPES_8_BREAKING ? void 0 : [] } }, visitor: ["elements"], aliases: ["Expression"] }), y("AssignmentExpression", { fields: { operator: { validate: s.BABEL_TYPES_8_BREAKING ? Object.assign(function() {
          const _ = (0, f.assertOneOf)(...r.ASSIGNMENT_OPERATORS), C = (0, f.assertOneOf)("=");
          return function(w, I, D) {
            ((0, n.default)("Pattern", w.left) ? C : _)(w, I, D);
          };
        }(), { type: "string" }) : (0, f.assertValueType)("string") }, left: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, f.assertNodeType)("LVal", "OptionalMemberExpression") }, right: { validate: (0, f.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] }), y("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, f.assertOneOf)(...r.BINARY_OPERATORS) }, left: { validate: function() {
          const _ = (0, f.assertNodeType)("Expression"), C = (0, f.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(w, I, D) {
            (w.operator === "in" ? C : _)(w, I, D);
          }, { oneOfNodeTypes: ["Expression", "PrivateName"] });
        }() }, right: { validate: (0, f.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] }), y("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, f.assertValueType)("string") } } }), y("Directive", { visitor: ["value"], fields: { value: { validate: (0, f.assertNodeType)("DirectiveLiteral") } } }), y("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, f.assertValueType)("string") } } }), y("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, f.arrayOfType)("Directive"), default: [] }, body: (0, f.validateArrayOfType)("Statement") }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] }), y("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, f.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), y("CallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, f.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier") }, arguments: (0, f.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder") }, s.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, f.assertValueType)("boolean"), optional: true } }, { typeArguments: { validate: (0, f.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, f.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) }), y("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, f.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: true }, body: { validate: (0, f.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] }), y("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, f.assertNodeType)("Expression") }, consequent: { validate: (0, f.assertNodeType)("Expression") }, alternate: { validate: (0, f.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] }), y("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, f.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), y("DebuggerStatement", { aliases: ["Statement"] }), y("DoWhileStatement", { builder: ["test", "body"], visitor: ["body", "test"], fields: { test: { validate: (0, f.assertNodeType)("Expression") }, body: { validate: (0, f.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] }), y("EmptyStatement", { aliases: ["Statement"] }), y("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, f.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] }), y("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, f.assertNodeType)("Program") }, comments: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.assertEach)((0, f.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: true }, tokens: { validate: (0, f.assertEach)(Object.assign(() => {
        }, { type: "any" })), optional: true } } }), y("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, f.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, f.assertNodeType)("Expression") }, body: { validate: (0, f.assertNodeType)("Statement") } } }), y("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, f.assertNodeType)("VariableDeclaration", "Expression"), optional: true }, test: { validate: (0, f.assertNodeType)("Expression"), optional: true }, update: { validate: (0, f.assertNodeType)("Expression"), optional: true }, body: { validate: (0, f.assertNodeType)("Statement") } } });
        const S = () => ({ params: (0, f.validateArrayOfType)("Identifier", "Pattern", "RestElement"), generator: { default: false }, async: { default: false } });
        t.functionCommon = S;
        const T = () => ({ returnType: { validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, f.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true } });
        t.functionTypeAnnotationCommon = T;
        const d = () => Object.assign({}, S(), { declare: { validate: (0, f.assertValueType)("boolean"), optional: true }, id: { validate: (0, f.assertNodeType)("Identifier"), optional: true } });
        t.functionDeclarationCommon = d, y("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "typeParameters", "params", "returnType", "body"], fields: Object.assign({}, d(), T(), { body: { validate: (0, f.assertNodeType)("BlockStatement") }, predicate: { validate: (0, f.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: s.BABEL_TYPES_8_BREAKING ? function() {
          const _ = (0, f.assertNodeType)("Identifier");
          return function(C, w, I) {
            (0, n.default)("ExportDefaultDeclaration", C) || _(I, "id", I.id);
          };
        }() : void 0 }), y("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, S(), T(), { id: { validate: (0, f.assertNodeType)("Identifier"), optional: true }, body: { validate: (0, f.assertNodeType)("BlockStatement") }, predicate: { validate: (0, f.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) });
        const p = () => ({ typeAnnotation: { validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, optional: { validate: (0, f.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, f.arrayOfType)("Decorator"), optional: true } });
        t.patternLikeCommon = p, y("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, p(), { name: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertValueType)("string"), Object.assign(function(_, C, w) {
          if (!(0, u.default)(w, false)) throw new TypeError(`"${w}" is not a valid identifier name`);
        }, { type: "string" })) : (0, f.assertValueType)("string") } }), validate: s.BABEL_TYPES_8_BREAKING ? function(_, C, w) {
          const I = /\.(\w+)$/.exec(C);
          if (!I) return;
          const [, D] = I, j = { computed: false };
          if (D === "property") {
            if ((0, n.default)("MemberExpression", _, j) || (0, n.default)("OptionalMemberExpression", _, j)) return;
          } else if (D === "key") {
            if ((0, n.default)("Property", _, j) || (0, n.default)("Method", _, j)) return;
          } else if (D === "exported") {
            if ((0, n.default)("ExportSpecifier", _)) return;
          } else if (D === "imported") {
            if ((0, n.default)("ImportSpecifier", _, { imported: w })) return;
          } else if (D === "meta" && (0, n.default)("MetaProperty", _, { meta: w })) return;
          if (((0, c.isKeyword)(w.name) || (0, c.isReservedWord)(w.name, false)) && w.name !== "this") throw new TypeError(`"${w.name}" is not a valid identifier`);
        } : void 0 }), y("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, f.assertNodeType)("Expression") }, consequent: { validate: (0, f.assertNodeType)("Statement") }, alternate: { optional: true, validate: (0, f.assertNodeType)("Statement") } } }), y("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, f.assertNodeType)("Identifier") }, body: { validate: (0, f.assertNodeType)("Statement") } } }), y("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, f.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), y("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, f.chain)((0, f.assertValueType)("number"), Object.assign(function(_, C, w) {
        }, { type: "number" })) } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), y("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), y("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, f.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), y("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, f.assertValueType)("string") }, flags: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertValueType)("string"), Object.assign(function(_, C, w) {
          const I = /[^gimsuy]/.exec(w);
          if (I) throw new TypeError(`"${I[0]}" is not a valid RegExp flag`);
        }, { type: "string" })) : (0, f.assertValueType)("string"), default: "" } } }), y("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, f.assertOneOf)(...r.LOGICAL_OPERATORS) }, left: { validate: (0, f.assertNodeType)("Expression") }, right: { validate: (0, f.assertNodeType)("Expression") } } }), y("MemberExpression", { builder: ["object", "property", "computed", ...s.BABEL_TYPES_8_BREAKING ? [] : ["optional"]], visitor: ["object", "property"], aliases: ["Expression", "LVal"], fields: Object.assign({ object: { validate: (0, f.assertNodeType)("Expression", "Super") }, property: { validate: function() {
          const _ = (0, f.assertNodeType)("Identifier", "PrivateName"), C = (0, f.assertNodeType)("Expression"), w = function(I, D, j) {
            (I.computed ? C : _)(I, D, j);
          };
          return w.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], w;
        }() }, computed: { default: false } }, s.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, f.assertValueType)("boolean"), optional: true } }) }), y("NewExpression", { inherits: "CallExpression" }), y("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceType: { validate: (0, f.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, f.assertNodeType)("InterpreterDirective"), default: null, optional: true }, directives: { validate: (0, f.arrayOfType)("Directive"), default: [] }, body: (0, f.validateArrayOfType)("Statement") }, aliases: ["Scopable", "BlockParent", "Block"] }), y("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: (0, f.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement") } }), y("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"], fields: Object.assign({}, S(), T(), { kind: Object.assign({ validate: (0, f.assertOneOf)("method", "get", "set") }, s.BABEL_TYPES_8_BREAKING ? {} : { default: "method" }), computed: { default: false }, key: { validate: function() {
          const _ = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), C = (0, f.assertNodeType)("Expression"), w = function(I, D, j) {
            (I.computed ? C : _)(I, D, j);
          };
          return w.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], w;
        }() }, decorators: { validate: (0, f.arrayOfType)("Decorator"), optional: true }, body: { validate: (0, f.assertNodeType)("BlockStatement") } }), aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] }), y("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", ...s.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]], fields: { computed: { default: false }, key: { validate: function() {
          const _ = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), C = (0, f.assertNodeType)("Expression");
          return Object.assign(function(w, I, D) {
            (w.computed ? C : _)(w, I, D);
          }, { oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"] });
        }() }, value: { validate: (0, f.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertValueType)("boolean"), Object.assign(function(_, C, w) {
          if (w) {
            if (_.computed) throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            if (!(0, n.default)("Identifier", _.key)) throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, { type: "boolean" })) : (0, f.assertValueType)("boolean"), default: false }, decorators: { validate: (0, f.arrayOfType)("Decorator"), optional: true } }, visitor: ["key", "value", "decorators"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: s.BABEL_TYPES_8_BREAKING ? function() {
          const _ = (0, f.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), C = (0, f.assertNodeType)("Expression");
          return function(w, I, D) {
            ((0, n.default)("ObjectPattern", w) ? _ : C)(D, "value", D.value);
          };
        }() : void 0 }), y("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["LVal", "PatternLike"], deprecatedAlias: "RestProperty", fields: Object.assign({}, p(), { argument: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, f.assertNodeType)("LVal") } }), validate: s.BABEL_TYPES_8_BREAKING ? function(_, C) {
          const w = /(\w+)\[(\d+)\]/.exec(C);
          if (!w) throw new Error("Internal Babel error: malformed key.");
          const [, I, D] = w;
          if (_[I].length > +D + 1) throw new TypeError(`RestElement must be last element of ${I}`);
        } : void 0 }), y("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, f.assertNodeType)("Expression"), optional: true } } }), y("SequenceExpression", { visitor: ["expressions"], fields: { expressions: (0, f.validateArrayOfType)("Expression") }, aliases: ["Expression"] }), y("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, f.assertNodeType)("Expression") } } }), y("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, f.assertNodeType)("Expression"), optional: true }, consequent: (0, f.validateArrayOfType)("Statement") } }), y("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, f.assertNodeType)("Expression") }, cases: (0, f.validateArrayOfType)("SwitchCase") } }), y("ThisExpression", { aliases: ["Expression"] }), y("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, f.assertNodeType)("Expression") } } }), y("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertNodeType)("BlockStatement"), Object.assign(function(_) {
          if (!_.handler && !_.finalizer) throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, { oneOfNodeTypes: ["BlockStatement"] })) : (0, f.assertNodeType)("BlockStatement") }, handler: { optional: true, validate: (0, f.assertNodeType)("CatchClause") }, finalizer: { optional: true, validate: (0, f.assertNodeType)("BlockStatement") } } }), y("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: true }, argument: { validate: (0, f.assertNodeType)("Expression") }, operator: { validate: (0, f.assertOneOf)(...r.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] }), y("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: false }, argument: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("Identifier", "MemberExpression") : (0, f.assertNodeType)("Expression") }, operator: { validate: (0, f.assertOneOf)(...r.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] }), y("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, f.assertValueType)("boolean"), optional: true }, kind: { validate: (0, f.assertOneOf)("var", "let", "const", "using", "await using") }, declarations: (0, f.validateArrayOfType)("VariableDeclarator") }, validate: s.BABEL_TYPES_8_BREAKING ? (() => {
          const _ = (0, f.assertNodeType)("Identifier");
          return function(C, w, I) {
            if ((0, n.default)("ForXStatement", C, { left: I })) {
              if (I.declarations.length !== 1) throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${C.type}`);
            } else I.declarations.forEach((D) => {
              D.init || _(D, "id", D.id);
            });
          };
        })() : void 0 }), y("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern") : (0, f.assertNodeType)("LVal") }, definite: { optional: true, validate: (0, f.assertValueType)("boolean") }, init: { optional: true, validate: (0, f.assertNodeType)("Expression") } } }), y("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, f.assertNodeType)("Expression") }, body: { validate: (0, f.assertNodeType)("Statement") } } }), y("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, f.assertNodeType)("Expression") }, body: { validate: (0, f.assertNodeType)("Statement") } } }), y("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, p(), { left: { validate: (0, f.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") }, right: { validate: (0, f.assertNodeType)("Expression") }, decorators: { validate: (0, f.arrayOfType)("Decorator"), optional: true } }) }), y("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, p(), { elements: { validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeOrValueType)("null", "PatternLike", "LVal"))) } }) }), y("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["typeParameters", "params", "returnType", "body"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, S(), T(), { expression: { validate: (0, f.assertValueType)("boolean") }, body: { validate: (0, f.assertNodeType)("BlockStatement", "Expression") }, predicate: { validate: (0, f.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) }), y("ClassBody", { visitor: ["body"], fields: { body: (0, f.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock") } }), y("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, f.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, f.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, f.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, f.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, f.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, f.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"), optional: true }, decorators: { validate: (0, f.arrayOfType)("Decorator"), optional: true }, mixins: { validate: (0, f.assertNodeType)("InterfaceExtends"), optional: true } } }), y("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, f.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, f.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, f.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, f.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, f.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, f.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"), optional: true }, decorators: { validate: (0, f.arrayOfType)("Decorator"), optional: true }, mixins: { validate: (0, f.assertNodeType)("InterfaceExtends"), optional: true }, declare: { validate: (0, f.assertValueType)("boolean"), optional: true }, abstract: { validate: (0, f.assertValueType)("boolean"), optional: true } }, validate: s.BABEL_TYPES_8_BREAKING ? function() {
          const _ = (0, f.assertNodeType)("Identifier");
          return function(C, w, I) {
            (0, n.default)("ExportDefaultDeclaration", C) || _(I, "id", I.id);
          };
        }() : void 0 });
        const h = t.importAttributes = { attributes: { optional: true, validate: (0, f.arrayOfType)("ImportAttribute") }, assertions: { deprecated: true, optional: true, validate: (0, f.arrayOfType)("ImportAttribute") } };
        y("ExportAllDeclaration", { builder: ["source"], visitor: ["source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: Object.assign({ source: { validate: (0, f.assertNodeType)("StringLiteral") }, exportKind: (0, f.validateOptional)((0, f.assertOneOf)("type", "value")) }, h) }), y("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: (0, f.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"), exportKind: (0, f.validateOptional)((0, f.assertOneOf)("value")) } }), y("ExportNamedDeclaration", { builder: ["declaration", "specifiers", "source"], visitor: s ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: Object.assign({ declaration: { optional: true, validate: s.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertNodeType)("Declaration"), Object.assign(function(_, C, w) {
          if (w && _.specifiers.length) throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          if (w && _.source) throw new TypeError("Cannot export a declaration from a source");
        }, { oneOfNodeTypes: ["Declaration"] })) : (0, f.assertNodeType)("Declaration") } }, h, { specifiers: { default: [], validate: (0, f.arrayOf)(function() {
          const _ = (0, f.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), C = (0, f.assertNodeType)("ExportSpecifier");
          return s.BABEL_TYPES_8_BREAKING ? Object.assign(function(w, I, D) {
            (w.source ? _ : C)(w, I, D);
          }, { oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"] }) : _;
        }()) }, source: { validate: (0, f.assertNodeType)("StringLiteral"), optional: true }, exportKind: (0, f.validateOptional)((0, f.assertOneOf)("type", "value")) }) }), y("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, f.assertNodeType)("Identifier") }, exported: { validate: (0, f.assertNodeType)("Identifier", "StringLiteral") }, exportKind: { validate: (0, f.assertOneOf)("type", "value"), optional: true } } }), y("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: function() {
          if (!s.BABEL_TYPES_8_BREAKING) return (0, f.assertNodeType)("VariableDeclaration", "LVal");
          const _ = (0, f.assertNodeType)("VariableDeclaration"), C = (0, f.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(w, I, D) {
            (0, n.default)("VariableDeclaration", D) ? _(w, I, D) : C(w, I, D);
          }, { oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"] });
        }() }, right: { validate: (0, f.assertNodeType)("Expression") }, body: { validate: (0, f.assertNodeType)("Statement") }, await: { default: false } } }), y("ImportDeclaration", { builder: ["specifiers", "source"], visitor: ["specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"], fields: Object.assign({}, h, { module: { optional: true, validate: (0, f.assertValueType)("boolean") }, phase: { default: null, validate: (0, f.assertOneOf)("source", "defer") }, specifiers: (0, f.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"), source: { validate: (0, f.assertNodeType)("StringLiteral") }, importKind: { validate: (0, f.assertOneOf)("type", "typeof", "value"), optional: true } }) }), y("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, f.assertNodeType)("Identifier") } } }), y("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, f.assertNodeType)("Identifier") } } }), y("ImportSpecifier", { visitor: ["imported", "local"], builder: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, f.assertNodeType)("Identifier") }, imported: { validate: (0, f.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, f.assertOneOf)("type", "typeof", "value"), optional: true } } }), y("ImportExpression", { visitor: ["source", "options"], aliases: ["Expression"], fields: { phase: { default: null, validate: (0, f.assertOneOf)("source", "defer") }, source: { validate: (0, f.assertNodeType)("Expression") }, options: { validate: (0, f.assertNodeType)("Expression"), optional: true } } }), y("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertNodeType)("Identifier"), Object.assign(function(_, C, w) {
          let I;
          switch (w.name) {
            case "function":
              I = "sent";
              break;
            case "new":
              I = "target";
              break;
            case "import":
              I = "meta";
          }
          if (!(0, n.default)("Identifier", _.property, { name: I })) throw new TypeError("Unrecognised MetaProperty");
        }, { oneOfNodeTypes: ["Identifier"] })) : (0, f.assertNodeType)("Identifier") }, property: { validate: (0, f.assertNodeType)("Identifier") } } });
        const m = () => ({ abstract: { validate: (0, f.assertValueType)("boolean"), optional: true }, accessibility: { validate: (0, f.assertOneOf)("public", "private", "protected"), optional: true }, static: { default: false }, override: { default: false }, computed: { default: false }, optional: { validate: (0, f.assertValueType)("boolean"), optional: true }, key: { validate: (0, f.chain)(function() {
          const _ = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), C = (0, f.assertNodeType)("Expression");
          return function(w, I, D) {
            (w.computed ? C : _)(w, I, D);
          };
        }(), (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression")) } });
        t.classMethodOrPropertyCommon = m;
        const E = () => Object.assign({}, S(), m(), { params: (0, f.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"), kind: { validate: (0, f.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, f.chain)((0, f.assertValueType)("string"), (0, f.assertOneOf)("public", "private", "protected")), optional: true }, decorators: { validate: (0, f.arrayOfType)("Decorator"), optional: true } });
        t.classMethodOrDeclareMethodCommon = E, y("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"], fields: Object.assign({}, E(), T(), { body: { validate: (0, f.assertNodeType)("BlockStatement") } }) }), y("ObjectPattern", { visitor: ["properties", "typeAnnotation", "decorators"], builder: ["properties"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, p(), { properties: (0, f.validateArrayOfType)("RestElement", "ObjectProperty") }) }), y("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, f.assertNodeType)("Expression") } } }), y("Super", { aliases: ["Expression"] }), y("TaggedTemplateExpression", { visitor: ["tag", "typeParameters", "quasi"], builder: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, f.assertNodeType)("Expression") }, quasi: { validate: (0, f.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, f.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), y("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, f.chain)((0, f.assertShape)({ raw: { validate: (0, f.assertValueType)("string") }, cooked: { validate: (0, f.assertValueType)("string"), optional: true } }), function(_) {
          const C = _.value.raw;
          let w = false;
          const I = () => {
            throw new Error("Internal @babel/types error.");
          }, { str: D, firstInvalidLoc: j } = (0, e.readStringContents)("template", C, 0, 0, 0, { unterminated() {
            w = true;
          }, strictNumericEscape: I, invalidEscapeSequence: I, numericSeparatorInEscapeSequence: I, unexpectedNumericSeparator: I, invalidDigit: I, invalidCodePoint: I });
          if (!w) throw new Error("Invalid raw");
          _.value.cooked = j ? null : D;
        }) }, tail: { default: false } } }), y("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: (0, f.validateArrayOfType)("TemplateElement"), expressions: { validate: (0, f.chain)((0, f.assertValueType)("array"), (0, f.assertEach)((0, f.assertNodeType)("Expression", "TSType")), function(_, C, w) {
          if (_.quasis.length !== w.length + 1) throw new TypeError(`Number of ${_.type} quasis should be exactly one more than the number of expressions.
Expected ${w.length + 1} quasis but got ${_.quasis.length}`);
        }) } } }), y("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertValueType)("boolean"), Object.assign(function(_, C, w) {
          if (w && !_.argument) throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, { type: "boolean" })) : (0, f.assertValueType)("boolean"), default: false }, argument: { optional: true, validate: (0, f.assertNodeType)("Expression") } } }), y("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, f.assertNodeType)("Expression") } } }), y("Import", { aliases: ["Expression"] }), y("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, f.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), y("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, f.assertNodeType)("Identifier") } } }), y("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, f.assertNodeType)("Expression") }, property: { validate: function() {
          const _ = (0, f.assertNodeType)("Identifier"), C = (0, f.assertNodeType)("Expression");
          return Object.assign(function(w, I, D) {
            (w.computed ? C : _)(w, I, D);
          }, { oneOfNodeTypes: ["Expression", "Identifier"] });
        }() }, computed: { default: false }, optional: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertValueType)("boolean"), (0, f.assertOptionalChainStart)()) : (0, f.assertValueType)("boolean") } } }), y("OptionalCallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: { callee: { validate: (0, f.assertNodeType)("Expression") }, arguments: (0, f.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"), optional: { validate: s.BABEL_TYPES_8_BREAKING ? (0, f.chain)((0, f.assertValueType)("boolean"), (0, f.assertOptionalChainStart)()) : (0, f.assertValueType)("boolean") }, typeArguments: { validate: (0, f.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, f.assertNodeType)("TSTypeParameterInstantiation"), optional: true } } }), y("ClassProperty", { visitor: ["decorators", "key", "typeAnnotation", "value"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, m(), { value: { validate: (0, f.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, f.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, f.arrayOfType)("Decorator"), optional: true }, readonly: { validate: (0, f.assertValueType)("boolean"), optional: true }, declare: { validate: (0, f.assertValueType)("boolean"), optional: true }, variance: { validate: (0, f.assertNodeType)("Variance"), optional: true } }) }), y("ClassAccessorProperty", { visitor: ["decorators", "key", "typeAnnotation", "value"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property", "Accessor"], fields: Object.assign({}, m(), { key: { validate: (0, f.chain)(function() {
          const _ = (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), C = (0, f.assertNodeType)("Expression");
          return function(w, I, D) {
            (w.computed ? C : _)(w, I, D);
          };
        }(), (0, f.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName")) }, value: { validate: (0, f.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, f.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, f.arrayOfType)("Decorator"), optional: true }, readonly: { validate: (0, f.assertValueType)("boolean"), optional: true }, declare: { validate: (0, f.assertValueType)("boolean"), optional: true }, variance: { validate: (0, f.assertNodeType)("Variance"), optional: true } }) }), y("ClassPrivateProperty", { visitor: ["decorators", "key", "typeAnnotation", "value"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, f.assertNodeType)("PrivateName") }, value: { validate: (0, f.assertNodeType)("Expression"), optional: true }, typeAnnotation: { validate: (0, f.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, f.arrayOfType)("Decorator"), optional: true }, static: { validate: (0, f.assertValueType)("boolean"), default: false }, readonly: { validate: (0, f.assertValueType)("boolean"), optional: true }, definite: { validate: (0, f.assertValueType)("boolean"), optional: true }, variance: { validate: (0, f.assertNodeType)("Variance"), optional: true } } }), y("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, E(), T(), { kind: { validate: (0, f.assertOneOf)("get", "set", "method"), default: "method" }, key: { validate: (0, f.assertNodeType)("PrivateName") }, body: { validate: (0, f.assertNodeType)("BlockStatement") } }) }), y("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, f.assertNodeType)("Identifier") } } }), y("StaticBlock", { visitor: ["body"], fields: { body: (0, f.validateArrayOfType)("Statement") }, aliases: ["Scopable", "BlockParent", "FunctionParent"] });
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/deprecated-aliases.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.DEPRECATED_ALIASES = void 0, t.DEPRECATED_ALIASES = { ModuleDeclaration: "ImportOrExportDeclaration" };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/experimental.js": (P, t, l) => {
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");
        (0, n.default)("ArgumentPlaceholder", {}), (0, n.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: s.BABEL_TYPES_8_BREAKING ? { object: { validate: (0, n.assertNodeType)("Expression") }, callee: { validate: (0, n.assertNodeType)("Expression") } } : { object: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) } } }), (0, n.default)("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, n.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, n.assertNodeType)("StringLiteral") } } }), (0, n.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, n.assertNodeType)("Expression") } } }), (0, n.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, n.assertNodeType)("BlockStatement") }, async: { validate: (0, n.assertValueType)("boolean"), default: false } } }), (0, n.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, n.assertNodeType)("Identifier") } } }), (0, n.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: (0, n.validateArrayOfType)("ObjectProperty", "SpreadElement") } }), (0, n.default)("TupleExpression", { fields: { elements: { validate: (0, n.arrayOfType)("Expression", "SpreadElement"), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, n.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, n.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, n.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, n.assertNodeType)("Program") } }, aliases: ["Expression"] }), (0, n.default)("TopicReference", { aliases: ["Expression"] }), (0, n.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, n.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, n.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, n.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, n.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] });
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/flow.js": (P, t, l) => {
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/core.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");
        const c = (0, u.defineAliasedType)("Flow"), e = (r) => {
          const f = r === "DeclareClass";
          c(r, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", ...f ? ["mixins", "implements"] : [], "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ id: (0, u.validateType)("Identifier"), typeParameters: (0, u.validateOptionalType)("TypeParameterDeclaration"), extends: (0, u.validateOptional)((0, u.arrayOfType)("InterfaceExtends")) }, f ? { mixins: (0, u.validateOptional)((0, u.arrayOfType)("InterfaceExtends")), implements: (0, u.validateOptional)((0, u.arrayOfType)("ClassImplements")) } : {}, { body: (0, u.validateType)("ObjectTypeAnnotation") }) });
        };
        c("AnyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["FlowType"], fields: { elementType: (0, u.validateType)("FlowType") } }), c("BooleanTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, u.validate)((0, u.assertValueType)("boolean")) } }), c("NullLiteralTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("ClassImplements", { visitor: ["id", "typeParameters"], fields: { id: (0, u.validateType)("Identifier"), typeParameters: (0, u.validateOptionalType)("TypeParameterInstantiation") } }), e("DeclareClass"), c("DeclareFunction", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, u.validateType)("Identifier"), predicate: (0, u.validateOptionalType)("DeclaredPredicate") } }), e("DeclareInterface"), c("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, u.validateType)("Identifier", "StringLiteral"), body: (0, u.validateType)("BlockStatement"), kind: (0, u.validateOptional)((0, u.assertOneOf)("CommonJS", "ES")) } }), c("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, u.validateType)("TypeAnnotation") } }), c("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, u.validateType)("Identifier"), typeParameters: (0, u.validateOptionalType)("TypeParameterDeclaration"), right: (0, u.validateType)("FlowType") } }), c("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, u.validateType)("Identifier"), typeParameters: (0, u.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, u.validateOptionalType)("FlowType"), impltype: (0, u.validateOptionalType)("FlowType") } }), c("DeclareVariable", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, u.validateType)("Identifier") } }), c("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source", "attributes"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ declaration: (0, u.validateOptionalType)("Flow"), specifiers: (0, u.validateOptional)((0, u.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")), source: (0, u.validateOptionalType)("StringLiteral"), default: (0, u.validateOptional)((0, u.assertValueType)("boolean")) }, n.importAttributes) }), c("DeclareExportAllDeclaration", { visitor: ["source", "attributes"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ source: (0, u.validateType)("StringLiteral"), exportKind: (0, u.validateOptional)((0, u.assertOneOf)("type", "value")) }, n.importAttributes) }), c("DeclaredPredicate", { visitor: ["value"], aliases: ["FlowPredicate"], fields: { value: (0, u.validateType)("Flow") } }), c("ExistsTypeAnnotation", { aliases: ["FlowType"] }), c("FunctionTypeAnnotation", { visitor: ["typeParameters", "params", "rest", "returnType"], aliases: ["FlowType"], fields: { typeParameters: (0, u.validateOptionalType)("TypeParameterDeclaration"), params: (0, u.validateArrayOfType)("FunctionTypeParam"), rest: (0, u.validateOptionalType)("FunctionTypeParam"), this: (0, u.validateOptionalType)("FunctionTypeParam"), returnType: (0, u.validateType)("FlowType") } }), c("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], fields: { name: (0, u.validateOptionalType)("Identifier"), typeAnnotation: (0, u.validateType)("FlowType"), optional: (0, u.validateOptional)((0, u.assertValueType)("boolean")) } }), c("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["FlowType"], fields: { id: (0, u.validateType)("Identifier", "QualifiedTypeIdentifier"), typeParameters: (0, u.validateOptionalType)("TypeParameterInstantiation") } }), c("InferredPredicate", { aliases: ["FlowPredicate"] }), c("InterfaceExtends", { visitor: ["id", "typeParameters"], fields: { id: (0, u.validateType)("Identifier", "QualifiedTypeIdentifier"), typeParameters: (0, u.validateOptionalType)("TypeParameterInstantiation") } }), e("InterfaceDeclaration"), c("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["FlowType"], fields: { extends: (0, u.validateOptional)((0, u.arrayOfType)("InterfaceExtends")), body: (0, u.validateType)("ObjectTypeAnnotation") } }), c("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, u.validate)((0, u.arrayOfType)("FlowType")) } }), c("MixedTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("EmptyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["FlowType"], fields: { typeAnnotation: (0, u.validateType)("FlowType") } }), c("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, u.validate)((0, u.assertValueType)("number")) } }), c("NumberTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, u.validate)((0, u.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")), indexers: { validate: (0, u.arrayOfType)("ObjectTypeIndexer"), optional: true, default: [] }, callProperties: { validate: (0, u.arrayOfType)("ObjectTypeCallProperty"), optional: true, default: [] }, internalSlots: { validate: (0, u.arrayOfType)("ObjectTypeInternalSlot"), optional: true, default: [] }, exact: { validate: (0, u.assertValueType)("boolean"), default: false }, inexact: (0, u.validateOptional)((0, u.assertValueType)("boolean")) } }), c("ObjectTypeInternalSlot", { visitor: ["id", "value"], builder: ["id", "value", "optional", "static", "method"], aliases: ["UserWhitespacable"], fields: { id: (0, u.validateType)("Identifier"), value: (0, u.validateType)("FlowType"), optional: (0, u.validate)((0, u.assertValueType)("boolean")), static: (0, u.validate)((0, u.assertValueType)("boolean")), method: (0, u.validate)((0, u.assertValueType)("boolean")) } }), c("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["UserWhitespacable"], fields: { value: (0, u.validateType)("FlowType"), static: (0, u.validate)((0, u.assertValueType)("boolean")) } }), c("ObjectTypeIndexer", { visitor: ["variance", "id", "key", "value"], builder: ["id", "key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { id: (0, u.validateOptionalType)("Identifier"), key: (0, u.validateType)("FlowType"), value: (0, u.validateType)("FlowType"), static: (0, u.validate)((0, u.assertValueType)("boolean")), variance: (0, u.validateOptionalType)("Variance") } }), c("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { key: (0, u.validateType)("Identifier", "StringLiteral"), value: (0, u.validateType)("FlowType"), kind: (0, u.validate)((0, u.assertOneOf)("init", "get", "set")), static: (0, u.validate)((0, u.assertValueType)("boolean")), proto: (0, u.validate)((0, u.assertValueType)("boolean")), optional: (0, u.validate)((0, u.assertValueType)("boolean")), variance: (0, u.validateOptionalType)("Variance"), method: (0, u.validate)((0, u.assertValueType)("boolean")) } }), c("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["UserWhitespacable"], fields: { argument: (0, u.validateType)("FlowType") } }), c("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, u.validateType)("Identifier"), typeParameters: (0, u.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, u.validateOptionalType)("FlowType"), impltype: (0, u.validateType)("FlowType") } }), c("QualifiedTypeIdentifier", { visitor: ["qualification", "id"], builder: ["id", "qualification"], fields: { id: (0, u.validateType)("Identifier"), qualification: (0, u.validateType)("Identifier", "QualifiedTypeIdentifier") } }), c("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, u.validate)((0, u.assertValueType)("string")) } }), c("StringTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("SymbolTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("ThisTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("TupleTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, u.validate)((0, u.arrayOfType)("FlowType")) } }), c("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["FlowType"], fields: { argument: (0, u.validateType)("FlowType") } }), c("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, u.validateType)("Identifier"), typeParameters: (0, u.validateOptionalType)("TypeParameterDeclaration"), right: (0, u.validateType)("FlowType") } }), c("TypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, u.validateType)("FlowType") } }), c("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["ExpressionWrapper", "Expression"], fields: { expression: (0, u.validateType)("Expression"), typeAnnotation: (0, u.validateType)("TypeAnnotation") } }), c("TypeParameter", { visitor: ["bound", "default", "variance"], fields: { name: (0, u.validate)((0, u.assertValueType)("string")), bound: (0, u.validateOptionalType)("TypeAnnotation"), default: (0, u.validateOptionalType)("FlowType"), variance: (0, u.validateOptionalType)("Variance") } }), c("TypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, u.validate)((0, u.arrayOfType)("TypeParameter")) } }), c("TypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, u.validate)((0, u.arrayOfType)("FlowType")) } }), c("UnionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, u.validate)((0, u.arrayOfType)("FlowType")) } }), c("Variance", { builder: ["kind"], fields: { kind: (0, u.validate)((0, u.assertOneOf)("minus", "plus")) } }), c("VoidTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), c("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, u.validateType)("Identifier"), body: (0, u.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody") } }), c("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, u.validate)((0, u.assertValueType)("boolean")), members: (0, u.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, u.validate)((0, u.assertValueType)("boolean")) } }), c("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, u.validate)((0, u.assertValueType)("boolean")), members: (0, u.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, u.validate)((0, u.assertValueType)("boolean")) } }), c("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, u.validate)((0, u.assertValueType)("boolean")), members: (0, u.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"), hasUnknownMembers: (0, u.validate)((0, u.assertValueType)("boolean")) } }), c("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, u.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, u.validate)((0, u.assertValueType)("boolean")) } }), c("EnumBooleanMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, u.validateType)("Identifier"), init: (0, u.validateType)("BooleanLiteral") } }), c("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, u.validateType)("Identifier"), init: (0, u.validateType)("NumericLiteral") } }), c("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, u.validateType)("Identifier"), init: (0, u.validateType)("StringLiteral") } }), c("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, u.validateType)("Identifier") } }), c("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, u.validateType)("FlowType"), indexType: (0, u.validateType)("FlowType") } }), c("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, u.validateType)("FlowType"), indexType: (0, u.validateType)("FlowType"), optional: (0, u.validate)((0, u.assertValueType)("boolean")) } });
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), Object.defineProperty(t, "ALIAS_KEYS", { enumerable: true, get: function() {
          return n.ALIAS_KEYS;
        } }), Object.defineProperty(t, "BUILDER_KEYS", { enumerable: true, get: function() {
          return n.BUILDER_KEYS;
        } }), Object.defineProperty(t, "DEPRECATED_ALIASES", { enumerable: true, get: function() {
          return c.DEPRECATED_ALIASES;
        } }), Object.defineProperty(t, "DEPRECATED_KEYS", { enumerable: true, get: function() {
          return n.DEPRECATED_KEYS;
        } }), Object.defineProperty(t, "FLIPPED_ALIAS_KEYS", { enumerable: true, get: function() {
          return n.FLIPPED_ALIAS_KEYS;
        } }), Object.defineProperty(t, "NODE_FIELDS", { enumerable: true, get: function() {
          return n.NODE_FIELDS;
        } }), Object.defineProperty(t, "NODE_PARENT_VALIDATIONS", { enumerable: true, get: function() {
          return n.NODE_PARENT_VALIDATIONS;
        } }), Object.defineProperty(t, "PLACEHOLDERS", { enumerable: true, get: function() {
          return u.PLACEHOLDERS;
        } }), Object.defineProperty(t, "PLACEHOLDERS_ALIAS", { enumerable: true, get: function() {
          return u.PLACEHOLDERS_ALIAS;
        } }), Object.defineProperty(t, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: true, get: function() {
          return u.PLACEHOLDERS_FLIPPED_ALIAS;
        } }), t.TYPES = void 0, Object.defineProperty(t, "VISITOR_KEYS", { enumerable: true, get: function() {
          return n.VISITOR_KEYS;
        } }), l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/core.js"), l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/flow.js"), l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/jsx.js"), l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/misc.js"), l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/experimental.js"), l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/typescript.js");
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/placeholders.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/deprecated-aliases.js");
        Object.keys(c.DEPRECATED_ALIASES).forEach((e) => {
          n.FLIPPED_ALIAS_KEYS[e] = n.FLIPPED_ALIAS_KEYS[c.DEPRECATED_ALIASES[e]];
        }), t.TYPES = [].concat(Object.keys(n.VISITOR_KEYS), Object.keys(n.FLIPPED_ALIAS_KEYS), Object.keys(n.DEPRECATED_KEYS));
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/jsx.js": (P, t, l) => {
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");
        const u = (0, n.defineAliasedType)("JSX");
        u("JSXAttribute", { visitor: ["name", "value"], aliases: ["Immutable"], fields: { name: { validate: (0, n.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: true, validate: (0, n.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } }), u("JSXClosingElement", { visitor: ["name"], aliases: ["Immutable"], fields: { name: { validate: (0, n.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } }), u("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["Immutable", "Expression"], fields: Object.assign({ openingElement: { validate: (0, n.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: true, validate: (0, n.assertNodeType)("JSXClosingElement") }, children: (0, n.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment") }, { selfClosing: { validate: (0, n.assertValueType)("boolean"), optional: true } }) }), u("JSXEmptyExpression", {}), u("JSXExpressionContainer", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, n.assertNodeType)("Expression", "JSXEmptyExpression") } } }), u("JSXSpreadChild", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, n.assertNodeType)("Expression") } } }), u("JSXIdentifier", { builder: ["name"], fields: { name: { validate: (0, n.assertValueType)("string") } } }), u("JSXMemberExpression", { visitor: ["object", "property"], fields: { object: { validate: (0, n.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, n.assertNodeType)("JSXIdentifier") } } }), u("JSXNamespacedName", { visitor: ["namespace", "name"], fields: { namespace: { validate: (0, n.assertNodeType)("JSXIdentifier") }, name: { validate: (0, n.assertNodeType)("JSXIdentifier") } } }), u("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "attributes"], aliases: ["Immutable"], fields: { name: { validate: (0, n.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: false }, attributes: (0, n.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"), typeParameters: { validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), u("JSXSpreadAttribute", { visitor: ["argument"], fields: { argument: { validate: (0, n.assertNodeType)("Expression") } } }), u("JSXText", { aliases: ["Immutable"], builder: ["value"], fields: { value: { validate: (0, n.assertValueType)("string") } } }), u("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["Immutable", "Expression"], fields: { openingFragment: { validate: (0, n.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, n.assertNodeType)("JSXClosingFragment") }, children: (0, n.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment") } }), u("JSXOpeningFragment", { aliases: ["Immutable"] }), u("JSXClosingFragment", { aliases: ["Immutable"] });
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/misc.js": (P, t, l) => {
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/placeholders.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/core.js");
        const e = (0, n.defineAliasedType)("Miscellaneous");
        e("Noop", { visitor: [] }), e("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: Object.assign({ name: { validate: (0, n.assertNodeType)("Identifier") }, expectedNode: { validate: (0, n.assertOneOf)(...u.PLACEHOLDERS) } }, (0, c.patternLikeCommon)()) }), e("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, n.assertValueType)("string") } } });
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/placeholders.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.PLACEHOLDERS_FLIPPED_ALIAS = t.PLACEHOLDERS_ALIAS = t.PLACEHOLDERS = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js");
        const u = t.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], c = t.PLACEHOLDERS_ALIAS = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
        for (const r of u) {
          const f = n.ALIAS_KEYS[r];
          f != null && f.length && (c[r] = f);
        }
        const e = t.PLACEHOLDERS_FLIPPED_ALIAS = {};
        Object.keys(c).forEach((r) => {
          c[r].forEach((f) => {
            hasOwnProperty.call(e, f) || (e[f] = []), e[f].push(r);
          });
        });
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/typescript.js": (P, t, l) => {
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/core.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js");
        const e = (0, n.defineAliasedType)("TypeScript"), r = (0, n.assertValueType)("boolean"), f = () => ({ returnType: { validate: (0, n.assertNodeType)("TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, n.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: true } });
        e("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, n.assertOneOf)("public", "private", "protected"), optional: true }, readonly: { validate: (0, n.assertValueType)("boolean"), optional: true }, parameter: { validate: (0, n.assertNodeType)("Identifier", "AssignmentPattern") }, override: { validate: (0, n.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, n.arrayOfType)("Decorator"), optional: true } } }), e("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, u.functionDeclarationCommon)(), f()) }), e("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, u.classMethodOrDeclareMethodCommon)(), f()) }), e("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, n.validateType)("TSEntityName"), right: (0, n.validateType)("Identifier") } });
        const y = () => ({ typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, n.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation") }), S = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: y() };
        e("TSCallSignatureDeclaration", S), e("TSConstructSignatureDeclaration", S);
        const T = () => ({ key: (0, n.validateType)("Expression"), computed: { default: false }, optional: (0, n.validateOptional)(r) });
        e("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation"], fields: Object.assign({}, T(), { readonly: (0, n.validateOptional)(r), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"), kind: { validate: (0, n.assertOneOf)("get", "set") } }) }), e("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, y(), T(), { kind: { validate: (0, n.assertOneOf)("method", "get", "set") } }) }), e("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, n.validateOptional)(r), static: (0, n.validateOptional)(r), parameters: (0, n.validateArrayOfType)("Identifier"), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation") } });
        const d = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
        for (const E of d) e(E, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        e("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        const p = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
        e("TSFunctionType", Object.assign({}, p, { fields: y() })), e("TSConstructorType", Object.assign({}, p, { fields: Object.assign({}, y(), { abstract: (0, n.validateOptional)(r) }) })), e("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, n.validateType)("TSEntityName"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } }), e("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, n.validateType)("Identifier", "TSThisType"), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"), asserts: (0, n.validateOptional)(r) } }), e("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName", "typeParameters"], fields: { exprName: (0, n.validateType)("TSEntityName", "TSImportType"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } }), e("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, n.validateArrayOfType)("TSTypeElement") } }), e("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, n.validateType)("TSType") } }), e("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, n.validateArrayOfType)("TSType", "TSNamedTupleMember") } }), e("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n.validateType)("TSType") } }), e("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n.validateType)("TSType") } }), e("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, n.validateType)("Identifier"), optional: { validate: r, default: false }, elementType: (0, n.validateType)("TSType") } });
        const h = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, n.validateArrayOfType)("TSType") } };
        e("TSUnionType", h), e("TSIntersectionType", h), e("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, n.validateType)("TSType"), extendsType: (0, n.validateType)("TSType"), trueType: (0, n.validateType)("TSType"), falseType: (0, n.validateType)("TSType") } }), e("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, n.validateType)("TSTypeParameter") } }), e("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n.validateType)("TSType") } }), e("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { operator: (0, n.validate)((0, n.assertValueType)("string")), typeAnnotation: (0, n.validateType)("TSType") } }), e("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, n.validateType)("TSType"), indexType: (0, n.validateType)("TSType") } }), e("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "nameType", "typeAnnotation"], builder: ["typeParameter", "typeAnnotation", "nameType"], fields: Object.assign({}, { typeParameter: (0, n.validateType)("TSTypeParameter") }, { readonly: (0, n.validateOptional)((0, n.assertOneOf)(true, false, "+", "-")), optional: (0, n.validateOptional)((0, n.assertOneOf)(true, false, "+", "-")), typeAnnotation: (0, n.validateOptionalType)("TSType"), nameType: (0, n.validateOptionalType)("TSType") }) }), e("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: { validate: function() {
          const E = (0, n.assertNodeType)("NumericLiteral", "BigIntLiteral"), _ = (0, n.assertOneOf)("-"), C = (0, n.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function w(I, D, j) {
            (0, c.default)("UnaryExpression", j) ? (_(j, "operator", j.operator), E(j, "argument", j.argument)) : C(I, D, j);
          }
          return w.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], w;
        }() } } }), e("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, n.validateType)("TSEntityName"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } }), e("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, n.validateOptional)(r), id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, n.validateOptional)((0, n.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, n.validateType)("TSInterfaceBody") } }), e("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, n.validateArrayOfType)("TSTypeElement") } }), e("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, n.validateOptional)(r), id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, n.validateType)("TSType") } }), e("TSInstantiationExpression", { aliases: ["Expression"], visitor: ["expression", "typeParameters"], fields: { expression: (0, n.validateType)("Expression"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } });
        const m = { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, n.validateType)("Expression"), typeAnnotation: (0, n.validateType)("TSType") } };
        e("TSAsExpression", m), e("TSSatisfiesExpression", m), e("TSTypeAssertion", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, n.validateType)("TSType"), expression: (0, n.validateType)("Expression") } }), e("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, n.validateOptional)(r), const: (0, n.validateOptional)(r), id: (0, n.validateType)("Identifier"), members: (0, n.validateArrayOfType)("TSEnumMember"), initializer: (0, n.validateOptionalType)("Expression") } }), e("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, n.validateType)("Identifier", "StringLiteral"), initializer: (0, n.validateOptionalType)("Expression") } }), e("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: Object.assign({ kind: { validate: (0, n.assertOneOf)("global", "module", "namespace") }, declare: (0, n.validateOptional)(r) }, { global: (0, n.validateOptional)(r) }, { id: (0, n.validateType)("Identifier", "StringLiteral"), body: (0, n.validateType)("TSModuleBlock", "TSModuleDeclaration") }) }), e("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"], visitor: ["body"], fields: { body: (0, n.validateArrayOfType)("Statement") } }), e("TSImportType", { aliases: ["TSType"], visitor: ["argument", "qualifier", "typeParameters"], fields: { argument: (0, n.validateType)("StringLiteral"), qualifier: (0, n.validateOptionalType)("TSEntityName"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation"), options: { validate: (0, n.assertNodeType)("Expression"), optional: true } } }), e("TSImportEqualsDeclaration", { aliases: ["Statement"], visitor: ["id", "moduleReference"], fields: { isExport: (0, n.validate)(r), id: (0, n.validateType)("Identifier"), moduleReference: (0, n.validateType)("TSEntityName", "TSExternalModuleReference"), importKind: { validate: (0, n.assertOneOf)("type", "value"), optional: true } } }), e("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, n.validateType)("StringLiteral") } }), e("TSNonNullExpression", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression"], fields: { expression: (0, n.validateType)("Expression") } }), e("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, n.validateType)("Expression") } }), e("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, n.validateType)("Identifier") } }), e("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, n.assertNodeType)("TSType") } } }), e("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, n.validateArrayOfType)("TSType") } }), e("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, n.validateArrayOfType)("TSTypeParameter") } }), e("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, n.assertValueType)("string") }, in: { validate: (0, n.assertValueType)("boolean"), optional: true }, out: { validate: (0, n.assertValueType)("boolean"), optional: true }, const: { validate: (0, n.assertValueType)("boolean"), optional: true }, constraint: { validate: (0, n.assertNodeType)("TSType"), optional: true }, default: { validate: (0, n.assertNodeType)("TSType"), optional: true } } });
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/utils.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.VISITOR_KEYS = t.NODE_PARENT_VALIDATIONS = t.NODE_FIELDS = t.FLIPPED_ALIAS_KEYS = t.DEPRECATED_KEYS = t.BUILDER_KEYS = t.ALIAS_KEYS = void 0, t.arrayOf = h, t.arrayOfType = m, t.assertEach = E, t.assertNodeOrValueType = function(...k) {
          function N(F, W, X) {
            for (const H of k) if (d(X) === H || (0, n.default)(H, X)) return void (0, u.validateChild)(F, W, X);
            throw new TypeError(`Property ${W} of ${F.type} expected node to be of a type ${JSON.stringify(k)} but instead got ${JSON.stringify(X == null ? void 0 : X.type)}`);
          }
          return N.oneOfNodeOrValueTypes = k, N;
        }, t.assertNodeType = _, t.assertOneOf = function(...k) {
          function N(F, W, X) {
            if (!k.includes(X)) throw new TypeError(`Property ${W} expected value to be one of ${JSON.stringify(k)} but got ${JSON.stringify(X)}`);
          }
          return N.oneOf = k, N;
        }, t.assertOptionalChainStart = function() {
          return function(k) {
            var N;
            let F = k;
            for (; k; ) {
              const { type: W } = F;
              if (W !== "OptionalCallExpression") {
                if (W !== "OptionalMemberExpression") break;
                if (F.optional) return;
                F = F.object;
              } else {
                if (F.optional) return;
                F = F.callee;
              }
            }
            throw new TypeError(`Non-optional ${k.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(N = F) == null ? void 0 : N.type}`);
          };
        }, t.assertShape = function(k) {
          function N(F, W, X) {
            const H = [];
            for (const U of Object.keys(k)) try {
              (0, u.validateField)(F, U, X[U], k[U]);
            } catch (q) {
              if (q instanceof TypeError) {
                H.push(q.message);
                continue;
              }
              throw q;
            }
            if (H.length) throw new TypeError(`Property ${W} of ${F.type} expected to have the following:
${H.join(`
`)}`);
          }
          return N.shapeOf = k, N;
        }, t.assertValueType = C, t.chain = w, t.default = L, t.defineAliasedType = function(...k) {
          return (N, F = {}) => {
            let W = F.aliases;
            var X;
            W || (F.inherits && (W = (X = j[F.inherits].aliases) == null ? void 0 : X.slice()), W != null || (W = []), F.aliases = W);
            const H = k.filter((U) => !W.includes(U));
            W.unshift(...H), L(N, F);
          };
        }, t.validate = p, t.validateArrayOfType = function(...k) {
          return p(m(...k));
        }, t.validateOptional = function(k) {
          return { validate: k, optional: true };
        }, t.validateOptionalType = function(...k) {
          return { validate: _(...k), optional: true };
        }, t.validateType = function(...k) {
          return p(_(...k));
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/validate.js");
        const c = t.VISITOR_KEYS = {}, e = t.ALIAS_KEYS = {}, r = t.FLIPPED_ALIAS_KEYS = {}, f = t.NODE_FIELDS = {}, y = t.BUILDER_KEYS = {}, S = t.DEPRECATED_KEYS = {}, T = t.NODE_PARENT_VALIDATIONS = {};
        function d(k) {
          return Array.isArray(k) ? "array" : k === null ? "null" : typeof k;
        }
        function p(k) {
          return { validate: k };
        }
        function h(k) {
          return w(C("array"), E(k));
        }
        function m(...k) {
          return h(_(...k));
        }
        function E(k) {
          const N = s.BABEL_TYPES_8_BREAKING ? u.validateChild : () => {
          };
          function F(W, X, H) {
            if (Array.isArray(H)) for (let U = 0; U < H.length; U++) {
              const q = `${X}[${U}]`, ee = H[U];
              k(W, q, ee), N(W, q, ee);
            }
          }
          return F.each = k, F;
        }
        function _(...k) {
          function N(F, W, X) {
            for (const H of k) if ((0, n.default)(H, X)) return void (0, u.validateChild)(F, W, X);
            throw new TypeError(`Property ${W} of ${F.type} expected node to be of a type ${JSON.stringify(k)} but instead got ${JSON.stringify(X == null ? void 0 : X.type)}`);
          }
          return N.oneOfNodeTypes = k, N;
        }
        function C(k) {
          function N(F, W, X) {
            if (d(X) !== k) throw new TypeError(`Property ${W} expected type of ${k} but got ${d(X)}`);
          }
          return N.type = k, N;
        }
        function w(...k) {
          function N(...F) {
            for (const W of k) W(...F);
          }
          if (N.chainOf = k, k.length >= 2 && "type" in k[0] && k[0].type === "array" && !("each" in k[1])) throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
          return N;
        }
        const I = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]), D = /* @__PURE__ */ new Set(["default", "optional", "deprecated", "validate"]), j = {};
        function L(k, N = {}) {
          const F = N.inherits && j[N.inherits] || {};
          let W = N.fields;
          if (!W && (W = {}, F.fields)) {
            const q = Object.getOwnPropertyNames(F.fields);
            for (const ee of q) {
              const re = F.fields[ee], Y = re.default;
              if (Array.isArray(Y) ? Y.length > 0 : Y && typeof Y == "object") throw new Error("field defaults can only be primitives or empty arrays currently");
              W[ee] = { default: Array.isArray(Y) ? [] : Y, optional: re.optional, deprecated: re.deprecated, validate: re.validate };
            }
          }
          const X = N.visitor || F.visitor || [], H = N.aliases || F.aliases || [], U = N.builder || F.builder || N.visitor || [];
          for (const q of Object.keys(N)) if (!I.has(q)) throw new Error(`Unknown type option "${q}" on ${k}`);
          N.deprecatedAlias && (S[N.deprecatedAlias] = k);
          for (const q of X.concat(U)) W[q] = W[q] || {};
          for (const q of Object.keys(W)) {
            const ee = W[q];
            ee.default === void 0 || U.includes(q) || (ee.optional = true), ee.default === void 0 ? ee.default = null : ee.validate || ee.default == null || (ee.validate = C(d(ee.default)));
            for (const re of Object.keys(ee)) if (!D.has(re)) throw new Error(`Unknown field key "${re}" on ${k}.${q}`);
          }
          c[k] = N.visitor = X, y[k] = N.builder = U, f[k] = N.fields = W, e[k] = N.aliases = H, H.forEach((q) => {
            r[q] = r[q] || [], r[q].push(k);
          }), N.validate && (T[k] = N.validate), j[k] = N;
        }
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true });
        var n = { react: true, assertNode: true, createTypeAnnotationBasedOnTypeof: true, createUnionTypeAnnotation: true, createFlowUnionType: true, createTSUnionType: true, cloneNode: true, clone: true, cloneDeep: true, cloneDeepWithoutLoc: true, cloneWithoutLoc: true, addComment: true, addComments: true, inheritInnerComments: true, inheritLeadingComments: true, inheritsComments: true, inheritTrailingComments: true, removeComments: true, ensureBlock: true, toBindingIdentifierName: true, toBlock: true, toComputedKey: true, toExpression: true, toIdentifier: true, toKeyAlias: true, toStatement: true, valueToNode: true, appendToMemberExpression: true, inherits: true, prependToMemberExpression: true, removeProperties: true, removePropertiesDeep: true, removeTypeDuplicates: true, getAssignmentIdentifiers: true, getBindingIdentifiers: true, getOuterBindingIdentifiers: true, getFunctionName: true, traverse: true, traverseFast: true, shallowEqual: true, is: true, isBinding: true, isBlockScoped: true, isImmutable: true, isLet: true, isNode: true, isNodesEquivalent: true, isPlaceholderType: true, isReferenced: true, isScope: true, isSpecifierDefault: true, isType: true, isValidES3Identifier: true, isValidIdentifier: true, isVar: true, matchesPattern: true, validate: true, buildMatchMemberExpression: true, __internal__deprecationWarning: true };
        Object.defineProperty(t, "__internal__deprecationWarning", { enumerable: true, get: function() {
          return st.default;
        } }), Object.defineProperty(t, "addComment", { enumerable: true, get: function() {
          return I.default;
        } }), Object.defineProperty(t, "addComments", { enumerable: true, get: function() {
          return D.default;
        } }), Object.defineProperty(t, "appendToMemberExpression", { enumerable: true, get: function() {
          return M.default;
        } }), Object.defineProperty(t, "assertNode", { enumerable: true, get: function() {
          return r.default;
        } }), Object.defineProperty(t, "buildMatchMemberExpression", { enumerable: true, get: function() {
          return Xe.default;
        } }), Object.defineProperty(t, "clone", { enumerable: true, get: function() {
          return E.default;
        } }), Object.defineProperty(t, "cloneDeep", { enumerable: true, get: function() {
          return _.default;
        } }), Object.defineProperty(t, "cloneDeepWithoutLoc", { enumerable: true, get: function() {
          return C.default;
        } }), Object.defineProperty(t, "cloneNode", { enumerable: true, get: function() {
          return m.default;
        } }), Object.defineProperty(t, "cloneWithoutLoc", { enumerable: true, get: function() {
          return w.default;
        } }), Object.defineProperty(t, "createFlowUnionType", { enumerable: true, get: function() {
          return S.default;
        } }), Object.defineProperty(t, "createTSUnionType", { enumerable: true, get: function() {
          return T.default;
        } }), Object.defineProperty(t, "createTypeAnnotationBasedOnTypeof", { enumerable: true, get: function() {
          return y.default;
        } }), Object.defineProperty(t, "createUnionTypeAnnotation", { enumerable: true, get: function() {
          return S.default;
        } }), Object.defineProperty(t, "ensureBlock", { enumerable: true, get: function() {
          return H.default;
        } }), Object.defineProperty(t, "getAssignmentIdentifiers", { enumerable: true, get: function() {
          return Te.default;
        } }), Object.defineProperty(t, "getBindingIdentifiers", { enumerable: true, get: function() {
          return le.default;
        } }), Object.defineProperty(t, "getFunctionName", { enumerable: true, get: function() {
          return Pe.default;
        } }), Object.defineProperty(t, "getOuterBindingIdentifiers", { enumerable: true, get: function() {
          return fe.default;
        } }), Object.defineProperty(t, "inheritInnerComments", { enumerable: true, get: function() {
          return j.default;
        } }), Object.defineProperty(t, "inheritLeadingComments", { enumerable: true, get: function() {
          return L.default;
        } }), Object.defineProperty(t, "inheritTrailingComments", { enumerable: true, get: function() {
          return N.default;
        } }), Object.defineProperty(t, "inherits", { enumerable: true, get: function() {
          return K.default;
        } }), Object.defineProperty(t, "inheritsComments", { enumerable: true, get: function() {
          return k.default;
        } }), Object.defineProperty(t, "is", { enumerable: true, get: function() {
          return ye.default;
        } }), Object.defineProperty(t, "isBinding", { enumerable: true, get: function() {
          return pe.default;
        } }), Object.defineProperty(t, "isBlockScoped", { enumerable: true, get: function() {
          return J.default;
        } }), Object.defineProperty(t, "isImmutable", { enumerable: true, get: function() {
          return Ee.default;
        } }), Object.defineProperty(t, "isLet", { enumerable: true, get: function() {
          return Me.default;
        } }), Object.defineProperty(t, "isNode", { enumerable: true, get: function() {
          return Ue.default;
        } }), Object.defineProperty(t, "isNodesEquivalent", { enumerable: true, get: function() {
          return qe.default;
        } }), Object.defineProperty(t, "isPlaceholderType", { enumerable: true, get: function() {
          return He.default;
        } }), Object.defineProperty(t, "isReferenced", { enumerable: true, get: function() {
          return Ie.default;
        } }), Object.defineProperty(t, "isScope", { enumerable: true, get: function() {
          return Re.default;
        } }), Object.defineProperty(t, "isSpecifierDefault", { enumerable: true, get: function() {
          return Be.default;
        } }), Object.defineProperty(t, "isType", { enumerable: true, get: function() {
          return je.default;
        } }), Object.defineProperty(t, "isValidES3Identifier", { enumerable: true, get: function() {
          return he.default;
        } }), Object.defineProperty(t, "isValidIdentifier", { enumerable: true, get: function() {
          return oe.default;
        } }), Object.defineProperty(t, "isVar", { enumerable: true, get: function() {
          return _e.default;
        } }), Object.defineProperty(t, "matchesPattern", { enumerable: true, get: function() {
          return Ne.default;
        } }), Object.defineProperty(t, "prependToMemberExpression", { enumerable: true, get: function() {
          return Q.default;
        } }), t.react = void 0, Object.defineProperty(t, "removeComments", { enumerable: true, get: function() {
          return F.default;
        } }), Object.defineProperty(t, "removeProperties", { enumerable: true, get: function() {
          return ie.default;
        } }), Object.defineProperty(t, "removePropertiesDeep", { enumerable: true, get: function() {
          return ue.default;
        } }), Object.defineProperty(t, "removeTypeDuplicates", { enumerable: true, get: function() {
          return ge.default;
        } }), Object.defineProperty(t, "shallowEqual", { enumerable: true, get: function() {
          return me.default;
        } }), Object.defineProperty(t, "toBindingIdentifierName", { enumerable: true, get: function() {
          return U.default;
        } }), Object.defineProperty(t, "toBlock", { enumerable: true, get: function() {
          return q.default;
        } }), Object.defineProperty(t, "toComputedKey", { enumerable: true, get: function() {
          return ee.default;
        } }), Object.defineProperty(t, "toExpression", { enumerable: true, get: function() {
          return re.default;
        } }), Object.defineProperty(t, "toIdentifier", { enumerable: true, get: function() {
          return Y.default;
        } }), Object.defineProperty(t, "toKeyAlias", { enumerable: true, get: function() {
          return Z.default;
        } }), Object.defineProperty(t, "toStatement", { enumerable: true, get: function() {
          return G.default;
        } }), Object.defineProperty(t, "traverse", { enumerable: true, get: function() {
          return xe.default;
        } }), Object.defineProperty(t, "traverseFast", { enumerable: true, get: function() {
          return we.default;
        } }), Object.defineProperty(t, "validate", { enumerable: true, get: function() {
          return $e.default;
        } }), Object.defineProperty(t, "valueToNode", { enumerable: true, get: function() {
          return B.default;
        } });
        var u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/react/isReactComponent.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/react/isCompatTag.js"), e = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/react/buildChildren.js"), r = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/asserts/assertNode.js"), f = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/asserts/generated/index.js");
        Object.keys(f).forEach(function(be) {
          be !== "default" && be !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, be) || be in t && t[be] === f[be] || Object.defineProperty(t, be, { enumerable: true, get: function() {
            return f[be];
          } }));
        });
        var y = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"), S = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"), T = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"), d = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");
        Object.keys(d).forEach(function(be) {
          be !== "default" && be !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, be) || be in t && t[be] === d[be] || Object.defineProperty(t, be, { enumerable: true, get: function() {
            return d[be];
          } }));
        });
        var p = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/uppercase.js");
        Object.keys(p).forEach(function(be) {
          be !== "default" && be !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, be) || be in t && t[be] === p[be] || Object.defineProperty(t, be, { enumerable: true, get: function() {
            return p[be];
          } }));
        });
        var h = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/productions.js");
        Object.keys(h).forEach(function(be) {
          be !== "default" && be !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, be) || be in t && t[be] === h[be] || Object.defineProperty(t, be, { enumerable: true, get: function() {
            return h[be];
          } }));
        });
        var m = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneNode.js"), E = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/clone.js"), _ = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneDeep.js"), C = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"), w = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"), I = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/addComment.js"), D = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/addComments.js"), j = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritInnerComments.js"), L = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), k = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritsComments.js"), N = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), F = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/removeComments.js"), W = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/generated/index.js");
        Object.keys(W).forEach(function(be) {
          be !== "default" && be !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, be) || be in t && t[be] === W[be] || Object.defineProperty(t, be, { enumerable: true, get: function() {
            return W[be];
          } }));
        });
        var X = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js");
        Object.keys(X).forEach(function(be) {
          be !== "default" && be !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, be) || be in t && t[be] === X[be] || Object.defineProperty(t, be, { enumerable: true, get: function() {
            return X[be];
          } }));
        });
        var H = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/ensureBlock.js"), U = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"), q = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toBlock.js"), ee = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toComputedKey.js"), re = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toExpression.js"), Y = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toIdentifier.js"), Z = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toKeyAlias.js"), G = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toStatement.js"), B = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/valueToNode.js"), z = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");
        Object.keys(z).forEach(function(be) {
          be !== "default" && be !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, be) || be in t && t[be] === z[be] || Object.defineProperty(t, be, { enumerable: true, get: function() {
            return z[be];
          } }));
        });
        var M = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"), K = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/inherits.js"), Q = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"), ie = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removeProperties.js"), ue = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"), ge = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"), Te = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js"), le = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), fe = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"), Pe = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getFunctionName.js"), xe = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/traverse/traverse.js");
        Object.keys(xe).forEach(function(be) {
          be !== "default" && be !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, be) || be in t && t[be] === xe[be] || Object.defineProperty(t, be, { enumerable: true, get: function() {
            return xe[be];
          } }));
        });
        var we = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/traverse/traverseFast.js"), me = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/shallowEqual.js"), ye = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js"), pe = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isBinding.js"), J = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isBlockScoped.js"), Ee = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isImmutable.js"), Me = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isLet.js"), Ue = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isNode.js"), qe = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isNodesEquivalent.js"), He = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isPlaceholderType.js"), Ie = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isReferenced.js"), Re = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isScope.js"), Be = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isSpecifierDefault.js"), je = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isType.js"), he = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidES3Identifier.js"), oe = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), _e = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isVar.js"), Ne = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/matchesPattern.js"), $e = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/validate.js"), Xe = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"), Je = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
        Object.keys(Je).forEach(function(be) {
          be !== "default" && be !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, be) || be in t && t[be] === Je[be] || Object.defineProperty(t, be, { enumerable: true, get: function() {
            return Je[be];
          } }));
        });
        var st = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        t.react = { isReactComponent: u.default, isCompatTag: c.default, buildChildren: e.default }, t.toSequenceExpression = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/converters/toSequenceExpression.js").default, s.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c, e = false) {
          return u.object = (0, n.memberExpression)(u.object, u.property, u.computed), u.property = c, u.computed = !!e, u;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function c(e) {
          const r = Array.from(e), f = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), S = /* @__PURE__ */ new Set(), T = [];
          for (let d = 0; d < r.length; d++) {
            const p = r[d];
            if (p && !T.includes(p)) {
              if ((0, n.isAnyTypeAnnotation)(p)) return [p];
              if ((0, n.isFlowBaseAnnotation)(p)) y.set(p.type, p);
              else if ((0, n.isUnionTypeAnnotation)(p)) S.has(p.types) || (r.push(...p.types), S.add(p.types));
              else if ((0, n.isGenericTypeAnnotation)(p)) {
                const h = u(p.id);
                if (f.has(h)) {
                  let m = f.get(h);
                  m.typeParameters ? p.typeParameters && (m.typeParameters.params.push(...p.typeParameters.params), m.typeParameters.params = c(m.typeParameters.params)) : m = p.typeParameters;
                } else f.set(h, p);
              } else T.push(p);
            }
          }
          for (const [, d] of y) T.push(d);
          for (const [, d] of f) T.push(d);
          return T;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
        function u(c) {
          return (0, n.isIdentifier)(c) ? c.name : `${c.id.name}.${u(c.qualification)}`;
        }
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/inherits.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c, e) {
          if (!c || !e) return c;
          for (const r of n.INHERIT_KEYS.optional) c[r] == null && (c[r] = e[r]);
          for (const r of Object.keys(e)) r[0] === "_" && r !== "__clone" && (c[r] = e[r]);
          for (const r of n.INHERIT_KEYS.force) c[r] = e[r];
          return (0, u.default)(c, e), c;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/comments/inheritsComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c, e) {
          if ((0, u.isSuper)(c.object)) throw new Error("Cannot prepend node to super property access (`super.foo`).");
          return c.object = (0, n.memberExpression)(e, c.object), c;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removeProperties.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(e, r = {}) {
          const f = r.preserveComments ? u : c;
          for (const S of f) e[S] != null && (e[S] = void 0);
          for (const S of Object.keys(e)) S[0] === "_" && e[S] != null && (e[S] = void 0);
          const y = Object.getOwnPropertySymbols(e);
          for (const S of y) e[S] = null;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js");
        const u = ["tokens", "start", "end", "loc", "raw", "rawValue"], c = [...n.COMMENT_KEYS, "comments", ...u];
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c, e) {
          return (0, n.default)(c, u.default, e), c;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/traverse/traverseFast.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/removeProperties.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function c(e) {
          const r = Array.from(e), f = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), S = /* @__PURE__ */ new Set(), T = [];
          for (let d = 0; d < r.length; d++) {
            const p = r[d];
            if (p && !T.includes(p)) {
              if ((0, n.isTSAnyKeyword)(p)) return [p];
              if ((0, n.isTSBaseType)(p)) y.set(p.type, p);
              else if ((0, n.isTSUnionType)(p)) S.has(p.types) || (r.push(...p.types), S.add(p.types));
              else if ((0, n.isTSTypeReference)(p) && p.typeParameters) {
                const h = u(p.typeName);
                if (f.has(h)) {
                  let m = f.get(h);
                  m.typeParameters ? p.typeParameters && (m.typeParameters.params.push(...p.typeParameters.params), m.typeParameters.params = c(m.typeParameters.params)) : m = p.typeParameters;
                } else f.set(h, p);
              } else T.push(p);
            }
          }
          for (const [, d] of y) T.push(d);
          for (const [, d] of f) T.push(d);
          return T;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
        function u(c) {
          return (0, n.isIdentifier)(c) ? c.name : `${c.right.name}.${u(c.left)}`;
        }
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(l) {
          const n = [].concat(l), u = /* @__PURE__ */ Object.create(null);
          for (; n.length; ) {
            const c = n.pop();
            if (c) switch (c.type) {
              case "ArrayPattern":
                n.push(...c.elements);
                break;
              case "AssignmentExpression":
              case "AssignmentPattern":
              case "ForInStatement":
              case "ForOfStatement":
                n.push(c.left);
                break;
              case "ObjectPattern":
                n.push(...c.properties);
                break;
              case "ObjectProperty":
                n.push(c.value);
                break;
              case "RestElement":
              case "UpdateExpression":
                n.push(c.argument);
                break;
              case "UnaryExpression":
                c.operator === "delete" && n.push(c.argument);
                break;
              case "Identifier":
                u[c.name] = c;
            }
          }
          return u;
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = u;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
        function u(c, e, r, f) {
          const y = [].concat(c), S = /* @__PURE__ */ Object.create(null);
          for (; y.length; ) {
            const T = y.shift();
            if (!T || f && ((0, n.isAssignmentExpression)(T) || (0, n.isUnaryExpression)(T) || (0, n.isUpdateExpression)(T))) continue;
            if ((0, n.isIdentifier)(T)) {
              e ? (S[T.name] = S[T.name] || []).push(T) : S[T.name] = T;
              continue;
            }
            if ((0, n.isExportDeclaration)(T) && !(0, n.isExportAllDeclaration)(T)) {
              (0, n.isDeclaration)(T.declaration) && y.push(T.declaration);
              continue;
            }
            if (r) {
              if ((0, n.isFunctionDeclaration)(T)) {
                y.push(T.id);
                continue;
              }
              if ((0, n.isFunctionExpression)(T)) continue;
            }
            const d = u.keys[T.type];
            if (d) for (let p = 0; p < d.length; p++) {
              const h = T[d[p]];
              h && (Array.isArray(h) ? y.push(...h) : y.push(h));
            }
          }
          return S;
        }
        u.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ClassPrivateMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getFunctionName.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c, e) {
          if ("id" in c && c.id) return { name: c.id.name, originalNode: c.id };
          let r, f = "";
          if ((0, n.isObjectProperty)(e, { value: c }) ? r = u(e) : (0, n.isObjectMethod)(c) || (0, n.isClassMethod)(c) ? (r = u(c), c.kind === "get" ? f = "get " : c.kind === "set" && (f = "set ")) : (0, n.isVariableDeclarator)(e, { init: c }) ? r = e.id : (0, n.isAssignmentExpression)(e, { operator: "=", right: c }) && (r = e.left), !r) return null;
          const y = (0, n.isLiteral)(r) ? function(S) {
            return (0, n.isNullLiteral)(S) ? "null" : (0, n.isRegExpLiteral)(S) ? `/${S.pattern}/${S.flags}` : (0, n.isTemplateLiteral)(S) ? S.quasis.map((T) => T.value.raw).join("") : S.value !== void 0 ? String(S.value) : null;
          }(r) : (0, n.isIdentifier)(r) ? r.name : (0, n.isPrivateName)(r) ? r.id.name : null;
          return y == null ? null : { name: f + y, originalNode: r };
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
        function u(c) {
          if (!c.computed || (0, n.isLiteral)(c.key)) return c.key;
        }
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");
        t.default = function(u, c) {
          return (0, n.default)(u, c, true);
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/traverse/traverse.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c, e, r) {
          typeof e == "function" && (e = { enter: e });
          const { enter: f, exit: y } = e;
          u(c, f, y, r, []);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");
        function u(c, e, r, f, y) {
          const S = n.VISITOR_KEYS[c.type];
          if (S) {
            e && e(c, y, f);
            for (const T of S) {
              const d = c[T];
              if (Array.isArray(d)) for (let p = 0; p < d.length; p++) {
                const h = d[p];
                h && (y.push({ node: c, key: T, index: p }), u(h, e, r, f, y), y.pop());
              }
              else d && (y.push({ node: c, key: T }), u(d, e, r, f, y), y.pop());
            }
            r && r(c, y, f);
          }
        }
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/traverse/traverseFast.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function u(c, e, r) {
          if (!c) return;
          const f = n.VISITOR_KEYS[c.type];
          if (f) {
            e(c, r = r || {});
            for (const y of f) {
              const S = c[y];
              if (Array.isArray(S)) for (const T of S) u(T, e, r);
              else u(S, e, r);
            }
          }
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/deprecationWarning.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(n, u, c = "") {
          if (l.has(n)) return;
          l.add(n);
          const { internal: e, trace: r } = function(f, y) {
            const { stackTraceLimit: S, prepareStackTrace: T } = Error;
            let d;
            if (Error.stackTraceLimit = 1 + f + y, Error.prepareStackTrace = function(h, m) {
              d = m;
            }, new Error().stack, Error.stackTraceLimit = S, Error.prepareStackTrace = T, !d) return { internal: false, trace: "" };
            const p = d.slice(1 + f, 1 + f + y);
            return { internal: /[\\/]@babel[\\/]/.test(p[1].getFileName()), trace: p.map((h) => `    at ${h}`).join(`
`) };
          }(1, 2);
          e || console.warn(`${c}\`${n}\` has been deprecated, please migrate to \`${u}\`
${r}`);
        };
        const l = /* @__PURE__ */ new Set();
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/inherit.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(l, n, u) {
          n && u && (n[l] = Array.from(new Set([].concat(n[l], u[l]).filter(Boolean))));
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c, e) {
          const r = c.value.split(/\r\n|\n|\r/);
          let f = 0;
          for (let S = 0; S < r.length; S++) /[^ \t]/.exec(r[S]) && (f = S);
          let y = "";
          for (let S = 0; S < r.length; S++) {
            const T = r[S], d = S === 0, p = S === r.length - 1, h = S === f;
            let m = T.replace(/\t/g, " ");
            d || (m = m.replace(/^ +/, "")), p || (m = m.replace(/ +$/, "")), m && (h || (m += " "), y += m);
          }
          y && e.push((0, u.inherits)((0, n.stringLiteral)(y), c));
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/builders/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/shallowEqual.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(l, n) {
          const u = Object.keys(n);
          for (const c of u) if (l[c] !== n[c]) return false;
          return true;
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c) {
          const e = u.split(".");
          return (r) => (0, n.default)(r, e, c);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/matchesPattern.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.isAccessor = function(e, r) {
          return !e || e.type !== "ClassAccessorProperty" ? false : r == null || (0, n.default)(e, r);
        }, t.isAnyTypeAnnotation = function(e, r) {
          return !!e && e.type === "AnyTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isArgumentPlaceholder = function(e, r) {
          return !!e && e.type === "ArgumentPlaceholder" && (r == null || (0, n.default)(e, r));
        }, t.isArrayExpression = function(e, r) {
          return !!e && e.type === "ArrayExpression" && (r == null || (0, n.default)(e, r));
        }, t.isArrayPattern = function(e, r) {
          return !!e && e.type === "ArrayPattern" && (r == null || (0, n.default)(e, r));
        }, t.isArrayTypeAnnotation = function(e, r) {
          return !!e && e.type === "ArrayTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isArrowFunctionExpression = function(e, r) {
          return !!e && e.type === "ArrowFunctionExpression" && (r == null || (0, n.default)(e, r));
        }, t.isAssignmentExpression = function(e, r) {
          return !!e && e.type === "AssignmentExpression" && (r == null || (0, n.default)(e, r));
        }, t.isAssignmentPattern = function(e, r) {
          return !!e && e.type === "AssignmentPattern" && (r == null || (0, n.default)(e, r));
        }, t.isAwaitExpression = function(e, r) {
          return !!e && e.type === "AwaitExpression" && (r == null || (0, n.default)(e, r));
        }, t.isBigIntLiteral = function(e, r) {
          return !!e && e.type === "BigIntLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isBinary = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "BinaryExpression":
            case "LogicalExpression":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isBinaryExpression = function(e, r) {
          return !!e && e.type === "BinaryExpression" && (r == null || (0, n.default)(e, r));
        }, t.isBindExpression = function(e, r) {
          return !!e && e.type === "BindExpression" && (r == null || (0, n.default)(e, r));
        }, t.isBlock = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "BlockStatement":
            case "Program":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if (e.expectedNode === "BlockStatement") break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isBlockParent = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if (e.expectedNode === "BlockStatement") break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isBlockStatement = function(e, r) {
          return !!e && e.type === "BlockStatement" && (r == null || (0, n.default)(e, r));
        }, t.isBooleanLiteral = function(e, r) {
          return !!e && e.type === "BooleanLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isBooleanLiteralTypeAnnotation = function(e, r) {
          return !!e && e.type === "BooleanLiteralTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isBooleanTypeAnnotation = function(e, r) {
          return !!e && e.type === "BooleanTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isBreakStatement = function(e, r) {
          return !!e && e.type === "BreakStatement" && (r == null || (0, n.default)(e, r));
        }, t.isCallExpression = function(e, r) {
          return !!e && e.type === "CallExpression" && (r == null || (0, n.default)(e, r));
        }, t.isCatchClause = function(e, r) {
          return !!e && e.type === "CatchClause" && (r == null || (0, n.default)(e, r));
        }, t.isClass = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ClassExpression":
            case "ClassDeclaration":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isClassAccessorProperty = function(e, r) {
          return !!e && e.type === "ClassAccessorProperty" && (r == null || (0, n.default)(e, r));
        }, t.isClassBody = function(e, r) {
          return !!e && e.type === "ClassBody" && (r == null || (0, n.default)(e, r));
        }, t.isClassDeclaration = function(e, r) {
          return !!e && e.type === "ClassDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isClassExpression = function(e, r) {
          return !!e && e.type === "ClassExpression" && (r == null || (0, n.default)(e, r));
        }, t.isClassImplements = function(e, r) {
          return !!e && e.type === "ClassImplements" && (r == null || (0, n.default)(e, r));
        }, t.isClassMethod = function(e, r) {
          return !!e && e.type === "ClassMethod" && (r == null || (0, n.default)(e, r));
        }, t.isClassPrivateMethod = function(e, r) {
          return !!e && e.type === "ClassPrivateMethod" && (r == null || (0, n.default)(e, r));
        }, t.isClassPrivateProperty = function(e, r) {
          return !!e && e.type === "ClassPrivateProperty" && (r == null || (0, n.default)(e, r));
        }, t.isClassProperty = function(e, r) {
          return !!e && e.type === "ClassProperty" && (r == null || (0, n.default)(e, r));
        }, t.isCompletionStatement = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isConditional = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ConditionalExpression":
            case "IfStatement":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isConditionalExpression = function(e, r) {
          return !!e && e.type === "ConditionalExpression" && (r == null || (0, n.default)(e, r));
        }, t.isContinueStatement = function(e, r) {
          return !!e && e.type === "ContinueStatement" && (r == null || (0, n.default)(e, r));
        }, t.isDebuggerStatement = function(e, r) {
          return !!e && e.type === "DebuggerStatement" && (r == null || (0, n.default)(e, r));
        }, t.isDecimalLiteral = function(e, r) {
          return !!e && e.type === "DecimalLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isDeclaration = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "FunctionDeclaration":
            case "VariableDeclaration":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
              break;
            case "Placeholder":
              if (e.expectedNode === "Declaration") break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isDeclareClass = function(e, r) {
          return !!e && e.type === "DeclareClass" && (r == null || (0, n.default)(e, r));
        }, t.isDeclareExportAllDeclaration = function(e, r) {
          return !!e && e.type === "DeclareExportAllDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isDeclareExportDeclaration = function(e, r) {
          return !!e && e.type === "DeclareExportDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isDeclareFunction = function(e, r) {
          return !!e && e.type === "DeclareFunction" && (r == null || (0, n.default)(e, r));
        }, t.isDeclareInterface = function(e, r) {
          return !!e && e.type === "DeclareInterface" && (r == null || (0, n.default)(e, r));
        }, t.isDeclareModule = function(e, r) {
          return !!e && e.type === "DeclareModule" && (r == null || (0, n.default)(e, r));
        }, t.isDeclareModuleExports = function(e, r) {
          return !!e && e.type === "DeclareModuleExports" && (r == null || (0, n.default)(e, r));
        }, t.isDeclareOpaqueType = function(e, r) {
          return !!e && e.type === "DeclareOpaqueType" && (r == null || (0, n.default)(e, r));
        }, t.isDeclareTypeAlias = function(e, r) {
          return !!e && e.type === "DeclareTypeAlias" && (r == null || (0, n.default)(e, r));
        }, t.isDeclareVariable = function(e, r) {
          return !!e && e.type === "DeclareVariable" && (r == null || (0, n.default)(e, r));
        }, t.isDeclaredPredicate = function(e, r) {
          return !!e && e.type === "DeclaredPredicate" && (r == null || (0, n.default)(e, r));
        }, t.isDecorator = function(e, r) {
          return !!e && e.type === "Decorator" && (r == null || (0, n.default)(e, r));
        }, t.isDirective = function(e, r) {
          return !!e && e.type === "Directive" && (r == null || (0, n.default)(e, r));
        }, t.isDirectiveLiteral = function(e, r) {
          return !!e && e.type === "DirectiveLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isDoExpression = function(e, r) {
          return !!e && e.type === "DoExpression" && (r == null || (0, n.default)(e, r));
        }, t.isDoWhileStatement = function(e, r) {
          return !!e && e.type === "DoWhileStatement" && (r == null || (0, n.default)(e, r));
        }, t.isEmptyStatement = function(e, r) {
          return !!e && e.type === "EmptyStatement" && (r == null || (0, n.default)(e, r));
        }, t.isEmptyTypeAnnotation = function(e, r) {
          return !!e && e.type === "EmptyTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isEnumBody = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isEnumBooleanBody = function(e, r) {
          return !!e && e.type === "EnumBooleanBody" && (r == null || (0, n.default)(e, r));
        }, t.isEnumBooleanMember = function(e, r) {
          return !!e && e.type === "EnumBooleanMember" && (r == null || (0, n.default)(e, r));
        }, t.isEnumDeclaration = function(e, r) {
          return !!e && e.type === "EnumDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isEnumDefaultedMember = function(e, r) {
          return !!e && e.type === "EnumDefaultedMember" && (r == null || (0, n.default)(e, r));
        }, t.isEnumMember = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isEnumNumberBody = function(e, r) {
          return !!e && e.type === "EnumNumberBody" && (r == null || (0, n.default)(e, r));
        }, t.isEnumNumberMember = function(e, r) {
          return !!e && e.type === "EnumNumberMember" && (r == null || (0, n.default)(e, r));
        }, t.isEnumStringBody = function(e, r) {
          return !!e && e.type === "EnumStringBody" && (r == null || (0, n.default)(e, r));
        }, t.isEnumStringMember = function(e, r) {
          return !!e && e.type === "EnumStringMember" && (r == null || (0, n.default)(e, r));
        }, t.isEnumSymbolBody = function(e, r) {
          return !!e && e.type === "EnumSymbolBody" && (r == null || (0, n.default)(e, r));
        }, t.isExistsTypeAnnotation = function(e, r) {
          return !!e && e.type === "ExistsTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isExportAllDeclaration = function(e, r) {
          return !!e && e.type === "ExportAllDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isExportDeclaration = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isExportDefaultDeclaration = function(e, r) {
          return !!e && e.type === "ExportDefaultDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isExportDefaultSpecifier = function(e, r) {
          return !!e && e.type === "ExportDefaultSpecifier" && (r == null || (0, n.default)(e, r));
        }, t.isExportNamedDeclaration = function(e, r) {
          return !!e && e.type === "ExportNamedDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isExportNamespaceSpecifier = function(e, r) {
          return !!e && e.type === "ExportNamespaceSpecifier" && (r == null || (0, n.default)(e, r));
        }, t.isExportSpecifier = function(e, r) {
          return !!e && e.type === "ExportSpecifier" && (r == null || (0, n.default)(e, r));
        }, t.isExpression = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "CallExpression":
            case "ConditionalExpression":
            case "FunctionExpression":
            case "Identifier":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "ObjectExpression":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "ThisExpression":
            case "UnaryExpression":
            case "UpdateExpression":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "ImportExpression":
            case "MetaProperty":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "TypeCastExpression":
            case "JSXElement":
            case "JSXFragment":
            case "BindExpression":
            case "DoExpression":
            case "RecordExpression":
            case "TupleExpression":
            case "DecimalLiteral":
            case "ModuleExpression":
            case "TopicReference":
            case "PipelineTopicExpression":
            case "PipelineBareFunction":
            case "PipelinePrimaryTopicReference":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (e.expectedNode) {
                case "Expression":
                case "Identifier":
                case "StringLiteral":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isExpressionStatement = function(e, r) {
          return !!e && e.type === "ExpressionStatement" && (r == null || (0, n.default)(e, r));
        }, t.isExpressionWrapper = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ExpressionStatement":
            case "ParenthesizedExpression":
            case "TypeCastExpression":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isFile = function(e, r) {
          return !!e && e.type === "File" && (r == null || (0, n.default)(e, r));
        }, t.isFlow = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ClassImplements":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "DeclaredPredicate":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "FunctionTypeParam":
            case "GenericTypeAnnotation":
            case "InferredPredicate":
            case "InterfaceExtends":
            case "InterfaceDeclaration":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
            case "OpaqueType":
            case "QualifiedTypeIdentifier":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "TypeAlias":
            case "TypeAnnotation":
            case "TypeCastExpression":
            case "TypeParameter":
            case "TypeParameterDeclaration":
            case "TypeParameterInstantiation":
            case "UnionTypeAnnotation":
            case "Variance":
            case "VoidTypeAnnotation":
            case "EnumDeclaration":
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isFlowBaseAnnotation = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "AnyTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NumberTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "VoidTypeAnnotation":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isFlowDeclaration = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isFlowPredicate = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "DeclaredPredicate":
            case "InferredPredicate":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isFlowType = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "GenericTypeAnnotation":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "UnionTypeAnnotation":
            case "VoidTypeAnnotation":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isFor = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ForInStatement":
            case "ForStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isForInStatement = function(e, r) {
          return !!e && e.type === "ForInStatement" && (r == null || (0, n.default)(e, r));
        }, t.isForOfStatement = function(e, r) {
          return !!e && e.type === "ForOfStatement" && (r == null || (0, n.default)(e, r));
        }, t.isForStatement = function(e, r) {
          return !!e && e.type === "ForStatement" && (r == null || (0, n.default)(e, r));
        }, t.isForXStatement = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ForInStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isFunction = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isFunctionDeclaration = function(e, r) {
          return !!e && e.type === "FunctionDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isFunctionExpression = function(e, r) {
          return !!e && e.type === "FunctionExpression" && (r == null || (0, n.default)(e, r));
        }, t.isFunctionParent = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isFunctionTypeAnnotation = function(e, r) {
          return !!e && e.type === "FunctionTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isFunctionTypeParam = function(e, r) {
          return !!e && e.type === "FunctionTypeParam" && (r == null || (0, n.default)(e, r));
        }, t.isGenericTypeAnnotation = function(e, r) {
          return !!e && e.type === "GenericTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isIdentifier = function(e, r) {
          return !!e && e.type === "Identifier" && (r == null || (0, n.default)(e, r));
        }, t.isIfStatement = function(e, r) {
          return !!e && e.type === "IfStatement" && (r == null || (0, n.default)(e, r));
        }, t.isImmutable = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "BigIntLiteral":
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXOpeningElement":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if (e.expectedNode === "StringLiteral") break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isImport = function(e, r) {
          return !!e && e.type === "Import" && (r == null || (0, n.default)(e, r));
        }, t.isImportAttribute = function(e, r) {
          return !!e && e.type === "ImportAttribute" && (r == null || (0, n.default)(e, r));
        }, t.isImportDeclaration = function(e, r) {
          return !!e && e.type === "ImportDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isImportDefaultSpecifier = function(e, r) {
          return !!e && e.type === "ImportDefaultSpecifier" && (r == null || (0, n.default)(e, r));
        }, t.isImportExpression = function(e, r) {
          return !!e && e.type === "ImportExpression" && (r == null || (0, n.default)(e, r));
        }, t.isImportNamespaceSpecifier = function(e, r) {
          return !!e && e.type === "ImportNamespaceSpecifier" && (r == null || (0, n.default)(e, r));
        }, t.isImportOrExportDeclaration = c, t.isImportSpecifier = function(e, r) {
          return !!e && e.type === "ImportSpecifier" && (r == null || (0, n.default)(e, r));
        }, t.isIndexedAccessType = function(e, r) {
          return !!e && e.type === "IndexedAccessType" && (r == null || (0, n.default)(e, r));
        }, t.isInferredPredicate = function(e, r) {
          return !!e && e.type === "InferredPredicate" && (r == null || (0, n.default)(e, r));
        }, t.isInterfaceDeclaration = function(e, r) {
          return !!e && e.type === "InterfaceDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isInterfaceExtends = function(e, r) {
          return !!e && e.type === "InterfaceExtends" && (r == null || (0, n.default)(e, r));
        }, t.isInterfaceTypeAnnotation = function(e, r) {
          return !!e && e.type === "InterfaceTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isInterpreterDirective = function(e, r) {
          return !!e && e.type === "InterpreterDirective" && (r == null || (0, n.default)(e, r));
        }, t.isIntersectionTypeAnnotation = function(e, r) {
          return !!e && e.type === "IntersectionTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isJSX = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXEmptyExpression":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXIdentifier":
            case "JSXMemberExpression":
            case "JSXNamespacedName":
            case "JSXOpeningElement":
            case "JSXSpreadAttribute":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isJSXAttribute = function(e, r) {
          return !!e && e.type === "JSXAttribute" && (r == null || (0, n.default)(e, r));
        }, t.isJSXClosingElement = function(e, r) {
          return !!e && e.type === "JSXClosingElement" && (r == null || (0, n.default)(e, r));
        }, t.isJSXClosingFragment = function(e, r) {
          return !!e && e.type === "JSXClosingFragment" && (r == null || (0, n.default)(e, r));
        }, t.isJSXElement = function(e, r) {
          return !!e && e.type === "JSXElement" && (r == null || (0, n.default)(e, r));
        }, t.isJSXEmptyExpression = function(e, r) {
          return !!e && e.type === "JSXEmptyExpression" && (r == null || (0, n.default)(e, r));
        }, t.isJSXExpressionContainer = function(e, r) {
          return !!e && e.type === "JSXExpressionContainer" && (r == null || (0, n.default)(e, r));
        }, t.isJSXFragment = function(e, r) {
          return !!e && e.type === "JSXFragment" && (r == null || (0, n.default)(e, r));
        }, t.isJSXIdentifier = function(e, r) {
          return !!e && e.type === "JSXIdentifier" && (r == null || (0, n.default)(e, r));
        }, t.isJSXMemberExpression = function(e, r) {
          return !!e && e.type === "JSXMemberExpression" && (r == null || (0, n.default)(e, r));
        }, t.isJSXNamespacedName = function(e, r) {
          return !!e && e.type === "JSXNamespacedName" && (r == null || (0, n.default)(e, r));
        }, t.isJSXOpeningElement = function(e, r) {
          return !!e && e.type === "JSXOpeningElement" && (r == null || (0, n.default)(e, r));
        }, t.isJSXOpeningFragment = function(e, r) {
          return !!e && e.type === "JSXOpeningFragment" && (r == null || (0, n.default)(e, r));
        }, t.isJSXSpreadAttribute = function(e, r) {
          return !!e && e.type === "JSXSpreadAttribute" && (r == null || (0, n.default)(e, r));
        }, t.isJSXSpreadChild = function(e, r) {
          return !!e && e.type === "JSXSpreadChild" && (r == null || (0, n.default)(e, r));
        }, t.isJSXText = function(e, r) {
          return !!e && e.type === "JSXText" && (r == null || (0, n.default)(e, r));
        }, t.isLVal = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "Identifier":
            case "MemberExpression":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSParameterProperty":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (e.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isLabeledStatement = function(e, r) {
          return !!e && e.type === "LabeledStatement" && (r == null || (0, n.default)(e, r));
        }, t.isLiteral = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "TemplateLiteral":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if (e.expectedNode === "StringLiteral") break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isLogicalExpression = function(e, r) {
          return !!e && e.type === "LogicalExpression" && (r == null || (0, n.default)(e, r));
        }, t.isLoop = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "WhileStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isMemberExpression = function(e, r) {
          return !!e && e.type === "MemberExpression" && (r == null || (0, n.default)(e, r));
        }, t.isMetaProperty = function(e, r) {
          return !!e && e.type === "MetaProperty" && (r == null || (0, n.default)(e, r));
        }, t.isMethod = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isMiscellaneous = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "Noop":
            case "Placeholder":
            case "V8IntrinsicIdentifier":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isMixedTypeAnnotation = function(e, r) {
          return !!e && e.type === "MixedTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isModuleDeclaration = function(e, r) {
          return (0, u.default)("isModuleDeclaration", "isImportOrExportDeclaration"), c(e, r);
        }, t.isModuleExpression = function(e, r) {
          return !!e && e.type === "ModuleExpression" && (r == null || (0, n.default)(e, r));
        }, t.isModuleSpecifier = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ExportSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isNewExpression = function(e, r) {
          return !!e && e.type === "NewExpression" && (r == null || (0, n.default)(e, r));
        }, t.isNoop = function(e, r) {
          return !!e && e.type === "Noop" && (r == null || (0, n.default)(e, r));
        }, t.isNullLiteral = function(e, r) {
          return !!e && e.type === "NullLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isNullLiteralTypeAnnotation = function(e, r) {
          return !!e && e.type === "NullLiteralTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isNullableTypeAnnotation = function(e, r) {
          return !!e && e.type === "NullableTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isNumberLiteral = function(e, r) {
          return (0, u.default)("isNumberLiteral", "isNumericLiteral"), !!e && e.type === "NumberLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isNumberLiteralTypeAnnotation = function(e, r) {
          return !!e && e.type === "NumberLiteralTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isNumberTypeAnnotation = function(e, r) {
          return !!e && e.type === "NumberTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isNumericLiteral = function(e, r) {
          return !!e && e.type === "NumericLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isObjectExpression = function(e, r) {
          return !!e && e.type === "ObjectExpression" && (r == null || (0, n.default)(e, r));
        }, t.isObjectMember = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ObjectMethod":
            case "ObjectProperty":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isObjectMethod = function(e, r) {
          return !!e && e.type === "ObjectMethod" && (r == null || (0, n.default)(e, r));
        }, t.isObjectPattern = function(e, r) {
          return !!e && e.type === "ObjectPattern" && (r == null || (0, n.default)(e, r));
        }, t.isObjectProperty = function(e, r) {
          return !!e && e.type === "ObjectProperty" && (r == null || (0, n.default)(e, r));
        }, t.isObjectTypeAnnotation = function(e, r) {
          return !!e && e.type === "ObjectTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isObjectTypeCallProperty = function(e, r) {
          return !!e && e.type === "ObjectTypeCallProperty" && (r == null || (0, n.default)(e, r));
        }, t.isObjectTypeIndexer = function(e, r) {
          return !!e && e.type === "ObjectTypeIndexer" && (r == null || (0, n.default)(e, r));
        }, t.isObjectTypeInternalSlot = function(e, r) {
          return !!e && e.type === "ObjectTypeInternalSlot" && (r == null || (0, n.default)(e, r));
        }, t.isObjectTypeProperty = function(e, r) {
          return !!e && e.type === "ObjectTypeProperty" && (r == null || (0, n.default)(e, r));
        }, t.isObjectTypeSpreadProperty = function(e, r) {
          return !!e && e.type === "ObjectTypeSpreadProperty" && (r == null || (0, n.default)(e, r));
        }, t.isOpaqueType = function(e, r) {
          return !!e && e.type === "OpaqueType" && (r == null || (0, n.default)(e, r));
        }, t.isOptionalCallExpression = function(e, r) {
          return !!e && e.type === "OptionalCallExpression" && (r == null || (0, n.default)(e, r));
        }, t.isOptionalIndexedAccessType = function(e, r) {
          return !!e && e.type === "OptionalIndexedAccessType" && (r == null || (0, n.default)(e, r));
        }, t.isOptionalMemberExpression = function(e, r) {
          return !!e && e.type === "OptionalMemberExpression" && (r == null || (0, n.default)(e, r));
        }, t.isParenthesizedExpression = function(e, r) {
          return !!e && e.type === "ParenthesizedExpression" && (r == null || (0, n.default)(e, r));
        }, t.isPattern = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
              break;
            case "Placeholder":
              if (e.expectedNode === "Pattern") break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isPatternLike = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "Identifier":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (e.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isPipelineBareFunction = function(e, r) {
          return !!e && e.type === "PipelineBareFunction" && (r == null || (0, n.default)(e, r));
        }, t.isPipelinePrimaryTopicReference = function(e, r) {
          return !!e && e.type === "PipelinePrimaryTopicReference" && (r == null || (0, n.default)(e, r));
        }, t.isPipelineTopicExpression = function(e, r) {
          return !!e && e.type === "PipelineTopicExpression" && (r == null || (0, n.default)(e, r));
        }, t.isPlaceholder = function(e, r) {
          return !!e && e.type === "Placeholder" && (r == null || (0, n.default)(e, r));
        }, t.isPrivate = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isPrivateName = function(e, r) {
          return !!e && e.type === "PrivateName" && (r == null || (0, n.default)(e, r));
        }, t.isProgram = function(e, r) {
          return !!e && e.type === "Program" && (r == null || (0, n.default)(e, r));
        }, t.isProperty = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ObjectProperty":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isPureish = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "ArrowFunctionExpression":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if (e.expectedNode === "StringLiteral") break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isQualifiedTypeIdentifier = function(e, r) {
          return !!e && e.type === "QualifiedTypeIdentifier" && (r == null || (0, n.default)(e, r));
        }, t.isRecordExpression = function(e, r) {
          return !!e && e.type === "RecordExpression" && (r == null || (0, n.default)(e, r));
        }, t.isRegExpLiteral = function(e, r) {
          return !!e && e.type === "RegExpLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isRegexLiteral = function(e, r) {
          return (0, u.default)("isRegexLiteral", "isRegExpLiteral"), !!e && e.type === "RegexLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isRestElement = function(e, r) {
          return !!e && e.type === "RestElement" && (r == null || (0, n.default)(e, r));
        }, t.isRestProperty = function(e, r) {
          return (0, u.default)("isRestProperty", "isRestElement"), !!e && e.type === "RestProperty" && (r == null || (0, n.default)(e, r));
        }, t.isReturnStatement = function(e, r) {
          return !!e && e.type === "ReturnStatement" && (r == null || (0, n.default)(e, r));
        }, t.isScopable = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if (e.expectedNode === "BlockStatement") break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isSequenceExpression = function(e, r) {
          return !!e && e.type === "SequenceExpression" && (r == null || (0, n.default)(e, r));
        }, t.isSpreadElement = function(e, r) {
          return !!e && e.type === "SpreadElement" && (r == null || (0, n.default)(e, r));
        }, t.isSpreadProperty = function(e, r) {
          return (0, u.default)("isSpreadProperty", "isSpreadElement"), !!e && e.type === "SpreadProperty" && (r == null || (0, n.default)(e, r));
        }, t.isStandardized = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "InterpreterDirective":
            case "Directive":
            case "DirectiveLiteral":
            case "BlockStatement":
            case "BreakStatement":
            case "CallExpression":
            case "CatchClause":
            case "ConditionalExpression":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "File":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Identifier":
            case "IfStatement":
            case "LabeledStatement":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "Program":
            case "ObjectExpression":
            case "ObjectMethod":
            case "ObjectProperty":
            case "RestElement":
            case "ReturnStatement":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "SwitchCase":
            case "SwitchStatement":
            case "ThisExpression":
            case "ThrowStatement":
            case "TryStatement":
            case "UnaryExpression":
            case "UpdateExpression":
            case "VariableDeclaration":
            case "VariableDeclarator":
            case "WhileStatement":
            case "WithStatement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ArrowFunctionExpression":
            case "ClassBody":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ExportSpecifier":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportExpression":
            case "MetaProperty":
            case "ClassMethod":
            case "ObjectPattern":
            case "SpreadElement":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateElement":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "ExportNamespaceSpecifier":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
            case "StaticBlock":
              break;
            case "Placeholder":
              switch (e.expectedNode) {
                case "Identifier":
                case "StringLiteral":
                case "BlockStatement":
                case "ClassBody":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isStatement = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "BlockStatement":
            case "BreakStatement":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "IfStatement":
            case "LabeledStatement":
            case "ReturnStatement":
            case "SwitchStatement":
            case "ThrowStatement":
            case "TryStatement":
            case "VariableDeclaration":
            case "WhileStatement":
            case "WithStatement":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
            case "TSImportEqualsDeclaration":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
              break;
            case "Placeholder":
              switch (e.expectedNode) {
                case "Statement":
                case "Declaration":
                case "BlockStatement":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isStaticBlock = function(e, r) {
          return !!e && e.type === "StaticBlock" && (r == null || (0, n.default)(e, r));
        }, t.isStringLiteral = function(e, r) {
          return !!e && e.type === "StringLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isStringLiteralTypeAnnotation = function(e, r) {
          return !!e && e.type === "StringLiteralTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isStringTypeAnnotation = function(e, r) {
          return !!e && e.type === "StringTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isSuper = function(e, r) {
          return !!e && e.type === "Super" && (r == null || (0, n.default)(e, r));
        }, t.isSwitchCase = function(e, r) {
          return !!e && e.type === "SwitchCase" && (r == null || (0, n.default)(e, r));
        }, t.isSwitchStatement = function(e, r) {
          return !!e && e.type === "SwitchStatement" && (r == null || (0, n.default)(e, r));
        }, t.isSymbolTypeAnnotation = function(e, r) {
          return !!e && e.type === "SymbolTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isTSAnyKeyword = function(e, r) {
          return !!e && e.type === "TSAnyKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSArrayType = function(e, r) {
          return !!e && e.type === "TSArrayType" && (r == null || (0, n.default)(e, r));
        }, t.isTSAsExpression = function(e, r) {
          return !!e && e.type === "TSAsExpression" && (r == null || (0, n.default)(e, r));
        }, t.isTSBaseType = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSLiteralType":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isTSBigIntKeyword = function(e, r) {
          return !!e && e.type === "TSBigIntKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSBooleanKeyword = function(e, r) {
          return !!e && e.type === "TSBooleanKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSCallSignatureDeclaration = function(e, r) {
          return !!e && e.type === "TSCallSignatureDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isTSConditionalType = function(e, r) {
          return !!e && e.type === "TSConditionalType" && (r == null || (0, n.default)(e, r));
        }, t.isTSConstructSignatureDeclaration = function(e, r) {
          return !!e && e.type === "TSConstructSignatureDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isTSConstructorType = function(e, r) {
          return !!e && e.type === "TSConstructorType" && (r == null || (0, n.default)(e, r));
        }, t.isTSDeclareFunction = function(e, r) {
          return !!e && e.type === "TSDeclareFunction" && (r == null || (0, n.default)(e, r));
        }, t.isTSDeclareMethod = function(e, r) {
          return !!e && e.type === "TSDeclareMethod" && (r == null || (0, n.default)(e, r));
        }, t.isTSEntityName = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "Identifier":
            case "TSQualifiedName":
              break;
            case "Placeholder":
              if (e.expectedNode === "Identifier") break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isTSEnumDeclaration = function(e, r) {
          return !!e && e.type === "TSEnumDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isTSEnumMember = function(e, r) {
          return !!e && e.type === "TSEnumMember" && (r == null || (0, n.default)(e, r));
        }, t.isTSExportAssignment = function(e, r) {
          return !!e && e.type === "TSExportAssignment" && (r == null || (0, n.default)(e, r));
        }, t.isTSExpressionWithTypeArguments = function(e, r) {
          return !!e && e.type === "TSExpressionWithTypeArguments" && (r == null || (0, n.default)(e, r));
        }, t.isTSExternalModuleReference = function(e, r) {
          return !!e && e.type === "TSExternalModuleReference" && (r == null || (0, n.default)(e, r));
        }, t.isTSFunctionType = function(e, r) {
          return !!e && e.type === "TSFunctionType" && (r == null || (0, n.default)(e, r));
        }, t.isTSImportEqualsDeclaration = function(e, r) {
          return !!e && e.type === "TSImportEqualsDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isTSImportType = function(e, r) {
          return !!e && e.type === "TSImportType" && (r == null || (0, n.default)(e, r));
        }, t.isTSIndexSignature = function(e, r) {
          return !!e && e.type === "TSIndexSignature" && (r == null || (0, n.default)(e, r));
        }, t.isTSIndexedAccessType = function(e, r) {
          return !!e && e.type === "TSIndexedAccessType" && (r == null || (0, n.default)(e, r));
        }, t.isTSInferType = function(e, r) {
          return !!e && e.type === "TSInferType" && (r == null || (0, n.default)(e, r));
        }, t.isTSInstantiationExpression = function(e, r) {
          return !!e && e.type === "TSInstantiationExpression" && (r == null || (0, n.default)(e, r));
        }, t.isTSInterfaceBody = function(e, r) {
          return !!e && e.type === "TSInterfaceBody" && (r == null || (0, n.default)(e, r));
        }, t.isTSInterfaceDeclaration = function(e, r) {
          return !!e && e.type === "TSInterfaceDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isTSIntersectionType = function(e, r) {
          return !!e && e.type === "TSIntersectionType" && (r == null || (0, n.default)(e, r));
        }, t.isTSIntrinsicKeyword = function(e, r) {
          return !!e && e.type === "TSIntrinsicKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSLiteralType = function(e, r) {
          return !!e && e.type === "TSLiteralType" && (r == null || (0, n.default)(e, r));
        }, t.isTSMappedType = function(e, r) {
          return !!e && e.type === "TSMappedType" && (r == null || (0, n.default)(e, r));
        }, t.isTSMethodSignature = function(e, r) {
          return !!e && e.type === "TSMethodSignature" && (r == null || (0, n.default)(e, r));
        }, t.isTSModuleBlock = function(e, r) {
          return !!e && e.type === "TSModuleBlock" && (r == null || (0, n.default)(e, r));
        }, t.isTSModuleDeclaration = function(e, r) {
          return !!e && e.type === "TSModuleDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isTSNamedTupleMember = function(e, r) {
          return !!e && e.type === "TSNamedTupleMember" && (r == null || (0, n.default)(e, r));
        }, t.isTSNamespaceExportDeclaration = function(e, r) {
          return !!e && e.type === "TSNamespaceExportDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isTSNeverKeyword = function(e, r) {
          return !!e && e.type === "TSNeverKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSNonNullExpression = function(e, r) {
          return !!e && e.type === "TSNonNullExpression" && (r == null || (0, n.default)(e, r));
        }, t.isTSNullKeyword = function(e, r) {
          return !!e && e.type === "TSNullKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSNumberKeyword = function(e, r) {
          return !!e && e.type === "TSNumberKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSObjectKeyword = function(e, r) {
          return !!e && e.type === "TSObjectKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSOptionalType = function(e, r) {
          return !!e && e.type === "TSOptionalType" && (r == null || (0, n.default)(e, r));
        }, t.isTSParameterProperty = function(e, r) {
          return !!e && e.type === "TSParameterProperty" && (r == null || (0, n.default)(e, r));
        }, t.isTSParenthesizedType = function(e, r) {
          return !!e && e.type === "TSParenthesizedType" && (r == null || (0, n.default)(e, r));
        }, t.isTSPropertySignature = function(e, r) {
          return !!e && e.type === "TSPropertySignature" && (r == null || (0, n.default)(e, r));
        }, t.isTSQualifiedName = function(e, r) {
          return !!e && e.type === "TSQualifiedName" && (r == null || (0, n.default)(e, r));
        }, t.isTSRestType = function(e, r) {
          return !!e && e.type === "TSRestType" && (r == null || (0, n.default)(e, r));
        }, t.isTSSatisfiesExpression = function(e, r) {
          return !!e && e.type === "TSSatisfiesExpression" && (r == null || (0, n.default)(e, r));
        }, t.isTSStringKeyword = function(e, r) {
          return !!e && e.type === "TSStringKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSSymbolKeyword = function(e, r) {
          return !!e && e.type === "TSSymbolKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSThisType = function(e, r) {
          return !!e && e.type === "TSThisType" && (r == null || (0, n.default)(e, r));
        }, t.isTSTupleType = function(e, r) {
          return !!e && e.type === "TSTupleType" && (r == null || (0, n.default)(e, r));
        }, t.isTSType = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSImportType":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isTSTypeAliasDeclaration = function(e, r) {
          return !!e && e.type === "TSTypeAliasDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isTSTypeAnnotation = function(e, r) {
          return !!e && e.type === "TSTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isTSTypeAssertion = function(e, r) {
          return !!e && e.type === "TSTypeAssertion" && (r == null || (0, n.default)(e, r));
        }, t.isTSTypeElement = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isTSTypeLiteral = function(e, r) {
          return !!e && e.type === "TSTypeLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isTSTypeOperator = function(e, r) {
          return !!e && e.type === "TSTypeOperator" && (r == null || (0, n.default)(e, r));
        }, t.isTSTypeParameter = function(e, r) {
          return !!e && e.type === "TSTypeParameter" && (r == null || (0, n.default)(e, r));
        }, t.isTSTypeParameterDeclaration = function(e, r) {
          return !!e && e.type === "TSTypeParameterDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isTSTypeParameterInstantiation = function(e, r) {
          return !!e && e.type === "TSTypeParameterInstantiation" && (r == null || (0, n.default)(e, r));
        }, t.isTSTypePredicate = function(e, r) {
          return !!e && e.type === "TSTypePredicate" && (r == null || (0, n.default)(e, r));
        }, t.isTSTypeQuery = function(e, r) {
          return !!e && e.type === "TSTypeQuery" && (r == null || (0, n.default)(e, r));
        }, t.isTSTypeReference = function(e, r) {
          return !!e && e.type === "TSTypeReference" && (r == null || (0, n.default)(e, r));
        }, t.isTSUndefinedKeyword = function(e, r) {
          return !!e && e.type === "TSUndefinedKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSUnionType = function(e, r) {
          return !!e && e.type === "TSUnionType" && (r == null || (0, n.default)(e, r));
        }, t.isTSUnknownKeyword = function(e, r) {
          return !!e && e.type === "TSUnknownKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTSVoidKeyword = function(e, r) {
          return !!e && e.type === "TSVoidKeyword" && (r == null || (0, n.default)(e, r));
        }, t.isTaggedTemplateExpression = function(e, r) {
          return !!e && e.type === "TaggedTemplateExpression" && (r == null || (0, n.default)(e, r));
        }, t.isTemplateElement = function(e, r) {
          return !!e && e.type === "TemplateElement" && (r == null || (0, n.default)(e, r));
        }, t.isTemplateLiteral = function(e, r) {
          return !!e && e.type === "TemplateLiteral" && (r == null || (0, n.default)(e, r));
        }, t.isTerminatorless = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
            case "YieldExpression":
            case "AwaitExpression":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isThisExpression = function(e, r) {
          return !!e && e.type === "ThisExpression" && (r == null || (0, n.default)(e, r));
        }, t.isThisTypeAnnotation = function(e, r) {
          return !!e && e.type === "ThisTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isThrowStatement = function(e, r) {
          return !!e && e.type === "ThrowStatement" && (r == null || (0, n.default)(e, r));
        }, t.isTopicReference = function(e, r) {
          return !!e && e.type === "TopicReference" && (r == null || (0, n.default)(e, r));
        }, t.isTryStatement = function(e, r) {
          return !!e && e.type === "TryStatement" && (r == null || (0, n.default)(e, r));
        }, t.isTupleExpression = function(e, r) {
          return !!e && e.type === "TupleExpression" && (r == null || (0, n.default)(e, r));
        }, t.isTupleTypeAnnotation = function(e, r) {
          return !!e && e.type === "TupleTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isTypeAlias = function(e, r) {
          return !!e && e.type === "TypeAlias" && (r == null || (0, n.default)(e, r));
        }, t.isTypeAnnotation = function(e, r) {
          return !!e && e.type === "TypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isTypeCastExpression = function(e, r) {
          return !!e && e.type === "TypeCastExpression" && (r == null || (0, n.default)(e, r));
        }, t.isTypeParameter = function(e, r) {
          return !!e && e.type === "TypeParameter" && (r == null || (0, n.default)(e, r));
        }, t.isTypeParameterDeclaration = function(e, r) {
          return !!e && e.type === "TypeParameterDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isTypeParameterInstantiation = function(e, r) {
          return !!e && e.type === "TypeParameterInstantiation" && (r == null || (0, n.default)(e, r));
        }, t.isTypeScript = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "TSParameterProperty":
            case "TSDeclareFunction":
            case "TSDeclareMethod":
            case "TSQualifiedName":
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSNamedTupleMember":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSInterfaceDeclaration":
            case "TSInterfaceBody":
            case "TSTypeAliasDeclaration":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSEnumDeclaration":
            case "TSEnumMember":
            case "TSModuleDeclaration":
            case "TSModuleBlock":
            case "TSImportType":
            case "TSImportEqualsDeclaration":
            case "TSExternalModuleReference":
            case "TSNonNullExpression":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
            case "TSTypeAnnotation":
            case "TSTypeParameterInstantiation":
            case "TSTypeParameterDeclaration":
            case "TSTypeParameter":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isTypeofTypeAnnotation = function(e, r) {
          return !!e && e.type === "TypeofTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isUnaryExpression = function(e, r) {
          return !!e && e.type === "UnaryExpression" && (r == null || (0, n.default)(e, r));
        }, t.isUnaryLike = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "UnaryExpression":
            case "SpreadElement":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isUnionTypeAnnotation = function(e, r) {
          return !!e && e.type === "UnionTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isUpdateExpression = function(e, r) {
          return !!e && e.type === "UpdateExpression" && (r == null || (0, n.default)(e, r));
        }, t.isUserWhitespacable = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ObjectMethod":
            case "ObjectProperty":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isV8IntrinsicIdentifier = function(e, r) {
          return !!e && e.type === "V8IntrinsicIdentifier" && (r == null || (0, n.default)(e, r));
        }, t.isVariableDeclaration = function(e, r) {
          return !!e && e.type === "VariableDeclaration" && (r == null || (0, n.default)(e, r));
        }, t.isVariableDeclarator = function(e, r) {
          return !!e && e.type === "VariableDeclarator" && (r == null || (0, n.default)(e, r));
        }, t.isVariance = function(e, r) {
          return !!e && e.type === "Variance" && (r == null || (0, n.default)(e, r));
        }, t.isVoidTypeAnnotation = function(e, r) {
          return !!e && e.type === "VoidTypeAnnotation" && (r == null || (0, n.default)(e, r));
        }, t.isWhile = function(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "DoWhileStatement":
            case "WhileStatement":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }, t.isWhileStatement = function(e, r) {
          return !!e && e.type === "WhileStatement" && (r == null || (0, n.default)(e, r));
        }, t.isWithStatement = function(e, r) {
          return !!e && e.type === "WithStatement" && (r == null || (0, n.default)(e, r));
        }, t.isYieldExpression = function(e, r) {
          return !!e && e.type === "YieldExpression" && (r == null || (0, n.default)(e, r));
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/shallowEqual.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function c(e, r) {
          if (!e) return false;
          switch (e.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              break;
            default:
              return false;
          }
          return r == null || (0, n.default)(e, r);
        }
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/is.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(r, f, y) {
          return f ? (0, u.default)(f.type, r) ? y === void 0 || (0, n.default)(f, y) : !y && f.type === "Placeholder" && r in e.FLIPPED_ALIAS_KEYS && (0, c.default)(f.expectedNode, r) : false;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/utils/shallowEqual.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isType.js"), c = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isPlaceholderType.js"), e = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isBinding.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c, e) {
          if (e && u.type === "Identifier" && c.type === "ObjectProperty" && e.type === "ObjectExpression") return false;
          const r = n.default.keys[c.type];
          if (r) for (let f = 0; f < r.length; f++) {
            const y = c[r[f]];
            if (Array.isArray(y)) {
              if (y.includes(u)) return true;
            } else if (y === u) return true;
          }
          return false;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isBlockScoped.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c) {
          return (0, n.isFunctionDeclaration)(c) || (0, n.isClassDeclaration)(c) || (0, u.default)(c);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isLet.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isImmutable.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c) {
          return (0, n.default)(c.type, "Immutable") ? true : (0, u.isIdentifier)(c) ? c.name === "undefined" : false;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isType.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isLet.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c) {
          return (0, n.isVariableDeclaration)(c) && (c.kind !== "var" || c[u.BLOCK_SCOPED_SYMBOL]);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isNode.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          return !(!u || !n.VISITOR_KEYS[u.type]);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isNodesEquivalent.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function u(c, e) {
          if (typeof c != "object" || typeof e != "object" || c == null || e == null) return c === e;
          if (c.type !== e.type) return false;
          const r = Object.keys(n.NODE_FIELDS[c.type] || c.type), f = n.VISITOR_KEYS[c.type];
          for (const y of r) {
            const S = c[y], T = e[y];
            if (typeof S != typeof T) return false;
            if (S != null || T != null) {
              if (S == null || T == null) return false;
              if (Array.isArray(S)) {
                if (!Array.isArray(T) || S.length !== T.length) return false;
                for (let d = 0; d < S.length; d++) if (!u(S[d], T[d])) return false;
              } else if (typeof S != "object" || f != null && f.includes(y)) {
                if (!u(S, T)) return false;
              } else for (const d of Object.keys(S)) if (S[d] !== T[d]) return false;
            }
          }
          return true;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isPlaceholderType.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c) {
          if (u === c) return true;
          const e = n.PLACEHOLDERS_ALIAS[u];
          if (e) {
            for (const r of e) if (c === r) return true;
          }
          return false;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isReferenced.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(l, n, u) {
          switch (n.type) {
            case "MemberExpression":
            case "OptionalMemberExpression":
              return n.property === l ? !!n.computed : n.object === l;
            case "JSXMemberExpression":
              return n.object === l;
            case "VariableDeclarator":
              return n.init === l;
            case "ArrowFunctionExpression":
              return n.body === l;
            case "PrivateName":
            case "LabeledStatement":
            case "CatchClause":
            case "RestElement":
            case "BreakStatement":
            case "ContinueStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportAttribute":
            case "JSXAttribute":
            case "ObjectPattern":
            case "ArrayPattern":
            case "MetaProperty":
              return false;
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "ObjectMethod":
              return n.key === l && !!n.computed;
            case "ObjectProperty":
              return n.key === l ? !!n.computed : !u || u.type !== "ObjectPattern";
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "TSPropertySignature":
              return n.key !== l || !!n.computed;
            case "ClassPrivateProperty":
            case "ObjectTypeProperty":
              return n.key !== l;
            case "ClassDeclaration":
            case "ClassExpression":
              return n.superClass === l;
            case "AssignmentExpression":
            case "AssignmentPattern":
              return n.right === l;
            case "ExportSpecifier":
              return (u == null || !u.source) && n.local === l;
            case "TSEnumMember":
              return n.id !== l;
          }
          return true;
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isScope.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c) {
          return (0, n.isBlockStatement)(u) && ((0, n.isFunction)(c) || (0, n.isCatchClause)(c)) ? false : (0, n.isPattern)(u) && ((0, n.isFunction)(c) || (0, n.isCatchClause)(c)) ? true : (0, n.isScopable)(u);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isSpecifierDefault.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u) {
          return (0, n.isImportDefaultSpecifier)(u) || (0, n.isIdentifier)(u.imported || u.exported, { name: "default" });
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isType.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c) {
          if (u === c) return true;
          if (u == null || n.ALIAS_KEYS[c]) return false;
          const e = n.FLIPPED_ALIAS_KEYS[c];
          if (e) {
            if (e[0] === u) return true;
            for (const r of e) if (u === r) return true;
          }
          return false;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidES3Identifier.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c) {
          return (0, n.default)(c) && !u.has(c);
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js");
        const u = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isValidIdentifier.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c = true) {
          return typeof u != "string" || c && ((0, n.isKeyword)(u) || (0, n.isStrictReservedWord)(u, true)) ? false : (0, n.isIdentifierName)(u);
        };
        var n = l("./node_modules/.pnpm/@babel+helper-validator-identifier@7.25.9/node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/isVar.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(c) {
          return (0, n.isVariableDeclaration)(c, { kind: "var" }) && !c[u.BLOCK_SCOPED_SYMBOL];
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js"), u = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/matchesPattern.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(u, c, e) {
          if (!(0, n.isMemberExpression)(u)) return false;
          const r = Array.isArray(c) ? c : c.split("."), f = [];
          let y;
          for (y = u; (0, n.isMemberExpression)(y); y = y.object) f.push(y.property);
          if (f.push(y), f.length < r.length || !e && f.length > r.length) return false;
          for (let S = 0, T = f.length - 1; S < r.length; S++, T--) {
            const d = f[T];
            let p;
            if ((0, n.isIdentifier)(d)) p = d.name;
            else if ((0, n.isStringLiteral)(d)) p = d.value;
            else {
              if (!(0, n.isThisExpression)(d)) return false;
              p = "this";
            }
            if (r[S] !== p) return false;
          }
          return true;
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/react/isCompatTag.js": (P, t) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(l) {
          return !!l && /^[a-z]/.test(l);
        };
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/react/isReactComponent.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = void 0;
        const n = (0, l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js").default)("React.Component");
        t.default = n;
      }, "./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/validators/validate.js": (P, t, l) => {
        Object.defineProperty(t, "__esModule", { value: true }), t.default = function(e, r, f) {
          if (!e) return;
          const y = n.NODE_FIELDS[e.type];
          if (!y) return;
          const S = y[r];
          u(e, r, f, S), c(e, r, f);
        }, t.validateChild = c, t.validateField = u, t.validateInternal = function(e, r, f, y, S) {
          if (!(e == null || !e.validate) && !(e.optional && y == null) && (e.validate(r, f, y), S)) {
            var T;
            const d = y.type;
            if (d == null) return;
            (T = n.NODE_PARENT_VALIDATIONS[d]) == null || T.call(n.NODE_PARENT_VALIDATIONS, r, f, y);
          }
        };
        var n = l("./node_modules/.pnpm/@babel+types@7.26.3/node_modules/@babel/types/lib/definitions/index.js");
        function u(e, r, f, y) {
          y != null && y.validate && (y.optional && f == null || y.validate(e, r, f));
        }
        function c(e, r, f) {
          var y;
          const S = f == null ? void 0 : f.type;
          S != null && ((y = n.NODE_PARENT_VALIDATIONS[S]) == null || y.call(n.NODE_PARENT_VALIDATIONS, e, r, f));
        }
      }, "./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs": (P, t, l) => {
        l.r(t), l.d(t, { default: () => G });
        var n = { Space_Separator: /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, u = { isSpaceSeparator: (B) => typeof B == "string" && n.Space_Separator.test(B), isIdStartChar: (B) => typeof B == "string" && (B >= "a" && B <= "z" || B >= "A" && B <= "Z" || B === "$" || B === "_" || n.ID_Start.test(B)), isIdContinueChar: (B) => typeof B == "string" && (B >= "a" && B <= "z" || B >= "A" && B <= "Z" || B >= "0" && B <= "9" || B === "$" || B === "_" || B === "\u200C" || B === "\u200D" || n.ID_Continue.test(B)), isDigit: (B) => typeof B == "string" && /[0-9]/.test(B), isHexDigit: (B) => typeof B == "string" && /[0-9A-Fa-f]/.test(B) };
        let c, e, r, f, y, S, T, d, p;
        function h(B, z, M) {
          const K = B[z];
          if (K != null && typeof K == "object") if (Array.isArray(K)) for (let Q = 0; Q < K.length; Q++) {
            const ie = String(Q), ue = h(K, ie, M);
            ue === void 0 ? delete K[ie] : Object.defineProperty(K, ie, { value: ue, writable: true, enumerable: true, configurable: true });
          }
          else for (const Q in K) {
            const ie = h(K, Q, M);
            ie === void 0 ? delete K[Q] : Object.defineProperty(K, Q, { value: ie, writable: true, enumerable: true, configurable: true });
          }
          return M.call(B, z, K);
        }
        let m, E, _, C, w;
        function I() {
          for (m = "default", E = "", _ = false, C = 1; ; ) {
            w = D();
            const B = L[m]();
            if (B) return B;
          }
        }
        function D() {
          if (c[f]) return String.fromCodePoint(c.codePointAt(f));
        }
        function j() {
          const B = D();
          return B === `
` ? (y++, S = 0) : B ? S += B.length : S++, B && (f += B.length), B;
        }
        const L = { default() {
          switch (w) {
            case "	":
            case "\v":
            case "\f":
            case " ":
            case "\xA0":
            case "\uFEFF":
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
              return void j();
            case "/":
              return j(), void (m = "comment");
            case void 0:
              return j(), k("eof");
          }
          if (!u.isSpaceSeparator(w)) return L[e]();
          j();
        }, comment() {
          switch (w) {
            case "*":
              return j(), void (m = "multiLineComment");
            case "/":
              return j(), void (m = "singleLineComment");
          }
          throw U(j());
        }, multiLineComment() {
          switch (w) {
            case "*":
              return j(), void (m = "multiLineCommentAsterisk");
            case void 0:
              throw U(j());
          }
          j();
        }, multiLineCommentAsterisk() {
          switch (w) {
            case "*":
              return void j();
            case "/":
              return j(), void (m = "default");
            case void 0:
              throw U(j());
          }
          j(), m = "multiLineComment";
        }, singleLineComment() {
          switch (w) {
            case `
`:
            case "\r":
            case "\u2028":
            case "\u2029":
              return j(), void (m = "default");
            case void 0:
              return j(), k("eof");
          }
          j();
        }, value() {
          switch (w) {
            case "{":
            case "[":
              return k("punctuator", j());
            case "n":
              return j(), N("ull"), k("null", null);
            case "t":
              return j(), N("rue"), k("boolean", true);
            case "f":
              return j(), N("alse"), k("boolean", false);
            case "-":
            case "+":
              return j() === "-" && (C = -1), void (m = "sign");
            case ".":
              return E = j(), void (m = "decimalPointLeading");
            case "0":
              return E = j(), void (m = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return E = j(), void (m = "decimalInteger");
            case "I":
              return j(), N("nfinity"), k("numeric", 1 / 0);
            case "N":
              return j(), N("aN"), k("numeric", NaN);
            case '"':
            case "'":
              return _ = j() === '"', E = "", void (m = "string");
          }
          throw U(j());
        }, identifierNameStartEscape() {
          if (w !== "u") throw U(j());
          j();
          const B = F();
          switch (B) {
            case "$":
            case "_":
              break;
            default:
              if (!u.isIdStartChar(B)) throw ee();
          }
          E += B, m = "identifierName";
        }, identifierName() {
          switch (w) {
            case "$":
            case "_":
            case "\u200C":
            case "\u200D":
              return void (E += j());
            case "\\":
              return j(), void (m = "identifierNameEscape");
          }
          if (!u.isIdContinueChar(w)) return k("identifier", E);
          E += j();
        }, identifierNameEscape() {
          if (w !== "u") throw U(j());
          j();
          const B = F();
          switch (B) {
            case "$":
            case "_":
            case "\u200C":
            case "\u200D":
              break;
            default:
              if (!u.isIdContinueChar(B)) throw ee();
          }
          E += B, m = "identifierName";
        }, sign() {
          switch (w) {
            case ".":
              return E = j(), void (m = "decimalPointLeading");
            case "0":
              return E = j(), void (m = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return E = j(), void (m = "decimalInteger");
            case "I":
              return j(), N("nfinity"), k("numeric", C * (1 / 0));
            case "N":
              return j(), N("aN"), k("numeric", NaN);
          }
          throw U(j());
        }, zero() {
          switch (w) {
            case ".":
              return E += j(), void (m = "decimalPoint");
            case "e":
            case "E":
              return E += j(), void (m = "decimalExponent");
            case "x":
            case "X":
              return E += j(), void (m = "hexadecimal");
          }
          return k("numeric", 0 * C);
        }, decimalInteger() {
          switch (w) {
            case ".":
              return E += j(), void (m = "decimalPoint");
            case "e":
            case "E":
              return E += j(), void (m = "decimalExponent");
          }
          if (!u.isDigit(w)) return k("numeric", C * Number(E));
          E += j();
        }, decimalPointLeading() {
          if (u.isDigit(w)) return E += j(), void (m = "decimalFraction");
          throw U(j());
        }, decimalPoint() {
          switch (w) {
            case "e":
            case "E":
              return E += j(), void (m = "decimalExponent");
          }
          return u.isDigit(w) ? (E += j(), void (m = "decimalFraction")) : k("numeric", C * Number(E));
        }, decimalFraction() {
          switch (w) {
            case "e":
            case "E":
              return E += j(), void (m = "decimalExponent");
          }
          if (!u.isDigit(w)) return k("numeric", C * Number(E));
          E += j();
        }, decimalExponent() {
          switch (w) {
            case "+":
            case "-":
              return E += j(), void (m = "decimalExponentSign");
          }
          if (u.isDigit(w)) return E += j(), void (m = "decimalExponentInteger");
          throw U(j());
        }, decimalExponentSign() {
          if (u.isDigit(w)) return E += j(), void (m = "decimalExponentInteger");
          throw U(j());
        }, decimalExponentInteger() {
          if (!u.isDigit(w)) return k("numeric", C * Number(E));
          E += j();
        }, hexadecimal() {
          if (u.isHexDigit(w)) return E += j(), void (m = "hexadecimalInteger");
          throw U(j());
        }, hexadecimalInteger() {
          if (!u.isHexDigit(w)) return k("numeric", C * Number(E));
          E += j();
        }, string() {
          switch (w) {
            case "\\":
              return j(), void (E += function() {
                switch (D()) {
                  case "b":
                    return j(), "\b";
                  case "f":
                    return j(), "\f";
                  case "n":
                    return j(), `
`;
                  case "r":
                    return j(), "\r";
                  case "t":
                    return j(), "	";
                  case "v":
                    return j(), "\v";
                  case "0":
                    if (j(), u.isDigit(D())) throw U(j());
                    return "\0";
                  case "x":
                    return j(), function() {
                      let B = "", z = D();
                      if (!u.isHexDigit(z) || (B += j(), z = D(), !u.isHexDigit(z))) throw U(j());
                      return B += j(), String.fromCodePoint(parseInt(B, 16));
                    }();
                  case "u":
                    return j(), F();
                  case `
`:
                  case "\u2028":
                  case "\u2029":
                    return j(), "";
                  case "\r":
                    return j(), D() === `
` && j(), "";
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                  case void 0:
                    throw U(j());
                }
                return j();
              }());
            case '"':
              return _ ? (j(), k("string", E)) : void (E += j());
            case "'":
              return _ ? void (E += j()) : (j(), k("string", E));
            case `
`:
            case "\r":
              throw U(j());
            case "\u2028":
            case "\u2029":
              (function(B) {
                console.warn(`JSON5: '${re(B)}' in strings is not valid ECMAScript; consider escaping`);
              })(w);
              break;
            case void 0:
              throw U(j());
          }
          E += j();
        }, start() {
          switch (w) {
            case "{":
            case "[":
              return k("punctuator", j());
          }
          m = "value";
        }, beforePropertyName() {
          switch (w) {
            case "$":
            case "_":
              return E = j(), void (m = "identifierName");
            case "\\":
              return j(), void (m = "identifierNameStartEscape");
            case "}":
              return k("punctuator", j());
            case '"':
            case "'":
              return _ = j() === '"', void (m = "string");
          }
          if (u.isIdStartChar(w)) return E += j(), void (m = "identifierName");
          throw U(j());
        }, afterPropertyName() {
          if (w === ":") return k("punctuator", j());
          throw U(j());
        }, beforePropertyValue() {
          m = "value";
        }, afterPropertyValue() {
          switch (w) {
            case ",":
            case "}":
              return k("punctuator", j());
          }
          throw U(j());
        }, beforeArrayValue() {
          if (w === "]") return k("punctuator", j());
          m = "value";
        }, afterArrayValue() {
          switch (w) {
            case ",":
            case "]":
              return k("punctuator", j());
          }
          throw U(j());
        }, end() {
          throw U(j());
        } };
        function k(B, z) {
          return { type: B, value: z, line: y, column: S };
        }
        function N(B) {
          for (const z of B) {
            if (D() !== z) throw U(j());
            j();
          }
        }
        function F() {
          let B = "", z = 4;
          for (; z-- > 0; ) {
            const M = D();
            if (!u.isHexDigit(M)) throw U(j());
            B += j();
          }
          return String.fromCodePoint(parseInt(B, 16));
        }
        const W = { start() {
          if (T.type === "eof") throw q();
          X();
        }, beforePropertyName() {
          switch (T.type) {
            case "identifier":
            case "string":
              return d = T.value, void (e = "afterPropertyName");
            case "punctuator":
              return void H();
            case "eof":
              throw q();
          }
        }, afterPropertyName() {
          if (T.type === "eof") throw q();
          e = "beforePropertyValue";
        }, beforePropertyValue() {
          if (T.type === "eof") throw q();
          X();
        }, beforeArrayValue() {
          if (T.type === "eof") throw q();
          T.type !== "punctuator" || T.value !== "]" ? X() : H();
        }, afterPropertyValue() {
          if (T.type === "eof") throw q();
          switch (T.value) {
            case ",":
              return void (e = "beforePropertyName");
            case "}":
              H();
          }
        }, afterArrayValue() {
          if (T.type === "eof") throw q();
          switch (T.value) {
            case ",":
              return void (e = "beforeArrayValue");
            case "]":
              H();
          }
        }, end() {
        } };
        function X() {
          let B;
          switch (T.type) {
            case "punctuator":
              switch (T.value) {
                case "{":
                  B = {};
                  break;
                case "[":
                  B = [];
              }
              break;
            case "null":
            case "boolean":
            case "numeric":
            case "string":
              B = T.value;
          }
          if (p === void 0) p = B;
          else {
            const z = r[r.length - 1];
            Array.isArray(z) ? z.push(B) : Object.defineProperty(z, d, { value: B, writable: true, enumerable: true, configurable: true });
          }
          if (B !== null && typeof B == "object") r.push(B), e = Array.isArray(B) ? "beforeArrayValue" : "beforePropertyName";
          else {
            const z = r[r.length - 1];
            e = z == null ? "end" : Array.isArray(z) ? "afterArrayValue" : "afterPropertyValue";
          }
        }
        function H() {
          r.pop();
          const B = r[r.length - 1];
          e = B == null ? "end" : Array.isArray(B) ? "afterArrayValue" : "afterPropertyValue";
        }
        function U(B) {
          return Y(B === void 0 ? `JSON5: invalid end of input at ${y}:${S}` : `JSON5: invalid character '${re(B)}' at ${y}:${S}`);
        }
        function q() {
          return Y(`JSON5: invalid end of input at ${y}:${S}`);
        }
        function ee() {
          return S -= 5, Y(`JSON5: invalid identifier character at ${y}:${S}`);
        }
        function re(B) {
          const z = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
          if (z[B]) return z[B];
          if (B < " ") {
            const M = B.charCodeAt(0).toString(16);
            return "\\x" + ("00" + M).substring(M.length);
          }
          return B;
        }
        function Y(B) {
          const z = new SyntaxError(B);
          return z.lineNumber = y, z.columnNumber = S, z;
        }
        const G = { parse: function(B, z) {
          c = String(B), e = "start", r = [], f = 0, y = 1, S = 0, T = void 0, d = void 0, p = void 0;
          do
            T = I(), W[e]();
          while (T.type !== "eof");
          return typeof z == "function" ? h({ "": p }, "", z) : p;
        }, stringify: function(B, z, M) {
          const K = [];
          let Q, ie, ue, ge = "", Te = "";
          if (z == null || typeof z != "object" || Array.isArray(z) || (M = z.space, ue = z.quote, z = z.replacer), typeof z == "function") ie = z;
          else if (Array.isArray(z)) {
            Q = [];
            for (const xe of z) {
              let we;
              typeof xe == "string" ? we = xe : (typeof xe == "number" || xe instanceof String || xe instanceof Number) && (we = String(xe)), we !== void 0 && Q.indexOf(we) < 0 && Q.push(we);
            }
          }
          return M instanceof Number ? M = Number(M) : M instanceof String && (M = String(M)), typeof M == "number" ? M > 0 && (M = Math.min(10, Math.floor(M)), Te = "          ".substr(0, M)) : typeof M == "string" && (Te = M.substr(0, 10)), le("", { "": B });
          function le(xe, we) {
            let me = we[xe];
            switch (me != null && (typeof me.toJSON5 == "function" ? me = me.toJSON5(xe) : typeof me.toJSON == "function" && (me = me.toJSON(xe))), ie && (me = ie.call(we, xe, me)), me instanceof Number ? me = Number(me) : me instanceof String ? me = String(me) : me instanceof Boolean && (me = me.valueOf()), me) {
              case null:
                return "null";
              case true:
                return "true";
              case false:
                return "false";
            }
            return typeof me == "string" ? fe(me) : typeof me == "number" ? String(me) : typeof me == "object" ? Array.isArray(me) ? function(ye) {
              if (K.indexOf(ye) >= 0) throw TypeError("Converting circular structure to JSON5");
              K.push(ye);
              let pe = ge;
              ge += Te;
              let J, Ee = [];
              for (let Me = 0; Me < ye.length; Me++) {
                const Ue = le(String(Me), ye);
                Ee.push(Ue !== void 0 ? Ue : "null");
              }
              if (Ee.length === 0) J = "[]";
              else if (Te === "") J = "[" + Ee.join(",") + "]";
              else {
                let Me = `,
` + ge, Ue = Ee.join(Me);
                J = `[
` + ge + Ue + `,
` + pe + "]";
              }
              return K.pop(), ge = pe, J;
            }(me) : function(ye) {
              if (K.indexOf(ye) >= 0) throw TypeError("Converting circular structure to JSON5");
              K.push(ye);
              let pe = ge;
              ge += Te;
              let J, Ee = Q || Object.keys(ye), Me = [];
              for (const Ue of Ee) {
                const qe = le(Ue, ye);
                if (qe !== void 0) {
                  let He = Pe(Ue) + ":";
                  Te !== "" && (He += " "), He += qe, Me.push(He);
                }
              }
              if (Me.length === 0) J = "{}";
              else {
                let Ue;
                if (Te === "") Ue = Me.join(","), J = "{" + Ue + "}";
                else {
                  let qe = `,
` + ge;
                  Ue = Me.join(qe), J = `{
` + ge + Ue + `,
` + pe + "}";
                }
              }
              return K.pop(), ge = pe, J;
            }(me) : void 0;
          }
          function fe(xe) {
            const we = { "'": 0.1, '"': 0.2 }, me = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
            let ye = "";
            for (let J = 0; J < xe.length; J++) {
              const Ee = xe[J];
              switch (Ee) {
                case "'":
                case '"':
                  we[Ee]++, ye += Ee;
                  continue;
                case "\0":
                  if (u.isDigit(xe[J + 1])) {
                    ye += "\\x00";
                    continue;
                  }
              }
              if (me[Ee]) ye += me[Ee];
              else if (Ee < " ") {
                let Me = Ee.charCodeAt(0).toString(16);
                ye += "\\x" + ("00" + Me).substring(Me.length);
              } else ye += Ee;
            }
            const pe = ue || Object.keys(we).reduce((J, Ee) => we[J] < we[Ee] ? J : Ee);
            return ye = ye.replace(new RegExp(pe, "g"), me[pe]), pe + ye + pe;
          }
          function Pe(xe) {
            if (xe.length === 0) return fe(xe);
            const we = String.fromCodePoint(xe.codePointAt(0));
            if (!u.isIdStartChar(we)) return fe(xe);
            for (let me = we.length; me < xe.length; me++) if (!u.isIdContinueChar(String.fromCodePoint(xe.codePointAt(me)))) return fe(xe);
            return xe;
          }
        } };
      }, "./node_modules/.pnpm/@babel+preset-typescript@7.26.0_@babel+core@7.26.0/node_modules/@babel/preset-typescript/package.json": (P) => {
        P.exports = JSON.parse('{"name":"@babel/preset-typescript","version":"7.26.0","description":"Babel preset for TypeScript.","repository":{"type":"git","url":"https://github.com/babel/babel.git","directory":"packages/babel-preset-typescript"},"license":"MIT","publishConfig":{"access":"public"},"main":"./lib/index.js","keywords":["babel-preset","typescript"],"dependencies":{"@babel/helper-plugin-utils":"^7.25.9","@babel/helper-validator-option":"^7.25.9","@babel/plugin-syntax-jsx":"^7.25.9","@babel/plugin-transform-modules-commonjs":"^7.25.9","@babel/plugin-transform-typescript":"^7.25.9"},"peerDependencies":{"@babel/core":"^7.0.0-0"},"devDependencies":{"@babel/core":"^7.26.0","@babel/helper-plugin-test-runner":"^7.25.9"},"homepage":"https://babel.dev/docs/en/next/babel-preset-typescript","bugs":"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen","engines":{"node":">=6.9.0"},"author":"The Babel Team (https://babel.dev/team)","type":"commonjs"}');
      }, "./node_modules/.pnpm/globals@11.12.0/node_modules/globals/globals.json": (P) => {
        P.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
      } }, b = {};
      function A(P) {
        var t = b[P];
        if (t !== void 0) return t.exports;
        var l = b[P] = { exports: {} };
        return o[P].call(l.exports, l, l.exports, A), l.exports;
      }
      A.d = (P, t) => {
        for (var l in t) A.o(t, l) && !A.o(P, l) && Object.defineProperty(P, l, { enumerable: true, get: t[l] });
      }, A.o = (P, t) => Object.prototype.hasOwnProperty.call(P, t), A.r = (P) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(P, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(P, "__esModule", { value: true });
      };
      var R = {};
      (() => {
        A.d(R, { default: () => c });
        var P = A("./node_modules/.pnpm/@babel+core@7.26.0/node_modules/@babel/core/lib/index.js"), t = A("url"), l = A("./node_modules/.pnpm/@babel+template@7.25.9/node_modules/@babel/template/lib/index.js");
        function n(e, r) {
          return { name: "transform-import-meta", visitor: { Program(f) {
            const y = [];
            if (f.traverse({ MemberExpression(S) {
              const { node: T } = S;
              T.object.type === "MetaProperty" && T.object.meta.name === "import" && T.object.property.name === "meta" && T.property.type === "Identifier" && T.property.name === "url" && y.push(S);
            } }), y.length !== 0) for (const S of y) S.replaceWith(l.smart.ast`${r.filename ? JSON.stringify((0, t.pathToFileURL)(r.filename)) : "require('url').pathToFileURL(__filename).toString()"}`);
          } } };
        }
        function u({ template: e, types: r }) {
          return { name: "@import-meta-env/babel", visitor: { Identifier(f) {
            if (!r.isIdentifier(f) || !r.isMemberExpression(f.parentPath) && !r.isOptionalMemberExpression(f.parentPath) || !r.isMemberExpression(f.parentPath.node)) return;
            const y = f.parentPath.node;
            if (!r.isMetaProperty(y.object)) return;
            const S = y.object;
            S.meta.name === "import" && S.property.name === "meta" && y.property.name === "env" && f.parentPath.replaceWith(e.expression.ast("process.env"));
          } } };
        }
        function c(e) {
          var r, f, y, S, T, d;
          const p = Object.assign(Object.assign({ babelrc: false, configFile: false, compact: false, retainLines: typeof e.retainLines != "boolean" || e.retainLines, filename: "", cwd: "/" }, e.babel), { plugins: [[A("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"), { allowTopLevelThis: true }], [A("./node_modules/.pnpm/babel-plugin-dynamic-import-node@2.3.3/node_modules/babel-plugin-dynamic-import-node/lib/index.js"), { noInterop: true }], [n, { filename: e.filename }], [A("./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-class-properties/lib/index.js")], [A("./node_modules/.pnpm/@babel+plugin-transform-export-namespace-from@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js")], [u]] });
          e.ts && (p.plugins.push([A("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.26.3_@babel+core@7.26.0/node_modules/@babel/plugin-transform-typescript/lib/index.js"), { allowDeclareFields: true }]), p.plugins.unshift([A("./node_modules/.pnpm/babel-plugin-transform-typescript-metadata@0.3.2_@babel+core@7.26.0_@babel+traverse@7.26.4/node_modules/babel-plugin-transform-typescript-metadata/lib/plugin.js")], [A("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-proposal-decorators/lib/index.js"), { legacy: true }]), p.plugins.push(A("./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js")), p.plugins.push(A("./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.26.0_@babel+core@7.26.0/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js"))), e.legacy && (p.plugins.push(A("./node_modules/.pnpm/@babel+plugin-transform-nullish-coalescing-operator@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-nullish-coalescing-operator/lib/index.js")), p.plugins.push(A("./node_modules/.pnpm/@babel+plugin-transform-optional-chaining@7.25.9_@babel+core@7.26.0/node_modules/@babel/plugin-transform-optional-chaining/lib/index.js"))), e.babel && Array.isArray(e.babel.plugins) && ((r = p.plugins) === null || r === void 0 || r.push(...e.babel.plugins));
          try {
            return { code: ((f = (0, P.transformSync)(e.source, p)) === null || f === void 0 ? void 0 : f.code) || "" };
          } catch (h) {
            return { error: h, code: "exports.__JITI_ERROR__ = " + JSON.stringify({ filename: e.filename, line: ((y = h.loc) === null || y === void 0 ? void 0 : y.line) || 0, column: ((S = h.loc) === null || S === void 0 ? void 0 : S.column) || 0, code: (T = h.code) === null || T === void 0 ? void 0 : T.replace("BABEL_", "").replace("PARSE_ERROR", "ParseError"), message: (d = h.message) === null || d === void 0 ? void 0 : d.replace("/: ", "").replace(/\(.+\)\s*$/, "") }) };
          }
        }
      })(), a3.exports = R.default;
    })();
  }(Qo)), Qo.exports;
}
function uP(a3) {
  throw a3;
}
var cP = function(s, o) {
  const b = lP();
  return o = { onError: uP, ...o }, o.transform || (o.transform = Vm()), b(s, o);
}, Fe;
(function(a3) {
  a3[a3.NONE = 0] = "NONE";
  const o = 1;
  a3[a3._abstract = o] = "_abstract";
  const b = o + 1;
  a3[a3._accessor = b] = "_accessor";
  const A = b + 1;
  a3[a3._as = A] = "_as";
  const R = A + 1;
  a3[a3._assert = R] = "_assert";
  const P = R + 1;
  a3[a3._asserts = P] = "_asserts";
  const t = P + 1;
  a3[a3._async = t] = "_async";
  const l = t + 1;
  a3[a3._await = l] = "_await";
  const n = l + 1;
  a3[a3._checks = n] = "_checks";
  const u = n + 1;
  a3[a3._constructor = u] = "_constructor";
  const c = u + 1;
  a3[a3._declare = c] = "_declare";
  const e = c + 1;
  a3[a3._enum = e] = "_enum";
  const r = e + 1;
  a3[a3._exports = r] = "_exports";
  const f = r + 1;
  a3[a3._from = f] = "_from";
  const y = f + 1;
  a3[a3._get = y] = "_get";
  const S = y + 1;
  a3[a3._global = S] = "_global";
  const T = S + 1;
  a3[a3._implements = T] = "_implements";
  const d = T + 1;
  a3[a3._infer = d] = "_infer";
  const p = d + 1;
  a3[a3._interface = p] = "_interface";
  const h = p + 1;
  a3[a3._is = h] = "_is";
  const m = h + 1;
  a3[a3._keyof = m] = "_keyof";
  const E = m + 1;
  a3[a3._mixins = E] = "_mixins";
  const _ = E + 1;
  a3[a3._module = _] = "_module";
  const C = _ + 1;
  a3[a3._namespace = C] = "_namespace";
  const w = C + 1;
  a3[a3._of = w] = "_of";
  const I = w + 1;
  a3[a3._opaque = I] = "_opaque";
  const D = I + 1;
  a3[a3._out = D] = "_out";
  const j = D + 1;
  a3[a3._override = j] = "_override";
  const L = j + 1;
  a3[a3._private = L] = "_private";
  const k = L + 1;
  a3[a3._protected = k] = "_protected";
  const N = k + 1;
  a3[a3._proto = N] = "_proto";
  const F = N + 1;
  a3[a3._public = F] = "_public";
  const W = F + 1;
  a3[a3._readonly = W] = "_readonly";
  const X = W + 1;
  a3[a3._require = X] = "_require";
  const H = X + 1;
  a3[a3._satisfies = H] = "_satisfies";
  const U = H + 1;
  a3[a3._set = U] = "_set";
  const q = U + 1;
  a3[a3._static = q] = "_static";
  const ee = q + 1;
  a3[a3._symbol = ee] = "_symbol";
  const re = ee + 1;
  a3[a3._type = re] = "_type";
  const Y = re + 1;
  a3[a3._unique = Y] = "_unique";
  const Z = Y + 1;
  a3[a3._using = Z] = "_using";
})(Fe || (Fe = {}));
var x;
(function(a3) {
  a3[a3.PRECEDENCE_MASK = 15] = "PRECEDENCE_MASK";
  const o = 16;
  a3[a3.IS_KEYWORD = o] = "IS_KEYWORD";
  const b = 32;
  a3[a3.IS_ASSIGN = b] = "IS_ASSIGN";
  const A = 64;
  a3[a3.IS_RIGHT_ASSOCIATIVE = A] = "IS_RIGHT_ASSOCIATIVE";
  const R = 128;
  a3[a3.IS_PREFIX = R] = "IS_PREFIX";
  const P = 256;
  a3[a3.IS_POSTFIX = P] = "IS_POSTFIX";
  const t = 512;
  a3[a3.IS_EXPRESSION_START = t] = "IS_EXPRESSION_START";
  const l = 512;
  a3[a3.num = l] = "num";
  const n = 1536;
  a3[a3.bigint = n] = "bigint";
  const u = 2560;
  a3[a3.decimal = u] = "decimal";
  const c = 3584;
  a3[a3.regexp = c] = "regexp";
  const e = 4608;
  a3[a3.string = e] = "string";
  const r = 5632;
  a3[a3.name = r] = "name";
  const f = 6144;
  a3[a3.eof = f] = "eof";
  const y = 7680;
  a3[a3.bracketL = y] = "bracketL";
  const S = 8192;
  a3[a3.bracketR = S] = "bracketR";
  const T = 9728;
  a3[a3.braceL = T] = "braceL";
  const d = 10752;
  a3[a3.braceBarL = d] = "braceBarL";
  const p = 11264;
  a3[a3.braceR = p] = "braceR";
  const h = 12288;
  a3[a3.braceBarR = h] = "braceBarR";
  const m = 13824;
  a3[a3.parenL = m] = "parenL";
  const E = 14336;
  a3[a3.parenR = E] = "parenR";
  const _ = 15360;
  a3[a3.comma = _] = "comma";
  const C = 16384;
  a3[a3.semi = C] = "semi";
  const w = 17408;
  a3[a3.colon = w] = "colon";
  const I = 18432;
  a3[a3.doubleColon = I] = "doubleColon";
  const D = 19456;
  a3[a3.dot = D] = "dot";
  const j = 20480;
  a3[a3.question = j] = "question";
  const L = 21504;
  a3[a3.questionDot = L] = "questionDot";
  const k = 22528;
  a3[a3.arrow = k] = "arrow";
  const N = 23552;
  a3[a3.template = N] = "template";
  const F = 24576;
  a3[a3.ellipsis = F] = "ellipsis";
  const W = 25600;
  a3[a3.backQuote = W] = "backQuote";
  const X = 27136;
  a3[a3.dollarBraceL = X] = "dollarBraceL";
  const H = 27648;
  a3[a3.at = H] = "at";
  const U = 29184;
  a3[a3.hash = U] = "hash";
  const q = 29728;
  a3[a3.eq = q] = "eq";
  const ee = 30752;
  a3[a3.assign = ee] = "assign";
  const re = 32640;
  a3[a3.preIncDec = re] = "preIncDec";
  const Y = 33664;
  a3[a3.postIncDec = Y] = "postIncDec";
  const Z = 34432;
  a3[a3.bang = Z] = "bang";
  const G = 35456;
  a3[a3.tilde = G] = "tilde";
  const B = 35841;
  a3[a3.pipeline = B] = "pipeline";
  const z = 36866;
  a3[a3.nullishCoalescing = z] = "nullishCoalescing";
  const M = 37890;
  a3[a3.logicalOR = M] = "logicalOR";
  const K = 38915;
  a3[a3.logicalAND = K] = "logicalAND";
  const Q = 39940;
  a3[a3.bitwiseOR = Q] = "bitwiseOR";
  const ie = 40965;
  a3[a3.bitwiseXOR = ie] = "bitwiseXOR";
  const ue = 41990;
  a3[a3.bitwiseAND = ue] = "bitwiseAND";
  const ge = 43015;
  a3[a3.equality = ge] = "equality";
  const Te = 44040;
  a3[a3.lessThan = Te] = "lessThan";
  const le = 45064;
  a3[a3.greaterThan = le] = "greaterThan";
  const fe = 46088;
  a3[a3.relationalOrEqual = fe] = "relationalOrEqual";
  const Pe = 47113;
  a3[a3.bitShiftL = Pe] = "bitShiftL";
  const xe = 48137;
  a3[a3.bitShiftR = xe] = "bitShiftR";
  const we = 49802;
  a3[a3.plus = we] = "plus";
  const me = 50826;
  a3[a3.minus = me] = "minus";
  const ye = 51723;
  a3[a3.modulo = ye] = "modulo";
  const pe = 52235;
  a3[a3.star = pe] = "star";
  const J = 53259;
  a3[a3.slash = J] = "slash";
  const Ee = 54348;
  a3[a3.exponent = Ee] = "exponent";
  const Me = 55296;
  a3[a3.jsxName = Me] = "jsxName";
  const Ue = 56320;
  a3[a3.jsxText = Ue] = "jsxText";
  const qe = 57344;
  a3[a3.jsxEmptyText = qe] = "jsxEmptyText";
  const He = 58880;
  a3[a3.jsxTagStart = He] = "jsxTagStart";
  const Ie = 59392;
  a3[a3.jsxTagEnd = Ie] = "jsxTagEnd";
  const Re = 60928;
  a3[a3.typeParameterStart = Re] = "typeParameterStart";
  const Be = 61440;
  a3[a3.nonNullAssertion = Be] = "nonNullAssertion";
  const je = 62480;
  a3[a3._break = je] = "_break";
  const he = 63504;
  a3[a3._case = he] = "_case";
  const oe = 64528;
  a3[a3._catch = oe] = "_catch";
  const _e = 65552;
  a3[a3._continue = _e] = "_continue";
  const Ne = 66576;
  a3[a3._debugger = Ne] = "_debugger";
  const $e = 67600;
  a3[a3._default = $e] = "_default";
  const Xe = 68624;
  a3[a3._do = Xe] = "_do";
  const Je = 69648;
  a3[a3._else = Je] = "_else";
  const st = 70672;
  a3[a3._finally = st] = "_finally";
  const be = 71696;
  a3[a3._for = be] = "_for";
  const ke = 73232;
  a3[a3._function = ke] = "_function";
  const Ve = 73744;
  a3[a3._if = Ve] = "_if";
  const ze = 74768;
  a3[a3._return = ze] = "_return";
  const rt = 75792;
  a3[a3._switch = rt] = "_switch";
  const it = 77456;
  a3[a3._throw = it] = "_throw";
  const Ye = 77840;
  a3[a3._try = Ye] = "_try";
  const tt = 78864;
  a3[a3._var = tt] = "_var";
  const pt = 79888;
  a3[a3._let = pt] = "_let";
  const Et = 80912;
  a3[a3._const = Et] = "_const";
  const Qe = 81936;
  a3[a3._while = Qe] = "_while";
  const yt = 82960;
  a3[a3._with = yt] = "_with";
  const vt = 84496;
  a3[a3._new = vt] = "_new";
  const kt = 85520;
  a3[a3._this = kt] = "_this";
  const qt = 86544;
  a3[a3._super = qt] = "_super";
  const sn = 87568;
  a3[a3._class = sn] = "_class";
  const _n = 88080;
  a3[a3._extends = _n] = "_extends";
  const bn = 89104;
  a3[a3._export = bn] = "_export";
  const Kt = 90640;
  a3[a3._import = Kt] = "_import";
  const Jt = 91664;
  a3[a3._yield = Jt] = "_yield";
  const Ft = 92688;
  a3[a3._null = Ft] = "_null";
  const fn = 93712;
  a3[a3._true = fn] = "_true";
  const _t = 94736;
  a3[a3._false = _t] = "_false";
  const Xn = 95256;
  a3[a3._in = Xn] = "_in";
  const Jn = 96280;
  a3[a3._instanceof = Jn] = "_instanceof";
  const rr = 97936;
  a3[a3._typeof = rr] = "_typeof";
  const sr = 98960;
  a3[a3._void = sr] = "_void";
  const Qn = 99984;
  a3[a3._delete = Qn] = "_delete";
  const Br = 100880;
  a3[a3._async = Br] = "_async";
  const Tn = 101904;
  a3[a3._get = Tn] = "_get";
  const Zn = 102928;
  a3[a3._set = Zn] = "_set";
  const Gn = 103952;
  a3[a3._declare = Gn] = "_declare";
  const gn = 104976;
  a3[a3._readonly = gn] = "_readonly";
  const ur = 106e3;
  a3[a3._abstract = ur] = "_abstract";
  const Ir = 107024;
  a3[a3._static = Ir] = "_static";
  const zn = 107536;
  a3[a3._public = zn] = "_public";
  const kr = 108560;
  a3[a3._private = kr] = "_private";
  const Jr = 109584;
  a3[a3._protected = Jr] = "_protected";
  const Qr = 110608;
  a3[a3._override = Qr] = "_override";
  const wt = 112144;
  a3[a3._as = wt] = "_as";
  const $r = 113168;
  a3[a3._enum = $r] = "_enum";
  const vr = 114192;
  a3[a3._type = vr] = "_type";
  const Er = 115216;
  a3[a3._implements = Er] = "_implements";
})(x || (x = {}));
function Wm(a3) {
  switch (a3) {
    case x.num:
      return "num";
    case x.bigint:
      return "bigint";
    case x.decimal:
      return "decimal";
    case x.regexp:
      return "regexp";
    case x.string:
      return "string";
    case x.name:
      return "name";
    case x.eof:
      return "eof";
    case x.bracketL:
      return "[";
    case x.bracketR:
      return "]";
    case x.braceL:
      return "{";
    case x.braceBarL:
      return "{|";
    case x.braceR:
      return "}";
    case x.braceBarR:
      return "|}";
    case x.parenL:
      return "(";
    case x.parenR:
      return ")";
    case x.comma:
      return ",";
    case x.semi:
      return ";";
    case x.colon:
      return ":";
    case x.doubleColon:
      return "::";
    case x.dot:
      return ".";
    case x.question:
      return "?";
    case x.questionDot:
      return "?.";
    case x.arrow:
      return "=>";
    case x.template:
      return "template";
    case x.ellipsis:
      return "...";
    case x.backQuote:
      return "`";
    case x.dollarBraceL:
      return "${";
    case x.at:
      return "@";
    case x.hash:
      return "#";
    case x.eq:
      return "=";
    case x.assign:
      return "_=";
    case x.preIncDec:
      return "++/--";
    case x.postIncDec:
      return "++/--";
    case x.bang:
      return "!";
    case x.tilde:
      return "~";
    case x.pipeline:
      return "|>";
    case x.nullishCoalescing:
      return "??";
    case x.logicalOR:
      return "||";
    case x.logicalAND:
      return "&&";
    case x.bitwiseOR:
      return "|";
    case x.bitwiseXOR:
      return "^";
    case x.bitwiseAND:
      return "&";
    case x.equality:
      return "==/!=";
    case x.lessThan:
      return "<";
    case x.greaterThan:
      return ">";
    case x.relationalOrEqual:
      return "<=/>=";
    case x.bitShiftL:
      return "<<";
    case x.bitShiftR:
      return ">>/>>>";
    case x.plus:
      return "+";
    case x.minus:
      return "-";
    case x.modulo:
      return "%";
    case x.star:
      return "*";
    case x.slash:
      return "/";
    case x.exponent:
      return "**";
    case x.jsxName:
      return "jsxName";
    case x.jsxText:
      return "jsxText";
    case x.jsxEmptyText:
      return "jsxEmptyText";
    case x.jsxTagStart:
      return "jsxTagStart";
    case x.jsxTagEnd:
      return "jsxTagEnd";
    case x.typeParameterStart:
      return "typeParameterStart";
    case x.nonNullAssertion:
      return "nonNullAssertion";
    case x._break:
      return "break";
    case x._case:
      return "case";
    case x._catch:
      return "catch";
    case x._continue:
      return "continue";
    case x._debugger:
      return "debugger";
    case x._default:
      return "default";
    case x._do:
      return "do";
    case x._else:
      return "else";
    case x._finally:
      return "finally";
    case x._for:
      return "for";
    case x._function:
      return "function";
    case x._if:
      return "if";
    case x._return:
      return "return";
    case x._switch:
      return "switch";
    case x._throw:
      return "throw";
    case x._try:
      return "try";
    case x._var:
      return "var";
    case x._let:
      return "let";
    case x._const:
      return "const";
    case x._while:
      return "while";
    case x._with:
      return "with";
    case x._new:
      return "new";
    case x._this:
      return "this";
    case x._super:
      return "super";
    case x._class:
      return "class";
    case x._extends:
      return "extends";
    case x._export:
      return "export";
    case x._import:
      return "import";
    case x._yield:
      return "yield";
    case x._null:
      return "null";
    case x._true:
      return "true";
    case x._false:
      return "false";
    case x._in:
      return "in";
    case x._instanceof:
      return "instanceof";
    case x._typeof:
      return "typeof";
    case x._void:
      return "void";
    case x._delete:
      return "delete";
    case x._async:
      return "async";
    case x._get:
      return "get";
    case x._set:
      return "set";
    case x._declare:
      return "declare";
    case x._readonly:
      return "readonly";
    case x._abstract:
      return "abstract";
    case x._static:
      return "static";
    case x._public:
      return "public";
    case x._private:
      return "private";
    case x._protected:
      return "protected";
    case x._override:
      return "override";
    case x._as:
      return "as";
    case x._enum:
      return "enum";
    case x._type:
      return "type";
    case x._implements:
      return "implements";
    default:
      return "";
  }
}
class qr {
  constructor(s, o, b) {
    this.startTokenIndex = s, this.endTokenIndex = o, this.isFunctionScope = b;
  }
}
class pP {
  constructor(s, o, b, A, R, P, t, l, n, u, c, e, r) {
    this.potentialArrowAt = s, this.noAnonFunctionType = o, this.inDisallowConditionalTypesContext = b, this.tokensLength = A, this.scopesLength = R, this.pos = P, this.type = t, this.contextualKeyword = l, this.start = n, this.end = u, this.isType = c, this.scopeDepth = e, this.error = r;
  }
}
class tr {
  constructor() {
    tr.prototype.__init.call(this), tr.prototype.__init2.call(this), tr.prototype.__init3.call(this), tr.prototype.__init4.call(this), tr.prototype.__init5.call(this), tr.prototype.__init6.call(this), tr.prototype.__init7.call(this), tr.prototype.__init8.call(this), tr.prototype.__init9.call(this), tr.prototype.__init10.call(this), tr.prototype.__init11.call(this), tr.prototype.__init12.call(this), tr.prototype.__init13.call(this);
  }
  __init() {
    this.potentialArrowAt = -1;
  }
  __init2() {
    this.noAnonFunctionType = false;
  }
  __init3() {
    this.inDisallowConditionalTypesContext = false;
  }
  __init4() {
    this.tokens = [];
  }
  __init5() {
    this.scopes = [];
  }
  __init6() {
    this.pos = 0;
  }
  __init7() {
    this.type = x.eof;
  }
  __init8() {
    this.contextualKeyword = Fe.NONE;
  }
  __init9() {
    this.start = 0;
  }
  __init10() {
    this.end = 0;
  }
  __init11() {
    this.isType = false;
  }
  __init12() {
    this.scopeDepth = 0;
  }
  __init13() {
    this.error = null;
  }
  snapshot() {
    return new pP(this.potentialArrowAt, this.noAnonFunctionType, this.inDisallowConditionalTypesContext, this.tokens.length, this.scopes.length, this.pos, this.type, this.contextualKeyword, this.start, this.end, this.isType, this.scopeDepth, this.error);
  }
  restoreFromSnapshot(s) {
    this.potentialArrowAt = s.potentialArrowAt, this.noAnonFunctionType = s.noAnonFunctionType, this.inDisallowConditionalTypesContext = s.inDisallowConditionalTypesContext, this.tokens.length = s.tokensLength, this.scopes.length = s.scopesLength, this.pos = s.pos, this.type = s.type, this.contextualKeyword = s.contextualKeyword, this.start = s.start, this.end = s.end, this.isType = s.isType, this.scopeDepth = s.scopeDepth, this.error = s.error;
  }
}
var Ge;
(function(a3) {
  a3[a3.backSpace = 8] = "backSpace";
  const o = 10;
  a3[a3.lineFeed = o] = "lineFeed";
  const b = 9;
  a3[a3.tab = b] = "tab";
  const A = 13;
  a3[a3.carriageReturn = A] = "carriageReturn";
  const R = 14;
  a3[a3.shiftOut = R] = "shiftOut";
  const P = 32;
  a3[a3.space = P] = "space";
  const t = 33;
  a3[a3.exclamationMark = t] = "exclamationMark";
  const l = 34;
  a3[a3.quotationMark = l] = "quotationMark";
  const n = 35;
  a3[a3.numberSign = n] = "numberSign";
  const u = 36;
  a3[a3.dollarSign = u] = "dollarSign";
  const c = 37;
  a3[a3.percentSign = c] = "percentSign";
  const e = 38;
  a3[a3.ampersand = e] = "ampersand";
  const r = 39;
  a3[a3.apostrophe = r] = "apostrophe";
  const f = 40;
  a3[a3.leftParenthesis = f] = "leftParenthesis";
  const y = 41;
  a3[a3.rightParenthesis = y] = "rightParenthesis";
  const S = 42;
  a3[a3.asterisk = S] = "asterisk";
  const T = 43;
  a3[a3.plusSign = T] = "plusSign";
  const d = 44;
  a3[a3.comma = d] = "comma";
  const p = 45;
  a3[a3.dash = p] = "dash";
  const h = 46;
  a3[a3.dot = h] = "dot";
  const m = 47;
  a3[a3.slash = m] = "slash";
  const E = 48;
  a3[a3.digit0 = E] = "digit0";
  const _ = 49;
  a3[a3.digit1 = _] = "digit1";
  const C = 50;
  a3[a3.digit2 = C] = "digit2";
  const w = 51;
  a3[a3.digit3 = w] = "digit3";
  const I = 52;
  a3[a3.digit4 = I] = "digit4";
  const D = 53;
  a3[a3.digit5 = D] = "digit5";
  const j = 54;
  a3[a3.digit6 = j] = "digit6";
  const L = 55;
  a3[a3.digit7 = L] = "digit7";
  const k = 56;
  a3[a3.digit8 = k] = "digit8";
  const N = 57;
  a3[a3.digit9 = N] = "digit9";
  const F = 58;
  a3[a3.colon = F] = "colon";
  const W = 59;
  a3[a3.semicolon = W] = "semicolon";
  const X = 60;
  a3[a3.lessThan = X] = "lessThan";
  const H = 61;
  a3[a3.equalsTo = H] = "equalsTo";
  const U = 62;
  a3[a3.greaterThan = U] = "greaterThan";
  const q = 63;
  a3[a3.questionMark = q] = "questionMark";
  const ee = 64;
  a3[a3.atSign = ee] = "atSign";
  const re = 65;
  a3[a3.uppercaseA = re] = "uppercaseA";
  const Y = 66;
  a3[a3.uppercaseB = Y] = "uppercaseB";
  const Z = 67;
  a3[a3.uppercaseC = Z] = "uppercaseC";
  const G = 68;
  a3[a3.uppercaseD = G] = "uppercaseD";
  const B = 69;
  a3[a3.uppercaseE = B] = "uppercaseE";
  const z = 70;
  a3[a3.uppercaseF = z] = "uppercaseF";
  const M = 71;
  a3[a3.uppercaseG = M] = "uppercaseG";
  const K = 72;
  a3[a3.uppercaseH = K] = "uppercaseH";
  const Q = 73;
  a3[a3.uppercaseI = Q] = "uppercaseI";
  const ie = 74;
  a3[a3.uppercaseJ = ie] = "uppercaseJ";
  const ue = 75;
  a3[a3.uppercaseK = ue] = "uppercaseK";
  const ge = 76;
  a3[a3.uppercaseL = ge] = "uppercaseL";
  const Te = 77;
  a3[a3.uppercaseM = Te] = "uppercaseM";
  const le = 78;
  a3[a3.uppercaseN = le] = "uppercaseN";
  const fe = 79;
  a3[a3.uppercaseO = fe] = "uppercaseO";
  const Pe = 80;
  a3[a3.uppercaseP = Pe] = "uppercaseP";
  const xe = 81;
  a3[a3.uppercaseQ = xe] = "uppercaseQ";
  const we = 82;
  a3[a3.uppercaseR = we] = "uppercaseR";
  const me = 83;
  a3[a3.uppercaseS = me] = "uppercaseS";
  const ye = 84;
  a3[a3.uppercaseT = ye] = "uppercaseT";
  const pe = 85;
  a3[a3.uppercaseU = pe] = "uppercaseU";
  const J = 86;
  a3[a3.uppercaseV = J] = "uppercaseV";
  const Ee = 87;
  a3[a3.uppercaseW = Ee] = "uppercaseW";
  const Me = 88;
  a3[a3.uppercaseX = Me] = "uppercaseX";
  const Ue = 89;
  a3[a3.uppercaseY = Ue] = "uppercaseY";
  const qe = 90;
  a3[a3.uppercaseZ = qe] = "uppercaseZ";
  const He = 91;
  a3[a3.leftSquareBracket = He] = "leftSquareBracket";
  const Ie = 92;
  a3[a3.backslash = Ie] = "backslash";
  const Re = 93;
  a3[a3.rightSquareBracket = Re] = "rightSquareBracket";
  const Be = 94;
  a3[a3.caret = Be] = "caret";
  const je = 95;
  a3[a3.underscore = je] = "underscore";
  const he = 96;
  a3[a3.graveAccent = he] = "graveAccent";
  const oe = 97;
  a3[a3.lowercaseA = oe] = "lowercaseA";
  const _e = 98;
  a3[a3.lowercaseB = _e] = "lowercaseB";
  const Ne = 99;
  a3[a3.lowercaseC = Ne] = "lowercaseC";
  const $e = 100;
  a3[a3.lowercaseD = $e] = "lowercaseD";
  const Xe = 101;
  a3[a3.lowercaseE = Xe] = "lowercaseE";
  const Je = 102;
  a3[a3.lowercaseF = Je] = "lowercaseF";
  const st = 103;
  a3[a3.lowercaseG = st] = "lowercaseG";
  const be = 104;
  a3[a3.lowercaseH = be] = "lowercaseH";
  const ke = 105;
  a3[a3.lowercaseI = ke] = "lowercaseI";
  const Ve = 106;
  a3[a3.lowercaseJ = Ve] = "lowercaseJ";
  const ze = 107;
  a3[a3.lowercaseK = ze] = "lowercaseK";
  const rt = 108;
  a3[a3.lowercaseL = rt] = "lowercaseL";
  const it = 109;
  a3[a3.lowercaseM = it] = "lowercaseM";
  const Ye = 110;
  a3[a3.lowercaseN = Ye] = "lowercaseN";
  const tt = 111;
  a3[a3.lowercaseO = tt] = "lowercaseO";
  const pt = 112;
  a3[a3.lowercaseP = pt] = "lowercaseP";
  const Et = 113;
  a3[a3.lowercaseQ = Et] = "lowercaseQ";
  const Qe = 114;
  a3[a3.lowercaseR = Qe] = "lowercaseR";
  const yt = 115;
  a3[a3.lowercaseS = yt] = "lowercaseS";
  const vt = 116;
  a3[a3.lowercaseT = vt] = "lowercaseT";
  const kt = 117;
  a3[a3.lowercaseU = kt] = "lowercaseU";
  const qt = 118;
  a3[a3.lowercaseV = qt] = "lowercaseV";
  const sn = 119;
  a3[a3.lowercaseW = sn] = "lowercaseW";
  const _n = 120;
  a3[a3.lowercaseX = _n] = "lowercaseX";
  const bn = 121;
  a3[a3.lowercaseY = bn] = "lowercaseY";
  const Kt = 122;
  a3[a3.lowercaseZ = Kt] = "lowercaseZ";
  const Jt = 123;
  a3[a3.leftCurlyBrace = Jt] = "leftCurlyBrace";
  const Ft = 124;
  a3[a3.verticalBar = Ft] = "verticalBar";
  const fn = 125;
  a3[a3.rightCurlyBrace = fn] = "rightCurlyBrace";
  const _t = 126;
  a3[a3.tilde = _t] = "tilde";
  const Xn = 160;
  a3[a3.nonBreakingSpace = Xn] = "nonBreakingSpace";
  const Jn = 5760;
  a3[a3.oghamSpaceMark = Jn] = "oghamSpaceMark";
  const rr = 8232;
  a3[a3.lineSeparator = rr] = "lineSeparator";
  const sr = 8233;
  a3[a3.paragraphSeparator = sr] = "paragraphSeparator";
})(Ge || (Ge = {}));
let bo, nn, an, te, mt, Hm;
function vi() {
  return Hm++;
}
function dP(a3) {
  if ("pos" in a3) {
    const s = hP(a3.pos);
    a3.message += ` (${s.line}:${s.column})`, a3.loc = s;
  }
  return a3;
}
class fP {
  constructor(s, o) {
    this.line = s, this.column = o;
  }
}
function hP(a3) {
  let s = 1, o = 1;
  for (let b = 0; b < a3; b++) mt.charCodeAt(b) === Ge.lineFeed ? (s++, o = 1) : o++;
  return new fP(s, o);
}
function mP(a3, s, o, b) {
  mt = a3, te = new tr(), Hm = 1, bo = s, nn = o, an = b;
}
function It(a3) {
  return te.contextualKeyword === a3;
}
function kc(a3) {
  const s = Mi();
  return s.type === x.name && s.contextualKeyword === a3;
}
function Mn(a3) {
  return te.contextualKeyword === a3 && et(x.name);
}
function Nn(a3) {
  Mn(a3) || Wt();
}
function mr() {
  return Ae(x.eof) || Ae(x.braceR) || nr();
}
function nr() {
  const a3 = te.tokens[te.tokens.length - 1], s = a3 ? a3.end : 0;
  for (let o = s; o < te.start; o++) {
    const b = mt.charCodeAt(o);
    if (b === Ge.lineFeed || b === Ge.carriageReturn || b === 8232 || b === 8233) return true;
  }
  return false;
}
function Gm() {
  const a3 = Oc();
  for (let s = te.end; s < a3; s++) {
    const o = mt.charCodeAt(s);
    if (o === Ge.lineFeed || o === Ge.carriageReturn || o === 8232 || o === 8233) return true;
  }
  return false;
}
function Hr() {
  return et(x.semi) || mr();
}
function Sn() {
  Hr() || Wt('Unexpected token, expected ";"');
}
function ot(a3) {
  et(a3) || Wt(`Unexpected token, expected "${Wm(a3)}"`);
}
function Wt(a3 = "Unexpected token", s = te.start) {
  if (te.error) return;
  const o = new SyntaxError(a3);
  o.pos = s, te.error = o, te.pos = mt.length, Vt(x.eof);
}
const zm = [9, 11, 12, Ge.space, Ge.nonBreakingSpace, Ge.oghamSpaceMark, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], Rd = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Km = new Uint8Array(65536);
for (const a3 of zm) Km[a3] = 1;
function yP(a3) {
  if (a3 < 48) return a3 === 36;
  if (a3 < 58) return true;
  if (a3 < 65) return false;
  if (a3 < 91) return true;
  if (a3 < 97) return a3 === 95;
  if (a3 < 123) return true;
  if (a3 < 128) return false;
  throw new Error("Should not be called with non-ASCII char code.");
}
const jr = new Uint8Array(65536);
for (let a3 = 0; a3 < 128; a3++) jr[a3] = yP(a3) ? 1 : 0;
for (let a3 = 128; a3 < 65536; a3++) jr[a3] = 1;
for (const a3 of zm) jr[a3] = 0;
jr[8232] = 0;
jr[8233] = 0;
const Fi = jr.slice();
for (let a3 = Ge.digit0; a3 <= Ge.digit9; a3++) Fi[a3] = 0;
const jd = new Int32Array([-1, 27, 783, 918, 1755, 2376, 2862, 3483, -1, 3699, -1, 4617, 4752, 4833, 5130, 5508, 5940, -1, 6480, 6939, 7749, 8181, 8451, 8613, -1, 8829, -1, -1, -1, 54, 243, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 432, -1, -1, -1, 675, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 135, -1, -1, -1, -1, -1, -1, -1, -1, -1, 162, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 189, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 216, -1, -1, -1, -1, -1, -1, Fe._abstract << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 270, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 297, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 324, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 351, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 378, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 405, -1, -1, -1, -1, -1, -1, -1, -1, Fe._accessor << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._as << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 459, -1, -1, -1, -1, -1, 594, -1, -1, -1, -1, -1, -1, 486, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 513, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 540, -1, -1, -1, -1, -1, -1, Fe._assert << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 567, -1, -1, -1, -1, -1, -1, -1, Fe._asserts << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 621, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 648, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._async << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 702, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 729, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 756, -1, -1, -1, -1, -1, -1, Fe._await << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 810, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 837, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 864, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 891, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._break << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 945, -1, -1, -1, -1, -1, -1, 1107, -1, -1, -1, 1242, -1, -1, 1350, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 972, 1026, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 999, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._case << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1053, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1080, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._catch << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1134, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1161, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1188, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1215, -1, -1, -1, -1, -1, -1, -1, Fe._checks << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1269, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1296, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1323, -1, -1, -1, -1, -1, -1, -1, (x._class << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1377, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1404, 1620, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1431, -1, -1, -1, -1, -1, -1, (x._const << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1458, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1485, -1, -1, -1, -1, -1, -1, -1, -1, 1512, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1539, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1566, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1593, -1, -1, -1, -1, -1, -1, -1, -1, Fe._constructor << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1647, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1674, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1701, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1728, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._continue << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1782, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2349, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1809, 1971, -1, -1, 2106, -1, -1, -1, -1, -1, 2241, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1836, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1863, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1890, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1917, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1944, -1, -1, -1, -1, -1, -1, -1, -1, (x._debugger << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1998, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2025, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2052, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2079, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._declare << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2133, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2160, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2187, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2214, -1, -1, -1, -1, -1, -1, (x._default << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2268, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2295, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2322, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._delete << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._do << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2403, -1, 2484, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2565, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2430, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2457, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._else << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2511, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2538, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._enum << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2592, -1, -1, -1, 2727, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2619, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2646, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2673, -1, -1, -1, -1, -1, -1, (x._export << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2700, -1, -1, -1, -1, -1, -1, -1, Fe._exports << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2754, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2781, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2808, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2835, -1, -1, -1, -1, -1, -1, -1, (x._extends << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2889, -1, -1, -1, -1, -1, -1, -1, 2997, -1, -1, -1, -1, -1, 3159, -1, -1, 3213, -1, -1, 3294, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2916, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2943, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2970, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._false << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3024, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3051, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3078, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3105, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3132, -1, (x._finally << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3186, -1, -1, -1, -1, -1, -1, -1, -1, (x._for << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3240, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3267, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._from << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3321, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3348, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3375, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3402, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3429, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3456, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._function << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3510, -1, -1, -1, -1, -1, -1, 3564, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3537, -1, -1, -1, -1, -1, -1, Fe._get << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3591, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3618, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3645, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3672, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._global << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3726, -1, -1, -1, -1, -1, -1, 3753, 4077, -1, -1, -1, -1, 4590, -1, -1, -1, -1, -1, -1, -1, (x._if << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3780, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3807, -1, -1, 3996, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3834, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3861, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3888, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3915, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3942, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3969, -1, -1, -1, -1, -1, -1, -1, Fe._implements << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4023, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4050, -1, -1, -1, -1, -1, -1, (x._import << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._in << 1) + 1, -1, -1, -1, -1, -1, 4104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4185, 4401, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4131, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4158, -1, -1, -1, -1, -1, -1, -1, -1, Fe._infer << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4212, -1, -1, -1, -1, -1, -1, -1, 4239, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4266, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4293, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4320, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4347, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4374, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._instanceof << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4428, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4455, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4482, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4509, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4536, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4563, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._interface << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._is << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4644, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4671, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4698, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4725, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._keyof << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4779, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4806, -1, -1, -1, -1, -1, -1, (x._let << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4860, -1, -1, -1, -1, -1, 4995, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4887, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4914, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4941, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4968, -1, -1, -1, -1, -1, -1, -1, Fe._mixins << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5022, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5049, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5076, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5103, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._module << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5157, -1, -1, -1, 5373, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5427, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5184, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5211, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5238, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5265, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5292, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5319, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5346, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._namespace << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5400, -1, -1, -1, (x._new << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5454, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5481, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._null << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5535, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5562, -1, -1, -1, -1, 5697, 5751, -1, -1, -1, -1, Fe._of << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5589, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5616, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5643, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5670, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._opaque << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5724, -1, -1, -1, -1, -1, -1, Fe._out << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5778, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5805, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5832, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5859, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5886, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5913, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._override << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5967, -1, -1, 6345, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5994, -1, -1, -1, -1, -1, 6129, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6021, -1, -1, -1, -1, -1, 6048, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6075, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6102, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._private << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6156, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6183, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6318, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6210, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6237, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6264, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6291, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._protected << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._proto << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6372, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6399, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6426, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6453, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._public << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6507, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6534, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6696, -1, -1, 6831, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6561, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6588, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6615, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6642, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6669, -1, Fe._readonly << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6723, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6750, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6777, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6804, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._require << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6858, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6885, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6912, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._return << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6966, -1, -1, -1, 7182, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7236, 7371, -1, 7479, -1, 7614, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6993, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7020, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7047, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7074, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7101, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7128, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7155, -1, -1, -1, -1, -1, -1, -1, Fe._satisfies << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7209, -1, -1, -1, -1, -1, -1, Fe._set << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7263, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7290, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7317, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7344, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._static << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7398, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7425, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7452, -1, -1, -1, -1, -1, -1, -1, -1, (x._super << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7506, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7533, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7560, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7587, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._switch << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7641, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7668, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7695, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7722, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._symbol << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7776, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7938, -1, -1, -1, -1, -1, -1, 8046, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7803, -1, -1, -1, -1, -1, -1, -1, -1, 7857, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7830, -1, -1, -1, -1, -1, -1, -1, (x._this << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7884, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7911, -1, -1, -1, (x._throw << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7965, -1, -1, -1, 8019, -1, -1, -1, -1, -1, -1, 7992, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._true << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._try << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8073, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8100, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._type << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8127, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8154, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._typeof << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8208, -1, -1, -1, -1, 8343, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8262, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8289, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8316, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._unique << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8370, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8397, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8424, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, Fe._using << 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8478, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8532, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8505, -1, -1, -1, -1, -1, -1, -1, -1, (x._var << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8559, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8586, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._void << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8640, 8748, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8667, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8694, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8721, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._while << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8775, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8802, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._with << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8856, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8883, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8910, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8937, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, (x._yield << 1) + 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]);
function bP() {
  let a3 = 0, s = 0, o = te.pos;
  for (; o < mt.length && (s = mt.charCodeAt(o), !(s < Ge.lowercaseA || s > Ge.lowercaseZ)); ) {
    const A = jd[a3 + (s - Ge.lowercaseA) + 1];
    if (A === -1) break;
    a3 = A, o++;
  }
  const b = jd[a3];
  if (b > -1 && !jr[s]) {
    te.pos = o, b & 1 ? Vt(b >>> 1) : Vt(x.name, b >>> 1);
    return;
  }
  for (; o < mt.length; ) {
    const A = mt.charCodeAt(o);
    if (jr[A]) o++;
    else if (A === Ge.backslash) {
      if (o += 2, mt.charCodeAt(o) === Ge.leftCurlyBrace) {
        for (; o < mt.length && mt.charCodeAt(o) !== Ge.rightCurlyBrace; ) o++;
        o++;
      }
    } else if (A === Ge.atSign && mt.charCodeAt(o + 1) === Ge.atSign) o += 2;
    else break;
  }
  te.pos = o, Vt(x.name);
}
var Rt;
(function(a3) {
  a3[a3.Access = 0] = "Access";
  const o = 1;
  a3[a3.ExportAccess = o] = "ExportAccess";
  const b = o + 1;
  a3[a3.TopLevelDeclaration = b] = "TopLevelDeclaration";
  const A = b + 1;
  a3[a3.FunctionScopedDeclaration = A] = "FunctionScopedDeclaration";
  const R = A + 1;
  a3[a3.BlockScopedDeclaration = R] = "BlockScopedDeclaration";
  const P = R + 1;
  a3[a3.ObjectShorthandTopLevelDeclaration = P] = "ObjectShorthandTopLevelDeclaration";
  const t = P + 1;
  a3[a3.ObjectShorthandFunctionScopedDeclaration = t] = "ObjectShorthandFunctionScopedDeclaration";
  const l = t + 1;
  a3[a3.ObjectShorthandBlockScopedDeclaration = l] = "ObjectShorthandBlockScopedDeclaration";
  const n = l + 1;
  a3[a3.ObjectShorthand = n] = "ObjectShorthand";
  const u = n + 1;
  a3[a3.ImportDeclaration = u] = "ImportDeclaration";
  const c = u + 1;
  a3[a3.ObjectKey = c] = "ObjectKey";
  const e = c + 1;
  a3[a3.ImportAccess = e] = "ImportAccess";
})(Rt || (Rt = {}));
var Nr;
(function(a3) {
  a3[a3.NoChildren = 0] = "NoChildren";
  const o = 1;
  a3[a3.OneChild = o] = "OneChild";
  const b = o + 1;
  a3[a3.StaticChildren = b] = "StaticChildren";
  const A = b + 1;
  a3[a3.KeyAfterPropSpread = A] = "KeyAfterPropSpread";
})(Nr || (Nr = {}));
function qm(a3) {
  const s = a3.identifierRole;
  return s === Rt.TopLevelDeclaration || s === Rt.FunctionScopedDeclaration || s === Rt.BlockScopedDeclaration || s === Rt.ObjectShorthandTopLevelDeclaration || s === Rt.ObjectShorthandFunctionScopedDeclaration || s === Rt.ObjectShorthandBlockScopedDeclaration;
}
function gP(a3) {
  const s = a3.identifierRole;
  return s === Rt.FunctionScopedDeclaration || s === Rt.BlockScopedDeclaration || s === Rt.ObjectShorthandFunctionScopedDeclaration || s === Rt.ObjectShorthandBlockScopedDeclaration;
}
function Ym(a3) {
  const s = a3.identifierRole;
  return s === Rt.TopLevelDeclaration || s === Rt.ObjectShorthandTopLevelDeclaration || s === Rt.ImportDeclaration;
}
function vP(a3) {
  const s = a3.identifierRole;
  return s === Rt.TopLevelDeclaration || s === Rt.BlockScopedDeclaration || s === Rt.ObjectShorthandTopLevelDeclaration || s === Rt.ObjectShorthandBlockScopedDeclaration;
}
function EP(a3) {
  const s = a3.identifierRole;
  return s === Rt.FunctionScopedDeclaration || s === Rt.ObjectShorthandFunctionScopedDeclaration;
}
function SP(a3) {
  return a3.identifierRole === Rt.ObjectShorthandTopLevelDeclaration || a3.identifierRole === Rt.ObjectShorthandBlockScopedDeclaration || a3.identifierRole === Rt.ObjectShorthandFunctionScopedDeclaration;
}
class go {
  constructor() {
    this.type = te.type, this.contextualKeyword = te.contextualKeyword, this.start = te.start, this.end = te.end, this.scopeDepth = te.scopeDepth, this.isType = te.isType, this.identifierRole = null, this.jsxRole = null, this.shadowsGlobal = false, this.isAsyncOperation = false, this.contextId = null, this.rhsEndIndex = null, this.isExpression = false, this.numNullishCoalesceStarts = 0, this.numNullishCoalesceEnds = 0, this.isOptionalChainStart = false, this.isOptionalChainEnd = false, this.subscriptStartIndex = null, this.nullishStartIndex = null;
  }
}
function lt() {
  te.tokens.push(new go()), Zm();
}
function ps() {
  te.tokens.push(new go()), te.start = te.pos, MP();
}
function _P() {
  te.type === x.assign && --te.pos, jP();
}
function Gt(a3) {
  for (let o = te.tokens.length - a3; o < te.tokens.length; o++) te.tokens[o].isType = true;
  const s = te.isType;
  return te.isType = true, s;
}
function Ht(a3) {
  te.isType = a3;
}
function et(a3) {
  return Ae(a3) ? (lt(), true) : false;
}
function Xm(a3) {
  const s = te.isType;
  te.isType = true, et(a3), te.isType = s;
}
function Ae(a3) {
  return te.type === a3;
}
function Cn() {
  const a3 = te.snapshot();
  lt();
  const s = te.type;
  return te.restoreFromSnapshot(a3), s;
}
class TP {
  constructor(s, o) {
    this.type = s, this.contextualKeyword = o;
  }
}
function Mi() {
  const a3 = te.snapshot();
  lt();
  const s = te.type, o = te.contextualKeyword;
  return te.restoreFromSnapshot(a3), new TP(s, o);
}
function Oc() {
  return Jm(te.pos);
}
function Jm(a3) {
  Rd.lastIndex = a3;
  const s = Rd.exec(mt);
  return a3 + s[0].length;
}
function Qm() {
  return mt.charCodeAt(Oc());
}
function Zm() {
  if (ty(), te.start = te.pos, te.pos >= mt.length) {
    const a3 = te.tokens;
    a3.length >= 2 && a3[a3.length - 1].start >= mt.length && a3[a3.length - 2].start >= mt.length && Wt("Unexpectedly reached the end of input."), Vt(x.eof);
    return;
  }
  wP(mt.charCodeAt(te.pos));
}
function wP(a3) {
  Fi[a3] || a3 === Ge.backslash || a3 === Ge.atSign && mt.charCodeAt(te.pos + 1) === Ge.atSign ? bP() : sy(a3);
}
function PP() {
  for (; mt.charCodeAt(te.pos) !== Ge.asterisk || mt.charCodeAt(te.pos + 1) !== Ge.slash; ) if (te.pos++, te.pos > mt.length) {
    Wt("Unterminated comment", te.pos - 2);
    return;
  }
  te.pos += 2;
}
function ey(a3) {
  let s = mt.charCodeAt(te.pos += a3);
  if (te.pos < mt.length) for (; s !== Ge.lineFeed && s !== Ge.carriageReturn && s !== Ge.lineSeparator && s !== Ge.paragraphSeparator && ++te.pos < mt.length; ) s = mt.charCodeAt(te.pos);
}
function ty() {
  for (; te.pos < mt.length; ) {
    const a3 = mt.charCodeAt(te.pos);
    switch (a3) {
      case Ge.carriageReturn:
        mt.charCodeAt(te.pos + 1) === Ge.lineFeed && ++te.pos;
      case Ge.lineFeed:
      case Ge.lineSeparator:
      case Ge.paragraphSeparator:
        ++te.pos;
        break;
      case Ge.slash:
        switch (mt.charCodeAt(te.pos + 1)) {
          case Ge.asterisk:
            te.pos += 2, PP();
            break;
          case Ge.slash:
            ey(2);
            break;
          default:
            return;
        }
        break;
      default:
        if (Km[a3]) ++te.pos;
        else return;
    }
  }
}
function Vt(a3, s = Fe.NONE) {
  te.end = te.pos, te.type = a3, te.contextualKeyword = s;
}
function xP() {
  const a3 = mt.charCodeAt(te.pos + 1);
  if (a3 >= Ge.digit0 && a3 <= Ge.digit9) {
    iy(true);
    return;
  }
  a3 === Ge.dot && mt.charCodeAt(te.pos + 2) === Ge.dot ? (te.pos += 3, Vt(x.ellipsis)) : (++te.pos, Vt(x.dot));
}
function AP() {
  mt.charCodeAt(te.pos + 1) === Ge.equalsTo ? cn(x.assign, 2) : cn(x.slash, 1);
}
function CP(a3) {
  let s = a3 === Ge.asterisk ? x.star : x.modulo, o = 1, b = mt.charCodeAt(te.pos + 1);
  a3 === Ge.asterisk && b === Ge.asterisk && (o++, b = mt.charCodeAt(te.pos + 2), s = x.exponent), b === Ge.equalsTo && mt.charCodeAt(te.pos + 2) !== Ge.greaterThan && (o++, s = x.assign), cn(s, o);
}
function IP(a3) {
  const s = mt.charCodeAt(te.pos + 1);
  if (s === a3) {
    mt.charCodeAt(te.pos + 2) === Ge.equalsTo ? cn(x.assign, 3) : cn(a3 === Ge.verticalBar ? x.logicalOR : x.logicalAND, 2);
    return;
  }
  if (a3 === Ge.verticalBar) {
    if (s === Ge.greaterThan) {
      cn(x.pipeline, 2);
      return;
    } else if (s === Ge.rightCurlyBrace && an) {
      cn(x.braceBarR, 2);
      return;
    }
  }
  if (s === Ge.equalsTo) {
    cn(x.assign, 2);
    return;
  }
  cn(a3 === Ge.verticalBar ? x.bitwiseOR : x.bitwiseAND, 1);
}
function kP() {
  mt.charCodeAt(te.pos + 1) === Ge.equalsTo ? cn(x.assign, 2) : cn(x.bitwiseXOR, 1);
}
function OP(a3) {
  const s = mt.charCodeAt(te.pos + 1);
  if (s === a3) {
    cn(x.preIncDec, 2);
    return;
  }
  s === Ge.equalsTo ? cn(x.assign, 2) : a3 === Ge.plusSign ? cn(x.plus, 1) : cn(x.minus, 1);
}
function DP() {
  const a3 = mt.charCodeAt(te.pos + 1);
  if (a3 === Ge.lessThan) {
    if (mt.charCodeAt(te.pos + 2) === Ge.equalsTo) {
      cn(x.assign, 3);
      return;
    }
    te.isType ? cn(x.lessThan, 1) : cn(x.bitShiftL, 2);
    return;
  }
  a3 === Ge.equalsTo ? cn(x.relationalOrEqual, 2) : cn(x.lessThan, 1);
}
function ny() {
  if (te.isType) {
    cn(x.greaterThan, 1);
    return;
  }
  const a3 = mt.charCodeAt(te.pos + 1);
  if (a3 === Ge.greaterThan) {
    const s = mt.charCodeAt(te.pos + 2) === Ge.greaterThan ? 3 : 2;
    if (mt.charCodeAt(te.pos + s) === Ge.equalsTo) {
      cn(x.assign, s + 1);
      return;
    }
    cn(x.bitShiftR, s);
    return;
  }
  a3 === Ge.equalsTo ? cn(x.relationalOrEqual, 2) : cn(x.greaterThan, 1);
}
function ry() {
  te.type === x.greaterThan && (te.pos -= 1, ny());
}
function NP(a3) {
  const s = mt.charCodeAt(te.pos + 1);
  if (s === Ge.equalsTo) {
    cn(x.equality, mt.charCodeAt(te.pos + 2) === Ge.equalsTo ? 3 : 2);
    return;
  }
  if (a3 === Ge.equalsTo && s === Ge.greaterThan) {
    te.pos += 2, Vt(x.arrow);
    return;
  }
  cn(a3 === Ge.equalsTo ? x.eq : x.bang, 1);
}
function RP() {
  const a3 = mt.charCodeAt(te.pos + 1), s = mt.charCodeAt(te.pos + 2);
  a3 === Ge.questionMark && !(an && te.isType) ? s === Ge.equalsTo ? cn(x.assign, 3) : cn(x.nullishCoalescing, 2) : a3 === Ge.dot && !(s >= Ge.digit0 && s <= Ge.digit9) ? (te.pos += 2, Vt(x.questionDot)) : (++te.pos, Vt(x.question));
}
function sy(a3) {
  switch (a3) {
    case Ge.numberSign:
      ++te.pos, Vt(x.hash);
      return;
    case Ge.dot:
      xP();
      return;
    case Ge.leftParenthesis:
      ++te.pos, Vt(x.parenL);
      return;
    case Ge.rightParenthesis:
      ++te.pos, Vt(x.parenR);
      return;
    case Ge.semicolon:
      ++te.pos, Vt(x.semi);
      return;
    case Ge.comma:
      ++te.pos, Vt(x.comma);
      return;
    case Ge.leftSquareBracket:
      ++te.pos, Vt(x.bracketL);
      return;
    case Ge.rightSquareBracket:
      ++te.pos, Vt(x.bracketR);
      return;
    case Ge.leftCurlyBrace:
      an && mt.charCodeAt(te.pos + 1) === Ge.verticalBar ? cn(x.braceBarL, 2) : (++te.pos, Vt(x.braceL));
      return;
    case Ge.rightCurlyBrace:
      ++te.pos, Vt(x.braceR);
      return;
    case Ge.colon:
      mt.charCodeAt(te.pos + 1) === Ge.colon ? cn(x.doubleColon, 2) : (++te.pos, Vt(x.colon));
      return;
    case Ge.questionMark:
      RP();
      return;
    case Ge.atSign:
      ++te.pos, Vt(x.at);
      return;
    case Ge.graveAccent:
      ++te.pos, Vt(x.backQuote);
      return;
    case Ge.digit0: {
      const s = mt.charCodeAt(te.pos + 1);
      if (s === Ge.lowercaseX || s === Ge.uppercaseX || s === Ge.lowercaseO || s === Ge.uppercaseO || s === Ge.lowercaseB || s === Ge.uppercaseB) {
        LP();
        return;
      }
    }
    case Ge.digit1:
    case Ge.digit2:
    case Ge.digit3:
    case Ge.digit4:
    case Ge.digit5:
    case Ge.digit6:
    case Ge.digit7:
    case Ge.digit8:
    case Ge.digit9:
      iy(false);
      return;
    case Ge.quotationMark:
    case Ge.apostrophe:
      FP(a3);
      return;
    case Ge.slash:
      AP();
      return;
    case Ge.percentSign:
    case Ge.asterisk:
      CP(a3);
      return;
    case Ge.verticalBar:
    case Ge.ampersand:
      IP(a3);
      return;
    case Ge.caret:
      kP();
      return;
    case Ge.plusSign:
    case Ge.dash:
      OP(a3);
      return;
    case Ge.lessThan:
      DP();
      return;
    case Ge.greaterThan:
      ny();
      return;
    case Ge.equalsTo:
    case Ge.exclamationMark:
      NP(a3);
      return;
    case Ge.tilde:
      cn(x.tilde, 1);
      return;
  }
  Wt(`Unexpected character '${String.fromCharCode(a3)}'`, te.pos);
}
function cn(a3, s) {
  te.pos += s, Vt(a3);
}
function jP() {
  const a3 = te.pos;
  let s = false, o = false;
  for (; ; ) {
    if (te.pos >= mt.length) {
      Wt("Unterminated regular expression", a3);
      return;
    }
    const b = mt.charCodeAt(te.pos);
    if (s) s = false;
    else {
      if (b === Ge.leftSquareBracket) o = true;
      else if (b === Ge.rightSquareBracket && o) o = false;
      else if (b === Ge.slash && !o) break;
      s = b === Ge.backslash;
    }
    ++te.pos;
  }
  ++te.pos, BP(), Vt(x.regexp);
}
function Zo() {
  for (; ; ) {
    const a3 = mt.charCodeAt(te.pos);
    if (a3 >= Ge.digit0 && a3 <= Ge.digit9 || a3 === Ge.underscore) te.pos++;
    else break;
  }
}
function LP() {
  for (te.pos += 2; ; ) {
    const s = mt.charCodeAt(te.pos);
    if (s >= Ge.digit0 && s <= Ge.digit9 || s >= Ge.lowercaseA && s <= Ge.lowercaseF || s >= Ge.uppercaseA && s <= Ge.uppercaseF || s === Ge.underscore) te.pos++;
    else break;
  }
  mt.charCodeAt(te.pos) === Ge.lowercaseN ? (++te.pos, Vt(x.bigint)) : Vt(x.num);
}
function iy(a3) {
  let s = false, o = false;
  a3 || Zo();
  let b = mt.charCodeAt(te.pos);
  if (b === Ge.dot && (++te.pos, Zo(), b = mt.charCodeAt(te.pos)), (b === Ge.uppercaseE || b === Ge.lowercaseE) && (b = mt.charCodeAt(++te.pos), (b === Ge.plusSign || b === Ge.dash) && ++te.pos, Zo(), b = mt.charCodeAt(te.pos)), b === Ge.lowercaseN ? (++te.pos, s = true) : b === Ge.lowercaseM && (++te.pos, o = true), s) {
    Vt(x.bigint);
    return;
  }
  if (o) {
    Vt(x.decimal);
    return;
  }
  Vt(x.num);
}
function FP(a3) {
  for (te.pos++; ; ) {
    if (te.pos >= mt.length) {
      Wt("Unterminated string constant");
      return;
    }
    const s = mt.charCodeAt(te.pos);
    if (s === Ge.backslash) te.pos++;
    else if (s === a3) break;
    te.pos++;
  }
  te.pos++, Vt(x.string);
}
function MP() {
  for (; ; ) {
    if (te.pos >= mt.length) {
      Wt("Unterminated template");
      return;
    }
    const a3 = mt.charCodeAt(te.pos);
    if (a3 === Ge.graveAccent || a3 === Ge.dollarSign && mt.charCodeAt(te.pos + 1) === Ge.leftCurlyBrace) {
      if (te.pos === te.start && Ae(x.template)) if (a3 === Ge.dollarSign) {
        te.pos += 2, Vt(x.dollarBraceL);
        return;
      } else {
        ++te.pos, Vt(x.backQuote);
        return;
      }
      Vt(x.template);
      return;
    }
    a3 === Ge.backslash && te.pos++, te.pos++;
  }
}
function BP() {
  for (; te.pos < mt.length; ) {
    const a3 = mt.charCodeAt(te.pos);
    if (jr[a3]) te.pos++;
    else if (a3 === Ge.backslash) {
      if (te.pos += 2, mt.charCodeAt(te.pos) === Ge.leftCurlyBrace) {
        for (; te.pos < mt.length && mt.charCodeAt(te.pos) !== Ge.rightCurlyBrace; ) te.pos++;
        te.pos++;
      }
    } else break;
  }
}
function Ei(a3, s = a3.currentIndex()) {
  let o = s + 1;
  if (la(a3, o)) {
    const b = a3.identifierNameAtIndex(s);
    return { isType: false, leftName: b, rightName: b, endIndex: o };
  }
  if (o++, la(a3, o)) return { isType: true, leftName: null, rightName: null, endIndex: o };
  if (o++, la(a3, o)) return { isType: false, leftName: a3.identifierNameAtIndex(s), rightName: a3.identifierNameAtIndex(s + 2), endIndex: o };
  if (o++, la(a3, o)) return { isType: true, leftName: null, rightName: null, endIndex: o };
  throw new Error(`Unexpected import/export specifier at ${s}`);
}
function la(a3, s) {
  const o = a3.tokens[s];
  return o.type === x.braceR || o.type === x.comma;
}
const $P = /* @__PURE__ */ new Map([["quot", '"'], ["amp", "&"], ["apos", "'"], ["lt", "<"], ["gt", ">"], ["nbsp", "\xA0"], ["iexcl", "\xA1"], ["cent", "\xA2"], ["pound", "\xA3"], ["curren", "\xA4"], ["yen", "\xA5"], ["brvbar", "\xA6"], ["sect", "\xA7"], ["uml", "\xA8"], ["copy", "\xA9"], ["ordf", "\xAA"], ["laquo", "\xAB"], ["not", "\xAC"], ["shy", "\xAD"], ["reg", "\xAE"], ["macr", "\xAF"], ["deg", "\xB0"], ["plusmn", "\xB1"], ["sup2", "\xB2"], ["sup3", "\xB3"], ["acute", "\xB4"], ["micro", "\xB5"], ["para", "\xB6"], ["middot", "\xB7"], ["cedil", "\xB8"], ["sup1", "\xB9"], ["ordm", "\xBA"], ["raquo", "\xBB"], ["frac14", "\xBC"], ["frac12", "\xBD"], ["frac34", "\xBE"], ["iquest", "\xBF"], ["Agrave", "\xC0"], ["Aacute", "\xC1"], ["Acirc", "\xC2"], ["Atilde", "\xC3"], ["Auml", "\xC4"], ["Aring", "\xC5"], ["AElig", "\xC6"], ["Ccedil", "\xC7"], ["Egrave", "\xC8"], ["Eacute", "\xC9"], ["Ecirc", "\xCA"], ["Euml", "\xCB"], ["Igrave", "\xCC"], ["Iacute", "\xCD"], ["Icirc", "\xCE"], ["Iuml", "\xCF"], ["ETH", "\xD0"], ["Ntilde", "\xD1"], ["Ograve", "\xD2"], ["Oacute", "\xD3"], ["Ocirc", "\xD4"], ["Otilde", "\xD5"], ["Ouml", "\xD6"], ["times", "\xD7"], ["Oslash", "\xD8"], ["Ugrave", "\xD9"], ["Uacute", "\xDA"], ["Ucirc", "\xDB"], ["Uuml", "\xDC"], ["Yacute", "\xDD"], ["THORN", "\xDE"], ["szlig", "\xDF"], ["agrave", "\xE0"], ["aacute", "\xE1"], ["acirc", "\xE2"], ["atilde", "\xE3"], ["auml", "\xE4"], ["aring", "\xE5"], ["aelig", "\xE6"], ["ccedil", "\xE7"], ["egrave", "\xE8"], ["eacute", "\xE9"], ["ecirc", "\xEA"], ["euml", "\xEB"], ["igrave", "\xEC"], ["iacute", "\xED"], ["icirc", "\xEE"], ["iuml", "\xEF"], ["eth", "\xF0"], ["ntilde", "\xF1"], ["ograve", "\xF2"], ["oacute", "\xF3"], ["ocirc", "\xF4"], ["otilde", "\xF5"], ["ouml", "\xF6"], ["divide", "\xF7"], ["oslash", "\xF8"], ["ugrave", "\xF9"], ["uacute", "\xFA"], ["ucirc", "\xFB"], ["uuml", "\xFC"], ["yacute", "\xFD"], ["thorn", "\xFE"], ["yuml", "\xFF"], ["OElig", "\u0152"], ["oelig", "\u0153"], ["Scaron", "\u0160"], ["scaron", "\u0161"], ["Yuml", "\u0178"], ["fnof", "\u0192"], ["circ", "\u02C6"], ["tilde", "\u02DC"], ["Alpha", "\u0391"], ["Beta", "\u0392"], ["Gamma", "\u0393"], ["Delta", "\u0394"], ["Epsilon", "\u0395"], ["Zeta", "\u0396"], ["Eta", "\u0397"], ["Theta", "\u0398"], ["Iota", "\u0399"], ["Kappa", "\u039A"], ["Lambda", "\u039B"], ["Mu", "\u039C"], ["Nu", "\u039D"], ["Xi", "\u039E"], ["Omicron", "\u039F"], ["Pi", "\u03A0"], ["Rho", "\u03A1"], ["Sigma", "\u03A3"], ["Tau", "\u03A4"], ["Upsilon", "\u03A5"], ["Phi", "\u03A6"], ["Chi", "\u03A7"], ["Psi", "\u03A8"], ["Omega", "\u03A9"], ["alpha", "\u03B1"], ["beta", "\u03B2"], ["gamma", "\u03B3"], ["delta", "\u03B4"], ["epsilon", "\u03B5"], ["zeta", "\u03B6"], ["eta", "\u03B7"], ["theta", "\u03B8"], ["iota", "\u03B9"], ["kappa", "\u03BA"], ["lambda", "\u03BB"], ["mu", "\u03BC"], ["nu", "\u03BD"], ["xi", "\u03BE"], ["omicron", "\u03BF"], ["pi", "\u03C0"], ["rho", "\u03C1"], ["sigmaf", "\u03C2"], ["sigma", "\u03C3"], ["tau", "\u03C4"], ["upsilon", "\u03C5"], ["phi", "\u03C6"], ["chi", "\u03C7"], ["psi", "\u03C8"], ["omega", "\u03C9"], ["thetasym", "\u03D1"], ["upsih", "\u03D2"], ["piv", "\u03D6"], ["ensp", "\u2002"], ["emsp", "\u2003"], ["thinsp", "\u2009"], ["zwnj", "\u200C"], ["zwj", "\u200D"], ["lrm", "\u200E"], ["rlm", "\u200F"], ["ndash", "\u2013"], ["mdash", "\u2014"], ["lsquo", "\u2018"], ["rsquo", "\u2019"], ["sbquo", "\u201A"], ["ldquo", "\u201C"], ["rdquo", "\u201D"], ["bdquo", "\u201E"], ["dagger", "\u2020"], ["Dagger", "\u2021"], ["bull", "\u2022"], ["hellip", "\u2026"], ["permil", "\u2030"], ["prime", "\u2032"], ["Prime", "\u2033"], ["lsaquo", "\u2039"], ["rsaquo", "\u203A"], ["oline", "\u203E"], ["frasl", "\u2044"], ["euro", "\u20AC"], ["image", "\u2111"], ["weierp", "\u2118"], ["real", "\u211C"], ["trade", "\u2122"], ["alefsym", "\u2135"], ["larr", "\u2190"], ["uarr", "\u2191"], ["rarr", "\u2192"], ["darr", "\u2193"], ["harr", "\u2194"], ["crarr", "\u21B5"], ["lArr", "\u21D0"], ["uArr", "\u21D1"], ["rArr", "\u21D2"], ["dArr", "\u21D3"], ["hArr", "\u21D4"], ["forall", "\u2200"], ["part", "\u2202"], ["exist", "\u2203"], ["empty", "\u2205"], ["nabla", "\u2207"], ["isin", "\u2208"], ["notin", "\u2209"], ["ni", "\u220B"], ["prod", "\u220F"], ["sum", "\u2211"], ["minus", "\u2212"], ["lowast", "\u2217"], ["radic", "\u221A"], ["prop", "\u221D"], ["infin", "\u221E"], ["ang", "\u2220"], ["and", "\u2227"], ["or", "\u2228"], ["cap", "\u2229"], ["cup", "\u222A"], ["int", "\u222B"], ["there4", "\u2234"], ["sim", "\u223C"], ["cong", "\u2245"], ["asymp", "\u2248"], ["ne", "\u2260"], ["equiv", "\u2261"], ["le", "\u2264"], ["ge", "\u2265"], ["sub", "\u2282"], ["sup", "\u2283"], ["nsub", "\u2284"], ["sube", "\u2286"], ["supe", "\u2287"], ["oplus", "\u2295"], ["otimes", "\u2297"], ["perp", "\u22A5"], ["sdot", "\u22C5"], ["lceil", "\u2308"], ["rceil", "\u2309"], ["lfloor", "\u230A"], ["rfloor", "\u230B"], ["lang", "\u2329"], ["rang", "\u232A"], ["loz", "\u25CA"], ["spades", "\u2660"], ["clubs", "\u2663"], ["hearts", "\u2665"], ["diams", "\u2666"]]);
function ay(a3) {
  const [s, o] = Ld(a3.jsxPragma || "React.createElement"), [b, A] = Ld(a3.jsxFragmentPragma || "React.Fragment");
  return { base: s, suffix: o, fragmentBase: b, fragmentSuffix: A };
}
function Ld(a3) {
  let s = a3.indexOf(".");
  return s === -1 && (s = a3.length), [a3.slice(0, s), a3.slice(s)];
}
class Fr {
  getPrefixCode() {
    return "";
  }
  getHoistedCode() {
    return "";
  }
  getSuffixCode() {
    return "";
  }
}
class _s extends Fr {
  __init() {
    this.lastLineNumber = 1;
  }
  __init2() {
    this.lastIndex = 0;
  }
  __init3() {
    this.filenameVarName = null;
  }
  __init4() {
    this.esmAutomaticImportNameResolutions = {};
  }
  __init5() {
    this.cjsAutomaticModuleNameResolutions = {};
  }
  constructor(s, o, b, A, R) {
    super(), this.rootTransformer = s, this.tokens = o, this.importProcessor = b, this.nameManager = A, this.options = R, _s.prototype.__init.call(this), _s.prototype.__init2.call(this), _s.prototype.__init3.call(this), _s.prototype.__init4.call(this), _s.prototype.__init5.call(this), this.jsxPragmaInfo = ay(R), this.isAutomaticRuntime = R.jsxRuntime === "automatic", this.jsxImportSource = R.jsxImportSource || "react";
  }
  process() {
    return this.tokens.matches1(x.jsxTagStart) ? (this.processJSXTag(), true) : false;
  }
  getPrefixCode() {
    let s = "";
    if (this.filenameVarName && (s += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`), this.isAutomaticRuntime) if (this.importProcessor) for (const [o, b] of Object.entries(this.cjsAutomaticModuleNameResolutions)) s += `var ${b} = require("${o}");`;
    else {
      const { createElement: o, ...b } = this.esmAutomaticImportNameResolutions;
      o && (s += `import {createElement as ${o}} from "${this.jsxImportSource}";`);
      const A = Object.entries(b).map(([R, P]) => `${R} as ${P}`).join(", ");
      if (A) {
        const R = this.jsxImportSource + (this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
        s += `import {${A}} from "${R}";`;
      }
    }
    return s;
  }
  processJSXTag() {
    const { jsxRole: s, start: o } = this.tokens.currentToken(), b = this.options.production ? null : this.getElementLocationCode(o);
    this.isAutomaticRuntime && s !== Nr.KeyAfterPropSpread ? this.transformTagToJSXFunc(b, s) : this.transformTagToCreateElement(b);
  }
  getElementLocationCode(s) {
    return `lineNumber: ${this.getLineNumberForIndex(s)}`;
  }
  getLineNumberForIndex(s) {
    const o = this.tokens.code;
    for (; this.lastIndex < s && this.lastIndex < o.length; ) o[this.lastIndex] === `
` && this.lastLineNumber++, this.lastIndex++;
    return this.lastLineNumber;
  }
  transformTagToJSXFunc(s, o) {
    const b = o === Nr.StaticChildren;
    this.tokens.replaceToken(this.getJSXFuncInvocationCode(b));
    let A = null;
    if (this.tokens.matches1(x.jsxTagEnd)) this.tokens.replaceToken(`${this.getFragmentCode()}, {`), this.processAutomaticChildrenAndEndProps(o);
    else {
      if (this.processTagIntro(), this.tokens.appendCode(", {"), A = this.processProps(true), this.tokens.matches2(x.slash, x.jsxTagEnd)) this.tokens.appendCode("}");
      else if (this.tokens.matches1(x.jsxTagEnd)) this.tokens.removeToken(), this.processAutomaticChildrenAndEndProps(o);
      else throw new Error("Expected either /> or > at the end of the tag.");
      A && this.tokens.appendCode(`, ${A}`);
    }
    for (this.options.production || (A === null && this.tokens.appendCode(", void 0"), this.tokens.appendCode(`, ${b}, ${this.getDevSource(s)}, this`)), this.tokens.removeInitialToken(); !this.tokens.matches1(x.jsxTagEnd); ) this.tokens.removeToken();
    this.tokens.replaceToken(")");
  }
  transformTagToCreateElement(s) {
    if (this.tokens.replaceToken(this.getCreateElementInvocationCode()), this.tokens.matches1(x.jsxTagEnd)) this.tokens.replaceToken(`${this.getFragmentCode()}, null`), this.processChildren(true);
    else if (this.processTagIntro(), this.processPropsObjectWithDevInfo(s), !this.tokens.matches2(x.slash, x.jsxTagEnd)) if (this.tokens.matches1(x.jsxTagEnd)) this.tokens.removeToken(), this.processChildren(true);
    else throw new Error("Expected either /> or > at the end of the tag.");
    for (this.tokens.removeInitialToken(); !this.tokens.matches1(x.jsxTagEnd); ) this.tokens.removeToken();
    this.tokens.replaceToken(")");
  }
  getJSXFuncInvocationCode(s) {
    return this.options.production ? s ? this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime") : this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime") : this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
  }
  getCreateElementInvocationCode() {
    if (this.isAutomaticRuntime) return this.claimAutoImportedFuncInvocation("createElement", "");
    {
      const { jsxPragmaInfo: s } = this;
      return `${this.importProcessor && this.importProcessor.getIdentifierReplacement(s.base) || s.base}${s.suffix}(`;
    }
  }
  getFragmentCode() {
    if (this.isAutomaticRuntime) return this.claimAutoImportedName("Fragment", this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
    {
      const { jsxPragmaInfo: s } = this;
      return (this.importProcessor && this.importProcessor.getIdentifierReplacement(s.fragmentBase) || s.fragmentBase) + s.fragmentSuffix;
    }
  }
  claimAutoImportedFuncInvocation(s, o) {
    const b = this.claimAutoImportedName(s, o);
    return this.importProcessor ? `${b}.call(void 0, ` : `${b}(`;
  }
  claimAutoImportedName(s, o) {
    if (this.importProcessor) {
      const b = this.jsxImportSource + o;
      return this.cjsAutomaticModuleNameResolutions[b] || (this.cjsAutomaticModuleNameResolutions[b] = this.importProcessor.getFreeIdentifierForPath(b)), `${this.cjsAutomaticModuleNameResolutions[b]}.${s}`;
    } else return this.esmAutomaticImportNameResolutions[s] || (this.esmAutomaticImportNameResolutions[s] = this.nameManager.claimFreeName(`_${s}`)), this.esmAutomaticImportNameResolutions[s];
  }
  processTagIntro() {
    let s = this.tokens.currentIndex() + 1;
    for (; this.tokens.tokens[s].isType || !this.tokens.matches2AtIndex(s - 1, x.jsxName, x.jsxName) && !this.tokens.matches2AtIndex(s - 1, x.greaterThan, x.jsxName) && !this.tokens.matches1AtIndex(s, x.braceL) && !this.tokens.matches1AtIndex(s, x.jsxTagEnd) && !this.tokens.matches2AtIndex(s, x.slash, x.jsxTagEnd); ) s++;
    if (s === this.tokens.currentIndex() + 1) {
      const o = this.tokens.identifierName();
      oy(o) && this.tokens.replaceToken(`'${o}'`);
    }
    for (; this.tokens.currentIndex() < s; ) this.rootTransformer.processToken();
  }
  processPropsObjectWithDevInfo(s) {
    const o = this.options.production ? "" : `__self: this, __source: ${this.getDevSource(s)}`;
    if (!this.tokens.matches1(x.jsxName) && !this.tokens.matches1(x.braceL)) {
      o ? this.tokens.appendCode(`, {${o}}`) : this.tokens.appendCode(", null");
      return;
    }
    this.tokens.appendCode(", {"), this.processProps(false), o ? this.tokens.appendCode(` ${o}}`) : this.tokens.appendCode("}");
  }
  processProps(s) {
    let o = null;
    for (; ; ) {
      if (this.tokens.matches2(x.jsxName, x.eq)) {
        const b = this.tokens.identifierName();
        if (s && b === "key") {
          o !== null && this.tokens.appendCode(o.replace(/[^\n]/g, "")), this.tokens.removeToken(), this.tokens.removeToken();
          const A = this.tokens.snapshot();
          this.processPropValue(), o = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(A);
          continue;
        } else this.processPropName(b), this.tokens.replaceToken(": "), this.processPropValue();
      } else if (this.tokens.matches1(x.jsxName)) {
        const b = this.tokens.identifierName();
        this.processPropName(b), this.tokens.appendCode(": true");
      } else if (this.tokens.matches1(x.braceL)) this.tokens.replaceToken(""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken("");
      else break;
      this.tokens.appendCode(",");
    }
    return o;
  }
  processPropName(s) {
    s.includes("-") ? this.tokens.replaceToken(`'${s}'`) : this.tokens.copyToken();
  }
  processPropValue() {
    this.tokens.matches1(x.braceL) ? (this.tokens.replaceToken(""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken("")) : this.tokens.matches1(x.jsxTagStart) ? this.processJSXTag() : this.processStringPropValue();
  }
  processStringPropValue() {
    const s = this.tokens.currentToken(), o = this.tokens.code.slice(s.start + 1, s.end - 1), b = Fd(o), A = VP(o);
    this.tokens.replaceToken(A + b);
  }
  processAutomaticChildrenAndEndProps(s) {
    s === Nr.StaticChildren ? (this.tokens.appendCode(" children: ["), this.processChildren(false), this.tokens.appendCode("]}")) : (s === Nr.OneChild && this.tokens.appendCode(" children: "), this.processChildren(false), this.tokens.appendCode("}"));
  }
  processChildren(s) {
    let o = s;
    for (; ; ) {
      if (this.tokens.matches2(x.jsxTagStart, x.slash)) return;
      let b = false;
      if (this.tokens.matches1(x.braceL)) this.tokens.matches2(x.braceL, x.braceR) ? (this.tokens.replaceToken(""), this.tokens.replaceToken("")) : (this.tokens.replaceToken(o ? ", " : ""), this.rootTransformer.processBalancedCode(), this.tokens.replaceToken(""), b = true);
      else if (this.tokens.matches1(x.jsxTagStart)) this.tokens.appendCode(o ? ", " : ""), this.processJSXTag(), b = true;
      else if (this.tokens.matches1(x.jsxText) || this.tokens.matches1(x.jsxEmptyText)) b = this.processChildTextElement(o);
      else throw new Error("Unexpected token when processing JSX children.");
      b && (o = true);
    }
  }
  processChildTextElement(s) {
    const o = this.tokens.currentToken(), b = this.tokens.code.slice(o.start, o.end), A = Fd(b), R = UP(b);
    return R === '""' ? (this.tokens.replaceToken(A), false) : (this.tokens.replaceToken(`${s ? ", " : ""}${R}${A}`), true);
  }
  getDevSource(s) {
    return `{fileName: ${this.getFilenameVarName()}, ${s}}`;
  }
  getFilenameVarName() {
    return this.filenameVarName || (this.filenameVarName = this.nameManager.claimFreeName("_jsxFileName")), this.filenameVarName;
  }
}
function oy(a3) {
  const s = a3.charCodeAt(0);
  return s >= Ge.lowercaseA && s <= Ge.lowercaseZ;
}
function UP(a3) {
  let s = "", o = "", b = false, A = false;
  for (let R = 0; R < a3.length; R++) {
    const P = a3[R];
    if (P === " " || P === "	" || P === "\r") b || (o += P);
    else if (P === `
`) o = "", b = true;
    else {
      if (A && b && (s += " "), s += o, o = "", P === "&") {
        const { entity: t, newI: l } = ly(a3, R + 1);
        R = l - 1, s += t;
      } else s += P;
      A = true, b = false;
    }
  }
  return b || (s += o), JSON.stringify(s);
}
function Fd(a3) {
  let s = 0, o = 0;
  for (const b of a3) b === `
` ? (s++, o = 0) : b === " " && o++;
  return `
`.repeat(s) + " ".repeat(o);
}
function VP(a3) {
  let s = "";
  for (let o = 0; o < a3.length; o++) {
    const b = a3[o];
    if (b === `
`) if (/\s/.test(a3[o + 1])) for (s += " "; o < a3.length && /\s/.test(a3[o + 1]); ) o++;
    else s += `
`;
    else if (b === "&") {
      const { entity: A, newI: R } = ly(a3, o + 1);
      s += A, o = R - 1;
    } else s += b;
  }
  return JSON.stringify(s);
}
function ly(a3, s) {
  let o = "", b = 0, A, R = s;
  if (a3[R] === "#") {
    let P = 10;
    R++;
    let t;
    if (a3[R] === "x") for (P = 16, R++, t = R; R < a3.length && HP(a3.charCodeAt(R)); ) R++;
    else for (t = R; R < a3.length && WP(a3.charCodeAt(R)); ) R++;
    if (a3[R] === ";") {
      const l = a3.slice(t, R);
      l && (R++, A = String.fromCodePoint(parseInt(l, P)));
    }
  } else for (; R < a3.length && b++ < 10; ) {
    const P = a3[R];
    if (R++, P === ";") {
      A = $P.get(o);
      break;
    }
    o += P;
  }
  return A ? { entity: A, newI: R } : { entity: "&", newI: s };
}
function WP(a3) {
  return a3 >= Ge.digit0 && a3 <= Ge.digit9;
}
function HP(a3) {
  return a3 >= Ge.digit0 && a3 <= Ge.digit9 || a3 >= Ge.lowercaseA && a3 <= Ge.lowercaseF || a3 >= Ge.uppercaseA && a3 <= Ge.uppercaseF;
}
function uy(a3, s) {
  const o = ay(s), b = /* @__PURE__ */ new Set();
  for (let A = 0; A < a3.tokens.length; A++) {
    const R = a3.tokens[A];
    if (R.type === x.name && !R.isType && (R.identifierRole === Rt.Access || R.identifierRole === Rt.ObjectShorthand || R.identifierRole === Rt.ExportAccess) && !R.shadowsGlobal && b.add(a3.identifierNameForToken(R)), R.type === x.jsxTagStart && b.add(o.base), R.type === x.jsxTagStart && A + 1 < a3.tokens.length && a3.tokens[A + 1].type === x.jsxTagEnd && (b.add(o.base), b.add(o.fragmentBase)), R.type === x.jsxName && R.identifierRole === Rt.Access) {
      const P = a3.identifierNameForToken(R);
      (!oy(P) || a3.tokens[A + 1].type === x.dot) && b.add(a3.identifierNameForToken(R));
    }
  }
  return b;
}
class Ts {
  __init() {
    this.nonTypeIdentifiers = /* @__PURE__ */ new Set();
  }
  __init2() {
    this.importInfoByPath = /* @__PURE__ */ new Map();
  }
  __init3() {
    this.importsToReplace = /* @__PURE__ */ new Map();
  }
  __init4() {
    this.identifierReplacements = /* @__PURE__ */ new Map();
  }
  __init5() {
    this.exportBindingsByLocalName = /* @__PURE__ */ new Map();
  }
  constructor(s, o, b, A, R, P, t) {
    this.nameManager = s, this.tokens = o, this.enableLegacyTypeScriptModuleInterop = b, this.options = A, this.isTypeScriptTransformEnabled = R, this.keepUnusedImports = P, this.helperManager = t, Ts.prototype.__init.call(this), Ts.prototype.__init2.call(this), Ts.prototype.__init3.call(this), Ts.prototype.__init4.call(this), Ts.prototype.__init5.call(this);
  }
  preprocessTokens() {
    for (let s = 0; s < this.tokens.tokens.length; s++) this.tokens.matches1AtIndex(s, x._import) && !this.tokens.matches3AtIndex(s, x._import, x.name, x.eq) && this.preprocessImportAtIndex(s), this.tokens.matches1AtIndex(s, x._export) && !this.tokens.matches2AtIndex(s, x._export, x.eq) && this.preprocessExportAtIndex(s);
    this.generateImportReplacements();
  }
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = uy(this.tokens, this.options);
    for (const [s, o] of this.importInfoByPath.entries()) {
      if (o.hasBareImport || o.hasStarExport || o.exportStarNames.length > 0 || o.namedExports.length > 0) continue;
      [...o.defaultNames, ...o.wildcardNames, ...o.namedImports.map(({ localName: A }) => A)].every((A) => this.shouldAutomaticallyElideImportedName(A)) && this.importsToReplace.set(s, "");
    }
  }
  shouldAutomaticallyElideImportedName(s) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(s);
  }
  generateImportReplacements() {
    for (const [s, o] of this.importInfoByPath.entries()) {
      const { defaultNames: b, wildcardNames: A, namedImports: R, namedExports: P, exportStarNames: t, hasStarExport: l } = o;
      if (b.length === 0 && A.length === 0 && R.length === 0 && P.length === 0 && t.length === 0 && !l) {
        this.importsToReplace.set(s, `require('${s}');`);
        continue;
      }
      const n = this.getFreeIdentifierForPath(s);
      let u;
      this.enableLegacyTypeScriptModuleInterop ? u = n : u = A.length > 0 ? A[0] : this.getFreeIdentifierForPath(s);
      let c = `var ${n} = require('${s}');`;
      if (A.length > 0) for (const e of A) {
        const r = this.enableLegacyTypeScriptModuleInterop ? n : `${this.helperManager.getHelperName("interopRequireWildcard")}(${n})`;
        c += ` var ${e} = ${r};`;
      }
      else t.length > 0 && u !== n ? c += ` var ${u} = ${this.helperManager.getHelperName("interopRequireWildcard")}(${n});` : b.length > 0 && u !== n && (c += ` var ${u} = ${this.helperManager.getHelperName("interopRequireDefault")}(${n});`);
      for (const { importedName: e, localName: r } of P) c += ` ${this.helperManager.getHelperName("createNamedExportFrom")}(${n}, '${r}', '${e}');`;
      for (const e of t) c += ` exports.${e} = ${u};`;
      l && (c += ` ${this.helperManager.getHelperName("createStarExport")}(${n});`), this.importsToReplace.set(s, c);
      for (const e of b) this.identifierReplacements.set(e, `${u}.default`);
      for (const { importedName: e, localName: r } of R) this.identifierReplacements.set(r, `${n}.${e}`);
    }
  }
  getFreeIdentifierForPath(s) {
    const o = s.split("/"), A = o[o.length - 1].replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${A}`);
  }
  preprocessImportAtIndex(s) {
    const o = [], b = [], A = [];
    if (s++, (this.tokens.matchesContextualAtIndex(s, Fe._type) || this.tokens.matches1AtIndex(s, x._typeof)) && !this.tokens.matches1AtIndex(s + 1, x.comma) && !this.tokens.matchesContextualAtIndex(s + 1, Fe._from) || this.tokens.matches1AtIndex(s, x.parenL)) return;
    if (this.tokens.matches1AtIndex(s, x.name) && (o.push(this.tokens.identifierNameAtIndex(s)), s++, this.tokens.matches1AtIndex(s, x.comma) && s++), this.tokens.matches1AtIndex(s, x.star) && (s += 2, b.push(this.tokens.identifierNameAtIndex(s)), s++), this.tokens.matches1AtIndex(s, x.braceL)) {
      const t = this.getNamedImports(s + 1);
      s = t.newIndex;
      for (const l of t.namedImports) l.importedName === "default" ? o.push(l.localName) : A.push(l);
    }
    if (this.tokens.matchesContextualAtIndex(s, Fe._from) && s++, !this.tokens.matches1AtIndex(s, x.string)) throw new Error("Expected string token at the end of import statement.");
    const R = this.tokens.stringValueAtIndex(s), P = this.getImportInfo(R);
    P.defaultNames.push(...o), P.wildcardNames.push(...b), P.namedImports.push(...A), o.length === 0 && b.length === 0 && A.length === 0 && (P.hasBareImport = true);
  }
  preprocessExportAtIndex(s) {
    if (this.tokens.matches2AtIndex(s, x._export, x._var) || this.tokens.matches2AtIndex(s, x._export, x._let) || this.tokens.matches2AtIndex(s, x._export, x._const)) this.preprocessVarExportAtIndex(s);
    else if (this.tokens.matches2AtIndex(s, x._export, x._function) || this.tokens.matches2AtIndex(s, x._export, x._class)) {
      const o = this.tokens.identifierNameAtIndex(s + 2);
      this.addExportBinding(o, o);
    } else if (this.tokens.matches3AtIndex(s, x._export, x.name, x._function)) {
      const o = this.tokens.identifierNameAtIndex(s + 3);
      this.addExportBinding(o, o);
    } else this.tokens.matches2AtIndex(s, x._export, x.braceL) ? this.preprocessNamedExportAtIndex(s) : this.tokens.matches2AtIndex(s, x._export, x.star) && this.preprocessExportStarAtIndex(s);
  }
  preprocessVarExportAtIndex(s) {
    let o = 0;
    for (let b = s + 2; ; b++) if (this.tokens.matches1AtIndex(b, x.braceL) || this.tokens.matches1AtIndex(b, x.dollarBraceL) || this.tokens.matches1AtIndex(b, x.bracketL)) o++;
    else if (this.tokens.matches1AtIndex(b, x.braceR) || this.tokens.matches1AtIndex(b, x.bracketR)) o--;
    else {
      if (o === 0 && !this.tokens.matches1AtIndex(b, x.name)) break;
      if (this.tokens.matches1AtIndex(1, x.eq)) {
        const A = this.tokens.currentToken().rhsEndIndex;
        if (A == null) throw new Error("Expected = token with an end index.");
        b = A - 1;
      } else {
        const A = this.tokens.tokens[b];
        if (qm(A)) {
          const R = this.tokens.identifierNameAtIndex(b);
          this.identifierReplacements.set(R, `exports.${R}`);
        }
      }
    }
  }
  preprocessNamedExportAtIndex(s) {
    s += 2;
    const { newIndex: o, namedImports: b } = this.getNamedImports(s);
    if (s = o, this.tokens.matchesContextualAtIndex(s, Fe._from)) s++;
    else {
      for (const { importedName: P, localName: t } of b) this.addExportBinding(P, t);
      return;
    }
    if (!this.tokens.matches1AtIndex(s, x.string)) throw new Error("Expected string token at the end of import statement.");
    const A = this.tokens.stringValueAtIndex(s);
    this.getImportInfo(A).namedExports.push(...b);
  }
  preprocessExportStarAtIndex(s) {
    let o = null;
    if (this.tokens.matches3AtIndex(s, x._export, x.star, x._as) ? (s += 3, o = this.tokens.identifierNameAtIndex(s), s += 2) : s += 3, !this.tokens.matches1AtIndex(s, x.string)) throw new Error("Expected string token at the end of star export statement.");
    const b = this.tokens.stringValueAtIndex(s), A = this.getImportInfo(b);
    o !== null ? A.exportStarNames.push(o) : A.hasStarExport = true;
  }
  getNamedImports(s) {
    const o = [];
    for (; ; ) {
      if (this.tokens.matches1AtIndex(s, x.braceR)) {
        s++;
        break;
      }
      const b = Ei(this.tokens, s);
      if (s = b.endIndex, b.isType || o.push({ importedName: b.leftName, localName: b.rightName }), this.tokens.matches2AtIndex(s, x.comma, x.braceR)) {
        s += 2;
        break;
      } else if (this.tokens.matches1AtIndex(s, x.braceR)) {
        s++;
        break;
      } else if (this.tokens.matches1AtIndex(s, x.comma)) s++;
      else throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[s])}`);
    }
    return { newIndex: s, namedImports: o };
  }
  getImportInfo(s) {
    const o = this.importInfoByPath.get(s);
    if (o) return o;
    const b = { defaultNames: [], wildcardNames: [], namedImports: [], namedExports: [], hasBareImport: false, exportStarNames: [], hasStarExport: false };
    return this.importInfoByPath.set(s, b), b;
  }
  addExportBinding(s, o) {
    this.exportBindingsByLocalName.has(s) || this.exportBindingsByLocalName.set(s, []), this.exportBindingsByLocalName.get(s).push(o);
  }
  claimImportCode(s) {
    const o = this.importsToReplace.get(s);
    return this.importsToReplace.set(s, ""), o || "";
  }
  getIdentifierReplacement(s) {
    return this.identifierReplacements.get(s) || null;
  }
  resolveExportBinding(s) {
    const o = this.exportBindingsByLocalName.get(s);
    return !o || o.length === 0 ? null : o.map((b) => `exports.${b}`).join(" = ");
  }
  getGlobalNames() {
    return /* @__PURE__ */ new Set([...this.identifierReplacements.keys(), ...this.exportBindingsByLocalName.keys()]);
  }
}
var uu = { exports: {} }, ua = { exports: {} }, Md;
function GP() {
  return Md || (Md = 1, function(a3, s) {
    (function(o, b) {
      b(s);
    })(Yn, function(o) {
      class b {
        constructor() {
          this._indexes = { __proto__: null }, this.array = [];
        }
      }
      function A(n) {
        return n;
      }
      function R(n, u) {
        return n._indexes[u];
      }
      function P(n, u) {
        const c = R(n, u);
        if (c !== void 0) return c;
        const { array: e, _indexes: r } = n, f = e.push(u);
        return r[u] = f - 1;
      }
      function t(n) {
        const { array: u, _indexes: c } = n;
        if (u.length === 0) return;
        const e = u.pop();
        c[e] = void 0;
      }
      function l(n, u) {
        const c = R(n, u);
        if (c === void 0) return;
        const { array: e, _indexes: r } = n;
        for (let f = c + 1; f < e.length; f++) {
          const y = e[f];
          e[f - 1] = y, r[y]--;
        }
        r[u] = void 0, e.pop();
      }
      o.SetArray = b, o.get = R, o.pop = t, o.put = P, o.remove = l, Object.defineProperty(o, "__esModule", { value: true });
    });
  }(ua, ua.exports)), ua.exports;
}
var ca = { exports: {} }, Bd;
function cy() {
  return Bd || (Bd = 1, function(a3, s) {
    (function(o, b) {
      b(s);
    })(Yn, function(o) {
      const R = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", P = new Uint8Array(64), t = new Uint8Array(128);
      for (let D = 0; D < R.length; D++) {
        const j = R.charCodeAt(D);
        P[D] = j, t[j] = D;
      }
      function l(D, j) {
        let L = 0, k = 0, N = 0;
        do {
          const W = D.next();
          N = t[W], L |= (N & 31) << k, k += 5;
        } while (N & 32);
        const F = L & 1;
        return L >>>= 1, F && (L = -2147483648 | -L), j + L;
      }
      function n(D, j, L) {
        let k = j - L;
        k = k < 0 ? -k << 1 | 1 : k << 1;
        do {
          let N = k & 31;
          k >>>= 5, k > 0 && (N |= 32), D.write(P[N]);
        } while (k > 0);
        return j;
      }
      function u(D, j) {
        return D.pos >= j ? false : D.peek() !== 44;
      }
      const c = 1024 * 16, e = typeof TextDecoder < "u" ? new TextDecoder() : typeof Buffer < "u" ? { decode(D) {
        return Buffer.from(D.buffer, D.byteOffset, D.byteLength).toString();
      } } : { decode(D) {
        let j = "";
        for (let L = 0; L < D.length; L++) j += String.fromCharCode(D[L]);
        return j;
      } };
      class r {
        constructor() {
          this.pos = 0, this.out = "", this.buffer = new Uint8Array(c);
        }
        write(j) {
          const { buffer: L } = this;
          L[this.pos++] = j, this.pos === c && (this.out += e.decode(L), this.pos = 0);
        }
        flush() {
          const { buffer: j, out: L, pos: k } = this;
          return k > 0 ? L + e.decode(j.subarray(0, k)) : L;
        }
      }
      class f {
        constructor(j) {
          this.pos = 0, this.buffer = j;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(j) {
          const { buffer: L, pos: k } = this, N = L.indexOf(j, k);
          return N === -1 ? L.length : N;
        }
      }
      const y = [];
      function S(D) {
        const { length: j } = D, L = new f(D), k = [], N = [];
        let F = 0;
        for (; L.pos < j; L.pos++) {
          F = l(L, F);
          const W = l(L, 0);
          if (!u(L, j)) {
            const re = N.pop();
            re[2] = F, re[3] = W;
            continue;
          }
          const X = l(L, 0), q = l(L, 0) & 1 ? [F, W, 0, 0, X, l(L, 0)] : [F, W, 0, 0, X];
          let ee = y;
          if (u(L, j)) {
            ee = [];
            do {
              const re = l(L, 0);
              ee.push(re);
            } while (u(L, j));
          }
          q.vars = ee, k.push(q), N.push(q);
        }
        return k;
      }
      function T(D) {
        const j = new r();
        for (let L = 0; L < D.length; ) L = d(D, L, j, [0]);
        return j.flush();
      }
      function d(D, j, L, k) {
        const N = D[j], { 0: F, 1: W, 2: X, 3: H, 4: U, vars: q } = N;
        j > 0 && L.write(44), k[0] = n(L, F, k[0]), n(L, W, 0), n(L, U, 0);
        const ee = N.length === 6 ? 1 : 0;
        n(L, ee, 0), N.length === 6 && n(L, N[5], 0);
        for (const re of q) n(L, re, 0);
        for (j++; j < D.length; ) {
          const re = D[j], { 0: Y, 1: Z } = re;
          if (Y > X || Y === X && Z >= H) break;
          j = d(D, j, L, k);
        }
        return L.write(44), k[0] = n(L, X, k[0]), n(L, H, 0), j;
      }
      function p(D) {
        const { length: j } = D, L = new f(D), k = [], N = [];
        let F = 0, W = 0, X = 0, H = 0, U = 0, q = 0, ee = 0, re = 0;
        do {
          const Y = L.indexOf(";");
          let Z = 0;
          for (; L.pos < Y; L.pos++) {
            if (Z = l(L, Z), !u(L, Y)) {
              const ue = N.pop();
              ue[2] = F, ue[3] = Z;
              continue;
            }
            const G = l(L, 0), B = G & 1, z = G & 2, M = G & 4;
            let K = null, Q = y, ie;
            if (B) {
              const ue = l(L, W);
              X = l(L, W === ue ? X : 0), W = ue, ie = [F, Z, 0, 0, ue, X];
            } else ie = [F, Z, 0, 0];
            if (ie.isScope = !!M, z) {
              const ue = H, ge = U;
              H = l(L, H);
              const Te = ue === H;
              U = l(L, Te ? U : 0), q = l(L, Te && ge === U ? q : 0), K = [H, U, q];
            }
            if (ie.callsite = K, u(L, Y)) {
              Q = [];
              do {
                ee = F, re = Z;
                const ue = l(L, 0);
                let ge;
                if (ue < -1) {
                  ge = [[l(L, 0)]];
                  for (let Te = -1; Te > ue; Te--) {
                    const le = ee;
                    ee = l(L, ee), re = l(L, ee === le ? re : 0);
                    const fe = l(L, 0);
                    ge.push([fe, ee, re]);
                  }
                } else ge = [[ue]];
                Q.push(ge);
              } while (u(L, Y));
            }
            ie.bindings = Q, k.push(ie), N.push(ie);
          }
          F++, L.pos = Y + 1;
        } while (L.pos < j);
        return k;
      }
      function h(D) {
        if (D.length === 0) return "";
        const j = new r();
        for (let L = 0; L < D.length; ) L = m(D, L, j, [0, 0, 0, 0, 0, 0, 0]);
        return j.flush();
      }
      function m(D, j, L, k) {
        const N = D[j], { 0: F, 1: W, 2: X, 3: H, isScope: U, callsite: q, bindings: ee } = N;
        k[0] < F ? (E(L, k[0], F), k[0] = F, k[1] = 0) : j > 0 && L.write(44), k[1] = n(L, N[1], k[1]);
        const re = (N.length === 6 ? 1 : 0) | (q ? 2 : 0) | (U ? 4 : 0);
        if (n(L, re, 0), N.length === 6) {
          const { 4: Y, 5: Z } = N;
          Y !== k[2] && (k[3] = 0), k[2] = n(L, Y, k[2]), k[3] = n(L, Z, k[3]);
        }
        if (q) {
          const { 0: Y, 1: Z, 2: G } = N.callsite;
          Y !== k[4] ? (k[5] = 0, k[6] = 0) : Z !== k[5] && (k[6] = 0), k[4] = n(L, Y, k[4]), k[5] = n(L, Z, k[5]), k[6] = n(L, G, k[6]);
        }
        if (ee) for (const Y of ee) {
          Y.length > 1 && n(L, -Y.length, 0);
          const Z = Y[0][0];
          n(L, Z, 0);
          let G = F, B = W;
          for (let z = 1; z < Y.length; z++) {
            const M = Y[z];
            G = n(L, M[1], G), B = n(L, M[2], B), n(L, M[0], 0);
          }
        }
        for (j++; j < D.length; ) {
          const Y = D[j], { 0: Z, 1: G } = Y;
          if (Z > X || Z === X && G >= H) break;
          j = m(D, j, L, k);
        }
        return k[0] < X ? (E(L, k[0], X), k[0] = X, k[1] = 0) : L.write(44), k[1] = n(L, H, k[1]), j;
      }
      function E(D, j, L) {
        do
          D.write(59);
        while (++j < L);
      }
      function _(D) {
        const { length: j } = D, L = new f(D), k = [];
        let N = 0, F = 0, W = 0, X = 0, H = 0;
        do {
          const U = L.indexOf(";"), q = [];
          let ee = true, re = 0;
          for (N = 0; L.pos < U; ) {
            let Y;
            N = l(L, N), N < re && (ee = false), re = N, u(L, U) ? (F = l(L, F), W = l(L, W), X = l(L, X), u(L, U) ? (H = l(L, H), Y = [N, F, W, X, H]) : Y = [N, F, W, X]) : Y = [N], q.push(Y), L.pos++;
          }
          ee || C(q), k.push(q), L.pos = U + 1;
        } while (L.pos <= j);
        return k;
      }
      function C(D) {
        D.sort(w);
      }
      function w(D, j) {
        return D[0] - j[0];
      }
      function I(D) {
        const j = new r();
        let L = 0, k = 0, N = 0, F = 0;
        for (let W = 0; W < D.length; W++) {
          const X = D[W];
          if (W > 0 && j.write(59), X.length === 0) continue;
          let H = 0;
          for (let U = 0; U < X.length; U++) {
            const q = X[U];
            U > 0 && j.write(44), H = n(j, q[0], H), q.length !== 1 && (L = n(j, q[1], L), k = n(j, q[2], k), N = n(j, q[3], N), q.length !== 4 && (F = n(j, q[4], F)));
          }
        }
        return j.flush();
      }
      o.decode = _, o.decodeGeneratedRanges = p, o.decodeOriginalScopes = S, o.encode = I, o.encodeGeneratedRanges = h, o.encodeOriginalScopes = T, Object.defineProperty(o, "__esModule", { value: true });
    });
  }(ca, ca.exports)), ca.exports;
}
var pa = { exports: {} }, el = { exports: {} }, $d;
function zP() {
  return $d || ($d = 1, function(a3, s) {
    (function(o, b) {
      a3.exports = b();
    })(Yn, function() {
      const o = /^[\w+.-]+:\/\//, b = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, A = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function R(d) {
        return o.test(d);
      }
      function P(d) {
        return d.startsWith("//");
      }
      function t(d) {
        return d.startsWith("/");
      }
      function l(d) {
        return d.startsWith("file:");
      }
      function n(d) {
        return /^[.?#]/.test(d);
      }
      function u(d) {
        const p = b.exec(d);
        return e(p[1], p[2] || "", p[3], p[4] || "", p[5] || "/", p[6] || "", p[7] || "");
      }
      function c(d) {
        const p = A.exec(d), h = p[2];
        return e("file:", "", p[1] || "", "", t(h) ? h : "/" + h, p[3] || "", p[4] || "");
      }
      function e(d, p, h, m, E, _, C) {
        return { scheme: d, user: p, host: h, port: m, path: E, query: _, hash: C, type: 7 };
      }
      function r(d) {
        if (P(d)) {
          const h = u("http:" + d);
          return h.scheme = "", h.type = 6, h;
        }
        if (t(d)) {
          const h = u("http://foo.com" + d);
          return h.scheme = "", h.host = "", h.type = 5, h;
        }
        if (l(d)) return c(d);
        if (R(d)) return u(d);
        const p = u("http://foo.com/" + d);
        return p.scheme = "", p.host = "", p.type = d ? d.startsWith("?") ? 3 : d.startsWith("#") ? 2 : 4 : 1, p;
      }
      function f(d) {
        if (d.endsWith("/..")) return d;
        const p = d.lastIndexOf("/");
        return d.slice(0, p + 1);
      }
      function y(d, p) {
        S(p, p.type), d.path === "/" ? d.path = p.path : d.path = f(p.path) + d.path;
      }
      function S(d, p) {
        const h = p <= 4, m = d.path.split("/");
        let E = 1, _ = 0, C = false;
        for (let I = 1; I < m.length; I++) {
          const D = m[I];
          if (!D) {
            C = true;
            continue;
          }
          if (C = false, D !== ".") {
            if (D === "..") {
              _ ? (C = true, _--, E--) : h && (m[E++] = D);
              continue;
            }
            m[E++] = D, _++;
          }
        }
        let w = "";
        for (let I = 1; I < E; I++) w += "/" + m[I];
        (!w || C && !w.endsWith("/..")) && (w += "/"), d.path = w;
      }
      function T(d, p) {
        if (!d && !p) return "";
        const h = r(d);
        let m = h.type;
        if (p && m !== 7) {
          const _ = r(p), C = _.type;
          switch (m) {
            case 1:
              h.hash = _.hash;
            case 2:
              h.query = _.query;
            case 3:
            case 4:
              y(h, _);
            case 5:
              h.user = _.user, h.host = _.host, h.port = _.port;
            case 6:
              h.scheme = _.scheme;
          }
          C > m && (m = C);
        }
        S(h, m);
        const E = h.query + h.hash;
        switch (m) {
          case 2:
          case 3:
            return E;
          case 4: {
            const _ = h.path.slice(1);
            return _ ? n(p || d) && !n(_) ? "./" + _ + E : _ + E : E || ".";
          }
          case 5:
            return h.path + E;
          default:
            return h.scheme + "//" + h.user + h.host + h.port + h.path + E;
        }
      }
      return T;
    });
  }(el)), el.exports;
}
var Ud;
function KP() {
  return Ud || (Ud = 1, function(a3, s) {
    (function(o, b) {
      b(s, cy(), zP());
    })(Yn, function(o, b, A) {
      function R(pe, J) {
        return J && !J.endsWith("/") && (J += "/"), A(pe, J);
      }
      function P(pe) {
        if (!pe) return "";
        const J = pe.lastIndexOf("/");
        return pe.slice(0, J + 1);
      }
      const t = 0, l = 1, n = 2, u = 3, c = 4, e = 1, r = 2;
      function f(pe, J) {
        const Ee = y(pe, 0);
        if (Ee === pe.length) return pe;
        J || (pe = pe.slice());
        for (let Me = Ee; Me < pe.length; Me = y(pe, Me + 1)) pe[Me] = T(pe[Me], J);
        return pe;
      }
      function y(pe, J) {
        for (let Ee = J; Ee < pe.length; Ee++) if (!S(pe[Ee])) return Ee;
        return pe.length;
      }
      function S(pe) {
        for (let J = 1; J < pe.length; J++) if (pe[J][t] < pe[J - 1][t]) return false;
        return true;
      }
      function T(pe, J) {
        return J || (pe = pe.slice()), pe.sort(d);
      }
      function d(pe, J) {
        return pe[t] - J[t];
      }
      let p = false;
      function h(pe, J, Ee, Me) {
        for (; Ee <= Me; ) {
          const Ue = Ee + (Me - Ee >> 1), qe = pe[Ue][t] - J;
          if (qe === 0) return p = true, Ue;
          qe < 0 ? Ee = Ue + 1 : Me = Ue - 1;
        }
        return p = false, Ee - 1;
      }
      function m(pe, J, Ee) {
        for (let Me = Ee + 1; Me < pe.length && pe[Me][t] === J; Ee = Me++) ;
        return Ee;
      }
      function E(pe, J, Ee) {
        for (let Me = Ee - 1; Me >= 0 && pe[Me][t] === J; Ee = Me--) ;
        return Ee;
      }
      function _() {
        return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
      }
      function C(pe, J, Ee, Me) {
        const { lastKey: Ue, lastNeedle: qe, lastIndex: He } = Ee;
        let Ie = 0, Re = pe.length - 1;
        if (Me === Ue) {
          if (J === qe) return p = He !== -1 && pe[He][t] === J, He;
          J >= qe ? Ie = He === -1 ? 0 : He : Re = He;
        }
        return Ee.lastKey = Me, Ee.lastNeedle = J, Ee.lastIndex = h(pe, J, Ie, Re);
      }
      function w(pe, J) {
        const Ee = J.map(D);
        for (let Me = 0; Me < pe.length; Me++) {
          const Ue = pe[Me];
          for (let qe = 0; qe < Ue.length; qe++) {
            const He = Ue[qe];
            if (He.length === 1) continue;
            const Ie = He[l], Re = He[n], Be = He[u], je = Ee[Ie], he = je[Re] || (je[Re] = []), oe = J[Ie];
            let _e = m(he, Be, C(he, Be, oe, Re));
            oe.lastIndex = ++_e, I(he, _e, [Be, Me, He[t]]);
          }
        }
        return Ee;
      }
      function I(pe, J, Ee) {
        for (let Me = pe.length; Me > J; Me--) pe[Me] = pe[Me - 1];
        pe[J] = Ee;
      }
      function D() {
        return { __proto__: null };
      }
      const j = function(pe, J) {
        const Ee = L(pe);
        if (!("sections" in Ee)) return new ee(Ee, J);
        const Me = [], Ue = [], qe = [], He = [], Ie = [];
        k(Ee, J, Me, Ue, qe, He, Ie, 0, 0, 1 / 0, 1 / 0);
        const Re = { version: 3, file: Ee.file, names: He, sources: Ue, sourcesContent: qe, mappings: Me, ignoreList: Ie };
        return ge(Re);
      };
      function L(pe) {
        return typeof pe == "string" ? JSON.parse(pe) : pe;
      }
      function k(pe, J, Ee, Me, Ue, qe, He, Ie, Re, Be, je) {
        const { sections: he } = pe;
        for (let oe = 0; oe < he.length; oe++) {
          const { map: _e, offset: Ne } = he[oe];
          let $e = Be, Xe = je;
          if (oe + 1 < he.length) {
            const Je = he[oe + 1].offset;
            $e = Math.min(Be, Ie + Je.line), $e === Be ? Xe = Math.min(je, Re + Je.column) : $e < Be && (Xe = Re + Je.column);
          }
          N(_e, J, Ee, Me, Ue, qe, He, Ie + Ne.line, Re + Ne.column, $e, Xe);
        }
      }
      function N(pe, J, Ee, Me, Ue, qe, He, Ie, Re, Be, je) {
        const he = L(pe);
        if ("sections" in he) return k(...arguments);
        const oe = new ee(he, J), _e = Me.length, Ne = qe.length, $e = Z(oe), { resolvedSources: Xe, sourcesContent: Je, ignoreList: st } = oe;
        if (F(Me, Xe), F(qe, oe.names), Je) F(Ue, Je);
        else for (let be = 0; be < Xe.length; be++) Ue.push(null);
        if (st) for (let be = 0; be < st.length; be++) He.push(st[be] + _e);
        for (let be = 0; be < $e.length; be++) {
          const ke = Ie + be;
          if (ke > Be) return;
          const Ve = W(Ee, ke), ze = be === 0 ? Re : 0, rt = $e[be];
          for (let it = 0; it < rt.length; it++) {
            const Ye = rt[it], tt = ze + Ye[t];
            if (ke === Be && tt >= je) return;
            if (Ye.length === 1) {
              Ve.push([tt]);
              continue;
            }
            const pt = _e + Ye[l], Et = Ye[n], Qe = Ye[u];
            Ve.push(Ye.length === 4 ? [tt, pt, Et, Qe] : [tt, pt, Et, Qe, Ne + Ye[c]]);
          }
        }
      }
      function F(pe, J) {
        for (let Ee = 0; Ee < J.length; Ee++) pe.push(J[Ee]);
      }
      function W(pe, J) {
        for (let Ee = pe.length; Ee <= J; Ee++) pe[Ee] = [];
        return pe[J];
      }
      const X = "`line` must be greater than 0 (lines start at line 1)", H = "`column` must be greater than or equal to 0 (columns start at column 0)", U = -1, q = 1;
      class ee {
        constructor(J, Ee) {
          const Me = typeof J == "string";
          if (!Me && J._decodedMemo) return J;
          const Ue = Me ? JSON.parse(J) : J, { version: qe, file: He, names: Ie, sourceRoot: Re, sources: Be, sourcesContent: je } = Ue;
          this.version = qe, this.file = He, this.names = Ie || [], this.sourceRoot = Re, this.sources = Be, this.sourcesContent = je, this.ignoreList = Ue.ignoreList || Ue.x_google_ignoreList || void 0;
          const he = R(Re || "", P(Ee));
          this.resolvedSources = Be.map((_e) => R(_e || "", he));
          const { mappings: oe } = Ue;
          typeof oe == "string" ? (this._encoded = oe, this._decoded = void 0) : (this._encoded = void 0, this._decoded = f(oe, Me)), this._decodedMemo = _(), this._bySources = void 0, this._bySourceMemos = void 0;
        }
      }
      function re(pe) {
        return pe;
      }
      function Y(pe) {
        var J, Ee;
        return (J = (Ee = pe)._encoded) !== null && J !== void 0 ? J : Ee._encoded = b.encode(pe._decoded);
      }
      function Z(pe) {
        var J;
        return (J = pe)._decoded || (J._decoded = b.decode(pe._encoded));
      }
      function G(pe, J, Ee) {
        const Me = Z(pe);
        if (J >= Me.length) return null;
        const Ue = Me[J], qe = we(Ue, pe._decodedMemo, J, Ee, q);
        return qe === -1 ? null : Ue[qe];
      }
      function B(pe, J) {
        let { line: Ee, column: Me, bias: Ue } = J;
        if (Ee--, Ee < 0) throw new Error(X);
        if (Me < 0) throw new Error(H);
        const qe = Z(pe);
        if (Ee >= qe.length) return Pe(null, null, null, null);
        const He = qe[Ee], Ie = we(He, pe._decodedMemo, Ee, Me, Ue || q);
        if (Ie === -1) return Pe(null, null, null, null);
        const Re = He[Ie];
        if (Re.length === 1) return Pe(null, null, null, null);
        const { names: Be, resolvedSources: je } = pe;
        return Pe(je[Re[l]], Re[n] + 1, Re[u], Re.length === 5 ? Be[Re[c]] : null);
      }
      function z(pe, J) {
        const { source: Ee, line: Me, column: Ue, bias: qe } = J;
        return ye(pe, Ee, Me, Ue, qe || q, false);
      }
      function M(pe, J) {
        const { source: Ee, line: Me, column: Ue, bias: qe } = J;
        return ye(pe, Ee, Me, Ue, qe || U, true);
      }
      function K(pe, J) {
        const Ee = Z(pe), { names: Me, resolvedSources: Ue } = pe;
        for (let qe = 0; qe < Ee.length; qe++) {
          const He = Ee[qe];
          for (let Ie = 0; Ie < He.length; Ie++) {
            const Re = He[Ie], Be = qe + 1, je = Re[0];
            let he = null, oe = null, _e = null, Ne = null;
            Re.length !== 1 && (he = Ue[Re[1]], oe = Re[2] + 1, _e = Re[3]), Re.length === 5 && (Ne = Me[Re[4]]), J({ generatedLine: Be, generatedColumn: je, source: he, originalLine: oe, originalColumn: _e, name: Ne });
          }
        }
      }
      function Q(pe, J) {
        const { sources: Ee, resolvedSources: Me } = pe;
        let Ue = Ee.indexOf(J);
        return Ue === -1 && (Ue = Me.indexOf(J)), Ue;
      }
      function ie(pe, J) {
        const { sourcesContent: Ee } = pe;
        if (Ee == null) return null;
        const Me = Q(pe, J);
        return Me === -1 ? null : Ee[Me];
      }
      function ue(pe, J) {
        const { ignoreList: Ee } = pe;
        if (Ee == null) return false;
        const Me = Q(pe, J);
        return Me === -1 ? false : Ee.includes(Me);
      }
      function ge(pe, J) {
        const Ee = new ee(fe(pe, []), J);
        return Ee._decoded = pe.mappings, Ee;
      }
      function Te(pe) {
        return fe(pe, Z(pe));
      }
      function le(pe) {
        return fe(pe, Y(pe));
      }
      function fe(pe, J) {
        return { version: pe.version, file: pe.file, names: pe.names, sourceRoot: pe.sourceRoot, sources: pe.sources, sourcesContent: pe.sourcesContent, mappings: J, ignoreList: pe.ignoreList || pe.x_google_ignoreList };
      }
      function Pe(pe, J, Ee, Me) {
        return { source: pe, line: J, column: Ee, name: Me };
      }
      function xe(pe, J) {
        return { line: pe, column: J };
      }
      function we(pe, J, Ee, Me, Ue) {
        let qe = C(pe, Me, J, Ee);
        return p ? qe = (Ue === U ? m : E)(pe, Me, qe) : Ue === U && qe++, qe === -1 || qe === pe.length ? -1 : qe;
      }
      function me(pe, J, Ee, Me, Ue) {
        let qe = we(pe, J, Ee, Me, q);
        if (!p && Ue === U && qe++, qe === -1 || qe === pe.length) return [];
        const He = p ? Me : pe[qe][t];
        p || (qe = E(pe, He, qe));
        const Ie = m(pe, He, qe), Re = [];
        for (; qe <= Ie; qe++) {
          const Be = pe[qe];
          Re.push(xe(Be[e] + 1, Be[r]));
        }
        return Re;
      }
      function ye(pe, J, Ee, Me, Ue, qe) {
        var He;
        if (Ee--, Ee < 0) throw new Error(X);
        if (Me < 0) throw new Error(H);
        const { sources: Ie, resolvedSources: Re } = pe;
        let Be = Ie.indexOf(J);
        if (Be === -1 && (Be = Re.indexOf(J)), Be === -1) return qe ? [] : xe(null, null);
        const he = ((He = pe)._bySources || (He._bySources = w(Z(pe), pe._bySourceMemos = Ie.map(_))))[Be][Ee];
        if (he == null) return qe ? [] : xe(null, null);
        const oe = pe._bySourceMemos[Be];
        if (qe) return me(he, oe, Ee, Me, Ue);
        const _e = we(he, oe, Ee, Me, Ue);
        if (_e === -1) return xe(null, null);
        const Ne = he[_e];
        return xe(Ne[e] + 1, Ne[r]);
      }
      o.AnyMap = j, o.GREATEST_LOWER_BOUND = q, o.LEAST_UPPER_BOUND = U, o.TraceMap = ee, o.allGeneratedPositionsFor = M, o.decodedMap = Te, o.decodedMappings = Z, o.eachMapping = K, o.encodedMap = le, o.encodedMappings = Y, o.generatedPositionFor = z, o.isIgnored = ue, o.originalPositionFor = B, o.presortedDecodedMap = ge, o.sourceContentFor = ie, o.traceSegment = G;
    });
  }(pa, pa.exports)), pa.exports;
}
(function(a3, s) {
  (function(o, b) {
    b(s, GP(), cy(), KP());
  })(Yn, function(o, b, A, R) {
    class e {
      constructor({ file: X, sourceRoot: H } = {}) {
        this._names = new b.SetArray(), this._sources = new b.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = X, this.sourceRoot = H, this._ignoreList = new b.SetArray();
      }
    }
    function r(W) {
      return W;
    }
    function f(W, X, H, U, q, ee, re, Y) {
      return C(false, W, X, H, U, q, ee, re, Y);
    }
    function y(W, X) {
      return F(false, W, X);
    }
    const S = (W, X, H, U, q, ee, re, Y) => C(true, W, X, H, U, q, ee, re, Y), T = (W, X) => F(true, W, X);
    function d(W, X, H) {
      const { _sources: U, _sourcesContent: q } = W, ee = b.put(U, X);
      q[ee] = H;
    }
    function p(W, X, H = true) {
      const { _sources: U, _sourcesContent: q, _ignoreList: ee } = W, re = b.put(U, X);
      re === q.length && (q[re] = null), H ? b.put(ee, re) : b.remove(ee, re);
    }
    function h(W) {
      const { _mappings: X, _sources: H, _sourcesContent: U, _names: q, _ignoreList: ee } = W;
      return j(X), { version: 3, file: W.file || void 0, names: q.array, sourceRoot: W.sourceRoot || void 0, sources: H.array, sourcesContent: U, mappings: X, ignoreList: ee.array };
    }
    function m(W) {
      const X = h(W);
      return Object.assign(Object.assign({}, X), { mappings: A.encode(X.mappings) });
    }
    function E(W) {
      const X = new R.TraceMap(W), H = new e({ file: X.file, sourceRoot: X.sourceRoot });
      return L(H._names, X.names), L(H._sources, X.sources), H._sourcesContent = X.sourcesContent || X.sources.map(() => null), H._mappings = R.decodedMappings(X), X.ignoreList && L(H._ignoreList, X.ignoreList), H;
    }
    function _(W) {
      const X = [], { _mappings: H, _sources: U, _names: q } = W;
      for (let ee = 0; ee < H.length; ee++) {
        const re = H[ee];
        for (let Y = 0; Y < re.length; Y++) {
          const Z = re[Y], G = { line: ee + 1, column: Z[0] };
          let B, z, M;
          Z.length !== 1 && (B = U.array[Z[1]], z = { line: Z[2] + 1, column: Z[3] }, Z.length === 5 && (M = q.array[Z[4]])), X.push({ generated: G, source: B, original: z, name: M });
        }
      }
      return X;
    }
    function C(W, X, H, U, q, ee, re, Y, Z) {
      const { _mappings: G, _sources: B, _sourcesContent: z, _names: M } = X, K = w(G, H), Q = I(K, U);
      if (!q) return W && k(K, Q) ? void 0 : D(K, Q, [U]);
      const ie = b.put(B, q), ue = Y ? b.put(M, Y) : -1;
      if (ie === z.length && (z[ie] = Z ?? null), !(W && N(K, Q, ie, ee, re, ue))) return D(K, Q, Y ? [U, ie, ee, re, ue] : [U, ie, ee, re]);
    }
    function w(W, X) {
      for (let H = W.length; H <= X; H++) W[H] = [];
      return W[X];
    }
    function I(W, X) {
      let H = W.length;
      for (let U = H - 1; U >= 0; H = U--) {
        const q = W[U];
        if (X >= q[0]) break;
      }
      return H;
    }
    function D(W, X, H) {
      for (let U = W.length; U > X; U--) W[U] = W[U - 1];
      W[X] = H;
    }
    function j(W) {
      const { length: X } = W;
      let H = X;
      for (let U = H - 1; U >= 0 && !(W[U].length > 0); H = U, U--) ;
      H < X && (W.length = H);
    }
    function L(W, X) {
      for (let H = 0; H < X.length; H++) b.put(W, X[H]);
    }
    function k(W, X) {
      return X === 0 ? true : W[X - 1].length === 1;
    }
    function N(W, X, H, U, q, ee) {
      if (X === 0) return false;
      const re = W[X - 1];
      return re.length === 1 ? false : H === re[1] && U === re[2] && q === re[3] && ee === (re.length === 5 ? re[4] : -1);
    }
    function F(W, X, H) {
      const { generated: U, source: q, original: ee, name: re, content: Y } = H;
      return q ? C(W, X, U.line - 1, U.column, q, ee.line - 1, ee.column, re, Y) : C(W, X, U.line - 1, U.column, null, null, null, null, null);
    }
    o.GenMapping = e, o.addMapping = y, o.addSegment = f, o.allMappings = _, o.fromMap = E, o.maybeAddMapping = T, o.maybeAddSegment = S, o.setIgnore = p, o.setSourceContent = d, o.toDecodedMap = h, o.toEncodedMap = m, Object.defineProperty(o, "__esModule", { value: true });
  });
})(uu, uu.exports);
var oi = uu.exports;
function qP({ code: a3, mappings: s }, o, b, A, R) {
  const P = YP(A, R), t = new oi.GenMapping({ file: b.compiledFilename });
  let l = 0, n = s[0];
  for (; n === void 0 && l < s.length - 1; ) l++, n = s[l];
  let u = 0, c = 0;
  n !== c && oi.maybeAddSegment(t, u, 0, o, u, 0);
  for (let y = 0; y < a3.length; y++) {
    if (y === n) {
      const S = n - c, T = P[l];
      for (oi.maybeAddSegment(t, u, S, o, u, T); (n === y || n === void 0) && l < s.length - 1; ) l++, n = s[l];
    }
    a3.charCodeAt(y) === Ge.lineFeed && (u++, c = y + 1, n !== c && oi.maybeAddSegment(t, u, 0, o, u, 0));
  }
  const { sourceRoot: e, sourcesContent: r, ...f } = oi.toEncodedMap(t);
  return f;
}
function YP(a3, s) {
  const o = new Array(s.length);
  let b = 0, A = s[b].start, R = 0;
  for (let P = 0; P < a3.length; P++) P === A && (o[b] = A - R, b++, A = s[b].start), a3.charCodeAt(P) === Ge.lineFeed && (R = P + 1);
  return o;
}
const XP = { require: `
    import {createRequire as CREATE_REQUIRE_NAME} from "module";
    const require = CREATE_REQUIRE_NAME(import.meta.url);
  `, interopRequireWildcard: `
    function interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
  `, interopRequireDefault: `
    function interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  `, createNamedExportFrom: `
    function createNamedExportFrom(obj, localName, importedName) {
      Object.defineProperty(exports, localName, {enumerable: true, configurable: true, get: () => obj[importedName]});
    }
  `, createStarExport: `
    function createStarExport(obj) {
      Object.keys(obj)
        .filter((key) => key !== "default" && key !== "__esModule")
        .forEach((key) => {
          if (exports.hasOwnProperty(key)) {
            return;
          }
          Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]});
        });
    }
  `, nullishCoalesce: `
    function nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
  `, asyncNullishCoalesce: `
    async function asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
  `, optionalChain: `
    function optionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `, asyncOptionalChain: `
    async function asyncOptionalChain(ops) {
      let lastAccessLHS = undefined;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
          return undefined;
        }
        if (op === 'access' || op === 'optionalAccess') {
          lastAccessLHS = value;
          value = await fn(value);
        } else if (op === 'call' || op === 'optionalCall') {
          value = await fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = undefined;
        }
      }
      return value;
    }
  `, optionalChainDelete: `
    function optionalChainDelete(ops) {
      const result = OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  `, asyncOptionalChainDelete: `
    async function asyncOptionalChainDelete(ops) {
      const result = await ASYNC_OPTIONAL_CHAIN_NAME(ops);
      return result == null ? true : result;
    }
  ` };
class Na {
  __init() {
    this.helperNames = {};
  }
  __init2() {
    this.createRequireName = null;
  }
  constructor(s) {
    this.nameManager = s, Na.prototype.__init.call(this), Na.prototype.__init2.call(this);
  }
  getHelperName(s) {
    let o = this.helperNames[s];
    return o || (o = this.nameManager.claimFreeName(`_${s}`), this.helperNames[s] = o, o);
  }
  emitHelpers() {
    let s = "";
    this.helperNames.optionalChainDelete && this.getHelperName("optionalChain"), this.helperNames.asyncOptionalChainDelete && this.getHelperName("asyncOptionalChain");
    for (const [o, b] of Object.entries(XP)) {
      const A = this.helperNames[o];
      let R = b;
      o === "optionalChainDelete" ? R = R.replace("OPTIONAL_CHAIN_NAME", this.helperNames.optionalChain) : o === "asyncOptionalChainDelete" ? R = R.replace("ASYNC_OPTIONAL_CHAIN_NAME", this.helperNames.asyncOptionalChain) : o === "require" && (this.createRequireName === null && (this.createRequireName = this.nameManager.claimFreeName("_createRequire")), R = R.replace(/CREATE_REQUIRE_NAME/g, this.createRequireName)), A && (s += " ", s += R.replace(o, A).replace(/\s+/g, " ").trim());
    }
    return s;
  }
}
function Vd(a3, s, o) {
  JP(a3, o) && QP(a3, s, o);
}
function JP(a3, s) {
  for (const o of a3.tokens) if (o.type === x.name && !o.isType && gP(o) && s.has(a3.identifierNameForToken(o))) return true;
  return false;
}
function QP(a3, s, o) {
  const b = [];
  let A = s.length - 1;
  for (let R = a3.tokens.length - 1; ; R--) {
    for (; b.length > 0 && b[b.length - 1].startTokenIndex === R + 1; ) b.pop();
    for (; A >= 0 && s[A].endTokenIndex === R + 1; ) b.push(s[A]), A--;
    if (R < 0) break;
    const P = a3.tokens[R], t = a3.identifierNameForToken(P);
    if (b.length > 1 && !P.isType && P.type === x.name && o.has(t)) {
      if (vP(P)) Wd(b[b.length - 1], a3, t);
      else if (EP(P)) {
        let l = b.length - 1;
        for (; l > 0 && !b[l].isFunctionScope; ) l--;
        if (l < 0) throw new Error("Did not find parent function scope.");
        Wd(b[l], a3, t);
      }
    }
  }
  if (b.length > 0) throw new Error("Expected empty scope stack after processing file.");
}
function Wd(a3, s, o) {
  for (let b = a3.startTokenIndex; b < a3.endTokenIndex; b++) {
    const A = s.tokens[b];
    (A.type === x.name || A.type === x.jsxName) && s.identifierNameForToken(A) === o && (A.shadowsGlobal = true);
  }
}
function ZP(a3, s) {
  const o = [];
  for (const b of s) b.type === x.name && o.push(a3.slice(b.start, b.end));
  return o;
}
class Dc {
  __init() {
    this.usedNames = /* @__PURE__ */ new Set();
  }
  constructor(s, o) {
    Dc.prototype.__init.call(this), this.usedNames = new Set(ZP(s, o));
  }
  claimFreeName(s) {
    const o = this.findFreeName(s);
    return this.usedNames.add(o), o;
  }
  findFreeName(s) {
    if (!this.usedNames.has(s)) return s;
    let o = 2;
    for (; this.usedNames.has(s + String(o)); ) o++;
    return s + String(o);
  }
}
var mn = {}, cu = {}, zr = {}, ex = Yn && Yn.__extends || /* @__PURE__ */ function() {
  var a3 = function(s, o) {
    return a3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(b, A) {
      b.__proto__ = A;
    } || function(b, A) {
      for (var R in A) A.hasOwnProperty(R) && (b[R] = A[R]);
    }, a3(s, o);
  };
  return function(s, o) {
    a3(s, o);
    function b() {
      this.constructor = s;
    }
    s.prototype = o === null ? Object.create(o) : (b.prototype = o.prototype, new b());
  };
}();
Object.defineProperty(zr, "__esModule", { value: true });
zr.DetailContext = zr.NoopContext = zr.VError = void 0;
var py = function(a3) {
  ex(s, a3);
  function s(o, b) {
    var A = a3.call(this, b) || this;
    return A.path = o, Object.setPrototypeOf(A, s.prototype), A;
  }
  return s;
}(Error);
zr.VError = py;
var tx = function() {
  function a3() {
  }
  return a3.prototype.fail = function(s, o, b) {
    return false;
  }, a3.prototype.unionResolver = function() {
    return this;
  }, a3.prototype.createContext = function() {
    return this;
  }, a3.prototype.resolveUnion = function(s) {
  }, a3;
}();
zr.NoopContext = tx;
var dy = function() {
  function a3() {
    this._propNames = [""], this._messages = [null], this._score = 0;
  }
  return a3.prototype.fail = function(s, o, b) {
    return this._propNames.push(s), this._messages.push(o), this._score += b, false;
  }, a3.prototype.unionResolver = function() {
    return new nx();
  }, a3.prototype.resolveUnion = function(s) {
    for (var o, b, A = s, R = null, P = 0, t = A.contexts; P < t.length; P++) {
      var l = t[P];
      (!R || l._score >= R._score) && (R = l);
    }
    R && R._score > 0 && ((o = this._propNames).push.apply(o, R._propNames), (b = this._messages).push.apply(b, R._messages));
  }, a3.prototype.getError = function(s) {
    for (var o = [], b = this._propNames.length - 1; b >= 0; b--) {
      var A = this._propNames[b];
      s += typeof A == "number" ? "[" + A + "]" : A ? "." + A : "";
      var R = this._messages[b];
      R && o.push(s + " " + R);
    }
    return new py(s, o.join("; "));
  }, a3.prototype.getErrorDetail = function(s) {
    for (var o = [], b = this._propNames.length - 1; b >= 0; b--) {
      var A = this._propNames[b];
      s += typeof A == "number" ? "[" + A + "]" : A ? "." + A : "";
      var R = this._messages[b];
      R && o.push({ path: s, message: R });
    }
    for (var P = null, b = o.length - 1; b >= 0; b--) P && (o[b].nested = [P]), P = o[b];
    return P;
  }, a3;
}();
zr.DetailContext = dy;
var nx = function() {
  function a3() {
    this.contexts = [];
  }
  return a3.prototype.createContext = function() {
    var s = new dy();
    return this.contexts.push(s), s;
  }, a3;
}();
(function(a3) {
  var s = Yn && Yn.__extends || /* @__PURE__ */ function() {
    var Z = function(G, B) {
      return Z = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(z, M) {
        z.__proto__ = M;
      } || function(z, M) {
        for (var K in M) M.hasOwnProperty(K) && (z[K] = M[K]);
      }, Z(G, B);
    };
    return function(G, B) {
      Z(G, B);
      function z() {
        this.constructor = G;
      }
      G.prototype = B === null ? Object.create(B) : (z.prototype = B.prototype, new z());
    };
  }();
  Object.defineProperty(a3, "__esModule", { value: true }), a3.basicTypes = a3.BasicType = a3.TParamList = a3.TParam = a3.param = a3.TFunc = a3.func = a3.TProp = a3.TOptional = a3.opt = a3.TIface = a3.iface = a3.TEnumLiteral = a3.enumlit = a3.TEnumType = a3.enumtype = a3.TIntersection = a3.intersection = a3.TUnion = a3.union = a3.TTuple = a3.tuple = a3.TArray = a3.array = a3.TLiteral = a3.lit = a3.TName = a3.name = a3.TType = void 0;
  var o = zr, b = /* @__PURE__ */ function() {
    function Z() {
    }
    return Z;
  }();
  a3.TType = b;
  function A(Z) {
    return typeof Z == "string" ? P(Z) : Z;
  }
  function R(Z, G) {
    var B = Z[G];
    if (!B) throw new Error("Unknown type " + G);
    return B;
  }
  function P(Z) {
    return new t(Z);
  }
  a3.name = P;
  var t = function(Z) {
    s(G, Z);
    function G(B) {
      var z = Z.call(this) || this;
      return z.name = B, z._failMsg = "is not a " + B, z;
    }
    return G.prototype.getChecker = function(B, z, M) {
      var K = this, Q = R(B, this.name), ie = Q.getChecker(B, z, M);
      return Q instanceof X || Q instanceof G ? ie : function(ue, ge) {
        return ie(ue, ge) ? true : ge.fail(null, K._failMsg, 0);
      };
    }, G;
  }(b);
  a3.TName = t;
  function l(Z) {
    return new n(Z);
  }
  a3.lit = l;
  var n = function(Z) {
    s(G, Z);
    function G(B) {
      var z = Z.call(this) || this;
      return z.value = B, z.name = JSON.stringify(B), z._failMsg = "is not " + z.name, z;
    }
    return G.prototype.getChecker = function(B, z) {
      var M = this;
      return function(K, Q) {
        return K === M.value ? true : Q.fail(null, M._failMsg, -1);
      };
    }, G;
  }(b);
  a3.TLiteral = n;
  function u(Z) {
    return new c(A(Z));
  }
  a3.array = u;
  var c = function(Z) {
    s(G, Z);
    function G(B) {
      var z = Z.call(this) || this;
      return z.ttype = B, z;
    }
    return G.prototype.getChecker = function(B, z) {
      var M = this.ttype.getChecker(B, z);
      return function(K, Q) {
        if (!Array.isArray(K)) return Q.fail(null, "is not an array", 0);
        for (var ie = 0; ie < K.length; ie++) {
          var ue = M(K[ie], Q);
          if (!ue) return Q.fail(ie, null, 1);
        }
        return true;
      };
    }, G;
  }(b);
  a3.TArray = c;
  function e() {
    for (var Z = [], G = 0; G < arguments.length; G++) Z[G] = arguments[G];
    return new r(Z.map(function(B) {
      return A(B);
    }));
  }
  a3.tuple = e;
  var r = function(Z) {
    s(G, Z);
    function G(B) {
      var z = Z.call(this) || this;
      return z.ttypes = B, z;
    }
    return G.prototype.getChecker = function(B, z) {
      var M = this.ttypes.map(function(Q) {
        return Q.getChecker(B, z);
      }), K = function(Q, ie) {
        if (!Array.isArray(Q)) return ie.fail(null, "is not an array", 0);
        for (var ue = 0; ue < M.length; ue++) {
          var ge = M[ue](Q[ue], ie);
          if (!ge) return ie.fail(ue, null, 1);
        }
        return true;
      };
      return z ? function(Q, ie) {
        return K(Q, ie) ? Q.length <= M.length ? true : ie.fail(M.length, "is extraneous", 2) : false;
      } : K;
    }, G;
  }(b);
  a3.TTuple = r;
  function f() {
    for (var Z = [], G = 0; G < arguments.length; G++) Z[G] = arguments[G];
    return new y(Z.map(function(B) {
      return A(B);
    }));
  }
  a3.union = f;
  var y = function(Z) {
    s(G, Z);
    function G(B) {
      var z = Z.call(this) || this;
      z.ttypes = B;
      var M = B.map(function(Q) {
        return Q instanceof t || Q instanceof n ? Q.name : null;
      }).filter(function(Q) {
        return Q;
      }), K = B.length - M.length;
      return M.length ? (K > 0 && M.push(K + " more"), z._failMsg = "is none of " + M.join(", ")) : z._failMsg = "is none of " + K + " types", z;
    }
    return G.prototype.getChecker = function(B, z) {
      var M = this, K = this.ttypes.map(function(Q) {
        return Q.getChecker(B, z);
      });
      return function(Q, ie) {
        for (var ue = ie.unionResolver(), ge = 0; ge < K.length; ge++) {
          var Te = K[ge](Q, ue.createContext());
          if (Te) return true;
        }
        return ie.resolveUnion(ue), ie.fail(null, M._failMsg, 0);
      };
    }, G;
  }(b);
  a3.TUnion = y;
  function S() {
    for (var Z = [], G = 0; G < arguments.length; G++) Z[G] = arguments[G];
    return new T(Z.map(function(B) {
      return A(B);
    }));
  }
  a3.intersection = S;
  var T = function(Z) {
    s(G, Z);
    function G(B) {
      var z = Z.call(this) || this;
      return z.ttypes = B, z;
    }
    return G.prototype.getChecker = function(B, z) {
      var M = /* @__PURE__ */ new Set(), K = this.ttypes.map(function(Q) {
        return Q.getChecker(B, z, M);
      });
      return function(Q, ie) {
        var ue = K.every(function(ge) {
          return ge(Q, ie);
        });
        return ue ? true : ie.fail(null, null, 0);
      };
    }, G;
  }(b);
  a3.TIntersection = T;
  function d(Z) {
    return new p(Z);
  }
  a3.enumtype = d;
  var p = function(Z) {
    s(G, Z);
    function G(B) {
      var z = Z.call(this) || this;
      return z.members = B, z.validValues = /* @__PURE__ */ new Set(), z._failMsg = "is not a valid enum value", z.validValues = new Set(Object.keys(B).map(function(M) {
        return B[M];
      })), z;
    }
    return G.prototype.getChecker = function(B, z) {
      var M = this;
      return function(K, Q) {
        return M.validValues.has(K) ? true : Q.fail(null, M._failMsg, 0);
      };
    }, G;
  }(b);
  a3.TEnumType = p;
  function h(Z, G) {
    return new m(Z, G);
  }
  a3.enumlit = h;
  var m = function(Z) {
    s(G, Z);
    function G(B, z) {
      var M = Z.call(this) || this;
      return M.enumName = B, M.prop = z, M._failMsg = "is not " + B + "." + z, M;
    }
    return G.prototype.getChecker = function(B, z) {
      var M = this, K = R(B, this.enumName);
      if (!(K instanceof p)) throw new Error("Type " + this.enumName + " used in enumlit is not an enum type");
      var Q = K.members[this.prop];
      if (!K.members.hasOwnProperty(this.prop)) throw new Error("Unknown value " + this.enumName + "." + this.prop + " used in enumlit");
      return function(ie, ue) {
        return ie === Q ? true : ue.fail(null, M._failMsg, -1);
      };
    }, G;
  }(b);
  a3.TEnumLiteral = m;
  function E(Z) {
    return Object.keys(Z).map(function(G) {
      return _(G, Z[G]);
    });
  }
  function _(Z, G) {
    return G instanceof D ? new j(Z, G.ttype, true) : new j(Z, A(G), false);
  }
  function C(Z, G) {
    return new w(Z, E(G));
  }
  a3.iface = C;
  var w = function(Z) {
    s(G, Z);
    function G(B, z) {
      var M = Z.call(this) || this;
      return M.bases = B, M.props = z, M.propSet = new Set(z.map(function(K) {
        return K.name;
      })), M;
    }
    return G.prototype.getChecker = function(B, z, M) {
      var K = this, Q = this.bases.map(function(fe) {
        return R(B, fe).getChecker(B, z);
      }), ie = this.props.map(function(fe) {
        return fe.ttype.getChecker(B, z);
      }), ue = new o.NoopContext(), ge = this.props.map(function(fe, Pe) {
        return !fe.isOpt && !ie[Pe](void 0, ue);
      }), Te = function(fe, Pe) {
        if (typeof fe != "object" || fe === null) return Pe.fail(null, "is not an object", 0);
        for (var xe = 0; xe < Q.length; xe++) if (!Q[xe](fe, Pe)) return false;
        for (var xe = 0; xe < ie.length; xe++) {
          var we = K.props[xe].name, me = fe[we];
          if (me === void 0) {
            if (ge[xe]) return Pe.fail(we, "is missing", 1);
          } else {
            var ye = ie[xe](me, Pe);
            if (!ye) return Pe.fail(we, null, 1);
          }
        }
        return true;
      };
      if (!z) return Te;
      var le = this.propSet;
      return M && (this.propSet.forEach(function(fe) {
        return M.add(fe);
      }), le = M), function(fe, Pe) {
        if (!Te(fe, Pe)) return false;
        for (var xe in fe) if (!le.has(xe)) return Pe.fail(xe, "is extraneous", 2);
        return true;
      };
    }, G;
  }(b);
  a3.TIface = w;
  function I(Z) {
    return new D(A(Z));
  }
  a3.opt = I;
  var D = function(Z) {
    s(G, Z);
    function G(B) {
      var z = Z.call(this) || this;
      return z.ttype = B, z;
    }
    return G.prototype.getChecker = function(B, z) {
      var M = this.ttype.getChecker(B, z);
      return function(K, Q) {
        return K === void 0 || M(K, Q);
      };
    }, G;
  }(b);
  a3.TOptional = D;
  var j = /* @__PURE__ */ function() {
    function Z(G, B, z) {
      this.name = G, this.ttype = B, this.isOpt = z;
    }
    return Z;
  }();
  a3.TProp = j;
  function L(Z) {
    for (var G = [], B = 1; B < arguments.length; B++) G[B - 1] = arguments[B];
    return new k(new W(G), A(Z));
  }
  a3.func = L;
  var k = function(Z) {
    s(G, Z);
    function G(B, z) {
      var M = Z.call(this) || this;
      return M.paramList = B, M.result = z, M;
    }
    return G.prototype.getChecker = function(B, z) {
      return function(M, K) {
        return typeof M == "function" ? true : K.fail(null, "is not a function", 0);
      };
    }, G;
  }(b);
  a3.TFunc = k;
  function N(Z, G, B) {
    return new F(Z, A(G), !!B);
  }
  a3.param = N;
  var F = /* @__PURE__ */ function() {
    function Z(G, B, z) {
      this.name = G, this.ttype = B, this.isOpt = z;
    }
    return Z;
  }();
  a3.TParam = F;
  var W = function(Z) {
    s(G, Z);
    function G(B) {
      var z = Z.call(this) || this;
      return z.params = B, z;
    }
    return G.prototype.getChecker = function(B, z) {
      var M = this, K = this.params.map(function(ge) {
        return ge.ttype.getChecker(B, z);
      }), Q = new o.NoopContext(), ie = this.params.map(function(ge, Te) {
        return !ge.isOpt && !K[Te](void 0, Q);
      }), ue = function(ge, Te) {
        if (!Array.isArray(ge)) return Te.fail(null, "is not an array", 0);
        for (var le = 0; le < K.length; le++) {
          var fe = M.params[le];
          if (ge[le] === void 0) {
            if (ie[le]) return Te.fail(fe.name, "is missing", 1);
          } else {
            var Pe = K[le](ge[le], Te);
            if (!Pe) return Te.fail(fe.name, null, 1);
          }
        }
        return true;
      };
      return z ? function(ge, Te) {
        return ue(ge, Te) ? ge.length <= K.length ? true : Te.fail(K.length, "is extraneous", 2) : false;
      } : ue;
    }, G;
  }(b);
  a3.TParamList = W;
  var X = function(Z) {
    s(G, Z);
    function G(B, z) {
      var M = Z.call(this) || this;
      return M.validator = B, M.message = z, M;
    }
    return G.prototype.getChecker = function(B, z) {
      var M = this;
      return function(K, Q) {
        return M.validator(K) ? true : Q.fail(null, M.message, 0);
      };
    }, G;
  }(b);
  a3.BasicType = X, a3.basicTypes = { any: new X(function(Z) {
    return true;
  }, "is invalid"), number: new X(function(Z) {
    return typeof Z == "number";
  }, "is not a number"), object: new X(function(Z) {
    return typeof Z == "object" && Z;
  }, "is not an object"), boolean: new X(function(Z) {
    return typeof Z == "boolean";
  }, "is not a boolean"), string: new X(function(Z) {
    return typeof Z == "string";
  }, "is not a string"), symbol: new X(function(Z) {
    return typeof Z == "symbol";
  }, "is not a symbol"), void: new X(function(Z) {
    return Z == null;
  }, "is not void"), undefined: new X(function(Z) {
    return Z === void 0;
  }, "is not undefined"), null: new X(function(Z) {
    return Z === null;
  }, "is not null"), never: new X(function(Z) {
    return false;
  }, "is unexpected"), Date: new X(U("[object Date]"), "is not a Date"), RegExp: new X(U("[object RegExp]"), "is not a RegExp") };
  var H = Object.prototype.toString;
  function U(Z) {
    return function(G) {
      return typeof G == "object" && G && H.call(G) === Z;
    };
  }
  typeof Buffer < "u" && (a3.basicTypes.Buffer = new X(function(Z) {
    return Buffer.isBuffer(Z);
  }, "is not a Buffer"));
  for (var q = function(Z) {
    a3.basicTypes[Z.name] = new X(function(G) {
      return G instanceof Z;
    }, "is not a " + Z.name);
  }, ee = 0, re = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; ee < re.length; ee++) {
    var Y = re[ee];
    q(Y);
  }
})(cu);
(function(a3) {
  var s = Yn && Yn.__spreadArrays || function() {
    for (var l = 0, n = 0, u = arguments.length; n < u; n++) l += arguments[n].length;
    for (var c = Array(l), e = 0, n = 0; n < u; n++) for (var r = arguments[n], f = 0, y = r.length; f < y; f++, e++) c[e] = r[f];
    return c;
  };
  Object.defineProperty(a3, "__esModule", { value: true }), a3.Checker = a3.createCheckers = void 0;
  var o = cu, b = zr, A = cu;
  Object.defineProperty(a3, "TArray", { enumerable: true, get: function() {
    return A.TArray;
  } }), Object.defineProperty(a3, "TEnumType", { enumerable: true, get: function() {
    return A.TEnumType;
  } }), Object.defineProperty(a3, "TEnumLiteral", { enumerable: true, get: function() {
    return A.TEnumLiteral;
  } }), Object.defineProperty(a3, "TFunc", { enumerable: true, get: function() {
    return A.TFunc;
  } }), Object.defineProperty(a3, "TIface", { enumerable: true, get: function() {
    return A.TIface;
  } }), Object.defineProperty(a3, "TLiteral", { enumerable: true, get: function() {
    return A.TLiteral;
  } }), Object.defineProperty(a3, "TName", { enumerable: true, get: function() {
    return A.TName;
  } }), Object.defineProperty(a3, "TOptional", { enumerable: true, get: function() {
    return A.TOptional;
  } }), Object.defineProperty(a3, "TParam", { enumerable: true, get: function() {
    return A.TParam;
  } }), Object.defineProperty(a3, "TParamList", { enumerable: true, get: function() {
    return A.TParamList;
  } }), Object.defineProperty(a3, "TProp", { enumerable: true, get: function() {
    return A.TProp;
  } }), Object.defineProperty(a3, "TTuple", { enumerable: true, get: function() {
    return A.TTuple;
  } }), Object.defineProperty(a3, "TType", { enumerable: true, get: function() {
    return A.TType;
  } }), Object.defineProperty(a3, "TUnion", { enumerable: true, get: function() {
    return A.TUnion;
  } }), Object.defineProperty(a3, "TIntersection", { enumerable: true, get: function() {
    return A.TIntersection;
  } }), Object.defineProperty(a3, "array", { enumerable: true, get: function() {
    return A.array;
  } }), Object.defineProperty(a3, "enumlit", { enumerable: true, get: function() {
    return A.enumlit;
  } }), Object.defineProperty(a3, "enumtype", { enumerable: true, get: function() {
    return A.enumtype;
  } }), Object.defineProperty(a3, "func", { enumerable: true, get: function() {
    return A.func;
  } }), Object.defineProperty(a3, "iface", { enumerable: true, get: function() {
    return A.iface;
  } }), Object.defineProperty(a3, "lit", { enumerable: true, get: function() {
    return A.lit;
  } }), Object.defineProperty(a3, "name", { enumerable: true, get: function() {
    return A.name;
  } }), Object.defineProperty(a3, "opt", { enumerable: true, get: function() {
    return A.opt;
  } }), Object.defineProperty(a3, "param", { enumerable: true, get: function() {
    return A.param;
  } }), Object.defineProperty(a3, "tuple", { enumerable: true, get: function() {
    return A.tuple;
  } }), Object.defineProperty(a3, "union", { enumerable: true, get: function() {
    return A.union;
  } }), Object.defineProperty(a3, "intersection", { enumerable: true, get: function() {
    return A.intersection;
  } }), Object.defineProperty(a3, "BasicType", { enumerable: true, get: function() {
    return A.BasicType;
  } });
  var R = zr;
  Object.defineProperty(a3, "VError", { enumerable: true, get: function() {
    return R.VError;
  } });
  function P() {
    for (var l = [], n = 0; n < arguments.length; n++) l[n] = arguments[n];
    for (var u = Object.assign.apply(Object, s([{}, o.basicTypes], l)), c = {}, e = 0, r = l; e < r.length; e++) for (var f = r[e], y = 0, S = Object.keys(f); y < S.length; y++) {
      var T = S[y];
      c[T] = new t(u, f[T]);
    }
    return c;
  }
  a3.createCheckers = P;
  var t = function() {
    function l(n, u, c) {
      if (c === void 0 && (c = "value"), this.suite = n, this.ttype = u, this._path = c, this.props = /* @__PURE__ */ new Map(), u instanceof o.TIface) for (var e = 0, r = u.props; e < r.length; e++) {
        var f = r[e];
        this.props.set(f.name, f.ttype);
      }
      this.checkerPlain = this.ttype.getChecker(n, false), this.checkerStrict = this.ttype.getChecker(n, true);
    }
    return l.prototype.setReportedPath = function(n) {
      this._path = n;
    }, l.prototype.check = function(n) {
      return this._doCheck(this.checkerPlain, n);
    }, l.prototype.test = function(n) {
      return this.checkerPlain(n, new b.NoopContext());
    }, l.prototype.validate = function(n) {
      return this._doValidate(this.checkerPlain, n);
    }, l.prototype.strictCheck = function(n) {
      return this._doCheck(this.checkerStrict, n);
    }, l.prototype.strictTest = function(n) {
      return this.checkerStrict(n, new b.NoopContext());
    }, l.prototype.strictValidate = function(n) {
      return this._doValidate(this.checkerStrict, n);
    }, l.prototype.getProp = function(n) {
      var u = this.props.get(n);
      if (!u) throw new Error("Type has no property " + n);
      return new l(this.suite, u, this._path + "." + n);
    }, l.prototype.methodArgs = function(n) {
      var u = this._getMethod(n);
      return new l(this.suite, u.paramList);
    }, l.prototype.methodResult = function(n) {
      var u = this._getMethod(n);
      return new l(this.suite, u.result);
    }, l.prototype.getArgs = function() {
      if (!(this.ttype instanceof o.TFunc)) throw new Error("getArgs() applied to non-function");
      return new l(this.suite, this.ttype.paramList);
    }, l.prototype.getResult = function() {
      if (!(this.ttype instanceof o.TFunc)) throw new Error("getResult() applied to non-function");
      return new l(this.suite, this.ttype.result);
    }, l.prototype.getType = function() {
      return this.ttype;
    }, l.prototype._doCheck = function(n, u) {
      var c = new b.NoopContext();
      if (!n(u, c)) {
        var e = new b.DetailContext();
        throw n(u, e), e.getError(this._path);
      }
    }, l.prototype._doValidate = function(n, u) {
      var c = new b.NoopContext();
      if (n(u, c)) return null;
      var e = new b.DetailContext();
      return n(u, e), e.getErrorDetail(this._path);
    }, l.prototype._getMethod = function(n) {
      var u = this.props.get(n);
      if (!u) throw new Error("Type has no property " + n);
      if (!(u instanceof o.TFunc)) throw new Error("Property " + n + " is not a method");
      return u;
    }, l;
  }();
  a3.Checker = t;
})(mn);
const rx = mn.union(mn.lit("jsx"), mn.lit("typescript"), mn.lit("flow"), mn.lit("imports"), mn.lit("react-hot-loader"), mn.lit("jest")), sx = mn.iface([], { compiledFilename: "string" }), ix = mn.iface([], { transforms: mn.array("Transform"), disableESTransforms: mn.opt("boolean"), jsxRuntime: mn.opt(mn.union(mn.lit("classic"), mn.lit("automatic"), mn.lit("preserve"))), production: mn.opt("boolean"), jsxImportSource: mn.opt("string"), jsxPragma: mn.opt("string"), jsxFragmentPragma: mn.opt("string"), keepUnusedImports: mn.opt("boolean"), preserveDynamicImport: mn.opt("boolean"), injectCreateRequireForImportRequire: mn.opt("boolean"), enableLegacyTypeScriptModuleInterop: mn.opt("boolean"), enableLegacyBabel5ModuleInterop: mn.opt("boolean"), sourceMapOptions: mn.opt("SourceMapOptions"), filePath: mn.opt("string") }), ax = { Transform: rx, SourceMapOptions: sx, Options: ix }, { Options: ox } = mn.createCheckers(ax);
function lx(a3) {
  ox.strictCheck(a3);
}
function fy() {
  lt(), Hn(false);
}
function hy(a3) {
  lt(), vo(a3);
}
function vs(a3) {
  Lt(), Nc(a3);
}
function Ra() {
  Lt(), te.tokens[te.tokens.length - 1].identifierRole = Rt.ImportDeclaration;
}
function Nc(a3) {
  let s;
  te.scopeDepth === 0 ? s = Rt.TopLevelDeclaration : a3 ? s = Rt.BlockScopedDeclaration : s = Rt.FunctionScopedDeclaration, te.tokens[te.tokens.length - 1].identifierRole = s;
}
function vo(a3) {
  switch (te.type) {
    case x._this: {
      const s = Gt(0);
      lt(), Ht(s);
      return;
    }
    case x._yield:
    case x.name: {
      te.type = x.name, vs(a3);
      return;
    }
    case x.bracketL: {
      lt(), Rc(x.bracketR, a3, true);
      return;
    }
    case x.braceL:
      Gc(true, a3);
      return;
    default:
      Wt();
  }
}
function Rc(a3, s, o = false, b = false, A = 0) {
  let R = true, P = false;
  const t = te.tokens.length;
  for (; !et(a3) && !te.error; ) if (R ? R = false : (ot(x.comma), te.tokens[te.tokens.length - 1].contextId = A, !P && te.tokens[t].isType && (te.tokens[te.tokens.length - 1].isType = true, P = true)), !(o && Ae(x.comma))) {
    if (et(a3)) break;
    if (Ae(x.ellipsis)) {
      hy(s), my(), et(x.comma), ot(a3);
      break;
    } else ux(b, s);
  }
}
function ux(a3, s) {
  a3 && jc([Fe._public, Fe._protected, Fe._private, Fe._readonly, Fe._override]), ja(s), my(), ja(s, true);
}
function my() {
  an ? AC() : nn && bA();
}
function ja(a3, s = false) {
  if (s || vo(a3), !et(x.eq)) return;
  const o = te.tokens.length - 1;
  Hn(), te.tokens[o].rhsEndIndex = te.tokens.length;
}
function pu() {
  return Ae(x.name);
}
function cx() {
  return Ae(x.name) || !!(te.type & x.IS_KEYWORD) || Ae(x.string) || Ae(x.num) || Ae(x.bigint) || Ae(x.decimal);
}
function yy() {
  const a3 = te.snapshot();
  return lt(), (Ae(x.bracketL) || Ae(x.braceL) || Ae(x.star) || Ae(x.ellipsis) || Ae(x.hash) || cx()) && !nr() ? true : (te.restoreFromSnapshot(a3), false);
}
function jc(a3) {
  for (; by(a3) !== null; ) ;
}
function by(a3) {
  if (!Ae(x.name)) return null;
  const s = te.contextualKeyword;
  if (a3.indexOf(s) !== -1 && yy()) {
    switch (s) {
      case Fe._readonly:
        te.tokens[te.tokens.length - 1].type = x._readonly;
        break;
      case Fe._abstract:
        te.tokens[te.tokens.length - 1].type = x._abstract;
        break;
      case Fe._static:
        te.tokens[te.tokens.length - 1].type = x._static;
        break;
      case Fe._public:
        te.tokens[te.tokens.length - 1].type = x._public;
        break;
      case Fe._private:
        te.tokens[te.tokens.length - 1].type = x._private;
        break;
      case Fe._protected:
        te.tokens[te.tokens.length - 1].type = x._protected;
        break;
      case Fe._override:
        te.tokens[te.tokens.length - 1].type = x._override;
        break;
      case Fe._declare:
        te.tokens[te.tokens.length - 1].type = x._declare;
        break;
    }
    return s;
  }
  return null;
}
function Bi() {
  for (Lt(); et(x.dot); ) Lt();
}
function px() {
  Bi(), !nr() && Ae(x.lessThan) && Zs();
}
function dx() {
  lt(), $i();
}
function fx() {
  lt();
}
function hx() {
  ot(x._typeof), Ae(x._import) ? gy() : Bi(), !nr() && Ae(x.lessThan) && Zs();
}
function gy() {
  ot(x._import), ot(x.parenL), ot(x.string), ot(x.parenR), et(x.dot) && Bi(), Ae(x.lessThan) && Zs();
}
function mx() {
  et(x._const);
  const a3 = et(x._in), s = Mn(Fe._out);
  et(x._const), (a3 || s) && !Ae(x.name) ? te.tokens[te.tokens.length - 1].type = x.name : Lt(), et(x._extends) && In(), et(x.eq) && In();
}
function Ds() {
  Ae(x.lessThan) && Eo();
}
function Eo() {
  const a3 = Gt(0);
  for (Ae(x.lessThan) || Ae(x.typeParameterStart) ? lt() : Wt(); !et(x.greaterThan) && !te.error; ) mx(), et(x.comma);
  Ht(a3);
}
function Lc(a3) {
  const s = a3 === x.arrow;
  Ds(), ot(x.parenL), te.scopeDepth++, yx(false), te.scopeDepth--, (s || Ae(a3)) && Si(a3);
}
function yx(a3) {
  Rc(x.parenR, a3);
}
function La() {
  et(x.comma) || Sn();
}
function Hd() {
  Lc(x.colon), La();
}
function bx() {
  const a3 = te.snapshot();
  lt();
  const s = et(x.name) && Ae(x.colon);
  return te.restoreFromSnapshot(a3), s;
}
function vy() {
  if (!(Ae(x.bracketL) && bx())) return false;
  const a3 = Gt(0);
  return ot(x.bracketL), Lt(), $i(), ot(x.bracketR), Qs(), La(), Ht(a3), true;
}
function Gd(a3) {
  et(x.question), !a3 && (Ae(x.parenL) || Ae(x.lessThan)) ? (Lc(x.colon), La()) : (Qs(), La());
}
function gx() {
  if (Ae(x.parenL) || Ae(x.lessThan)) {
    Hd();
    return;
  }
  if (Ae(x._new)) {
    lt(), Ae(x.parenL) || Ae(x.lessThan) ? Hd() : Gd(false);
    return;
  }
  const a3 = !!by([Fe._readonly]);
  vy() || ((It(Fe._get) || It(Fe._set)) && yy(), _i(-1), Gd(a3));
}
function vx() {
  Ey();
}
function Ey() {
  for (ot(x.braceL); !et(x.braceR) && !te.error; ) gx();
}
function Ex() {
  const a3 = te.snapshot(), s = Sx();
  return te.restoreFromSnapshot(a3), s;
}
function Sx() {
  return lt(), et(x.plus) || et(x.minus) ? It(Fe._readonly) : (It(Fe._readonly) && lt(), !Ae(x.bracketL) || (lt(), !pu()) ? false : (lt(), Ae(x._in)));
}
function _x() {
  Lt(), ot(x._in), In();
}
function Tx() {
  ot(x.braceL), Ae(x.plus) || Ae(x.minus) ? (lt(), Nn(Fe._readonly)) : Mn(Fe._readonly), ot(x.bracketL), _x(), Mn(Fe._as) && In(), ot(x.bracketR), Ae(x.plus) || Ae(x.minus) ? (lt(), ot(x.question)) : et(x.question), Fx(), Sn(), ot(x.braceR);
}
function wx() {
  for (ot(x.bracketL); !et(x.bracketR) && !te.error; ) Px(), et(x.comma);
}
function Px() {
  et(x.ellipsis) ? In() : (In(), et(x.question)), et(x.colon) && In();
}
function xx() {
  ot(x.parenL), In(), ot(x.parenR);
}
function Ax() {
  for (ps(), ps(); !Ae(x.backQuote) && !te.error; ) ot(x.dollarBraceL), In(), ps(), ps();
  lt();
}
var hs;
(function(a3) {
  a3[a3.TSFunctionType = 0] = "TSFunctionType";
  const o = 1;
  a3[a3.TSConstructorType = o] = "TSConstructorType";
  const b = o + 1;
  a3[a3.TSAbstractConstructorType = b] = "TSAbstractConstructorType";
})(hs || (hs = {}));
function tl(a3) {
  a3 === hs.TSAbstractConstructorType && Nn(Fe._abstract), (a3 === hs.TSConstructorType || a3 === hs.TSAbstractConstructorType) && ot(x._new);
  const s = te.inDisallowConditionalTypesContext;
  te.inDisallowConditionalTypesContext = false, Lc(x.arrow), te.inDisallowConditionalTypesContext = s;
}
function Cx() {
  switch (te.type) {
    case x.name:
      px();
      return;
    case x._void:
    case x._null:
      lt();
      return;
    case x.string:
    case x.num:
    case x.bigint:
    case x.decimal:
    case x._true:
    case x._false:
      Ys();
      return;
    case x.minus:
      lt(), Ys();
      return;
    case x._this: {
      fx(), It(Fe._is) && !nr() && dx();
      return;
    }
    case x._typeof:
      hx();
      return;
    case x._import:
      gy();
      return;
    case x.braceL:
      Ex() ? Tx() : vx();
      return;
    case x.bracketL:
      wx();
      return;
    case x.parenL:
      xx();
      return;
    case x.backQuote:
      Ax();
      return;
    default:
      if (te.type & x.IS_KEYWORD) {
        lt(), te.tokens[te.tokens.length - 1].type = x.name;
        return;
      }
      break;
  }
  Wt();
}
function Ix() {
  for (Cx(); !nr() && et(x.bracketL); ) et(x.bracketR) || (In(), ot(x.bracketR));
}
function kx() {
  if (Nn(Fe._infer), Lt(), Ae(x._extends)) {
    const a3 = te.snapshot();
    ot(x._extends);
    const s = te.inDisallowConditionalTypesContext;
    te.inDisallowConditionalTypesContext = true, In(), te.inDisallowConditionalTypesContext = s, (te.error || !te.inDisallowConditionalTypesContext && Ae(x.question)) && te.restoreFromSnapshot(a3);
  }
}
function du() {
  if (It(Fe._keyof) || It(Fe._unique) || It(Fe._readonly)) lt(), du();
  else if (It(Fe._infer)) kx();
  else {
    const a3 = te.inDisallowConditionalTypesContext;
    te.inDisallowConditionalTypesContext = false, Ix(), te.inDisallowConditionalTypesContext = a3;
  }
}
function zd() {
  if (et(x.bitwiseAND), du(), Ae(x.bitwiseAND)) for (; et(x.bitwiseAND); ) du();
}
function Ox() {
  if (et(x.bitwiseOR), zd(), Ae(x.bitwiseOR)) for (; et(x.bitwiseOR); ) zd();
}
function Dx() {
  return Ae(x.lessThan) ? true : Ae(x.parenL) && Rx();
}
function Nx() {
  if (Ae(x.name) || Ae(x._this)) return lt(), true;
  if (Ae(x.braceL) || Ae(x.bracketL)) {
    let a3 = 1;
    for (lt(); a3 > 0 && !te.error; ) Ae(x.braceL) || Ae(x.bracketL) ? a3++ : (Ae(x.braceR) || Ae(x.bracketR)) && a3--, lt();
    return true;
  }
  return false;
}
function Rx() {
  const a3 = te.snapshot(), s = jx();
  return te.restoreFromSnapshot(a3), s;
}
function jx() {
  return lt(), !!(Ae(x.parenR) || Ae(x.ellipsis) || Nx() && (Ae(x.colon) || Ae(x.comma) || Ae(x.question) || Ae(x.eq) || Ae(x.parenR) && (lt(), Ae(x.arrow))));
}
function Si(a3) {
  const s = Gt(0);
  ot(a3), Mx() || In(), Ht(s);
}
function Lx() {
  Ae(x.colon) && Si(x.colon);
}
function Qs() {
  Ae(x.colon) && $i();
}
function Fx() {
  et(x.colon) && In();
}
function Mx() {
  const a3 = te.snapshot();
  return It(Fe._asserts) ? (lt(), Mn(Fe._is) ? (In(), true) : pu() || Ae(x._this) ? (lt(), Mn(Fe._is) && In(), true) : (te.restoreFromSnapshot(a3), false)) : pu() || Ae(x._this) ? (lt(), It(Fe._is) && !nr() ? (lt(), In(), true) : (te.restoreFromSnapshot(a3), false)) : false;
}
function $i() {
  const a3 = Gt(0);
  ot(x.colon), In(), Ht(a3);
}
function In() {
  if (Kd(), te.inDisallowConditionalTypesContext || nr() || !et(x._extends)) return;
  const a3 = te.inDisallowConditionalTypesContext;
  te.inDisallowConditionalTypesContext = true, Kd(), te.inDisallowConditionalTypesContext = a3, ot(x.question), In(), ot(x.colon), In();
}
function Bx() {
  return It(Fe._abstract) && Cn() === x._new;
}
function Kd() {
  if (Dx()) {
    tl(hs.TSFunctionType);
    return;
  }
  if (Ae(x._new)) {
    tl(hs.TSConstructorType);
    return;
  } else if (Bx()) {
    tl(hs.TSAbstractConstructorType);
    return;
  }
  Ox();
}
function $x() {
  const a3 = Gt(1);
  In(), ot(x.greaterThan), Ht(a3), Ui();
}
function Ux() {
  if (et(x.jsxTagStart)) {
    te.tokens[te.tokens.length - 1].type = x.typeParameterStart;
    const a3 = Gt(1);
    for (; !Ae(x.greaterThan) && !te.error; ) In(), et(x.comma);
    Pr(), Ht(a3);
  }
}
function Sy() {
  for (; !Ae(x.braceL) && !te.error; ) Vx(), et(x.comma);
}
function Vx() {
  Bi(), Ae(x.lessThan) && Zs();
}
function Wx() {
  vs(false), Ds(), et(x._extends) && Sy(), Ey();
}
function Hx() {
  vs(false), Ds(), ot(x.eq), In(), Sn();
}
function Gx() {
  if (Ae(x.string) ? Ys() : Lt(), et(x.eq)) {
    const a3 = te.tokens.length - 1;
    Hn(), te.tokens[a3].rhsEndIndex = te.tokens.length;
  }
}
function Fc() {
  for (vs(false), ot(x.braceL); !et(x.braceR) && !te.error; ) Gx(), et(x.comma);
}
function Mc() {
  ot(x.braceL), wo(x.braceR);
}
function fu() {
  vs(false), et(x.dot) ? fu() : Mc();
}
function _y() {
  It(Fe._global) ? Lt() : Ae(x.string) ? ss() : Wt(), Ae(x.braceL) ? Mc() : Sn();
}
function hu() {
  Ra(), ot(x.eq), Kx(), Sn();
}
function zx() {
  return It(Fe._require) && Cn() === x.parenL;
}
function Kx() {
  zx() ? qx() : Bi();
}
function qx() {
  Nn(Fe._require), ot(x.parenL), Ae(x.string) || Wt(), Ys(), ot(x.parenR);
}
function Yx() {
  if (Hr()) return false;
  switch (te.type) {
    case x._function: {
      const a3 = Gt(1);
      lt();
      const s = te.start;
      return As(s, true), Ht(a3), true;
    }
    case x._class: {
      const a3 = Gt(1);
      return Cs(true, false), Ht(a3), true;
    }
    case x._const:
      if (Ae(x._const) && kc(Fe._enum)) {
        const a3 = Gt(1);
        return ot(x._const), Nn(Fe._enum), te.tokens[te.tokens.length - 1].type = x._enum, Fc(), Ht(a3), true;
      }
    case x._var:
    case x._let: {
      const a3 = Gt(1);
      return Sa(te.type !== x._var), Ht(a3), true;
    }
    case x.name: {
      const a3 = Gt(1), s = te.contextualKeyword;
      let o = false;
      return s === Fe._global ? (_y(), o = true) : o = So(s, true), Ht(a3), o;
    }
    default:
      return false;
  }
}
function qd() {
  return So(te.contextualKeyword, true);
}
function Xx(a3) {
  switch (a3) {
    case Fe._declare: {
      const s = te.tokens.length - 1;
      if (Yx()) return te.tokens[s].type = x._declare, true;
      break;
    }
    case Fe._global:
      if (Ae(x.braceL)) return Mc(), true;
      break;
    default:
      return So(a3, false);
  }
  return false;
}
function So(a3, s) {
  switch (a3) {
    case Fe._abstract:
      if ($s(s) && Ae(x._class)) return te.tokens[te.tokens.length - 1].type = x._abstract, Cs(true, false), true;
      break;
    case Fe._enum:
      if ($s(s) && Ae(x.name)) return te.tokens[te.tokens.length - 1].type = x._enum, Fc(), true;
      break;
    case Fe._interface:
      if ($s(s) && Ae(x.name)) {
        const o = Gt(s ? 2 : 1);
        return Wx(), Ht(o), true;
      }
      break;
    case Fe._module:
      if ($s(s)) {
        if (Ae(x.string)) {
          const o = Gt(s ? 2 : 1);
          return _y(), Ht(o), true;
        } else if (Ae(x.name)) {
          const o = Gt(s ? 2 : 1);
          return fu(), Ht(o), true;
        }
      }
      break;
    case Fe._namespace:
      if ($s(s) && Ae(x.name)) {
        const o = Gt(s ? 2 : 1);
        return fu(), Ht(o), true;
      }
      break;
    case Fe._type:
      if ($s(s) && Ae(x.name)) {
        const o = Gt(s ? 2 : 1);
        return Hx(), Ht(o), true;
      }
      break;
  }
  return false;
}
function $s(a3) {
  return a3 ? (lt(), true) : !Hr();
}
function Jx() {
  const a3 = te.snapshot();
  return Eo(), ei(), Lx(), ot(x.arrow), te.error ? (te.restoreFromSnapshot(a3), false) : (Vi(true), true);
}
function Bc() {
  te.type === x.bitShiftL && (te.pos -= 1, Vt(x.lessThan)), Zs();
}
function Zs() {
  const a3 = Gt(0);
  for (ot(x.lessThan); !Ae(x.greaterThan) && !te.error; ) In(), et(x.comma);
  a3 ? (ot(x.greaterThan), Ht(a3)) : (Ht(a3), ry(), ot(x.greaterThan), te.tokens[te.tokens.length - 1].isType = true);
}
function Ty() {
  if (Ae(x.name)) switch (te.contextualKeyword) {
    case Fe._abstract:
    case Fe._declare:
    case Fe._enum:
    case Fe._interface:
    case Fe._module:
    case Fe._namespace:
    case Fe._type:
      return true;
  }
  return false;
}
function Qx(a3, s) {
  if (Ae(x.colon) && Si(x.colon), !Ae(x.braceL) && Hr()) {
    let o = te.tokens.length - 1;
    for (; o >= 0 && (te.tokens[o].start >= a3 || te.tokens[o].type === x._default || te.tokens[o].type === x._export); ) te.tokens[o].isType = true, o--;
    return;
  }
  Vi(false, s);
}
function Zx(a3, s, o) {
  if (!nr() && et(x.bang)) {
    te.tokens[te.tokens.length - 1].type = x.nonNullAssertion;
    return;
  }
  if (Ae(x.lessThan) || Ae(x.bitShiftL)) {
    const b = te.snapshot();
    if (!s && Oy() && Jx()) return;
    if (Bc(), !s && et(x.parenL) ? (te.tokens[te.tokens.length - 1].subscriptStartIndex = a3, ms()) : Ae(x.backQuote) ? Hc() : (te.type === x.greaterThan || te.type !== x.parenL && te.type & x.IS_EXPRESSION_START && !nr()) && Wt(), te.error) te.restoreFromSnapshot(b);
    else return;
  } else !s && Ae(x.questionDot) && Cn() === x.lessThan && (lt(), te.tokens[a3].isOptionalChainStart = true, te.tokens[te.tokens.length - 1].subscriptStartIndex = a3, Zs(), ot(x.parenL), ms());
  Uc(a3, s, o);
}
function eA() {
  if (et(x._import)) return It(Fe._type) && Cn() !== x.eq && Nn(Fe._type), hu(), true;
  if (et(x.eq)) return Wn(), Sn(), true;
  if (Mn(Fe._as)) return Nn(Fe._namespace), Lt(), Sn(), true;
  if (It(Fe._type)) {
    const a3 = Cn();
    (a3 === x.braceL || a3 === x.star) && lt();
  }
  return false;
}
function tA() {
  if (Lt(), Ae(x.comma) || Ae(x.braceR)) {
    te.tokens[te.tokens.length - 1].identifierRole = Rt.ImportDeclaration;
    return;
  }
  if (Lt(), Ae(x.comma) || Ae(x.braceR)) {
    te.tokens[te.tokens.length - 1].identifierRole = Rt.ImportDeclaration, te.tokens[te.tokens.length - 2].isType = true, te.tokens[te.tokens.length - 1].isType = true;
    return;
  }
  if (Lt(), Ae(x.comma) || Ae(x.braceR)) {
    te.tokens[te.tokens.length - 3].identifierRole = Rt.ImportAccess, te.tokens[te.tokens.length - 1].identifierRole = Rt.ImportDeclaration;
    return;
  }
  Lt(), te.tokens[te.tokens.length - 3].identifierRole = Rt.ImportAccess, te.tokens[te.tokens.length - 1].identifierRole = Rt.ImportDeclaration, te.tokens[te.tokens.length - 4].isType = true, te.tokens[te.tokens.length - 3].isType = true, te.tokens[te.tokens.length - 2].isType = true, te.tokens[te.tokens.length - 1].isType = true;
}
function nA() {
  if (Lt(), Ae(x.comma) || Ae(x.braceR)) {
    te.tokens[te.tokens.length - 1].identifierRole = Rt.ExportAccess;
    return;
  }
  if (Lt(), Ae(x.comma) || Ae(x.braceR)) {
    te.tokens[te.tokens.length - 1].identifierRole = Rt.ExportAccess, te.tokens[te.tokens.length - 2].isType = true, te.tokens[te.tokens.length - 1].isType = true;
    return;
  }
  if (Lt(), Ae(x.comma) || Ae(x.braceR)) {
    te.tokens[te.tokens.length - 3].identifierRole = Rt.ExportAccess;
    return;
  }
  Lt(), te.tokens[te.tokens.length - 3].identifierRole = Rt.ExportAccess, te.tokens[te.tokens.length - 4].isType = true, te.tokens[te.tokens.length - 3].isType = true, te.tokens[te.tokens.length - 2].isType = true, te.tokens[te.tokens.length - 1].isType = true;
}
function rA() {
  if (It(Fe._abstract) && Cn() === x._class) return te.type = x._abstract, lt(), Cs(true, true), true;
  if (It(Fe._interface)) {
    const a3 = Gt(2);
    return So(Fe._interface, true), Ht(a3), true;
  }
  return false;
}
function sA() {
  if (te.type === x._const) {
    const a3 = Mi();
    if (a3.type === x.name && a3.contextualKeyword === Fe._enum) return ot(x._const), Nn(Fe._enum), te.tokens[te.tokens.length - 1].type = x._enum, Fc(), true;
  }
  return false;
}
function iA(a3) {
  const s = te.tokens.length;
  jc([Fe._abstract, Fe._readonly, Fe._declare, Fe._static, Fe._override]);
  const o = te.tokens.length;
  if (vy()) {
    const A = a3 ? s - 1 : s;
    for (let R = A; R < o; R++) te.tokens[R].isType = true;
    return true;
  }
  return false;
}
function aA(a3) {
  Xx(a3) || Sn();
}
function oA() {
  const a3 = Mn(Fe._declare);
  a3 && (te.tokens[te.tokens.length - 1].type = x._declare);
  let s = false;
  if (Ae(x.name)) if (a3) {
    const o = Gt(2);
    s = qd(), Ht(o);
  } else s = qd();
  if (!s) if (a3) {
    const o = Gt(2);
    gr(true), Ht(o);
  } else gr(true);
}
function lA(a3) {
  if (a3 && (Ae(x.lessThan) || Ae(x.bitShiftL)) && Bc(), Mn(Fe._implements)) {
    te.tokens[te.tokens.length - 1].type = x._implements;
    const s = Gt(1);
    Sy(), Ht(s);
  }
}
function uA() {
  Ds();
}
function cA() {
  Ds();
}
function pA() {
  const a3 = Gt(0);
  nr() || et(x.bang), Qs(), Ht(a3);
}
function dA() {
  Ae(x.colon) && $i();
}
function fA(a3, s) {
  return bo ? hA(a3, s) : mA(a3, s);
}
function hA(a3, s) {
  if (!Ae(x.lessThan)) return Kr(a3, s);
  const o = te.snapshot();
  let b = Kr(a3, s);
  if (te.error) te.restoreFromSnapshot(o);
  else return b;
  return te.type = x.typeParameterStart, Eo(), b = Kr(a3, s), b || Wt(), b;
}
function mA(a3, s) {
  if (!Ae(x.lessThan)) return Kr(a3, s);
  const o = te.snapshot();
  Eo();
  const b = Kr(a3, s);
  if (b || Wt(), te.error) te.restoreFromSnapshot(o);
  else return b;
  return Kr(a3, s);
}
function yA() {
  if (Ae(x.colon)) {
    const a3 = te.snapshot();
    Si(x.colon), mr() && Wt(), Ae(x.arrow) || Wt(), te.error && te.restoreFromSnapshot(a3);
  }
  return et(x.arrow);
}
function bA() {
  const a3 = Gt(0);
  et(x.question), Qs(), Ht(a3);
}
function gA() {
  (Ae(x.lessThan) || Ae(x.bitShiftL)) && Bc(), Wy();
}
function vA() {
  let a3 = false, s = false;
  for (; ; ) {
    if (te.pos >= mt.length) {
      Wt("Unterminated JSX contents");
      return;
    }
    const o = mt.charCodeAt(te.pos);
    if (o === Ge.lessThan || o === Ge.leftCurlyBrace) {
      if (te.pos === te.start) {
        if (o === Ge.lessThan) {
          te.pos++, Vt(x.jsxTagStart);
          return;
        }
        sy(o);
        return;
      }
      Vt(a3 && !s ? x.jsxEmptyText : x.jsxText);
      return;
    }
    o === Ge.lineFeed ? a3 = true : o !== Ge.space && o !== Ge.carriageReturn && o !== Ge.tab && (s = true), te.pos++;
  }
}
function EA(a3) {
  for (te.pos++; ; ) {
    if (te.pos >= mt.length) {
      Wt("Unterminated string constant");
      return;
    }
    if (mt.charCodeAt(te.pos) === a3) {
      te.pos++;
      break;
    }
    te.pos++;
  }
  Vt(x.string);
}
function SA() {
  let a3;
  do {
    if (te.pos > mt.length) {
      Wt("Unexpectedly reached the end of input.");
      return;
    }
    a3 = mt.charCodeAt(++te.pos);
  } while (jr[a3] || a3 === Ge.dash);
  Vt(x.jsxName);
}
function mu() {
  Pr();
}
function wy(a3) {
  if (mu(), !et(x.colon)) {
    te.tokens[te.tokens.length - 1].identifierRole = a3;
    return;
  }
  mu();
}
function Py() {
  const a3 = te.tokens.length;
  wy(Rt.Access);
  let s = false;
  for (; Ae(x.dot); ) s = true, Pr(), mu();
  if (!s) {
    const o = te.tokens[a3], b = mt.charCodeAt(o.start);
    b >= Ge.lowercaseA && b <= Ge.lowercaseZ && (o.identifierRole = null);
  }
}
function _A() {
  switch (te.type) {
    case x.braceL:
      lt(), Wn(), Pr();
      return;
    case x.jsxTagStart:
      Ay(), Pr();
      return;
    case x.string:
      Pr();
      return;
    default:
      Wt("JSX value should be either an expression or a quoted JSX text");
  }
}
function TA() {
  ot(x.ellipsis), Wn();
}
function wA(a3) {
  if (Ae(x.jsxTagEnd)) return false;
  Py(), nn && Ux();
  let s = false;
  for (; !Ae(x.slash) && !Ae(x.jsxTagEnd) && !te.error; ) {
    if (et(x.braceL)) {
      s = true, ot(x.ellipsis), Hn(), Pr();
      continue;
    }
    s && te.end - te.start === 3 && mt.charCodeAt(te.start) === Ge.lowercaseK && mt.charCodeAt(te.start + 1) === Ge.lowercaseE && mt.charCodeAt(te.start + 2) === Ge.lowercaseY && (te.tokens[a3].jsxRole = Nr.KeyAfterPropSpread), wy(Rt.ObjectKey), Ae(x.eq) && (Pr(), _A());
  }
  const o = Ae(x.slash);
  return o && Pr(), o;
}
function PA() {
  Ae(x.jsxTagEnd) || Py();
}
function xy() {
  const a3 = te.tokens.length - 1;
  te.tokens[a3].jsxRole = Nr.NoChildren;
  let s = 0;
  if (!wA(a3)) for (Us(); ; ) switch (te.type) {
    case x.jsxTagStart:
      if (Pr(), Ae(x.slash)) {
        Pr(), PA(), te.tokens[a3].jsxRole !== Nr.KeyAfterPropSpread && (s === 1 ? te.tokens[a3].jsxRole = Nr.OneChild : s > 1 && (te.tokens[a3].jsxRole = Nr.StaticChildren));
        return;
      }
      s++, xy(), Us();
      break;
    case x.jsxText:
      s++, Us();
      break;
    case x.jsxEmptyText:
      Us();
      break;
    case x.braceL:
      lt(), Ae(x.ellipsis) ? (TA(), Us(), s += 2) : (Ae(x.braceR) || (s++, Wn()), Us());
      break;
    default:
      Wt();
      return;
  }
}
function Ay() {
  Pr(), xy();
}
function Pr() {
  te.tokens.push(new go()), ty(), te.start = te.pos;
  const a3 = mt.charCodeAt(te.pos);
  if (Fi[a3]) SA();
  else if (a3 === Ge.quotationMark || a3 === Ge.apostrophe) EA(a3);
  else switch (++te.pos, a3) {
    case Ge.greaterThan:
      Vt(x.jsxTagEnd);
      break;
    case Ge.lessThan:
      Vt(x.jsxTagStart);
      break;
    case Ge.slash:
      Vt(x.slash);
      break;
    case Ge.equalsTo:
      Vt(x.eq);
      break;
    case Ge.leftCurlyBrace:
      Vt(x.braceL);
      break;
    case Ge.dot:
      Vt(x.dot);
      break;
    case Ge.colon:
      Vt(x.colon);
      break;
    default:
      Wt();
  }
}
function Us() {
  te.tokens.push(new go()), te.start = te.pos, vA();
}
function xA(a3) {
  if (Ae(x.question)) {
    const s = Cn();
    if (s === x.colon || s === x.comma || s === x.parenR) return;
  }
  Cy(a3);
}
function AA() {
  Xm(x.question), Ae(x.colon) && (nn ? $i() : an && Ns());
}
class CA {
  constructor(s) {
    this.stop = s;
  }
}
function Wn(a3 = false) {
  if (Hn(a3), Ae(x.comma)) for (; et(x.comma); ) Hn(a3);
}
function Hn(a3 = false, s = false) {
  return nn ? fA(a3, s) : an ? NC(a3, s) : Kr(a3, s);
}
function Kr(a3, s) {
  if (Ae(x._yield)) return HA(), false;
  (Ae(x.parenL) || Ae(x.name) || Ae(x._yield)) && (te.potentialArrowAt = te.start);
  const o = IA(a3);
  return s && Wc(), te.type & x.IS_ASSIGN ? (lt(), Hn(a3), false) : o;
}
function IA(a3) {
  return OA(a3) ? true : (kA(a3), false);
}
function kA(a3) {
  nn || an ? xA(a3) : Cy(a3);
}
function Cy(a3) {
  et(x.question) && (Hn(), ot(x.colon), Hn(a3));
}
function OA(a3) {
  const s = te.tokens.length;
  return Ui() ? true : (va(s, -1, a3), false);
}
function va(a3, s, o) {
  if (nn && (x._in & x.PRECEDENCE_MASK) > s && !nr() && (Mn(Fe._as) || Mn(Fe._satisfies))) {
    const A = Gt(1);
    In(), Ht(A), ry(), va(a3, s, o);
    return;
  }
  const b = te.type & x.PRECEDENCE_MASK;
  if (b > 0 && (!o || !Ae(x._in)) && b > s) {
    const A = te.type;
    lt(), A === x.nullishCoalescing && (te.tokens[te.tokens.length - 1].nullishStartIndex = a3);
    const R = te.tokens.length;
    Ui(), va(R, A & x.IS_RIGHT_ASSOCIATIVE ? b - 1 : b, o), A === x.nullishCoalescing && (te.tokens[a3].numNullishCoalesceStarts++, te.tokens[te.tokens.length - 1].numNullishCoalesceEnds++), va(a3, s, o);
  }
}
function Ui() {
  if (nn && !bo && et(x.lessThan)) return $x(), false;
  if (It(Fe._module) && Qm() === Ge.leftCurlyBrace && !Gm()) return GA(), false;
  if (te.type & x.IS_PREFIX) return lt(), Ui(), false;
  if (Iy()) return true;
  for (; te.type & x.IS_POSTFIX && !mr(); ) te.type === x.preIncDec && (te.type = x.postIncDec), lt();
  return false;
}
function Iy() {
  const a3 = te.tokens.length;
  return ss() ? true : ($c(a3), te.tokens.length > a3 && te.tokens[a3].isOptionalChainStart && (te.tokens[te.tokens.length - 1].isOptionalChainEnd = true), false);
}
function $c(a3, s = false) {
  an ? jC(a3, s) : ky(a3, s);
}
function ky(a3, s = false) {
  const o = new CA(false);
  do
    DA(a3, s, o);
  while (!o.stop && !te.error);
}
function DA(a3, s, o) {
  nn ? Zx(a3, s, o) : an ? mC(a3, s, o) : Uc(a3, s, o);
}
function Uc(a3, s, o) {
  if (!s && et(x.doubleColon)) Vc(), o.stop = true, $c(a3, s);
  else if (Ae(x.questionDot)) {
    if (te.tokens[a3].isOptionalChainStart = true, s && Cn() === x.parenL) {
      o.stop = true;
      return;
    }
    lt(), te.tokens[te.tokens.length - 1].subscriptStartIndex = a3, et(x.bracketL) ? (Wn(), ot(x.bracketR)) : et(x.parenL) ? ms() : Fa();
  } else if (et(x.dot)) te.tokens[te.tokens.length - 1].subscriptStartIndex = a3, Fa();
  else if (et(x.bracketL)) te.tokens[te.tokens.length - 1].subscriptStartIndex = a3, Wn(), ot(x.bracketR);
  else if (!s && Ae(x.parenL)) if (Oy()) {
    const b = te.snapshot(), A = te.tokens.length;
    lt(), te.tokens[te.tokens.length - 1].subscriptStartIndex = a3;
    const R = vi();
    te.tokens[te.tokens.length - 1].contextId = R, ms(), te.tokens[te.tokens.length - 1].contextId = R, NA() && (te.restoreFromSnapshot(b), o.stop = true, te.scopeDepth++, ei(), RA(A));
  } else {
    lt(), te.tokens[te.tokens.length - 1].subscriptStartIndex = a3;
    const b = vi();
    te.tokens[te.tokens.length - 1].contextId = b, ms(), te.tokens[te.tokens.length - 1].contextId = b;
  }
  else Ae(x.backQuote) ? Hc() : o.stop = true;
}
function Oy() {
  return te.tokens[te.tokens.length - 1].contextualKeyword === Fe._async && !mr();
}
function ms() {
  let a3 = true;
  for (; !et(x.parenR) && !te.error; ) {
    if (a3) a3 = false;
    else if (ot(x.comma), et(x.parenR)) break;
    jy(false);
  }
}
function NA() {
  return Ae(x.colon) || Ae(x.arrow);
}
function RA(a3) {
  nn ? dA() : an && DC(), ot(x.arrow), Ti(a3);
}
function Vc() {
  const a3 = te.tokens.length;
  ss(), $c(a3, true);
}
function ss() {
  if (et(x.modulo)) return Lt(), false;
  if (Ae(x.jsxText) || Ae(x.jsxEmptyText)) return Ys(), false;
  if (Ae(x.lessThan) && bo) return te.type = x.jsxTagStart, Ay(), lt(), false;
  const a3 = te.potentialArrowAt === te.start;
  switch (te.type) {
    case x.slash:
    case x.assign:
      _P();
    case x._super:
    case x._this:
    case x.regexp:
    case x.num:
    case x.bigint:
    case x.decimal:
    case x.string:
    case x._null:
    case x._true:
    case x._false:
      return lt(), false;
    case x._import:
      return lt(), Ae(x.dot) && (te.tokens[te.tokens.length - 1].type = x.name, lt(), Lt()), false;
    case x.name: {
      const s = te.tokens.length, o = te.start, b = te.contextualKeyword;
      return Lt(), b === Fe._await ? (WA(), false) : b === Fe._async && Ae(x._function) && !mr() ? (lt(), As(o, false), false) : a3 && b === Fe._async && !mr() && Ae(x.name) ? (te.scopeDepth++, vs(false), ot(x.arrow), Ti(s), true) : Ae(x._do) && !mr() ? (lt(), ys(), false) : a3 && !mr() && Ae(x.arrow) ? (te.scopeDepth++, Nc(false), ot(x.arrow), Ti(s), true) : (te.tokens[te.tokens.length - 1].identifierRole = Rt.Access, false);
    }
    case x._do:
      return lt(), ys(), false;
    case x.parenL:
      return Dy(a3);
    case x.bracketL:
      return lt(), Ry(x.bracketR, true), false;
    case x.braceL:
      return Gc(false, false), false;
    case x._function:
      return jA(), false;
    case x.at:
      ep();
    case x._class:
      return Cs(false), false;
    case x._new:
      return FA(), false;
    case x.backQuote:
      return Hc(), false;
    case x.doubleColon:
      return lt(), Vc(), false;
    case x.hash: {
      const s = Qm();
      return Fi[s] || s === Ge.backslash ? Fa() : lt(), false;
    }
    default:
      return Wt(), false;
  }
}
function Fa() {
  et(x.hash), Lt();
}
function jA() {
  const a3 = te.start;
  Lt(), et(x.dot) && Lt(), As(a3, false);
}
function Ys() {
  lt();
}
function _o() {
  ot(x.parenL), Wn(), ot(x.parenR);
}
function Dy(a3) {
  const s = te.snapshot(), o = te.tokens.length;
  ot(x.parenL);
  let b = true;
  for (; !Ae(x.parenR) && !te.error; ) {
    if (b) b = false;
    else if (ot(x.comma), Ae(x.parenR)) break;
    if (Ae(x.ellipsis)) {
      hy(false), Wc();
      break;
    } else Hn(false, true);
  }
  return ot(x.parenR), a3 && LA() && yu() ? (te.restoreFromSnapshot(s), te.scopeDepth++, ei(), yu(), Ti(o), te.error ? (te.restoreFromSnapshot(s), Dy(false), false) : true) : false;
}
function LA() {
  return Ae(x.colon) || !mr();
}
function yu() {
  return nn ? yA() : an ? RC() : et(x.arrow);
}
function Wc() {
  (nn || an) && AA();
}
function FA() {
  if (ot(x._new), et(x.dot)) {
    Lt();
    return;
  }
  MA(), an && yC(), et(x.parenL) && Ry(x.parenR);
}
function MA() {
  Vc(), et(x.questionDot);
}
function Hc() {
  for (ps(), ps(); !Ae(x.backQuote) && !te.error; ) ot(x.dollarBraceL), Wn(), ps(), ps();
  lt();
}
function Gc(a3, s) {
  const o = vi();
  let b = true;
  for (lt(), te.tokens[te.tokens.length - 1].contextId = o; !et(x.braceR) && !te.error; ) {
    if (b) b = false;
    else if (ot(x.comma), et(x.braceR)) break;
    let A = false;
    if (Ae(x.ellipsis)) {
      const R = te.tokens.length;
      if (fy(), a3 && (te.tokens.length === R + 2 && Nc(s), et(x.braceR))) break;
      continue;
    }
    a3 || (A = et(x.star)), !a3 && It(Fe._async) ? (A && Wt(), Lt(), Ae(x.colon) || Ae(x.parenL) || Ae(x.braceR) || Ae(x.eq) || Ae(x.comma) || (Ae(x.star) && (lt(), A = true), _i(o))) : _i(o), VA(a3, s, o);
  }
  te.tokens[te.tokens.length - 1].contextId = o;
}
function BA(a3) {
  return !a3 && (Ae(x.string) || Ae(x.num) || Ae(x.bracketL) || Ae(x.name) || !!(te.type & x.IS_KEYWORD));
}
function $A(a3, s) {
  const o = te.start;
  return Ae(x.parenL) ? (a3 && Wt(), bu(o, false), true) : BA(a3) ? (_i(s), bu(o, false), true) : false;
}
function UA(a3, s) {
  if (et(x.colon)) {
    a3 ? ja(s) : Hn(false);
    return;
  }
  let o;
  a3 ? te.scopeDepth === 0 ? o = Rt.ObjectShorthandTopLevelDeclaration : s ? o = Rt.ObjectShorthandBlockScopedDeclaration : o = Rt.ObjectShorthandFunctionScopedDeclaration : o = Rt.ObjectShorthand, te.tokens[te.tokens.length - 1].identifierRole = o, ja(s, true);
}
function VA(a3, s, o) {
  nn ? uA() : an && xC(), $A(a3, o) || UA(a3, s);
}
function _i(a3) {
  an && Zc(), et(x.bracketL) ? (te.tokens[te.tokens.length - 1].contextId = a3, Hn(), ot(x.bracketR), te.tokens[te.tokens.length - 1].contextId = a3) : (Ae(x.num) || Ae(x.string) || Ae(x.bigint) || Ae(x.decimal) ? ss() : Fa(), te.tokens[te.tokens.length - 1].identifierRole = Rt.ObjectKey, te.tokens[te.tokens.length - 1].contextId = a3);
}
function bu(a3, s) {
  const o = vi();
  te.scopeDepth++;
  const b = te.tokens.length;
  ei(s, o), Ny(a3, o);
  const R = te.tokens.length;
  te.scopes.push(new qr(b, R, true)), te.scopeDepth--;
}
function Ti(a3) {
  Vi(true);
  const s = te.tokens.length;
  te.scopes.push(new qr(a3, s, true)), te.scopeDepth--;
}
function Ny(a3, s = 0) {
  nn ? Qx(a3, s) : an ? hC(s) : Vi(false, s);
}
function Vi(a3, s = 0) {
  a3 && !Ae(x.braceL) ? Hn() : ys(true, s);
}
function Ry(a3, s = false) {
  let o = true;
  for (; !et(a3) && !te.error; ) {
    if (o) o = false;
    else if (ot(x.comma), et(a3)) break;
    jy(s);
  }
}
function jy(a3) {
  a3 && Ae(x.comma) || (Ae(x.ellipsis) ? (fy(), Wc()) : Ae(x.question) ? lt() : Hn(false, true));
}
function Lt() {
  lt(), te.tokens[te.tokens.length - 1].type = x.name;
}
function WA() {
  Ui();
}
function HA() {
  lt(), !Ae(x.semi) && !mr() && (et(x.star), Hn());
}
function GA() {
  Nn(Fe._module), ot(x.braceL), wo(x.braceR);
}
function zA(a3) {
  return (a3.type === x.name || !!(a3.type & x.IS_KEYWORD)) && a3.contextualKeyword !== Fe._from;
}
function Yr(a3) {
  const s = Gt(0);
  ot(a3 || x.colon), lr(), Ht(s);
}
function Yd() {
  ot(x.modulo), Nn(Fe._checks), et(x.parenL) && (Wn(), ot(x.parenR));
}
function zc() {
  const a3 = Gt(0);
  ot(x.colon), Ae(x.modulo) ? Yd() : (lr(), Ae(x.modulo) && Yd()), Ht(a3);
}
function KA() {
  lt(), Kc(true);
}
function qA() {
  lt(), Lt(), Ae(x.lessThan) && Mr(), ot(x.parenL), vu(), ot(x.parenR), zc(), Sn();
}
function gu() {
  Ae(x._class) ? KA() : Ae(x._function) ? qA() : Ae(x._var) ? YA() : Mn(Fe._module) ? et(x.dot) ? QA() : XA() : It(Fe._type) ? ZA() : It(Fe._opaque) ? eC() : It(Fe._interface) ? tC() : Ae(x._export) ? JA() : Wt();
}
function YA() {
  lt(), By(), Sn();
}
function XA() {
  for (Ae(x.string) ? ss() : Lt(), ot(x.braceL); !Ae(x.braceR) && !te.error; ) Ae(x._import) ? (lt(), Yy()) : Wt();
  ot(x.braceR);
}
function JA() {
  ot(x._export), et(x._default) ? Ae(x._function) || Ae(x._class) ? gu() : (lr(), Sn()) : Ae(x._var) || Ae(x._function) || Ae(x._class) || It(Fe._opaque) ? gu() : Ae(x.star) || Ae(x.braceL) || It(Fe._interface) || It(Fe._type) || It(Fe._opaque) ? Ky() : Wt();
}
function QA() {
  Nn(Fe._exports), Ns(), Sn();
}
function ZA() {
  lt(), Yc();
}
function eC() {
  lt(), Xc(true);
}
function tC() {
  lt(), Kc();
}
function Kc(a3 = false) {
  if (To(), Ae(x.lessThan) && Mr(), et(x._extends)) do
    Ea();
  while (!a3 && et(x.comma));
  if (It(Fe._mixins)) {
    lt();
    do
      Ea();
    while (et(x.comma));
  }
  if (It(Fe._implements)) {
    lt();
    do
      Ea();
    while (et(x.comma));
  }
  Ma(a3, false, a3);
}
function Ea() {
  Ly(false), Ae(x.lessThan) && xs();
}
function qc() {
  Kc();
}
function To() {
  Lt();
}
function Yc() {
  To(), Ae(x.lessThan) && Mr(), Yr(x.eq), Sn();
}
function Xc(a3) {
  Nn(Fe._type), To(), Ae(x.lessThan) && Mr(), Ae(x.colon) && Yr(x.colon), a3 || Yr(x.eq), Sn();
}
function nC() {
  Zc(), By(), et(x.eq) && lr();
}
function Mr() {
  const a3 = Gt(0);
  Ae(x.lessThan) || Ae(x.typeParameterStart) ? lt() : Wt();
  do
    nC(), Ae(x.greaterThan) || ot(x.comma);
  while (!Ae(x.greaterThan) && !te.error);
  ot(x.greaterThan), Ht(a3);
}
function xs() {
  const a3 = Gt(0);
  for (ot(x.lessThan); !Ae(x.greaterThan) && !te.error; ) lr(), Ae(x.greaterThan) || ot(x.comma);
  ot(x.greaterThan), Ht(a3);
}
function rC() {
  if (Nn(Fe._interface), et(x._extends)) do
    Ea();
  while (et(x.comma));
  Ma(false, false, false);
}
function Jc() {
  Ae(x.num) || Ae(x.string) ? ss() : Lt();
}
function sC() {
  Cn() === x.colon ? (Jc(), Yr()) : lr(), ot(x.bracketR), Yr();
}
function iC() {
  Jc(), ot(x.bracketR), ot(x.bracketR), Ae(x.lessThan) || Ae(x.parenL) ? Qc() : (et(x.question), Yr());
}
function Qc() {
  for (Ae(x.lessThan) && Mr(), ot(x.parenL); !Ae(x.parenR) && !Ae(x.ellipsis) && !te.error; ) Ba(), Ae(x.parenR) || ot(x.comma);
  et(x.ellipsis) && Ba(), ot(x.parenR), Yr();
}
function aC() {
  Qc();
}
function Ma(a3, s, o) {
  let b;
  for (s && Ae(x.braceBarL) ? (ot(x.braceBarL), b = x.braceBarR) : (ot(x.braceL), b = x.braceR); !Ae(b) && !te.error; ) {
    if (o && It(Fe._proto)) {
      const A = Cn();
      A !== x.colon && A !== x.question && (lt(), a3 = false);
    }
    if (a3 && It(Fe._static)) {
      const A = Cn();
      A !== x.colon && A !== x.question && lt();
    }
    if (Zc(), et(x.bracketL)) et(x.bracketL) ? iC() : sC();
    else if (Ae(x.parenL) || Ae(x.lessThan)) aC();
    else {
      if (It(Fe._get) || It(Fe._set)) {
        const A = Cn();
        (A === x.name || A === x.string || A === x.num) && lt();
      }
      oC();
    }
    lC();
  }
  ot(b);
}
function oC() {
  if (Ae(x.ellipsis)) {
    if (ot(x.ellipsis), et(x.comma) || et(x.semi), Ae(x.braceR)) return;
    lr();
  } else Jc(), Ae(x.lessThan) || Ae(x.parenL) ? Qc() : (et(x.question), Yr());
}
function lC() {
  !et(x.semi) && !et(x.comma) && !Ae(x.braceR) && !Ae(x.braceBarR) && Wt();
}
function Ly(a3) {
  for (a3 || Lt(); et(x.dot); ) Lt();
}
function uC() {
  Ly(true), Ae(x.lessThan) && xs();
}
function cC() {
  ot(x._typeof), Fy();
}
function pC() {
  for (ot(x.bracketL); te.pos < mt.length && !Ae(x.bracketR) && (lr(), !Ae(x.bracketR)); ) ot(x.comma);
  ot(x.bracketR);
}
function Ba() {
  const a3 = Cn();
  a3 === x.colon || a3 === x.question ? (Lt(), et(x.question), Yr()) : lr();
}
function vu() {
  for (; !Ae(x.parenR) && !Ae(x.ellipsis) && !te.error; ) Ba(), Ae(x.parenR) || ot(x.comma);
  et(x.ellipsis) && Ba();
}
function Fy() {
  let a3 = false;
  const s = te.noAnonFunctionType;
  switch (te.type) {
    case x.name: {
      if (It(Fe._interface)) {
        rC();
        return;
      }
      Lt(), uC();
      return;
    }
    case x.braceL:
      Ma(false, false, false);
      return;
    case x.braceBarL:
      Ma(false, true, false);
      return;
    case x.bracketL:
      pC();
      return;
    case x.lessThan:
      Mr(), ot(x.parenL), vu(), ot(x.parenR), ot(x.arrow), lr();
      return;
    case x.parenL:
      if (lt(), !Ae(x.parenR) && !Ae(x.ellipsis)) if (Ae(x.name)) {
        const o = Cn();
        a3 = o !== x.question && o !== x.colon;
      } else a3 = true;
      if (a3) if (te.noAnonFunctionType = false, lr(), te.noAnonFunctionType = s, te.noAnonFunctionType || !(Ae(x.comma) || Ae(x.parenR) && Cn() === x.arrow)) {
        ot(x.parenR);
        return;
      } else et(x.comma);
      vu(), ot(x.parenR), ot(x.arrow), lr();
      return;
    case x.minus:
      lt(), Ys();
      return;
    case x.string:
    case x.num:
    case x._true:
    case x._false:
    case x._null:
    case x._this:
    case x._void:
    case x.star:
      lt();
      return;
    default:
      if (te.type === x._typeof) {
        cC();
        return;
      } else if (te.type & x.IS_KEYWORD) {
        lt(), te.tokens[te.tokens.length - 1].type = x.name;
        return;
      }
  }
  Wt();
}
function dC() {
  for (Fy(); !mr() && (Ae(x.bracketL) || Ae(x.questionDot)); ) et(x.questionDot), ot(x.bracketL), et(x.bracketR) || (lr(), ot(x.bracketR));
}
function My() {
  et(x.question) ? My() : dC();
}
function Xd() {
  My(), !te.noAnonFunctionType && et(x.arrow) && lr();
}
function Jd() {
  for (et(x.bitwiseAND), Xd(); et(x.bitwiseAND); ) Xd();
}
function fC() {
  for (et(x.bitwiseOR), Jd(); et(x.bitwiseOR); ) Jd();
}
function lr() {
  fC();
}
function Ns() {
  Yr();
}
function By() {
  Lt(), Ae(x.colon) && Ns();
}
function Zc() {
  (Ae(x.plus) || Ae(x.minus)) && (lt(), te.tokens[te.tokens.length - 1].isType = true);
}
function hC(a3) {
  Ae(x.colon) && zc(), Vi(false, a3);
}
function mC(a3, s, o) {
  if (Ae(x.questionDot) && Cn() === x.lessThan) {
    if (s) {
      o.stop = true;
      return;
    }
    lt(), xs(), ot(x.parenL), ms();
    return;
  } else if (!s && Ae(x.lessThan)) {
    const b = te.snapshot();
    if (xs(), ot(x.parenL), ms(), te.error) te.restoreFromSnapshot(b);
    else return;
  }
  Uc(a3, s, o);
}
function yC() {
  if (Ae(x.lessThan)) {
    const a3 = te.snapshot();
    xs(), te.error && te.restoreFromSnapshot(a3);
  }
}
function bC() {
  if (Ae(x.name) && te.contextualKeyword === Fe._interface) {
    const a3 = Gt(0);
    return lt(), qc(), Ht(a3), true;
  } else if (It(Fe._enum)) return $y(), true;
  return false;
}
function gC() {
  return It(Fe._enum) ? ($y(), true) : false;
}
function vC(a3) {
  if (a3 === Fe._declare) {
    if (Ae(x._class) || Ae(x.name) || Ae(x._function) || Ae(x._var) || Ae(x._export)) {
      const s = Gt(1);
      gu(), Ht(s);
    }
  } else if (Ae(x.name)) {
    if (a3 === Fe._interface) {
      const s = Gt(1);
      qc(), Ht(s);
    } else if (a3 === Fe._type) {
      const s = Gt(1);
      Yc(), Ht(s);
    } else if (a3 === Fe._opaque) {
      const s = Gt(1);
      Xc(false), Ht(s);
    }
  }
  Sn();
}
function EC() {
  return It(Fe._type) || It(Fe._interface) || It(Fe._opaque) || It(Fe._enum);
}
function SC() {
  return Ae(x.name) && (te.contextualKeyword === Fe._type || te.contextualKeyword === Fe._interface || te.contextualKeyword === Fe._opaque || te.contextualKeyword === Fe._enum);
}
function _C() {
  if (It(Fe._type)) {
    const a3 = Gt(1);
    lt(), Ae(x.braceL) ? (tp(), wi()) : Yc(), Ht(a3);
  } else if (It(Fe._opaque)) {
    const a3 = Gt(1);
    lt(), Xc(false), Ht(a3);
  } else if (It(Fe._interface)) {
    const a3 = Gt(1);
    lt(), qc(), Ht(a3);
  } else gr(true);
}
function TC() {
  return Ae(x.star) || It(Fe._type) && Cn() === x.star;
}
function wC() {
  if (Mn(Fe._type)) {
    const a3 = Gt(2);
    Eu(), Ht(a3);
  } else Eu();
}
function PC(a3) {
  if (a3 && Ae(x.lessThan) && xs(), It(Fe._implements)) {
    const s = Gt(0);
    lt(), te.tokens[te.tokens.length - 1].type = x._implements;
    do
      To(), Ae(x.lessThan) && xs();
    while (et(x.comma));
    Ht(s);
  }
}
function xC() {
  Ae(x.lessThan) && (Mr(), Ae(x.parenL) || Wt());
}
function AC() {
  const a3 = Gt(0);
  et(x.question), Ae(x.colon) && Ns(), Ht(a3);
}
function CC() {
  if (Ae(x._typeof) || It(Fe._type)) {
    const a3 = Mi();
    (zA(a3) || a3.type === x.braceL || a3.type === x.star) && lt();
  }
}
function IC() {
  const a3 = te.contextualKeyword === Fe._type || te.type === x._typeof;
  a3 ? lt() : Lt(), It(Fe._as) && !kc(Fe._as) ? (Lt(), a3 && !Ae(x.name) && !(te.type & x.IS_KEYWORD) || Lt()) : (a3 && (Ae(x.name) || te.type & x.IS_KEYWORD) && Lt(), Mn(Fe._as) && Lt());
}
function kC() {
  if (Ae(x.lessThan)) {
    const a3 = Gt(0);
    Mr(), Ht(a3);
  }
}
function OC() {
  Ae(x.colon) && Ns();
}
function DC() {
  if (Ae(x.colon)) {
    const a3 = te.noAnonFunctionType;
    te.noAnonFunctionType = true, Ns(), te.noAnonFunctionType = a3;
  }
}
function NC(a3, s) {
  if (Ae(x.lessThan)) {
    const o = te.snapshot();
    let b = Kr(a3, s);
    if (te.error) te.restoreFromSnapshot(o), te.type = x.typeParameterStart;
    else return b;
    const A = Gt(0);
    if (Mr(), Ht(A), b = Kr(a3, s), b) return true;
    Wt();
  }
  return Kr(a3, s);
}
function RC() {
  if (Ae(x.colon)) {
    const a3 = Gt(0), s = te.snapshot(), o = te.noAnonFunctionType;
    te.noAnonFunctionType = true, zc(), te.noAnonFunctionType = o, mr() && Wt(), Ae(x.arrow) || Wt(), te.error && te.restoreFromSnapshot(s), Ht(a3);
  }
  return et(x.arrow);
}
function jC(a3, s = false) {
  if (te.tokens[te.tokens.length - 1].contextualKeyword === Fe._async && Ae(x.lessThan)) {
    const o = te.snapshot();
    if (LC() && !te.error) return;
    te.restoreFromSnapshot(o);
  }
  ky(a3, s);
}
function LC() {
  te.scopeDepth++;
  const a3 = te.tokens.length;
  return ei(), yu() ? (Ti(a3), true) : false;
}
function $y() {
  Nn(Fe._enum), te.tokens[te.tokens.length - 1].type = x._enum, Lt(), FC();
}
function FC() {
  Mn(Fe._of) && lt(), ot(x.braceL), MC(), ot(x.braceR);
}
function MC() {
  for (; !Ae(x.braceR) && !te.error && !et(x.ellipsis); ) BC(), Ae(x.braceR) || ot(x.comma);
}
function BC() {
  Lt(), et(x.eq) && lt();
}
function $C() {
  if (wo(x.eof), te.scopes.push(new qr(0, te.tokens.length, true)), te.scopeDepth !== 0) throw new Error(`Invalid scope depth at end of file: ${te.scopeDepth}`);
  return new xI(te.tokens, te.scopes);
}
function gr(a3) {
  an && bC() || (Ae(x.at) && ep(), UC(a3));
}
function UC(a3) {
  if (nn && sA()) return;
  const s = te.type;
  switch (s) {
    case x._break:
    case x._continue:
      WC();
      return;
    case x._debugger:
      HC();
      return;
    case x._do:
      GC();
      return;
    case x._for:
      zC();
      return;
    case x._function:
      if (Cn() === x.dot) break;
      a3 || Wt(), YC();
      return;
    case x._class:
      a3 || Wt(), Cs(true);
      return;
    case x._if:
      XC();
      return;
    case x._return:
      JC();
      return;
    case x._switch:
      QC();
      return;
    case x._throw:
      ZC();
      return;
    case x._try:
      tI();
      return;
    case x._let:
    case x._const:
      a3 || Wt();
    case x._var:
      Sa(s !== x._var);
      return;
    case x._while:
      nI();
      return;
    case x.braceL:
      ys();
      return;
    case x.semi:
      rI();
      return;
    case x._export:
    case x._import: {
      const A = Cn();
      if (A === x.parenL || A === x.dot) break;
      lt(), s === x._import ? Yy() : Ky();
      return;
    }
    case x.name:
      if (te.contextualKeyword === Fe._async) {
        const A = te.start, R = te.snapshot();
        if (lt(), Ae(x._function) && !mr()) {
          ot(x._function), As(A, true);
          return;
        } else te.restoreFromSnapshot(R);
      } else if (te.contextualKeyword === Fe._using && !Gm() && Cn() === x.name) {
        Sa(true);
        return;
      } else if (Uy()) {
        Nn(Fe._await), Sa(true);
        return;
      }
  }
  const o = te.tokens.length;
  Wn();
  let b = null;
  if (te.tokens.length === o + 1) {
    const A = te.tokens[te.tokens.length - 1];
    A.type === x.name && (b = A.contextualKeyword);
  }
  if (b == null) {
    Sn();
    return;
  }
  et(x.colon) ? sI() : iI(b);
}
function Uy() {
  if (!It(Fe._await)) return false;
  const a3 = te.snapshot();
  return lt(), !It(Fe._using) || nr() || (lt(), !Ae(x.name) || nr()) ? (te.restoreFromSnapshot(a3), false) : (te.restoreFromSnapshot(a3), true);
}
function ep() {
  for (; Ae(x.at); ) Vy();
}
function Vy() {
  if (lt(), et(x.parenL)) Wn(), ot(x.parenR);
  else {
    for (Lt(); et(x.dot); ) Lt();
    VC();
  }
}
function VC() {
  nn ? gA() : Wy();
}
function Wy() {
  et(x.parenL) && ms();
}
function WC() {
  lt(), Hr() || (Lt(), Sn());
}
function HC() {
  lt(), Sn();
}
function GC() {
  lt(), gr(false), ot(x._while), _o(), et(x.semi);
}
function zC() {
  te.scopeDepth++;
  const a3 = te.tokens.length;
  qC();
  const s = te.tokens.length;
  te.scopes.push(new qr(a3, s, false)), te.scopeDepth--;
}
function KC() {
  return !(!It(Fe._using) || kc(Fe._of));
}
function qC() {
  lt();
  let a3 = false;
  if (It(Fe._await) && (a3 = true, lt()), ot(x.parenL), Ae(x.semi)) {
    a3 && Wt(), nl();
    return;
  }
  const s = Uy();
  if (s || Ae(x._var) || Ae(x._let) || Ae(x._const) || KC()) {
    if (s && Nn(Fe._await), lt(), Hy(true, te.type !== x._var), Ae(x._in) || It(Fe._of)) {
      Qd(a3);
      return;
    }
    nl();
    return;
  }
  if (Wn(true), Ae(x._in) || It(Fe._of)) {
    Qd(a3);
    return;
  }
  a3 && Wt(), nl();
}
function YC() {
  const a3 = te.start;
  lt(), As(a3, true);
}
function XC() {
  lt(), _o(), gr(false), et(x._else) && gr(false);
}
function JC() {
  lt(), Hr() || (Wn(), Sn());
}
function QC() {
  lt(), _o(), te.scopeDepth++;
  const a3 = te.tokens.length;
  for (ot(x.braceL); !Ae(x.braceR) && !te.error; ) if (Ae(x._case) || Ae(x._default)) {
    const o = Ae(x._case);
    lt(), o && Wn(), ot(x.colon);
  } else gr(true);
  lt();
  const s = te.tokens.length;
  te.scopes.push(new qr(a3, s, false)), te.scopeDepth--;
}
function ZC() {
  lt(), Wn(), Sn();
}
function eI() {
  vo(true), nn && Qs();
}
function tI() {
  if (lt(), ys(), Ae(x._catch)) {
    lt();
    let a3 = null;
    if (Ae(x.parenL) && (te.scopeDepth++, a3 = te.tokens.length, ot(x.parenL), eI(), ot(x.parenR)), ys(), a3 != null) {
      const s = te.tokens.length;
      te.scopes.push(new qr(a3, s, false)), te.scopeDepth--;
    }
  }
  et(x._finally) && ys();
}
function Sa(a3) {
  lt(), Hy(false, a3), Sn();
}
function nI() {
  lt(), _o(), gr(false);
}
function rI() {
  lt();
}
function sI() {
  gr(true);
}
function iI(a3) {
  nn ? aA(a3) : an ? vC(a3) : Sn();
}
function ys(a3 = false, s = 0) {
  const o = te.tokens.length;
  te.scopeDepth++, ot(x.braceL), s && (te.tokens[te.tokens.length - 1].contextId = s), wo(x.braceR), s && (te.tokens[te.tokens.length - 1].contextId = s);
  const b = te.tokens.length;
  te.scopes.push(new qr(o, b, a3)), te.scopeDepth--;
}
function wo(a3) {
  for (; !et(a3) && !te.error; ) gr(true);
}
function nl() {
  ot(x.semi), Ae(x.semi) || Wn(), ot(x.semi), Ae(x.parenR) || Wn(), ot(x.parenR), gr(false);
}
function Qd(a3) {
  a3 ? Mn(Fe._of) : lt(), Wn(), ot(x.parenR), gr(false);
}
function Hy(a3, s) {
  for (; ; ) {
    if (aI(s), et(x.eq)) {
      const o = te.tokens.length - 1;
      Hn(a3), te.tokens[o].rhsEndIndex = te.tokens.length;
    }
    if (!et(x.comma)) break;
  }
}
function aI(a3) {
  vo(a3), nn ? pA() : an && OC();
}
function As(a3, s, o = false) {
  Ae(x.star) && lt(), s && !o && !Ae(x.name) && !Ae(x._yield) && Wt();
  let b = null;
  Ae(x.name) && (s || (b = te.tokens.length, te.scopeDepth++), vs(false));
  const A = te.tokens.length;
  te.scopeDepth++, ei(), Ny(a3);
  const R = te.tokens.length;
  te.scopes.push(new qr(A, R, true)), te.scopeDepth--, b !== null && (te.scopes.push(new qr(b, R, true)), te.scopeDepth--);
}
function ei(a3 = false, s = 0) {
  nn ? cA() : an && kC(), ot(x.parenL), s && (te.tokens[te.tokens.length - 1].contextId = s), Rc(x.parenR, false, false, a3, s), s && (te.tokens[te.tokens.length - 1].contextId = s);
}
function Cs(a3, s = false) {
  const o = vi();
  lt(), te.tokens[te.tokens.length - 1].contextId = o, te.tokens[te.tokens.length - 1].isExpression = !a3;
  let b = null;
  a3 || (b = te.tokens.length, te.scopeDepth++), cI(a3, s), pI();
  const A = te.tokens.length;
  if (oI(o), !te.error && (te.tokens[A].contextId = o, te.tokens[te.tokens.length - 1].contextId = o, b !== null)) {
    const R = te.tokens.length;
    te.scopes.push(new qr(b, R, false)), te.scopeDepth--;
  }
}
function Gy() {
  return Ae(x.eq) || Ae(x.semi) || Ae(x.braceR) || Ae(x.bang) || Ae(x.colon);
}
function zy() {
  return Ae(x.parenL) || Ae(x.lessThan);
}
function oI(a3) {
  for (ot(x.braceL); !et(x.braceR) && !te.error; ) {
    if (et(x.semi)) continue;
    if (Ae(x.at)) {
      Vy();
      continue;
    }
    const s = te.start;
    lI(s, a3);
  }
}
function lI(a3, s) {
  nn && jc([Fe._declare, Fe._public, Fe._protected, Fe._private, Fe._override]);
  let o = false;
  if (Ae(x.name) && te.contextualKeyword === Fe._static) {
    if (Lt(), zy()) {
      ci(a3, false);
      return;
    } else if (Gy()) {
      _a();
      return;
    }
    if (te.tokens[te.tokens.length - 1].type = x._static, o = true, Ae(x.braceL)) {
      te.tokens[te.tokens.length - 1].contextId = s, ys();
      return;
    }
  }
  uI(a3, o, s);
}
function uI(a3, s, o) {
  if (nn && iA(s)) return;
  if (et(x.star)) {
    li(o), ci(a3, false);
    return;
  }
  li(o);
  let b = false;
  const A = te.tokens[te.tokens.length - 1];
  A.contextualKeyword === Fe._constructor && (b = true), Zd(), zy() ? ci(a3, b) : Gy() ? _a() : A.contextualKeyword === Fe._async && !Hr() ? (te.tokens[te.tokens.length - 1].type = x._async, Ae(x.star) && lt(), li(o), Zd(), ci(a3, false)) : (A.contextualKeyword === Fe._get || A.contextualKeyword === Fe._set) && !(Hr() && Ae(x.star)) ? (A.contextualKeyword === Fe._get ? te.tokens[te.tokens.length - 1].type = x._get : te.tokens[te.tokens.length - 1].type = x._set, li(o), ci(a3, false)) : A.contextualKeyword === Fe._accessor && !Hr() ? (li(o), _a()) : Hr() ? _a() : Wt();
}
function ci(a3, s) {
  nn ? Ds() : an && Ae(x.lessThan) && Mr(), bu(a3, s);
}
function li(a3) {
  _i(a3);
}
function Zd() {
  if (nn) {
    const a3 = Gt(0);
    et(x.question), Ht(a3);
  }
}
function _a() {
  if (nn ? (Xm(x.bang), Qs()) : an && Ae(x.colon) && Ns(), Ae(x.eq)) {
    const a3 = te.tokens.length;
    lt(), Hn(), te.tokens[a3].rhsEndIndex = te.tokens.length;
  }
  Sn();
}
function cI(a3, s = false) {
  nn && (!a3 || s) && It(Fe._implements) || (Ae(x.name) && vs(true), nn ? Ds() : an && Ae(x.lessThan) && Mr());
}
function pI() {
  let a3 = false;
  et(x._extends) ? (Iy(), a3 = true) : a3 = false, nn ? lA(a3) : an && PC(a3);
}
function Ky() {
  const a3 = te.tokens.length - 1;
  nn && eA() || (mI() ? yI() : hI() ? (Lt(), Ae(x.comma) && Cn() === x.star ? (ot(x.comma), ot(x.star), Nn(Fe._as), Lt()) : qy(), wi()) : et(x._default) ? dI() : gI() ? fI() : (tp(), wi()), te.tokens[a3].rhsEndIndex = te.tokens.length);
}
function dI() {
  if (nn && rA() || an && gC()) return;
  const a3 = te.start;
  et(x._function) ? As(a3, true, true) : It(Fe._async) && Cn() === x._function ? (Mn(Fe._async), et(x._function), As(a3, true, true)) : Ae(x._class) ? Cs(true, true) : Ae(x.at) ? (ep(), Cs(true, true)) : (Hn(), Sn());
}
function fI() {
  nn ? oA() : an ? _C() : gr(true);
}
function hI() {
  if (nn && Ty()) return false;
  if (an && SC()) return false;
  if (Ae(x.name)) return te.contextualKeyword !== Fe._async;
  if (!Ae(x._default)) return false;
  const a3 = Oc(), s = Mi(), o = s.type === x.name && s.contextualKeyword === Fe._from;
  if (s.type === x.comma) return true;
  if (o) {
    const b = mt.charCodeAt(Jm(a3 + 4));
    return b === Ge.quotationMark || b === Ge.apostrophe;
  }
  return false;
}
function qy() {
  et(x.comma) && tp();
}
function wi() {
  Mn(Fe._from) && (ss(), Xy()), Sn();
}
function mI() {
  return an ? TC() : Ae(x.star);
}
function yI() {
  an ? wC() : Eu();
}
function Eu() {
  ot(x.star), It(Fe._as) ? bI() : wi();
}
function bI() {
  lt(), te.tokens[te.tokens.length - 1].type = x._as, Lt(), qy(), wi();
}
function gI() {
  return nn && Ty() || an && EC() || te.type === x._var || te.type === x._const || te.type === x._let || te.type === x._function || te.type === x._class || It(Fe._async) || Ae(x.at);
}
function tp() {
  let a3 = true;
  for (ot(x.braceL); !et(x.braceR) && !te.error; ) {
    if (a3) a3 = false;
    else if (ot(x.comma), et(x.braceR)) break;
    vI();
  }
}
function vI() {
  if (nn) {
    nA();
    return;
  }
  Lt(), te.tokens[te.tokens.length - 1].identifierRole = Rt.ExportAccess, Mn(Fe._as) && Lt();
}
function EI() {
  const a3 = te.snapshot();
  return Nn(Fe._module), Mn(Fe._from) ? It(Fe._from) ? (te.restoreFromSnapshot(a3), true) : (te.restoreFromSnapshot(a3), false) : Ae(x.comma) ? (te.restoreFromSnapshot(a3), false) : (te.restoreFromSnapshot(a3), true);
}
function SI() {
  It(Fe._module) && EI() && lt();
}
function Yy() {
  if (nn && Ae(x.name) && Cn() === x.eq) {
    hu();
    return;
  }
  if (nn && It(Fe._type)) {
    const a3 = Mi();
    if (a3.type === x.name && a3.contextualKeyword !== Fe._from) {
      if (Nn(Fe._type), Cn() === x.eq) {
        hu();
        return;
      }
    } else (a3.type === x.star || a3.type === x.braceL) && Nn(Fe._type);
  }
  Ae(x.string) || (SI(), TI(), Nn(Fe._from)), ss(), Xy(), Sn();
}
function _I() {
  return Ae(x.name);
}
function ef() {
  Ra();
}
function TI() {
  an && CC();
  let a3 = true;
  if (!(_I() && (ef(), !et(x.comma)))) {
    if (Ae(x.star)) {
      lt(), Nn(Fe._as), ef();
      return;
    }
    for (ot(x.braceL); !et(x.braceR) && !te.error; ) {
      if (a3) a3 = false;
      else if (et(x.colon) && Wt("ES2015 named imports do not destructure. Use another statement for destructuring after the import."), ot(x.comma), et(x.braceR)) break;
      wI();
    }
  }
}
function wI() {
  if (nn) {
    tA();
    return;
  }
  if (an) {
    IC();
    return;
  }
  Ra(), It(Fe._as) && (te.tokens[te.tokens.length - 1].identifierRole = Rt.ImportAccess, lt(), Ra());
}
function Xy() {
  (Ae(x._with) || It(Fe._assert) && !nr()) && (lt(), Gc(false, false));
}
function PI() {
  return te.pos === 0 && mt.charCodeAt(0) === Ge.numberSign && mt.charCodeAt(1) === Ge.exclamationMark && ey(2), Zm(), $C();
}
class xI {
  constructor(s, o) {
    this.tokens = s, this.scopes = o;
  }
}
function AI(a3, s, o, b) {
  if (b && o) throw new Error("Cannot combine flow and typescript plugins.");
  mP(a3, s, o, b);
  const A = PI();
  if (te.error) throw dP(te.error);
  return A;
}
function CI(a3) {
  let s = a3.currentIndex(), o = 0;
  const b = a3.currentToken();
  do {
    const A = a3.tokens[s];
    if (A.isOptionalChainStart && o++, A.isOptionalChainEnd && o--, o += A.numNullishCoalesceStarts, o -= A.numNullishCoalesceEnds, A.contextualKeyword === Fe._await && A.identifierRole == null && A.scopeDepth === b.scopeDepth) return true;
    s += 1;
  } while (o > 0 && s < a3.tokens.length);
  return false;
}
class di {
  __init() {
    this.resultCode = "";
  }
  __init2() {
    this.resultMappings = new Array(this.tokens.length);
  }
  __init3() {
    this.tokenIndex = 0;
  }
  constructor(s, o, b, A, R) {
    this.code = s, this.tokens = o, this.isFlowEnabled = b, this.disableESTransforms = A, this.helperManager = R, di.prototype.__init.call(this), di.prototype.__init2.call(this), di.prototype.__init3.call(this);
  }
  snapshot() {
    return { resultCode: this.resultCode, tokenIndex: this.tokenIndex };
  }
  restoreToSnapshot(s) {
    this.resultCode = s.resultCode, this.tokenIndex = s.tokenIndex;
  }
  dangerouslyGetAndRemoveCodeSinceSnapshot(s) {
    const o = this.resultCode.slice(s.resultCode.length);
    return this.resultCode = s.resultCode, o;
  }
  reset() {
    this.resultCode = "", this.resultMappings = new Array(this.tokens.length), this.tokenIndex = 0;
  }
  matchesContextualAtIndex(s, o) {
    return this.matches1AtIndex(s, x.name) && this.tokens[s].contextualKeyword === o;
  }
  identifierNameAtIndex(s) {
    return this.identifierNameForToken(this.tokens[s]);
  }
  identifierNameAtRelativeIndex(s) {
    return this.identifierNameForToken(this.tokenAtRelativeIndex(s));
  }
  identifierName() {
    return this.identifierNameForToken(this.currentToken());
  }
  identifierNameForToken(s) {
    return this.code.slice(s.start, s.end);
  }
  rawCodeForToken(s) {
    return this.code.slice(s.start, s.end);
  }
  stringValueAtIndex(s) {
    return this.stringValueForToken(this.tokens[s]);
  }
  stringValue() {
    return this.stringValueForToken(this.currentToken());
  }
  stringValueForToken(s) {
    return this.code.slice(s.start + 1, s.end - 1);
  }
  matches1AtIndex(s, o) {
    return this.tokens[s].type === o;
  }
  matches2AtIndex(s, o, b) {
    return this.tokens[s].type === o && this.tokens[s + 1].type === b;
  }
  matches3AtIndex(s, o, b, A) {
    return this.tokens[s].type === o && this.tokens[s + 1].type === b && this.tokens[s + 2].type === A;
  }
  matches1(s) {
    return this.tokens[this.tokenIndex].type === s;
  }
  matches2(s, o) {
    return this.tokens[this.tokenIndex].type === s && this.tokens[this.tokenIndex + 1].type === o;
  }
  matches3(s, o, b) {
    return this.tokens[this.tokenIndex].type === s && this.tokens[this.tokenIndex + 1].type === o && this.tokens[this.tokenIndex + 2].type === b;
  }
  matches4(s, o, b, A) {
    return this.tokens[this.tokenIndex].type === s && this.tokens[this.tokenIndex + 1].type === o && this.tokens[this.tokenIndex + 2].type === b && this.tokens[this.tokenIndex + 3].type === A;
  }
  matches5(s, o, b, A, R) {
    return this.tokens[this.tokenIndex].type === s && this.tokens[this.tokenIndex + 1].type === o && this.tokens[this.tokenIndex + 2].type === b && this.tokens[this.tokenIndex + 3].type === A && this.tokens[this.tokenIndex + 4].type === R;
  }
  matchesContextual(s) {
    return this.matchesContextualAtIndex(this.tokenIndex, s);
  }
  matchesContextIdAndLabel(s, o) {
    return this.matches1(s) && this.currentToken().contextId === o;
  }
  previousWhitespaceAndComments() {
    let s = this.code.slice(this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0, this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length);
    return this.isFlowEnabled && (s = s.replace(/@flow/g, "")), s;
  }
  replaceToken(s) {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += s, this.appendTokenSuffix(), this.tokenIndex++;
  }
  replaceTokenTrimmingLeftWhitespace(s) {
    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, ""), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += s, this.appendTokenSuffix(), this.tokenIndex++;
  }
  removeInitialToken() {
    this.replaceToken("");
  }
  removeToken() {
    this.replaceTokenTrimmingLeftWhitespace("");
  }
  removeBalancedCode() {
    let s = 0;
    for (; !this.isAtEnd(); ) {
      if (this.matches1(x.braceL)) s++;
      else if (this.matches1(x.braceR)) {
        if (s === 0) return;
        s--;
      }
      this.removeToken();
    }
  }
  copyExpectedToken(s) {
    if (this.tokens[this.tokenIndex].type !== s) throw new Error(`Expected token ${s}`);
    this.copyToken();
  }
  copyToken() {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end), this.appendTokenSuffix(), this.tokenIndex++;
  }
  copyTokenWithPrefix(s) {
    this.resultCode += this.previousWhitespaceAndComments(), this.appendTokenPrefix(), this.resultCode += s, this.resultMappings[this.tokenIndex] = this.resultCode.length, this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end), this.appendTokenSuffix(), this.tokenIndex++;
  }
  appendTokenPrefix() {
    const s = this.currentToken();
    if ((s.numNullishCoalesceStarts || s.isOptionalChainStart) && (s.isAsyncOperation = CI(this)), !this.disableESTransforms) {
      if (s.numNullishCoalesceStarts) for (let o = 0; o < s.numNullishCoalesceStarts; o++) s.isAsyncOperation ? (this.resultCode += "await ", this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce")) : this.resultCode += this.helperManager.getHelperName("nullishCoalesce"), this.resultCode += "(";
      s.isOptionalChainStart && (s.isAsyncOperation && (this.resultCode += "await "), this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === x._delete ? s.isAsyncOperation ? this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete") : this.resultCode += this.helperManager.getHelperName("optionalChainDelete") : s.isAsyncOperation ? this.resultCode += this.helperManager.getHelperName("asyncOptionalChain") : this.resultCode += this.helperManager.getHelperName("optionalChain"), this.resultCode += "([");
    }
  }
  appendTokenSuffix() {
    const s = this.currentToken();
    if (s.isOptionalChainEnd && !this.disableESTransforms && (this.resultCode += "])"), s.numNullishCoalesceEnds && !this.disableESTransforms) for (let o = 0; o < s.numNullishCoalesceEnds; o++) this.resultCode += "))";
  }
  appendCode(s) {
    this.resultCode += s;
  }
  currentToken() {
    return this.tokens[this.tokenIndex];
  }
  currentTokenCode() {
    const s = this.currentToken();
    return this.code.slice(s.start, s.end);
  }
  tokenAtRelativeIndex(s) {
    return this.tokens[this.tokenIndex + s];
  }
  currentIndex() {
    return this.tokenIndex;
  }
  nextToken() {
    if (this.tokenIndex === this.tokens.length) throw new Error("Unexpectedly reached end of input.");
    this.tokenIndex++;
  }
  previousToken() {
    this.tokenIndex--;
  }
  finish() {
    if (this.tokenIndex !== this.tokens.length) throw new Error("Tried to finish processing tokens before reaching the end.");
    return this.resultCode += this.previousWhitespaceAndComments(), { code: this.resultCode, mappings: this.resultMappings };
  }
  isAtEnd() {
    return this.tokenIndex === this.tokens.length;
  }
}
function II(a3, s, o, b) {
  const A = s.snapshot(), R = kI(s);
  let P = [];
  const t = [], l = [];
  let n = null;
  const u = [], c = [], e = s.currentToken().contextId;
  if (e == null) throw new Error("Expected non-null class context ID on class open-brace.");
  for (s.nextToken(); !s.matchesContextIdAndLabel(x.braceR, e); ) if (s.matchesContextual(Fe._constructor) && !s.currentToken().isType) ({ constructorInitializerStatements: P, constructorInsertPos: n } = tf(s));
  else if (s.matches1(x.semi)) b || c.push({ start: s.currentIndex(), end: s.currentIndex() + 1 }), s.nextToken();
  else if (s.currentToken().isType) s.nextToken();
  else {
    const r = s.currentIndex();
    let f = false, y = false, S = false;
    for (; $a(s.currentToken()); ) s.matches1(x._static) && (f = true), s.matches1(x.hash) && (y = true), (s.matches1(x._declare) || s.matches1(x._abstract)) && (S = true), s.nextToken();
    if (f && s.matches1(x.braceL)) {
      rl(s, e);
      continue;
    }
    if (y) {
      rl(s, e);
      continue;
    }
    if (s.matchesContextual(Fe._constructor) && !s.currentToken().isType) {
      ({ constructorInitializerStatements: P, constructorInsertPos: n } = tf(s));
      continue;
    }
    const T = s.currentIndex();
    if (OI(s), s.matches1(x.lessThan) || s.matches1(x.parenL)) {
      rl(s, e);
      continue;
    }
    for (; s.currentToken().isType; ) s.nextToken();
    if (s.matches1(x.eq)) {
      const d = s.currentIndex(), p = s.currentToken().rhsEndIndex;
      if (p == null) throw new Error("Expected rhsEndIndex on class field assignment.");
      for (s.nextToken(); s.currentIndex() < p; ) a3.processToken();
      let h;
      f ? (h = o.claimFreeName("__initStatic"), l.push(h)) : (h = o.claimFreeName("__init"), t.push(h)), u.push({ initializerName: h, equalsIndex: d, start: T, end: s.currentIndex() });
    } else (!b || S) && c.push({ start: r, end: s.currentIndex() });
  }
  return s.restoreToSnapshot(A), b ? { headerInfo: R, constructorInitializerStatements: P, instanceInitializerNames: [], staticInitializerNames: [], constructorInsertPos: n, fields: [], rangesToRemove: c } : { headerInfo: R, constructorInitializerStatements: P, instanceInitializerNames: t, staticInitializerNames: l, constructorInsertPos: n, fields: u, rangesToRemove: c };
}
function rl(a3, s) {
  for (a3.nextToken(); a3.currentToken().contextId !== s; ) a3.nextToken();
  for (; $a(a3.tokenAtRelativeIndex(-1)); ) a3.previousToken();
}
function kI(a3) {
  const s = a3.currentToken(), o = s.contextId;
  if (o == null) throw new Error("Expected context ID on class token.");
  const b = s.isExpression;
  if (b == null) throw new Error("Expected isExpression on class token.");
  let A = null, R = false;
  for (a3.nextToken(), a3.matches1(x.name) && (A = a3.identifierName()); !a3.matchesContextIdAndLabel(x.braceL, o); ) a3.matches1(x._extends) && !a3.currentToken().isType && (R = true), a3.nextToken();
  return { isExpression: b, className: A, hasSuperclass: R };
}
function tf(a3) {
  const s = [];
  a3.nextToken();
  const o = a3.currentToken().contextId;
  if (o == null) throw new Error("Expected context ID on open-paren starting constructor params.");
  for (; !a3.matchesContextIdAndLabel(x.parenR, o); ) if (a3.currentToken().contextId === o) {
    if (a3.nextToken(), $a(a3.currentToken())) {
      for (a3.nextToken(); $a(a3.currentToken()); ) a3.nextToken();
      const R = a3.currentToken();
      if (R.type !== x.name) throw new Error("Expected identifier after access modifiers in constructor arg.");
      const P = a3.identifierNameForToken(R);
      s.push(`this.${P} = ${P}`);
    }
  } else a3.nextToken();
  for (a3.nextToken(); a3.currentToken().isType; ) a3.nextToken();
  let b = a3.currentIndex(), A = false;
  for (; !a3.matchesContextIdAndLabel(x.braceR, o); ) {
    if (!A && a3.matches2(x._super, x.parenL)) {
      a3.nextToken();
      const R = a3.currentToken().contextId;
      if (R == null) throw new Error("Expected a context ID on the super call");
      for (; !a3.matchesContextIdAndLabel(x.parenR, R); ) a3.nextToken();
      b = a3.currentIndex(), A = true;
    }
    a3.nextToken();
  }
  return a3.nextToken(), { constructorInitializerStatements: s, constructorInsertPos: b };
}
function $a(a3) {
  return [x._async, x._get, x._set, x.plus, x.minus, x._readonly, x._static, x._public, x._private, x._protected, x._override, x._abstract, x.star, x._declare, x.hash].includes(a3.type);
}
function OI(a3) {
  if (a3.matches1(x.bracketL)) {
    const o = a3.currentToken().contextId;
    if (o == null) throw new Error("Expected class context ID on computed name open bracket.");
    for (; !a3.matchesContextIdAndLabel(x.bracketR, o); ) a3.nextToken();
    a3.nextToken();
  } else a3.nextToken();
}
function Jy(a3) {
  if (a3.removeInitialToken(), a3.removeToken(), a3.removeToken(), a3.removeToken(), a3.matches1(x.parenL)) a3.removeToken(), a3.removeToken(), a3.removeToken();
  else for (; a3.matches1(x.dot); ) a3.removeToken(), a3.removeToken();
}
const Qy = { typeDeclarations: /* @__PURE__ */ new Set(), valueDeclarations: /* @__PURE__ */ new Set() };
function Zy(a3) {
  const s = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
  for (let b = 0; b < a3.tokens.length; b++) {
    const A = a3.tokens[b];
    A.type === x.name && Ym(A) && (A.isType ? s.add(a3.identifierNameForToken(A)) : o.add(a3.identifierNameForToken(A)));
  }
  return { typeDeclarations: s, valueDeclarations: o };
}
function eb(a3) {
  let s = a3.currentIndex();
  for (; !a3.matches1AtIndex(s, x.braceR); ) s++;
  return a3.matchesContextualAtIndex(s + 1, Fe._from) && a3.matches1AtIndex(s + 2, x.string);
}
function ws(a3) {
  (a3.matches2(x._with, x.braceL) || a3.matches2(x.name, x.braceL) && a3.matchesContextual(Fe._assert)) && (a3.removeToken(), a3.removeToken(), a3.removeBalancedCode(), a3.removeToken());
}
function tb(a3, s, o, b) {
  if (!a3 || s) return false;
  const A = o.currentToken();
  if (A.rhsEndIndex == null) throw new Error("Expected non-null rhsEndIndex on export token.");
  const R = A.rhsEndIndex - o.currentIndex();
  if (R !== 3 && !(R === 4 && o.matches1AtIndex(A.rhsEndIndex - 1, x.semi))) return false;
  const P = o.tokenAtRelativeIndex(2);
  if (P.type !== x.name) return false;
  const t = o.identifierNameForToken(P);
  return b.typeDeclarations.has(t) && !b.valueDeclarations.has(t);
}
class fi extends Fr {
  __init() {
    this.hadExport = false;
  }
  __init2() {
    this.hadNamedExport = false;
  }
  __init3() {
    this.hadDefaultExport = false;
  }
  constructor(s, o, b, A, R, P, t, l, n, u, c, e) {
    super(), this.rootTransformer = s, this.tokens = o, this.importProcessor = b, this.nameManager = A, this.helperManager = R, this.reactHotLoaderTransformer = P, this.enableLegacyBabel5ModuleInterop = t, this.enableLegacyTypeScriptModuleInterop = l, this.isTypeScriptTransformEnabled = n, this.isFlowTransformEnabled = u, this.preserveDynamicImport = c, this.keepUnusedImports = e, fi.prototype.__init.call(this), fi.prototype.__init2.call(this), fi.prototype.__init3.call(this), this.declarationInfo = n ? Zy(o) : Qy;
  }
  getPrefixCode() {
    let s = "";
    return this.hadExport && (s += 'Object.defineProperty(exports, "__esModule", {value: true});'), s;
  }
  getSuffixCode() {
    return this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport ? `
module.exports = exports.default;
` : "";
  }
  process() {
    return this.tokens.matches3(x._import, x.name, x.eq) ? this.processImportEquals() : this.tokens.matches1(x._import) ? (this.processImport(), true) : this.tokens.matches2(x._export, x.eq) ? (this.tokens.replaceToken("module.exports"), true) : this.tokens.matches1(x._export) && !this.tokens.currentToken().isType ? (this.hadExport = true, this.processExport()) : this.tokens.matches2(x.name, x.postIncDec) && this.processPostIncDec() ? true : this.tokens.matches1(x.name) || this.tokens.matches1(x.jsxName) ? this.processIdentifier() : this.tokens.matches1(x.eq) ? this.processAssignment() : this.tokens.matches1(x.assign) ? this.processComplexAssignment() : this.tokens.matches1(x.preIncDec) ? this.processPreIncDec() : false;
  }
  processImportEquals() {
    const s = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.importProcessor.shouldAutomaticallyElideImportedName(s) ? Jy(this.tokens) : this.tokens.replaceToken("const"), true;
  }
  processImport() {
    if (this.tokens.matches2(x._import, x.parenL)) {
      if (this.preserveDynamicImport) {
        this.tokens.copyToken();
        return;
      }
      const o = this.enableLegacyTypeScriptModuleInterop ? "" : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${o}require`);
      const b = this.tokens.currentToken().contextId;
      if (b == null) throw new Error("Expected context ID on dynamic import invocation.");
      for (this.tokens.copyToken(); !this.tokens.matchesContextIdAndLabel(x.parenR, b); ) this.rootTransformer.processToken();
      this.tokens.replaceToken(o ? ")))" : "))");
      return;
    }
    if (this.removeImportAndDetectIfShouldElide()) this.tokens.removeToken();
    else {
      const o = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(o)), this.tokens.appendCode(this.importProcessor.claimImportCode(o));
    }
    ws(this.tokens), this.tokens.matches1(x.semi) && this.tokens.removeToken();
  }
  removeImportAndDetectIfShouldElide() {
    if (this.tokens.removeInitialToken(), this.tokens.matchesContextual(Fe._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, x.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, Fe._from)) return this.removeRemainingImport(), true;
    if (this.tokens.matches1(x.name) || this.tokens.matches1(x.star)) return this.removeRemainingImport(), false;
    if (this.tokens.matches1(x.string)) return false;
    let s = false, o = false;
    for (; !this.tokens.matches1(x.string); ) (!s && this.tokens.matches1(x.braceL) || this.tokens.matches1(x.comma)) && (this.tokens.removeToken(), this.tokens.matches1(x.braceR) || (o = true), (this.tokens.matches2(x.name, x.comma) || this.tokens.matches2(x.name, x.braceR) || this.tokens.matches4(x.name, x.name, x.name, x.comma) || this.tokens.matches4(x.name, x.name, x.name, x.braceR)) && (s = true)), this.tokens.removeToken();
    return this.keepUnusedImports ? false : this.isTypeScriptTransformEnabled ? !s : this.isFlowTransformEnabled ? o && !s : false;
  }
  removeRemainingImport() {
    for (; !this.tokens.matches1(x.string); ) this.tokens.removeToken();
  }
  processIdentifier() {
    const s = this.tokens.currentToken();
    if (s.shadowsGlobal) return false;
    if (s.identifierRole === Rt.ObjectShorthand) return this.processObjectShorthand();
    if (s.identifierRole !== Rt.Access) return false;
    const o = this.importProcessor.getIdentifierReplacement(this.tokens.identifierNameForToken(s));
    if (!o) return false;
    let b = this.tokens.currentIndex() + 1;
    for (; b < this.tokens.tokens.length && this.tokens.tokens[b].type === x.parenR; ) b++;
    return this.tokens.tokens[b].type === x.parenL ? this.tokens.tokenAtRelativeIndex(1).type === x.parenL && this.tokens.tokenAtRelativeIndex(-1).type !== x._new ? (this.tokens.replaceToken(`${o}.call(void 0, `), this.tokens.removeToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(x.parenR)) : this.tokens.replaceToken(`(0, ${o})`) : this.tokens.replaceToken(o), true;
  }
  processObjectShorthand() {
    const s = this.tokens.identifierName(), o = this.importProcessor.getIdentifierReplacement(s);
    return o ? (this.tokens.replaceToken(`${s}: ${o}`), true) : false;
  }
  processExport() {
    if (this.tokens.matches2(x._export, x._enum) || this.tokens.matches3(x._export, x._const, x._enum)) return this.hadNamedExport = true, false;
    if (this.tokens.matches2(x._export, x._default)) return this.tokens.matches3(x._export, x._default, x._enum) ? (this.hadDefaultExport = true, false) : (this.processExportDefault(), true);
    if (this.tokens.matches2(x._export, x.braceL)) return this.processExportBindings(), true;
    if (this.tokens.matches2(x._export, x.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, Fe._type)) {
      if (this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.matches1(x.braceL)) {
        for (; !this.tokens.matches1(x.braceR); ) this.tokens.removeToken();
        this.tokens.removeToken();
      } else this.tokens.removeToken(), this.tokens.matches1(x._as) && (this.tokens.removeToken(), this.tokens.removeToken());
      return this.tokens.matchesContextual(Fe._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, x.string) && (this.tokens.removeToken(), this.tokens.removeToken(), ws(this.tokens)), true;
    }
    if (this.hadNamedExport = true, this.tokens.matches2(x._export, x._var) || this.tokens.matches2(x._export, x._let) || this.tokens.matches2(x._export, x._const)) return this.processExportVar(), true;
    if (this.tokens.matches2(x._export, x._function) || this.tokens.matches3(x._export, x.name, x._function)) return this.processExportFunction(), true;
    if (this.tokens.matches2(x._export, x._class) || this.tokens.matches3(x._export, x._abstract, x._class) || this.tokens.matches2(x._export, x.at)) return this.processExportClass(), true;
    if (this.tokens.matches2(x._export, x.star)) return this.processExportStar(), true;
    throw new Error("Unrecognized export syntax.");
  }
  processAssignment() {
    const s = this.tokens.currentIndex(), o = this.tokens.tokens[s - 1];
    if (o.isType || o.type !== x.name || o.shadowsGlobal || s >= 2 && this.tokens.matches1AtIndex(s - 2, x.dot) || s >= 2 && [x._var, x._let, x._const].includes(this.tokens.tokens[s - 2].type)) return false;
    const b = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(o));
    return b ? (this.tokens.copyToken(), this.tokens.appendCode(` ${b} =`), true) : false;
  }
  processComplexAssignment() {
    const s = this.tokens.currentIndex(), o = this.tokens.tokens[s - 1];
    if (o.type !== x.name || o.shadowsGlobal || s >= 2 && this.tokens.matches1AtIndex(s - 2, x.dot)) return false;
    const b = this.importProcessor.resolveExportBinding(this.tokens.identifierNameForToken(o));
    return b ? (this.tokens.appendCode(` = ${b}`), this.tokens.copyToken(), true) : false;
  }
  processPreIncDec() {
    const s = this.tokens.currentIndex(), o = this.tokens.tokens[s + 1];
    if (o.type !== x.name || o.shadowsGlobal || s + 2 < this.tokens.tokens.length && (this.tokens.matches1AtIndex(s + 2, x.dot) || this.tokens.matches1AtIndex(s + 2, x.bracketL) || this.tokens.matches1AtIndex(s + 2, x.parenL))) return false;
    const b = this.tokens.identifierNameForToken(o), A = this.importProcessor.resolveExportBinding(b);
    return A ? (this.tokens.appendCode(`${A} = `), this.tokens.copyToken(), true) : false;
  }
  processPostIncDec() {
    const s = this.tokens.currentIndex(), o = this.tokens.tokens[s], b = this.tokens.tokens[s + 1];
    if (o.type !== x.name || o.shadowsGlobal || s >= 1 && this.tokens.matches1AtIndex(s - 1, x.dot)) return false;
    const A = this.tokens.identifierNameForToken(o), R = this.importProcessor.resolveExportBinding(A);
    if (!R) return false;
    const P = this.tokens.rawCodeForToken(b), t = this.importProcessor.getIdentifierReplacement(A) || A;
    if (P === "++") this.tokens.replaceToken(`(${t} = ${R} = ${t} + 1, ${t} - 1)`);
    else if (P === "--") this.tokens.replaceToken(`(${t} = ${R} = ${t} - 1, ${t} + 1)`);
    else throw new Error(`Unexpected operator: ${P}`);
    return this.tokens.removeToken(), true;
  }
  processExportDefault() {
    let s = true;
    if (this.tokens.matches4(x._export, x._default, x._function, x.name) || this.tokens.matches5(x._export, x._default, x.name, x._function, x.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, Fe._async)) {
      this.tokens.removeInitialToken(), this.tokens.removeToken();
      const o = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${o};`);
    } else if (this.tokens.matches4(x._export, x._default, x._class, x.name) || this.tokens.matches5(x._export, x._default, x._abstract, x._class, x.name) || this.tokens.matches3(x._export, x._default, x.at)) {
      this.tokens.removeInitialToken(), this.tokens.removeToken(), this.copyDecorators(), this.tokens.matches1(x._abstract) && this.tokens.removeToken();
      const o = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${o};`);
    } else if (tb(this.isTypeScriptTransformEnabled, this.keepUnusedImports, this.tokens, this.declarationInfo)) s = false, this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.removeToken();
    else if (this.reactHotLoaderTransformer) {
      const o = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${o}; exports.`), this.tokens.copyToken(), this.tokens.appendCode(` = ${o} =`), this.reactHotLoaderTransformer.setExtractedDefaultExportName(o);
    } else this.tokens.replaceToken("exports."), this.tokens.copyToken(), this.tokens.appendCode(" =");
    s && (this.hadDefaultExport = true);
  }
  copyDecorators() {
    for (; this.tokens.matches1(x.at); ) if (this.tokens.copyToken(), this.tokens.matches1(x.parenL)) this.tokens.copyExpectedToken(x.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(x.parenR);
    else {
      for (this.tokens.copyExpectedToken(x.name); this.tokens.matches1(x.dot); ) this.tokens.copyExpectedToken(x.dot), this.tokens.copyExpectedToken(x.name);
      this.tokens.matches1(x.parenL) && (this.tokens.copyExpectedToken(x.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(x.parenR));
    }
  }
  processExportVar() {
    this.isSimpleExportVar() ? this.processSimpleExportVar() : this.processComplexExportVar();
  }
  isSimpleExportVar() {
    let s = this.tokens.currentIndex();
    if (s++, s++, !this.tokens.matches1AtIndex(s, x.name)) return false;
    for (s++; s < this.tokens.tokens.length && this.tokens.tokens[s].isType; ) s++;
    return !!this.tokens.matches1AtIndex(s, x.eq);
  }
  processSimpleExportVar() {
    this.tokens.removeInitialToken(), this.tokens.copyToken();
    const s = this.tokens.identifierName();
    for (; !this.tokens.matches1(x.eq); ) this.rootTransformer.processToken();
    const o = this.tokens.currentToken().rhsEndIndex;
    if (o == null) throw new Error("Expected = token with an end index.");
    for (; this.tokens.currentIndex() < o; ) this.rootTransformer.processToken();
    this.tokens.appendCode(`; exports.${s} = ${s}`);
  }
  processComplexExportVar() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const s = this.tokens.matches1(x.braceL);
    s && this.tokens.appendCode("(");
    let o = 0;
    for (; ; ) if (this.tokens.matches1(x.braceL) || this.tokens.matches1(x.dollarBraceL) || this.tokens.matches1(x.bracketL)) o++, this.tokens.copyToken();
    else if (this.tokens.matches1(x.braceR) || this.tokens.matches1(x.bracketR)) o--, this.tokens.copyToken();
    else {
      if (o === 0 && !this.tokens.matches1(x.name) && !this.tokens.currentToken().isType) break;
      if (this.tokens.matches1(x.eq)) {
        const b = this.tokens.currentToken().rhsEndIndex;
        if (b == null) throw new Error("Expected = token with an end index.");
        for (; this.tokens.currentIndex() < b; ) this.rootTransformer.processToken();
      } else {
        const b = this.tokens.currentToken();
        if (qm(b)) {
          const A = this.tokens.identifierName();
          let R = this.importProcessor.getIdentifierReplacement(A);
          if (R === null) throw new Error(`Expected a replacement for ${A} in \`export var\` syntax.`);
          SP(b) && (R = `${A}: ${R}`), this.tokens.replaceToken(R);
        } else this.rootTransformer.processToken();
      }
    }
    if (s) {
      const b = this.tokens.currentToken().rhsEndIndex;
      if (b == null) throw new Error("Expected = token with an end index.");
      for (; this.tokens.currentIndex() < b; ) this.rootTransformer.processToken();
      this.tokens.appendCode(")");
    }
  }
  processExportFunction() {
    this.tokens.replaceToken("");
    const s = this.processNamedFunction();
    this.tokens.appendCode(` exports.${s} = ${s};`);
  }
  processNamedFunction() {
    if (this.tokens.matches1(x._function)) this.tokens.copyToken();
    else if (this.tokens.matches2(x.name, x._function)) {
      if (!this.tokens.matchesContextual(Fe._async)) throw new Error("Expected async keyword in function export.");
      this.tokens.copyToken(), this.tokens.copyToken();
    }
    if (this.tokens.matches1(x.star) && this.tokens.copyToken(), !this.tokens.matches1(x.name)) throw new Error("Expected identifier for exported function name.");
    const s = this.tokens.identifierName();
    if (this.tokens.copyToken(), this.tokens.currentToken().isType) for (this.tokens.removeInitialToken(); this.tokens.currentToken().isType; ) this.tokens.removeToken();
    return this.tokens.copyExpectedToken(x.parenL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(x.parenR), this.rootTransformer.processPossibleTypeRange(), this.tokens.copyExpectedToken(x.braceL), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(x.braceR), s;
  }
  processExportClass() {
    this.tokens.removeInitialToken(), this.copyDecorators(), this.tokens.matches1(x._abstract) && this.tokens.removeToken();
    const s = this.rootTransformer.processNamedClass();
    this.tokens.appendCode(` exports.${s} = ${s};`);
  }
  processExportBindings() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const s = eb(this.tokens), o = [];
    for (; ; ) {
      if (this.tokens.matches1(x.braceR)) {
        this.tokens.removeToken();
        break;
      }
      const b = Ei(this.tokens);
      for (; this.tokens.currentIndex() < b.endIndex; ) this.tokens.removeToken();
      if (!(b.isType || !s && this.shouldElideExportedIdentifier(b.leftName))) {
        const R = b.rightName;
        R === "default" ? this.hadDefaultExport = true : this.hadNamedExport = true;
        const P = b.leftName, t = this.importProcessor.getIdentifierReplacement(P);
        o.push(`exports.${R} = ${t || P};`);
      }
      if (this.tokens.matches1(x.braceR)) {
        this.tokens.removeToken();
        break;
      }
      if (this.tokens.matches2(x.comma, x.braceR)) {
        this.tokens.removeToken(), this.tokens.removeToken();
        break;
      } else if (this.tokens.matches1(x.comma)) this.tokens.removeToken();
      else throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.currentToken())}`);
    }
    if (this.tokens.matchesContextual(Fe._from)) {
      this.tokens.removeToken();
      const b = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(b)), ws(this.tokens);
    } else this.tokens.appendCode(o.join(" "));
    this.tokens.matches1(x.semi) && this.tokens.removeToken();
  }
  processExportStar() {
    for (this.tokens.removeInitialToken(); !this.tokens.matches1(x.string); ) this.tokens.removeToken();
    const s = this.tokens.stringValue();
    this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(s)), ws(this.tokens), this.tokens.matches1(x.semi) && this.tokens.removeToken();
  }
  shouldElideExportedIdentifier(s) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.declarationInfo.valueDeclarations.has(s);
  }
}
class DI extends Fr {
  constructor(s, o, b, A, R, P, t, l) {
    super(), this.tokens = s, this.nameManager = o, this.helperManager = b, this.reactHotLoaderTransformer = A, this.isTypeScriptTransformEnabled = R, this.isFlowTransformEnabled = P, this.keepUnusedImports = t, this.nonTypeIdentifiers = R && !t ? uy(s, l) : /* @__PURE__ */ new Set(), this.declarationInfo = R && !t ? Zy(s) : Qy, this.injectCreateRequireForImportRequire = !!l.injectCreateRequireForImportRequire;
  }
  process() {
    if (this.tokens.matches3(x._import, x.name, x.eq)) return this.processImportEquals();
    if (this.tokens.matches4(x._import, x.name, x.name, x.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, Fe._type)) {
      this.tokens.removeInitialToken();
      for (let s = 0; s < 7; s++) this.tokens.removeToken();
      return true;
    }
    if (this.tokens.matches2(x._export, x.eq)) return this.tokens.replaceToken("module.exports"), true;
    if (this.tokens.matches5(x._export, x._import, x.name, x.name, x.eq) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, Fe._type)) {
      this.tokens.removeInitialToken();
      for (let s = 0; s < 8; s++) this.tokens.removeToken();
      return true;
    }
    if (this.tokens.matches1(x._import)) return this.processImport();
    if (this.tokens.matches2(x._export, x._default)) return this.processExportDefault();
    if (this.tokens.matches2(x._export, x.braceL)) return this.processNamedExports();
    if (this.tokens.matches2(x._export, x.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, Fe._type)) {
      if (this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.matches1(x.braceL)) {
        for (; !this.tokens.matches1(x.braceR); ) this.tokens.removeToken();
        this.tokens.removeToken();
      } else this.tokens.removeToken(), this.tokens.matches1(x._as) && (this.tokens.removeToken(), this.tokens.removeToken());
      return this.tokens.matchesContextual(Fe._from) && this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, x.string) && (this.tokens.removeToken(), this.tokens.removeToken(), ws(this.tokens)), true;
    }
    return false;
  }
  processImportEquals() {
    const s = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.shouldAutomaticallyElideImportedName(s) ? Jy(this.tokens) : this.injectCreateRequireForImportRequire ? (this.tokens.replaceToken("const"), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.replaceToken(this.helperManager.getHelperName("require"))) : this.tokens.replaceToken("const"), true;
  }
  processImport() {
    if (this.tokens.matches2(x._import, x.parenL)) return false;
    const s = this.tokens.snapshot();
    if (this.removeImportTypeBindings()) {
      for (this.tokens.restoreToSnapshot(s); !this.tokens.matches1(x.string); ) this.tokens.removeToken();
      this.tokens.removeToken(), ws(this.tokens), this.tokens.matches1(x.semi) && this.tokens.removeToken();
    }
    return true;
  }
  removeImportTypeBindings() {
    if (this.tokens.copyExpectedToken(x._import), this.tokens.matchesContextual(Fe._type) && !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, x.comma) && !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, Fe._from)) return true;
    if (this.tokens.matches1(x.string)) return this.tokens.copyToken(), false;
    this.tokens.matchesContextual(Fe._module) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, Fe._from) && this.tokens.copyToken();
    let s = false, o = false, b = false;
    if (this.tokens.matches1(x.name) && (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName()) ? (this.tokens.removeToken(), this.tokens.matches1(x.comma) && this.tokens.removeToken()) : (s = true, this.tokens.copyToken(), this.tokens.matches1(x.comma) && (b = true, this.tokens.removeToken()))), this.tokens.matches1(x.star)) this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2)) ? (this.tokens.removeToken(), this.tokens.removeToken(), this.tokens.removeToken()) : (b && this.tokens.appendCode(","), s = true, this.tokens.copyExpectedToken(x.star), this.tokens.copyExpectedToken(x.name), this.tokens.copyExpectedToken(x.name));
    else if (this.tokens.matches1(x.braceL)) {
      for (b && this.tokens.appendCode(","), this.tokens.copyToken(); !this.tokens.matches1(x.braceR); ) {
        o = true;
        const A = Ei(this.tokens);
        if (A.isType || this.shouldAutomaticallyElideImportedName(A.rightName)) {
          for (; this.tokens.currentIndex() < A.endIndex; ) this.tokens.removeToken();
          this.tokens.matches1(x.comma) && this.tokens.removeToken();
        } else {
          for (s = true; this.tokens.currentIndex() < A.endIndex; ) this.tokens.copyToken();
          this.tokens.matches1(x.comma) && this.tokens.copyToken();
        }
      }
      this.tokens.copyExpectedToken(x.braceR);
    }
    return this.keepUnusedImports ? false : this.isTypeScriptTransformEnabled ? !s : this.isFlowTransformEnabled ? o && !s : false;
  }
  shouldAutomaticallyElideImportedName(s) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(s);
  }
  processExportDefault() {
    if (tb(this.isTypeScriptTransformEnabled, this.keepUnusedImports, this.tokens, this.declarationInfo)) return this.tokens.removeInitialToken(), this.tokens.removeToken(), this.tokens.removeToken(), true;
    if (!(this.tokens.matches4(x._export, x._default, x._function, x.name) || this.tokens.matches5(x._export, x._default, x.name, x._function, x.name) && this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, Fe._async) || this.tokens.matches4(x._export, x._default, x._class, x.name) || this.tokens.matches5(x._export, x._default, x._abstract, x._class, x.name)) && this.reactHotLoaderTransformer) {
      const o = this.nameManager.claimFreeName("_default");
      return this.tokens.replaceToken(`let ${o}; export`), this.tokens.copyToken(), this.tokens.appendCode(` ${o} =`), this.reactHotLoaderTransformer.setExtractedDefaultExportName(o), true;
    }
    return false;
  }
  processNamedExports() {
    if (!this.isTypeScriptTransformEnabled) return false;
    this.tokens.copyExpectedToken(x._export), this.tokens.copyExpectedToken(x.braceL);
    const s = eb(this.tokens);
    let o = false;
    for (; !this.tokens.matches1(x.braceR); ) {
      const b = Ei(this.tokens);
      if (b.isType || !s && this.shouldElideExportedName(b.leftName)) {
        for (; this.tokens.currentIndex() < b.endIndex; ) this.tokens.removeToken();
        this.tokens.matches1(x.comma) && this.tokens.removeToken();
      } else {
        for (o = true; this.tokens.currentIndex() < b.endIndex; ) this.tokens.copyToken();
        this.tokens.matches1(x.comma) && this.tokens.copyToken();
      }
    }
    return this.tokens.copyExpectedToken(x.braceR), !this.keepUnusedImports && s && !o && (this.tokens.removeToken(), this.tokens.removeToken(), ws(this.tokens)), true;
  }
  shouldElideExportedName(s) {
    return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && this.declarationInfo.typeDeclarations.has(s) && !this.declarationInfo.valueDeclarations.has(s);
  }
}
class NI extends Fr {
  constructor(s, o, b) {
    super(), this.rootTransformer = s, this.tokens = o, this.isImportsTransformEnabled = b;
  }
  process() {
    return this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange() ? true : this.tokens.matches1(x._enum) ? (this.processEnum(), true) : this.tokens.matches2(x._export, x._enum) ? (this.processNamedExportEnum(), true) : this.tokens.matches3(x._export, x._default, x._enum) ? (this.processDefaultExportEnum(), true) : false;
  }
  processNamedExportEnum() {
    if (this.isImportsTransformEnabled) {
      this.tokens.removeInitialToken();
      const s = this.tokens.identifierNameAtRelativeIndex(1);
      this.processEnum(), this.tokens.appendCode(` exports.${s} = ${s};`);
    } else this.tokens.copyToken(), this.processEnum();
  }
  processDefaultExportEnum() {
    this.tokens.removeInitialToken(), this.tokens.removeToken();
    const s = this.tokens.identifierNameAtRelativeIndex(1);
    this.processEnum(), this.isImportsTransformEnabled ? this.tokens.appendCode(` exports.default = ${s};`) : this.tokens.appendCode(` export default ${s};`);
  }
  processEnum() {
    this.tokens.replaceToken("const"), this.tokens.copyExpectedToken(x.name);
    let s = false;
    this.tokens.matchesContextual(Fe._of) && (this.tokens.removeToken(), s = this.tokens.matchesContextual(Fe._symbol), this.tokens.removeToken());
    const o = this.tokens.matches3(x.braceL, x.name, x.eq);
    this.tokens.appendCode(' = require("flow-enums-runtime")');
    const b = !s && !o;
    for (this.tokens.replaceTokenTrimmingLeftWhitespace(b ? ".Mirrored([" : "({"); !this.tokens.matches1(x.braceR); ) {
      if (this.tokens.matches1(x.ellipsis)) {
        this.tokens.removeToken();
        break;
      }
      this.processEnumElement(s, o), this.tokens.matches1(x.comma) && this.tokens.copyToken();
    }
    this.tokens.replaceToken(b ? "]);" : "});");
  }
  processEnumElement(s, o) {
    if (s) {
      const b = this.tokens.identifierName();
      this.tokens.copyToken(), this.tokens.appendCode(`: Symbol("${b}")`);
    } else o ? (this.tokens.copyToken(), this.tokens.replaceTokenTrimmingLeftWhitespace(":"), this.tokens.copyToken()) : this.tokens.replaceToken(`"${this.tokens.identifierName()}"`);
  }
}
function RI(a3) {
  let s, o = a3[0], b = 1;
  for (; b < a3.length; ) {
    const A = a3[b], R = a3[b + 1];
    if (b += 2, (A === "optionalAccess" || A === "optionalCall") && o == null) return;
    A === "access" || A === "optionalAccess" ? (s = o, o = R(o)) : (A === "call" || A === "optionalCall") && (o = R((...P) => o.call(s, ...P)), s = void 0);
  }
  return o;
}
const da = "jest", jI = ["mock", "unmock", "enableAutomock", "disableAutomock"];
class np extends Fr {
  __init() {
    this.hoistedFunctionNames = [];
  }
  constructor(s, o, b, A) {
    super(), this.rootTransformer = s, this.tokens = o, this.nameManager = b, this.importProcessor = A, np.prototype.__init.call(this);
  }
  process() {
    return this.tokens.currentToken().scopeDepth === 0 && this.tokens.matches4(x.name, x.dot, x.name, x.parenL) && this.tokens.identifierName() === da ? RI([this, "access", (s) => s.importProcessor, "optionalAccess", (s) => s.getGlobalNames, "call", (s) => s(), "optionalAccess", (s) => s.has, "call", (s) => s(da)]) ? false : this.extractHoistedCalls() : false;
  }
  getHoistedCode() {
    return this.hoistedFunctionNames.length > 0 ? this.hoistedFunctionNames.map((s) => `${s}();`).join("") : "";
  }
  extractHoistedCalls() {
    this.tokens.removeToken();
    let s = false;
    for (; this.tokens.matches3(x.dot, x.name, x.parenL); ) {
      const o = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
      if (jI.includes(o)) {
        const A = this.nameManager.claimFreeName("__jestHoist");
        this.hoistedFunctionNames.push(A), this.tokens.replaceToken(`function ${A}(){${da}.`), this.tokens.copyToken(), this.tokens.copyToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(x.parenR), this.tokens.appendCode(";}"), s = false;
      } else s ? this.tokens.copyToken() : this.tokens.replaceToken(`${da}.`), this.tokens.copyToken(), this.tokens.copyToken(), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(x.parenR), s = true;
    }
    return true;
  }
}
class LI extends Fr {
  constructor(s) {
    super(), this.tokens = s;
  }
  process() {
    if (this.tokens.matches1(x.num)) {
      const s = this.tokens.currentTokenCode();
      if (s.includes("_")) return this.tokens.replaceToken(s.replace(/_/g, "")), true;
    }
    return false;
  }
}
class FI extends Fr {
  constructor(s, o) {
    super(), this.tokens = s, this.nameManager = o;
  }
  process() {
    return this.tokens.matches2(x._catch, x.braceL) ? (this.tokens.copyToken(), this.tokens.appendCode(` (${this.nameManager.claimFreeName("e")})`), true) : false;
  }
}
class MI extends Fr {
  constructor(s, o) {
    super(), this.tokens = s, this.nameManager = o;
  }
  process() {
    if (this.tokens.matches1(x.nullishCoalescing)) {
      const b = this.tokens.currentToken();
      return this.tokens.tokens[b.nullishStartIndex].isAsyncOperation ? this.tokens.replaceTokenTrimmingLeftWhitespace(", async () => (") : this.tokens.replaceTokenTrimmingLeftWhitespace(", () => ("), true;
    }
    if (this.tokens.matches1(x._delete) && this.tokens.tokenAtRelativeIndex(1).isOptionalChainStart) return this.tokens.removeInitialToken(), true;
    const o = this.tokens.currentToken().subscriptStartIndex;
    if (o != null && this.tokens.tokens[o].isOptionalChainStart && this.tokens.tokenAtRelativeIndex(-1).type !== x._super) {
      const b = this.nameManager.claimFreeName("_");
      let A;
      if (o > 0 && this.tokens.matches1AtIndex(o - 1, x._delete) && this.isLastSubscriptInChain() ? A = `${b} => delete ${b}` : A = `${b} => ${b}`, this.tokens.tokens[o].isAsyncOperation && (A = `async ${A}`), this.tokens.matches2(x.questionDot, x.parenL) || this.tokens.matches2(x.questionDot, x.lessThan)) this.justSkippedSuper() && this.tokens.appendCode(".bind(this)"), this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalCall', ${A}`);
      else if (this.tokens.matches2(x.questionDot, x.bracketL)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${A}`);
      else if (this.tokens.matches1(x.questionDot)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'optionalAccess', ${A}.`);
      else if (this.tokens.matches1(x.dot)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${A}.`);
      else if (this.tokens.matches1(x.bracketL)) this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'access', ${A}[`);
      else if (this.tokens.matches1(x.parenL)) this.justSkippedSuper() && this.tokens.appendCode(".bind(this)"), this.tokens.replaceTokenTrimmingLeftWhitespace(`, 'call', ${A}(`);
      else throw new Error("Unexpected subscript operator in optional chain.");
      return true;
    }
    return false;
  }
  isLastSubscriptInChain() {
    let s = 0;
    for (let o = this.tokens.currentIndex() + 1; ; o++) {
      if (o >= this.tokens.tokens.length) throw new Error("Reached the end of the code while finding the end of the access chain.");
      if (this.tokens.tokens[o].isOptionalChainStart ? s++ : this.tokens.tokens[o].isOptionalChainEnd && s--, s < 0) return true;
      if (s === 0 && this.tokens.tokens[o].subscriptStartIndex != null) return false;
    }
  }
  justSkippedSuper() {
    let s = 0, o = this.tokens.currentIndex() - 1;
    for (; ; ) {
      if (o < 0) throw new Error("Reached the start of the code while finding the start of the access chain.");
      if (this.tokens.tokens[o].isOptionalChainStart ? s-- : this.tokens.tokens[o].isOptionalChainEnd && s++, s < 0) return false;
      if (s === 0 && this.tokens.tokens[o].subscriptStartIndex != null) return this.tokens.tokens[o - 1].type === x._super;
      o--;
    }
  }
}
class BI extends Fr {
  constructor(s, o, b, A) {
    super(), this.rootTransformer = s, this.tokens = o, this.importProcessor = b, this.options = A;
  }
  process() {
    const s = this.tokens.currentIndex();
    if (this.tokens.identifierName() === "createReactClass") {
      const o = this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");
      return o ? this.tokens.replaceToken(`(0, ${o})`) : this.tokens.copyToken(), this.tryProcessCreateClassCall(s), true;
    }
    if (this.tokens.matches3(x.name, x.dot, x.name) && this.tokens.identifierName() === "React" && this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass") {
      const o = this.importProcessor && this.importProcessor.getIdentifierReplacement("React") || "React";
      return o ? (this.tokens.replaceToken(o), this.tokens.copyToken(), this.tokens.copyToken()) : (this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.copyToken()), this.tryProcessCreateClassCall(s), true;
    }
    return false;
  }
  tryProcessCreateClassCall(s) {
    const o = this.findDisplayName(s);
    o && this.classNeedsDisplayName() && (this.tokens.copyExpectedToken(x.parenL), this.tokens.copyExpectedToken(x.braceL), this.tokens.appendCode(`displayName: '${o}',`), this.rootTransformer.processBalancedCode(), this.tokens.copyExpectedToken(x.braceR), this.tokens.copyExpectedToken(x.parenR));
  }
  findDisplayName(s) {
    return s < 2 ? null : this.tokens.matches2AtIndex(s - 2, x.name, x.eq) ? this.tokens.identifierNameAtIndex(s - 2) : s >= 2 && this.tokens.tokens[s - 2].identifierRole === Rt.ObjectKey ? this.tokens.identifierNameAtIndex(s - 2) : this.tokens.matches2AtIndex(s - 2, x._export, x._default) ? this.getDisplayNameFromFilename() : null;
  }
  getDisplayNameFromFilename() {
    const o = (this.options.filePath || "unknown").split("/"), b = o[o.length - 1], A = b.lastIndexOf("."), R = A === -1 ? b : b.slice(0, A);
    return R === "index" && o[o.length - 2] ? o[o.length - 2] : R;
  }
  classNeedsDisplayName() {
    let s = this.tokens.currentIndex();
    if (!this.tokens.matches2(x.parenL, x.braceL)) return false;
    const o = s + 1, b = this.tokens.tokens[o].contextId;
    if (b == null) throw new Error("Expected non-null context ID on object open-brace.");
    for (; s < this.tokens.tokens.length; s++) {
      const A = this.tokens.tokens[s];
      if (A.type === x.braceR && A.contextId === b) {
        s++;
        break;
      }
      if (this.tokens.identifierNameAtIndex(s) === "displayName" && this.tokens.tokens[s].identifierRole === Rt.ObjectKey && A.contextId === b) return false;
    }
    if (s === this.tokens.tokens.length) throw new Error("Unexpected end of input when processing React class.");
    return this.tokens.matches1AtIndex(s, x.parenR) || this.tokens.matches2AtIndex(s, x.comma, x.parenR);
  }
}
class rp extends Fr {
  __init() {
    this.extractedDefaultExportName = null;
  }
  constructor(s, o) {
    super(), this.tokens = s, this.filePath = o, rp.prototype.__init.call(this);
  }
  setExtractedDefaultExportName(s) {
    this.extractedDefaultExportName = s;
  }
  getPrefixCode() {
    return `
      (function () {
        var enterModule = require('react-hot-loader').enterModule;
        enterModule && enterModule(module);
      })();`.replace(/\s+/g, " ").trim();
  }
  getSuffixCode() {
    const s = /* @__PURE__ */ new Set();
    for (const b of this.tokens.tokens) !b.isType && Ym(b) && b.identifierRole !== Rt.ImportDeclaration && s.add(this.tokens.identifierNameForToken(b));
    const o = Array.from(s).map((b) => ({ variableName: b, uniqueLocalName: b }));
    return this.extractedDefaultExportName && o.push({ variableName: this.extractedDefaultExportName, uniqueLocalName: "default" }), `
;(function () {
  var reactHotLoader = require('react-hot-loader').default;
  var leaveModule = require('react-hot-loader').leaveModule;
  if (!reactHotLoader) {
    return;
  }
${o.map(({ variableName: b, uniqueLocalName: A }) => `  reactHotLoader.register(${b}, "${A}", ${JSON.stringify(this.filePath || "")});`).join(`
`)}
  leaveModule(module);
})();`;
  }
  process() {
    return false;
  }
}
const $I = /* @__PURE__ */ new Set(["break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "export", "extends", "finally", "for", "function", "if", "import", "in", "instanceof", "new", "return", "super", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "yield", "enum", "implements", "interface", "let", "package", "private", "protected", "public", "static", "await", "false", "null", "true"]);
function nf(a3) {
  if (a3.length === 0 || !Fi[a3.charCodeAt(0)]) return false;
  for (let s = 1; s < a3.length; s++) if (!jr[a3.charCodeAt(s)]) return false;
  return !$I.has(a3);
}
class UI extends Fr {
  constructor(s, o, b) {
    super(), this.rootTransformer = s, this.tokens = o, this.isImportsTransformEnabled = b;
  }
  process() {
    return this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange() ? true : this.tokens.matches1(x._public) || this.tokens.matches1(x._protected) || this.tokens.matches1(x._private) || this.tokens.matches1(x._abstract) || this.tokens.matches1(x._readonly) || this.tokens.matches1(x._override) || this.tokens.matches1(x.nonNullAssertion) ? (this.tokens.removeInitialToken(), true) : this.tokens.matches1(x._enum) || this.tokens.matches2(x._const, x._enum) ? (this.processEnum(), true) : this.tokens.matches2(x._export, x._enum) || this.tokens.matches3(x._export, x._const, x._enum) ? (this.processEnum(true), true) : false;
  }
  processEnum(s = false) {
    for (this.tokens.removeInitialToken(); this.tokens.matches1(x._const) || this.tokens.matches1(x._enum); ) this.tokens.removeToken();
    const o = this.tokens.identifierName();
    this.tokens.removeToken(), s && !this.isImportsTransformEnabled && this.tokens.appendCode("export "), this.tokens.appendCode(`var ${o}; (function (${o})`), this.tokens.copyExpectedToken(x.braceL), this.processEnumBody(o), this.tokens.copyExpectedToken(x.braceR), s && this.isImportsTransformEnabled ? this.tokens.appendCode(`)(${o} || (exports.${o} = ${o} = {}));`) : this.tokens.appendCode(`)(${o} || (${o} = {}));`);
  }
  processEnumBody(s) {
    let o = null;
    for (; !this.tokens.matches1(x.braceR); ) {
      const { nameStringCode: b, variableName: A } = this.extractEnumKeyInfo(this.tokens.currentToken());
      this.tokens.removeInitialToken(), this.tokens.matches3(x.eq, x.string, x.comma) || this.tokens.matches3(x.eq, x.string, x.braceR) ? this.processStringLiteralEnumMember(s, b, A) : this.tokens.matches1(x.eq) ? this.processExplicitValueEnumMember(s, b, A) : this.processImplicitValueEnumMember(s, b, A, o), this.tokens.matches1(x.comma) && this.tokens.removeToken(), A != null ? o = A : o = `${s}[${b}]`;
    }
  }
  extractEnumKeyInfo(s) {
    if (s.type === x.name) {
      const o = this.tokens.identifierNameForToken(s);
      return { nameStringCode: `"${o}"`, variableName: nf(o) ? o : null };
    } else if (s.type === x.string) {
      const o = this.tokens.stringValueForToken(s);
      return { nameStringCode: this.tokens.code.slice(s.start, s.end), variableName: nf(o) ? o : null };
    } else throw new Error("Expected name or string at beginning of enum element.");
  }
  processStringLiteralEnumMember(s, o, b) {
    b != null ? (this.tokens.appendCode(`const ${b}`), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.appendCode(`; ${s}[${o}] = ${b};`)) : (this.tokens.appendCode(`${s}[${o}]`), this.tokens.copyToken(), this.tokens.copyToken(), this.tokens.appendCode(";"));
  }
  processExplicitValueEnumMember(s, o, b) {
    const A = this.tokens.currentToken().rhsEndIndex;
    if (A == null) throw new Error("Expected rhsEndIndex on enum assign.");
    if (b != null) {
      for (this.tokens.appendCode(`const ${b}`), this.tokens.copyToken(); this.tokens.currentIndex() < A; ) this.rootTransformer.processToken();
      this.tokens.appendCode(`; ${s}[${s}[${o}] = ${b}] = ${o};`);
    } else {
      for (this.tokens.appendCode(`${s}[${s}[${o}]`), this.tokens.copyToken(); this.tokens.currentIndex() < A; ) this.rootTransformer.processToken();
      this.tokens.appendCode(`] = ${o};`);
    }
  }
  processImplicitValueEnumMember(s, o, b, A) {
    let R = A != null ? `${A} + 1` : "0";
    b != null && (this.tokens.appendCode(`const ${b} = ${R}; `), R = b), this.tokens.appendCode(`${s}[${s}[${o}] = ${R}] = ${o};`);
  }
}
class Ua {
  __init() {
    this.transformers = [];
  }
  __init2() {
    this.generatedVariables = [];
  }
  constructor(s, o, b, A) {
    Ua.prototype.__init.call(this), Ua.prototype.__init2.call(this), this.nameManager = s.nameManager, this.helperManager = s.helperManager;
    const { tokenProcessor: R, importProcessor: P } = s;
    this.tokens = R, this.isImportsTransformEnabled = o.includes("imports"), this.isReactHotLoaderTransformEnabled = o.includes("react-hot-loader"), this.disableESTransforms = !!A.disableESTransforms, A.disableESTransforms || (this.transformers.push(new MI(R, this.nameManager)), this.transformers.push(new LI(R)), this.transformers.push(new FI(R, this.nameManager))), o.includes("jsx") && (A.jsxRuntime !== "preserve" && this.transformers.push(new _s(this, R, P, this.nameManager, A)), this.transformers.push(new BI(this, R, P, A)));
    let t = null;
    if (o.includes("react-hot-loader")) {
      if (!A.filePath) throw new Error("filePath is required when using the react-hot-loader transform.");
      t = new rp(R, A.filePath), this.transformers.push(t);
    }
    if (o.includes("imports")) {
      if (P === null) throw new Error("Expected non-null importProcessor with imports transform enabled.");
      this.transformers.push(new fi(this, R, P, this.nameManager, this.helperManager, t, b, !!A.enableLegacyTypeScriptModuleInterop, o.includes("typescript"), o.includes("flow"), !!A.preserveDynamicImport, !!A.keepUnusedImports));
    } else this.transformers.push(new DI(R, this.nameManager, this.helperManager, t, o.includes("typescript"), o.includes("flow"), !!A.keepUnusedImports, A));
    o.includes("flow") && this.transformers.push(new NI(this, R, o.includes("imports"))), o.includes("typescript") && this.transformers.push(new UI(this, R, o.includes("imports"))), o.includes("jest") && this.transformers.push(new np(this, R, this.nameManager, P));
  }
  transform() {
    this.tokens.reset(), this.processBalancedCode();
    let o = this.isImportsTransformEnabled ? '"use strict";' : "";
    for (const P of this.transformers) o += P.getPrefixCode();
    o += this.helperManager.emitHelpers(), o += this.generatedVariables.map((P) => ` var ${P};`).join("");
    for (const P of this.transformers) o += P.getHoistedCode();
    let b = "";
    for (const P of this.transformers) b += P.getSuffixCode();
    const A = this.tokens.finish();
    let { code: R } = A;
    if (R.startsWith("#!")) {
      let P = R.indexOf(`
`);
      return P === -1 && (P = R.length, R += `
`), { code: R.slice(0, P + 1) + o + R.slice(P + 1) + b, mappings: this.shiftMappings(A.mappings, o.length) };
    } else return { code: o + R + b, mappings: this.shiftMappings(A.mappings, o.length) };
  }
  processBalancedCode() {
    let s = 0, o = 0;
    for (; !this.tokens.isAtEnd(); ) {
      if (this.tokens.matches1(x.braceL) || this.tokens.matches1(x.dollarBraceL)) s++;
      else if (this.tokens.matches1(x.braceR)) {
        if (s === 0) return;
        s--;
      }
      if (this.tokens.matches1(x.parenL)) o++;
      else if (this.tokens.matches1(x.parenR)) {
        if (o === 0) return;
        o--;
      }
      this.processToken();
    }
  }
  processToken() {
    if (this.tokens.matches1(x._class)) {
      this.processClass();
      return;
    }
    for (const s of this.transformers) if (s.process()) return;
    this.tokens.copyToken();
  }
  processNamedClass() {
    if (!this.tokens.matches2(x._class, x.name)) throw new Error("Expected identifier for exported class name.");
    const s = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    return this.processClass(), s;
  }
  processClass() {
    const s = II(this, this.tokens, this.nameManager, this.disableESTransforms), o = (s.headerInfo.isExpression || !s.headerInfo.className) && s.staticInitializerNames.length + s.instanceInitializerNames.length > 0;
    let b = s.headerInfo.className;
    o && (b = this.nameManager.claimFreeName("_class"), this.generatedVariables.push(b), this.tokens.appendCode(` (${b} =`));
    const R = this.tokens.currentToken().contextId;
    if (R == null) throw new Error("Expected class to have a context ID.");
    for (this.tokens.copyExpectedToken(x._class); !this.tokens.matchesContextIdAndLabel(x.braceL, R); ) this.processToken();
    this.processClassBody(s, b);
    const P = s.staticInitializerNames.map((t) => `${b}.${t}()`);
    o ? this.tokens.appendCode(`, ${P.map((t) => `${t}, `).join("")}${b})`) : s.staticInitializerNames.length > 0 && this.tokens.appendCode(` ${P.map((t) => `${t};`).join(" ")}`);
  }
  processClassBody(s, o) {
    const { headerInfo: b, constructorInsertPos: A, constructorInitializerStatements: R, fields: P, instanceInitializerNames: t, rangesToRemove: l } = s;
    let n = 0, u = 0;
    const c = this.tokens.currentToken().contextId;
    if (c == null) throw new Error("Expected non-null context ID on class.");
    this.tokens.copyExpectedToken(x.braceL), this.isReactHotLoaderTransformEnabled && this.tokens.appendCode("__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}");
    const e = R.length + t.length > 0;
    if (A === null && e) {
      const r = this.makeConstructorInitCode(R, t, o);
      if (b.hasSuperclass) {
        const f = this.nameManager.claimFreeName("args");
        this.tokens.appendCode(`constructor(...${f}) { super(...${f}); ${r}; }`);
      } else this.tokens.appendCode(`constructor() { ${r}; }`);
    }
    for (; !this.tokens.matchesContextIdAndLabel(x.braceR, c); ) if (n < P.length && this.tokens.currentIndex() === P[n].start) {
      let r = false;
      for (this.tokens.matches1(x.bracketL) ? this.tokens.copyTokenWithPrefix(`${P[n].initializerName}() {this`) : this.tokens.matches1(x.string) || this.tokens.matches1(x.num) ? (this.tokens.copyTokenWithPrefix(`${P[n].initializerName}() {this[`), r = true) : this.tokens.copyTokenWithPrefix(`${P[n].initializerName}() {this.`); this.tokens.currentIndex() < P[n].end; ) r && this.tokens.currentIndex() === P[n].equalsIndex && this.tokens.appendCode("]"), this.processToken();
      this.tokens.appendCode("}"), n++;
    } else if (u < l.length && this.tokens.currentIndex() >= l[u].start) {
      for (this.tokens.currentIndex() < l[u].end && this.tokens.removeInitialToken(); this.tokens.currentIndex() < l[u].end; ) this.tokens.removeToken();
      u++;
    } else this.tokens.currentIndex() === A ? (this.tokens.copyToken(), e && this.tokens.appendCode(`;${this.makeConstructorInitCode(R, t, o)};`), this.processToken()) : this.processToken();
    this.tokens.copyExpectedToken(x.braceR);
  }
  makeConstructorInitCode(s, o, b) {
    return [...s, ...o.map((A) => `${b}.prototype.${A}.call(this)`)].join(";");
  }
  processPossibleArrowParamEnd() {
    if (this.tokens.matches2(x.parenR, x.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
      let s = this.tokens.currentIndex() + 1;
      for (; this.tokens.tokens[s].isType; ) s++;
      if (this.tokens.matches1AtIndex(s, x.arrow)) {
        for (this.tokens.removeInitialToken(); this.tokens.currentIndex() < s; ) this.tokens.removeToken();
        return this.tokens.replaceTokenTrimmingLeftWhitespace(") =>"), true;
      }
    }
    return false;
  }
  processPossibleAsyncArrowWithTypeParams() {
    if (!this.tokens.matchesContextual(Fe._async) && !this.tokens.matches1(x._async)) return false;
    const s = this.tokens.tokenAtRelativeIndex(1);
    if (s.type !== x.lessThan || !s.isType) return false;
    let o = this.tokens.currentIndex() + 1;
    for (; this.tokens.tokens[o].isType; ) o++;
    if (this.tokens.matches1AtIndex(o, x.parenL)) {
      for (this.tokens.replaceToken("async ("), this.tokens.removeInitialToken(); this.tokens.currentIndex() < o; ) this.tokens.removeToken();
      return this.tokens.removeToken(), this.processBalancedCode(), this.processToken(), true;
    }
    return false;
  }
  processPossibleTypeRange() {
    if (this.tokens.currentToken().isType) {
      for (this.tokens.removeInitialToken(); this.tokens.currentToken().isType; ) this.tokens.removeToken();
      return true;
    }
    return false;
  }
  shiftMappings(s, o) {
    for (let b = 0; b < s.length; b++) {
      const A = s[b];
      A !== void 0 && (s[b] = A + o);
    }
    return s;
  }
}
var nb = {};
(function(a3) {
  a3.__esModule = true, a3.LinesAndColumns = void 0;
  var s = `
`, o = "\r", b = function() {
    function A(R) {
      this.string = R;
      for (var P = [0], t = 0; t < R.length; ) switch (R[t]) {
        case s:
          t += s.length, P.push(t);
          break;
        case o:
          t += o.length, R[t] === s && (t += s.length), P.push(t);
          break;
        default:
          t++;
          break;
      }
      this.offsets = P;
    }
    return A.prototype.locationForIndex = function(R) {
      if (R < 0 || R > this.string.length) return null;
      for (var P = 0, t = this.offsets; t[P + 1] <= R; ) P++;
      var l = R - t[P];
      return { line: P, column: l };
    }, A.prototype.indexForLocation = function(R) {
      var P = R.line, t = R.column;
      return P < 0 || P >= this.offsets.length || t < 0 || t > this.lengthOfLine(P) ? null : this.offsets[P] + t;
    }, A.prototype.lengthOfLine = function(R) {
      var P = this.offsets[R], t = R === this.offsets.length - 1 ? this.string.length : this.offsets[R + 1];
      return t - P;
    }, A;
  }();
  a3.LinesAndColumns = b, a3.default = b;
})(nb);
const VI = uf(nb);
function WI(a3, s) {
  if (s.length === 0) return "";
  const o = Object.keys(s[0]).filter((e) => e !== "type" && e !== "value" && e !== "start" && e !== "end" && e !== "loc"), b = Object.keys(s[0].type).filter((e) => e !== "label" && e !== "keyword"), A = ["Location", "Label", "Raw", ...o, ...b], R = new VI(a3), P = [A, ...s.map(l)], t = A.map(() => 0);
  for (const e of P) for (let r = 0; r < e.length; r++) t[r] = Math.max(t[r], e[r].length);
  return P.map((e) => e.map((r, f) => r.padEnd(t[f])).join(" ")).join(`
`);
  function l(e) {
    const r = a3.slice(e.start, e.end);
    return [u(e.start, e.end), Wm(e.type), HI(String(r), 14), ...o.map((f) => n(e[f], f)), ...b.map((f) => n(e.type[f], f))];
  }
  function n(e, r) {
    return e === true ? r : e === false || e === null ? "" : String(e);
  }
  function u(e, r) {
    return `${c(e)}-${c(r)}`;
  }
  function c(e) {
    const r = R.locationForIndex(e);
    return r ? `${r.line + 1}:${r.column + 1}` : "Unknown";
  }
}
function HI(a3, s) {
  return a3.length > s ? `${a3.slice(0, s - 3)}...` : a3;
}
function GI(a3) {
  const s = /* @__PURE__ */ new Set();
  for (let o = 0; o < a3.tokens.length; o++) a3.matches1AtIndex(o, x._import) && !a3.matches3AtIndex(o, x._import, x.name, x.eq) && zI(a3, o, s);
  return s;
}
function zI(a3, s, o) {
  s++, !a3.matches1AtIndex(s, x.parenL) && (a3.matches1AtIndex(s, x.name) && (o.add(a3.identifierNameAtIndex(s)), s++, a3.matches1AtIndex(s, x.comma) && s++), a3.matches1AtIndex(s, x.star) && (s += 2, o.add(a3.identifierNameAtIndex(s)), s++), a3.matches1AtIndex(s, x.braceL) && (s++, KI(a3, s, o)));
}
function KI(a3, s, o) {
  for (; ; ) {
    if (a3.matches1AtIndex(s, x.braceR)) return;
    const b = Ei(a3, s);
    if (s = b.endIndex, b.isType || o.add(b.rightName), a3.matches2AtIndex(s, x.comma, x.braceR)) return;
    if (a3.matches1AtIndex(s, x.braceR)) return;
    if (a3.matches1AtIndex(s, x.comma)) s++;
    else throw new Error(`Unexpected token: ${JSON.stringify(a3.tokens[s])}`);
  }
}
function qI() {
  return "3.35.0";
}
function YI(a3, s) {
  lx(s);
  try {
    const o = rb(a3, s), A = new Ua(o, s.transforms, !!s.enableLegacyBabel5ModuleInterop, s).transform();
    let R = { code: A.code };
    if (s.sourceMapOptions) {
      if (!s.filePath) throw new Error("filePath must be specified when generating a source map.");
      R = { ...R, sourceMap: qP(A, s.filePath, s.sourceMapOptions, a3, o.tokenProcessor.tokens) };
    }
    return R;
  } catch (o) {
    throw s.filePath && (o.message = `Error transforming ${s.filePath}: ${o.message}`), o;
  }
}
function XI(a3, s) {
  const o = rb(a3, s).tokenProcessor.tokens;
  return WI(a3, o);
}
function rb(a3, s) {
  const o = s.transforms.includes("jsx"), b = s.transforms.includes("typescript"), A = s.transforms.includes("flow"), R = s.disableESTransforms === true, P = AI(a3, o, b, A), t = P.tokens, l = P.scopes, n = new Dc(a3, t), u = new Na(n), c = new di(a3, t, A, R, u), e = !!s.enableLegacyTypeScriptModuleInterop;
  let r = null;
  return s.transforms.includes("imports") ? (r = new Ts(n, c, e, s, s.transforms.includes("typescript"), !!s.keepUnusedImports, u), r.preprocessTokens(), Vd(c, l, r.getGlobalNames()), s.transforms.includes("typescript") && !s.keepUnusedImports && r.pruneTypeOnlyImports()) : s.transforms.includes("typescript") && !s.keepUnusedImports && Vd(c, l, GI(c)), { tokenProcessor: c, scopes: l, nameManager: n, importProcessor: r, helperManager: u };
}
const JI = Object.freeze(Object.defineProperty({ __proto__: null, getFormattedTokens: XI, getVersion: qI, transform: YI }, Symbol.toStringTag, { value: "Module" })), QI = lf(JI);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(n, u) {
    for (var c in u) Object.defineProperty(n, c, { enumerable: true, get: u[c] });
  }
  s(a3, { useCustomJiti: function() {
    return P;
  }, loadConfig: function() {
    return l;
  } });
  const o = A(cP), b = QI;
  function A(n) {
    return n && n.__esModule ? n : { default: n };
  }
  let R = null;
  function P(n) {
    R = n();
  }
  function t() {
    return R ?? (R = (0, o.default)(__filename, { interopDefault: true, transform: (n) => n.source.includes("import.meta") ? Vm()(n) : (0, b.transform)(n.source, { transforms: ["typescript", "imports"] }) }));
  }
  function l(n) {
    let u = function() {
      return n ? t()(n) : {};
    }();
    var c;
    return (c = u.default) !== null && c !== void 0 ? c : u;
  }
})($m);
var sb = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return n;
  } });
  const s = b(gt), o = b(gt);
  function b(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let A = [".js", ".cjs", ".mjs"], R = ["", ".js", ".cjs", ".mjs", ".ts", ".cts", ".mts", ".jsx", ".tsx"], P = ["", ".ts", ".cts", ".mts", ".tsx", ".js", ".cjs", ".mjs", ".jsx"];
  function t(u, c) {
    for (let e of c) {
      let r = `${u}${e}`;
      if (s.default.existsSync(r) && s.default.statSync(r).isFile()) return r;
    }
    for (let e of c) {
      let r = `${u}/index${e}`;
      if (s.default.existsSync(r)) return r;
    }
    return null;
  }
  function* l(u, c, e, r = o.default.extname(u)) {
    let f = t(o.default.resolve(c, u), A.includes(r) ? R : P);
    if (f === null || e.has(f)) return;
    e.add(f), yield f, c = o.default.dirname(f), r = o.default.extname(f);
    let y = s.default.readFileSync(f, "utf-8");
    for (let S of [...y.matchAll(/import[\s\S]*?['"](.{3,}?)['"]/gi), ...y.matchAll(/import[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi), ...y.matchAll(/require\(['"`](.+)['"`]\)/gi)]) S[1].startsWith(".") && (yield* l(S[1], c, e, r));
  }
  function n(u) {
    return u === null ? /* @__PURE__ */ new Set() : new Set(l(u, o.default.dirname(u), /* @__PURE__ */ new Set()));
  }
})(sb);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return T;
  } });
  const s = e(gt), o = e(pf), b = e(df), A = e(hf), R = e(xf), P = no(), t = e(Vh), l = Wh, n = Hh, u = $m, c = e(sb);
  function e(d) {
    return d && d.__esModule ? d : { default: d };
  }
  let r = new o.default({ maxSize: 100 }), f = /* @__PURE__ */ new WeakMap();
  function y(d, p) {
    if (f.has(d)) return f.get(d);
    let h = (0, n.parseCandidateFiles)(d, p);
    return f.set(d, h).get(d);
  }
  function S(d) {
    let p = (0, R.default)(d);
    if (p !== null) {
      let [_, C, w, I] = r.get(p) || [], D = (0, c.default)(p), j = false, L = /* @__PURE__ */ new Map();
      for (let F of D) {
        let W = s.default.statSync(F).mtimeMs;
        L.set(F, W), (!I || !I.has(F) || W > I.get(F)) && (j = true);
      }
      if (!j) return [_, p, C, w];
      for (let F of D) delete require.cache[F];
      let k = (0, l.validateConfig)((0, A.default)((0, u.loadConfig)(p))), N = (0, b.default)(k);
      return r.set(p, [k, N, D, L]), [k, p, N, D];
    }
    var h, m;
    let E = (0, A.default)((m = (h = d == null ? void 0 : d.config) !== null && h !== void 0 ? h : d) !== null && m !== void 0 ? m : {});
    return E = (0, l.validateConfig)(E), [E, null, (0, b.default)(E), []];
  }
  function T(d) {
    return ({ tailwindDirectives: p, registerDependency: h }) => (m, E) => {
      let [_, C, w, I] = S(d), D = new Set(I);
      if (p.size > 0) {
        D.add(E.opts.from);
        for (let F of E.messages) F.type === "dependency" && D.add(F.file);
      }
      let [j, , L] = (0, P.getContext)(m, E, _, C, w, D), k = (0, P.getFileModifiedMap)(j), N = y(j, _);
      if (p.size > 0) {
        for (let X of N) for (let H of (0, t.default)(X)) h(H);
        let [F, W] = (0, n.resolvedChangedContent)(j, N, k);
        for (let X of F) j.changedContent.push(X);
        for (let [X, H] of W.entries()) L.set(X, H);
      }
      for (let F of I) h({ type: "dependency", file: F });
      for (let [F, W] of L.entries()) k.set(F, W);
      return j;
    };
  }
})(cf);
var ib = {}, ab = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return b;
  } });
  const s = o(xr);
  function o(A) {
    return A && A.__esModule ? A : { default: A };
  }
  function b(A) {
    let R = /* @__PURE__ */ new Set(), P = /* @__PURE__ */ new Set(), t = /* @__PURE__ */ new Set();
    if (A.walkAtRules((l) => {
      l.name === "apply" && t.add(l), l.name === "import" && (l.params === '"tailwindcss/base"' || l.params === "'tailwindcss/base'" ? (l.name = "tailwind", l.params = "base") : l.params === '"tailwindcss/components"' || l.params === "'tailwindcss/components'" ? (l.name = "tailwind", l.params = "components") : l.params === '"tailwindcss/utilities"' || l.params === "'tailwindcss/utilities'" ? (l.name = "tailwind", l.params = "utilities") : (l.params === '"tailwindcss/screens"' || l.params === "'tailwindcss/screens'" || l.params === '"tailwindcss/variants"' || l.params === "'tailwindcss/variants'") && (l.name = "tailwind", l.params = "variants")), l.name === "tailwind" && (l.params === "screens" && (l.params = "variants"), R.add(l.params)), ["layer", "responsive", "variants"].includes(l.name) && (["responsive", "variants"].includes(l.name) && s.default.warn(`${l.name}-at-rule-deprecated`, [`The \`@${l.name}\` directive has been deprecated in Tailwind CSS v3.0.`, "Use `@layer utilities` or `@layer components` instead.", "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"]), P.add(l));
    }), !R.has("base") || !R.has("components") || !R.has("utilities")) {
      for (let l of P) if (l.name === "layer" && ["base", "components", "utilities"].includes(l.params)) {
        if (!R.has(l.params)) throw l.error(`\`@layer ${l.params}\` is used but no matching \`@tailwind ${l.params}\` directive is present.`);
      } else if (l.name === "responsive") {
        if (!R.has("utilities")) throw l.error("`@responsive` is used but `@tailwind utilities` is missing.");
      } else if (l.name === "variants" && !R.has("utilities")) throw l.error("`@variants` is used but `@tailwind utilities` is missing.");
    }
    return { tailwindDirectives: R, applyDirectives: t };
  }
})(ab);
var ob = {}, lb = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  function s(b, A = void 0, R = void 0) {
    return b.map((P) => {
      let t = P.clone();
      return R !== void 0 && (t.raws.tailwind = { ...t.raws.tailwind, ...R }), A !== void 0 && o(t, (l) => {
        var n;
        if (((n = l.raws.tailwind) === null || n === void 0 ? void 0 : n.preserveSource) === true && l.source) return false;
        l.source = A;
      }), t;
    });
  }
  function o(b, A) {
    if (A(b) !== false) {
      var R;
      (R = b.each) === null || R === void 0 || R.call(b, (P) => o(P, A));
    }
  }
})(lb);
var ub = {}, cb = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(e, r) {
    for (var f in r) Object.defineProperty(e, f, { enumerable: true, get: r[f] });
  }
  s(a3, { pattern: function() {
    return R;
  }, withoutCapturing: function() {
    return P;
  }, any: function() {
    return t;
  }, optional: function() {
    return l;
  }, zeroOrMore: function() {
    return n;
  }, nestedBrackets: function() {
    return u;
  }, escape: function() {
    return c;
  } });
  const o = /[\\^$.*+?()[\]{}|]/g, b = RegExp(o.source);
  function A(e) {
    return e = Array.isArray(e) ? e : [e], e = e.map((r) => r instanceof RegExp ? r.source : r), e.join("");
  }
  function R(e) {
    return new RegExp(A(e), "g");
  }
  function P(e) {
    return new RegExp(`(?:${A(e)})`, "g");
  }
  function t(e) {
    return `(?:${e.map(A).join("|")})`;
  }
  function l(e) {
    return `(?:${A(e)})?`;
  }
  function n(e) {
    return `(?:${A(e)})*`;
  }
  function u(e, r, f = 1) {
    return P([c(e), /[^\s]*/, f === 1 ? `[^${c(e)}${c(r)}s]*` : t([`[^${c(e)}${c(r)}s]*`, u(e, r, f - 1)]), /[^\s]*/, c(r)]);
  }
  function c(e) {
    return e && b.test(e) ? e.replace(o, "\\$&") : e || "";
  }
})(cb);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "defaultExtractor", { enumerable: true, get: function() {
    return R;
  } });
  const s = A(cb), o = Is;
  function b(u) {
    if (typeof WeakMap != "function") return null;
    var c = /* @__PURE__ */ new WeakMap(), e = /* @__PURE__ */ new WeakMap();
    return (b = function(r) {
      return r ? e : c;
    })(u);
  }
  function A(u, c) {
    if (u && u.__esModule) return u;
    if (u === null || typeof u != "object" && typeof u != "function") return { default: u };
    var e = b(c);
    if (e && e.has(u)) return e.get(u);
    var r = {}, f = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var y in u) if (y !== "default" && Object.prototype.hasOwnProperty.call(u, y)) {
      var S = f ? Object.getOwnPropertyDescriptor(u, y) : null;
      S && (S.get || S.set) ? Object.defineProperty(r, y, S) : r[y] = u[y];
    }
    return r.default = u, e && e.set(u, r), r;
  }
  function R(u) {
    let c = Array.from(P(u));
    return (e) => {
      let r = [];
      for (let y of c) {
        var f;
        for (let S of (f = e.match(y)) !== null && f !== void 0 ? f : []) r.push(n(S));
      }
      for (let y of r.slice()) {
        let S = (0, o.splitAtTopLevelOnly)(y, ".");
        for (let T = 0; T < S.length; T++) {
          let d = S[T];
          if (T >= S.length - 1) {
            r.push(d);
            continue;
          }
          let p = Number(S[T + 1]);
          isNaN(p) ? r.push(d) : T++;
        }
      }
      return r;
    };
  }
  function* P(u) {
    let c = u.tailwindConfig.separator, e = u.tailwindConfig.prefix !== "" ? s.optional(s.pattern([/-?/, s.escape(u.tailwindConfig.prefix)])) : "", r = s.any([/\[[^\s:'"`]+:[^\s\[\]]+\]/, /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/, s.pattern([s.any([/-?(?:\w+)/, /@(?:\w+)/]), s.optional(s.any([s.pattern([s.any([/-(?:\w+-)*\['[^\s]+'\]/, /-(?:\w+-)*\["[^\s]+"\]/, /-(?:\w+-)*\[`[^\s]+`\]/, /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/]), /(?![{([]])/, /(?:\/[^\s'"`\\><$]*)?/]), s.pattern([s.any([/-(?:\w+-)*\['[^\s]+'\]/, /-(?:\w+-)*\["[^\s]+"\]/, /-(?:\w+-)*\[`[^\s]+`\]/, /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/]), /(?![{([]])/, /(?:\/[^\s'"`\\$]*)?/]), /[-\/][^\s'"`\\$={><]*/]))])]), f = [s.any([s.pattern([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, c]), s.pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/[\w_-]+/, c]), s.pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, c]), s.pattern([/[^\s"'`\[\\]+/, c])]), s.any([s.pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]\/[\w_-]+/, c]), s.pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, c]), s.pattern([/[^\s`\[\\]+/, c])])];
    for (const y of f) yield s.pattern(["((?=((", y, ")+))\\2)?", /!?/, e, r]);
    yield /[^<>"'`\s.(){}[\]#=%$][^<>"'`\s(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
  }
  let t = /([\[\]'"`])([^\[\]'"`])?/g, l = /[^"'`\s<>\]]+/;
  function n(u) {
    if (!u.includes("-[")) return u;
    let c = 0, e = [], r = u.matchAll(t);
    r = Array.from(r).flatMap((f) => {
      const [, ...y] = f;
      return y.map((S, T) => Object.assign([], f, { index: f.index + T, 0: S }));
    });
    for (let f of r) {
      let y = f[0], S = e[e.length - 1];
      if (y === S ? e.pop() : (y === "'" || y === '"' || y === "`") && e.push(y), !S) {
        if (y === "[") {
          c++;
          continue;
        } else if (y === "]") {
          c--;
          continue;
        }
        if (c < 0) return u.substring(0, f.index - 1);
        if (c === 0 && !l.test(y)) return u.substring(0, f.index);
      }
    }
    return u;
  }
})(ub);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return p;
  } });
  const s = l(gt), o = l(pf), b = u(Os), A = Zu(), R = l(xr), P = l(lb), t = ub;
  function l(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function n(h) {
    if (typeof WeakMap != "function") return null;
    var m = /* @__PURE__ */ new WeakMap(), E = /* @__PURE__ */ new WeakMap();
    return (n = function(_) {
      return _ ? E : m;
    })(h);
  }
  function u(h, m) {
    if (h && h.__esModule) return h;
    if (h === null || typeof h != "object" && typeof h != "function") return { default: h };
    var E = n(m);
    if (E && E.has(h)) return E.get(h);
    var _ = {}, C = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var w in h) if (w !== "default" && Object.prototype.hasOwnProperty.call(h, w)) {
      var I = C ? Object.getOwnPropertyDescriptor(h, w) : null;
      I && (I.get || I.set) ? Object.defineProperty(_, w, I) : _[w] = h[w];
    }
    return _.default = h, E && E.set(h, _), _;
  }
  let c = b.env;
  const e = { DEFAULT: t.defaultExtractor }, r = { DEFAULT: (h) => h, svelte: (h) => h.replace(/(?:^|\s)class:/g, " ") };
  function f(h, m) {
    let E = h.tailwindConfig.content.extract;
    return E[m] || E.DEFAULT || e[m] || e.DEFAULT(h);
  }
  function y(h, m) {
    let E = h.content.transform;
    return E[m] || E.DEFAULT || r[m] || r.DEFAULT;
  }
  let S = /* @__PURE__ */ new WeakMap();
  function T(h, m, E, _) {
    S.has(m) || S.set(m, new o.default({ maxSize: 25e3 }));
    for (let C of h.split(`
`)) if (C = C.trim(), !_.has(C)) if (_.add(C), S.get(m).has(C)) for (let w of S.get(m).get(C)) E.add(w);
    else {
      let w = m(C).filter((D) => D !== "!*"), I = new Set(w);
      for (let D of I) E.add(D);
      S.get(m).set(C, I);
    }
  }
  function d(h, m) {
    let E = m.offsets.sort(h), _ = { base: /* @__PURE__ */ new Set(), defaults: /* @__PURE__ */ new Set(), components: /* @__PURE__ */ new Set(), utilities: /* @__PURE__ */ new Set(), variants: /* @__PURE__ */ new Set() };
    for (let [C, w] of E) _[C.layer].add(w);
    return _;
  }
  function p(h) {
    return async (m) => {
      let E = { base: null, components: null, utilities: null, variants: null };
      if (m.walkAtRules((ee) => {
        ee.name === "tailwind" && Object.keys(E).includes(ee.params) && (E[ee.params] = ee);
      }), Object.values(E).every((ee) => ee === null)) return m;
      var _;
      let C = /* @__PURE__ */ new Set([...(_ = h.candidates) !== null && _ !== void 0 ? _ : [], b.NOT_ON_DEMAND]), w = /* @__PURE__ */ new Set();
      c.DEBUG && console.time("Reading changed files");
      let I = [];
      for (let ee of h.changedContent) {
        let re = y(h.tailwindConfig, ee.extension), Y = f(h, ee.extension);
        I.push([ee, { transformer: re, extractor: Y }]);
      }
      const D = 500;
      for (let ee = 0; ee < I.length; ee += D) {
        let re = I.slice(ee, ee + D);
        await Promise.all(re.map(async ([{ file: Y, content: Z }, { transformer: G, extractor: B }]) => {
          Z = Y ? await s.default.promises.readFile(Y, "utf8") : Z, T(G(Z), B, C, w);
        }));
      }
      c.DEBUG && console.timeEnd("Reading changed files");
      let j = h.classCache.size;
      c.DEBUG && console.time("Generate rules"), c.DEBUG && console.time("Sorting candidates");
      let L = new Set([...C].sort((ee, re) => ee === re ? 0 : ee < re ? -1 : 1));
      c.DEBUG && console.timeEnd("Sorting candidates"), (0, A.generateRules)(L, h), c.DEBUG && console.timeEnd("Generate rules"), c.DEBUG && console.time("Build stylesheet"), (h.stylesheetCache === null || h.classCache.size !== j) && (h.stylesheetCache = d([...h.ruleCache], h)), c.DEBUG && console.timeEnd("Build stylesheet");
      let { defaults: k, base: N, components: F, utilities: W, variants: X } = h.stylesheetCache;
      E.base && (E.base.before((0, P.default)([...k, ...N], E.base.source, { layer: "base" })), E.base.remove()), E.components && (E.components.before((0, P.default)([...F], E.components.source, { layer: "components" })), E.components.remove()), E.utilities && (E.utilities.before((0, P.default)([...W], E.utilities.source, { layer: "utilities" })), E.utilities.remove());
      const H = Array.from(X).filter((ee) => {
        var re;
        const Y = (re = ee.raws.tailwind) === null || re === void 0 ? void 0 : re.parentLayer;
        return Y === "components" ? E.components !== null : Y === "utilities" ? E.utilities !== null : true;
      });
      E.variants ? (E.variants.before((0, P.default)(H, E.variants.source, { layer: "variants" })), E.variants.remove()) : H.length > 0 && m.append((0, P.default)(H, m.source, { layer: "variants" }));
      var U;
      m.source.end = (U = m.source.end) !== null && U !== void 0 ? U : m.source.start;
      const q = H.some((ee) => {
        var re;
        return ((re = ee.raws.tailwind) === null || re === void 0 ? void 0 : re.parentLayer) === "utilities";
      });
      E.utilities && W.size === 0 && !q && R.default.warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]), c.DEBUG && (console.log("Potential classes: ", C.size), console.log("Active contexts: ", b.contextSourcesMap.size)), h.changedContent = [], m.walkAtRules("layer", (ee) => {
        Object.keys(E).includes(ee.params) && ee.remove();
      });
    };
  }
})(ob);
var pb = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return E;
  } });
  const s = t(Lr), o = t(as), b = Zu(), A = t(Js), R = Qu, P = to;
  function t(_) {
    return _ && _.__esModule ? _ : { default: _ };
  }
  function l(_) {
    let C = /* @__PURE__ */ new Map();
    s.default.root({ nodes: [_.clone()] }).walkRules((j) => {
      (0, o.default)((L) => {
        L.walkClasses((k) => {
          let N = k.parent.toString(), F = C.get(N);
          F || C.set(N, F = /* @__PURE__ */ new Set()), F.add(k.value);
        });
      }).processSync(j.selector);
    });
    let I = Array.from(C.values(), (j) => Array.from(j)), D = I.flat();
    return Object.assign(D, { groups: I });
  }
  let n = (0, o.default)();
  function u(_) {
    return n.astSync(_);
  }
  function c(_, C) {
    let w = /* @__PURE__ */ new Set();
    for (let I of _) w.add(I.split(C).pop());
    return Array.from(w);
  }
  function e(_, C) {
    let w = _.tailwindConfig.prefix;
    return typeof w == "function" ? w(C) : w + C;
  }
  function* r(_) {
    for (yield _; _.parent; ) yield _.parent, _ = _.parent;
  }
  function f(_, C = {}) {
    let w = _.nodes;
    _.nodes = [];
    let I = _.clone(C);
    return _.nodes = w, I;
  }
  function y(_) {
    for (let C of r(_)) if (_ !== C) {
      if (C.type === "root") break;
      _ = f(C, { nodes: [_] });
    }
    return _;
  }
  function S(_, C) {
    let w = /* @__PURE__ */ new Map();
    return _.walkRules((I) => {
      for (let k of r(I)) {
        var D;
        if (((D = k.raws.tailwind) === null || D === void 0 ? void 0 : D.layer) !== void 0) return;
      }
      let j = y(I), L = C.offsets.create("user");
      for (let k of l(I)) {
        let N = w.get(k) || [];
        w.set(k, N), N.push([{ layer: "user", sort: L, important: false }, j]);
      }
    }), w;
  }
  function T(_, C) {
    for (let w of _) {
      if (C.notClassCache.has(w) || C.applyClassCache.has(w)) continue;
      if (C.classCache.has(w)) {
        C.applyClassCache.set(w, C.classCache.get(w).map(([D, j]) => [D, j.clone()]));
        continue;
      }
      let I = Array.from((0, b.resolveMatches)(w, C));
      if (I.length === 0) {
        C.notClassCache.add(w);
        continue;
      }
      C.applyClassCache.set(w, I);
    }
    return C.applyClassCache;
  }
  function d(_) {
    let C = null;
    return { get: (w) => (C = C || _(), C.get(w)), has: (w) => (C = C || _(), C.has(w)) };
  }
  function p(_) {
    return { get: (C) => _.flatMap((w) => w.get(C) || []), has: (C) => _.some((w) => w.has(C)) };
  }
  function h(_) {
    let C = _.split(/[\s\t\n]+/g);
    return C[C.length - 1] === "!important" ? [C.slice(0, -1), true] : [C, false];
  }
  function m(_, C, w) {
    let I = /* @__PURE__ */ new Set(), D = [];
    if (_.walkAtRules("apply", (N) => {
      let [F] = h(N.params);
      for (let W of F) I.add(W);
      D.push(N);
    }), D.length === 0) return;
    let j = p([w, T(I, C)]);
    function L(N, F, W) {
      let X = u(N), H = u(F), q = u(`.${(0, A.default)(W)}`).nodes[0].nodes[0];
      return X.each((ee) => {
        let re = /* @__PURE__ */ new Set();
        H.each((Y) => {
          let Z = false;
          Y = Y.clone(), Y.walkClasses((G) => {
            G.value === q.value && (Z || (G.replaceWith(...ee.nodes.map((B) => B.clone())), re.add(Y), Z = true));
          });
        });
        for (let Y of re) {
          let Z = [[]];
          for (let G of Y.nodes) G.type === "combinator" ? (Z.push(G), Z.push([])) : Z[Z.length - 1].push(G);
          Y.nodes = [];
          for (let G of Z) Array.isArray(G) && G.sort((B, z) => B.type === "tag" && z.type === "class" ? -1 : B.type === "class" && z.type === "tag" ? 1 : B.type === "class" && z.type === "pseudo" && z.value.startsWith("::") ? -1 : B.type === "pseudo" && B.value.startsWith("::") && z.type === "class" ? 1 : 0), Y.nodes = Y.nodes.concat(G);
        }
        ee.replaceWith(...re);
      }), X.toString();
    }
    let k = /* @__PURE__ */ new Map();
    for (let N of D) {
      let [F] = k.get(N.parent) || [[], N.source];
      k.set(N.parent, [F, N.source]);
      let [W, X] = h(N.params);
      if (N.parent.type === "atrule") {
        if (N.parent.name === "screen") {
          let H = N.parent.params;
          throw N.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${W.map((U) => `${H}:${U}`).join(" ")} instead.`);
        }
        throw N.error(`@apply is not supported within nested at-rules like @${N.parent.name}. You can fix this by un-nesting @${N.parent.name}.`);
      }
      for (let H of W) {
        if ([e(C, "group"), e(C, "peer")].includes(H)) throw N.error(`@apply should not be used with the '${H}' utility`);
        if (!j.has(H)) throw N.error(`The \`${H}\` class does not exist. If \`${H}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
        let U = j.get(H);
        for (let [, q] of U) q.type !== "atrule" && q.walkRules(() => {
          throw N.error([`The \`${H}\` class cannot be used with \`@apply\` because \`@apply\` does not currently support nested CSS.`, "Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:", "https://tailwindcss.com/docs/using-with-preprocessors#nesting"].join(`
`));
        });
        F.push([H, X, U]);
      }
    }
    for (let [N, [F, W]] of k) {
      let X = [];
      for (let [U, q, ee] of F) {
        let re = [U, ...c([U], C.tailwindConfig.separator)];
        for (let [Y, Z] of ee) {
          let G = l(N), B = l(Z);
          if (B = B.groups.filter((Q) => Q.some((ie) => re.includes(ie))).flat(), B = B.concat(c(B, C.tailwindConfig.separator)), G.some((Q) => B.includes(Q))) throw Z.error(`You cannot \`@apply\` the \`${U}\` utility here because it creates a circular dependency.`);
          let M = s.default.root({ nodes: [Z.clone()] });
          M.walk((Q) => {
            Q.source = W;
          }), (Z.type !== "atrule" || Z.type === "atrule" && Z.name !== "keyframes") && M.walkRules((Q) => {
            if (!l(Q).some((le) => le === U)) {
              Q.remove();
              return;
            }
            let ie = typeof C.tailwindConfig.important == "string" ? C.tailwindConfig.important : null, ge = N.raws.tailwind !== void 0 && ie && N.selector.indexOf(ie) === 0 ? N.selector.slice(ie.length) : N.selector;
            ge === "" && (ge = N.selector), Q.selector = L(ge, Q.selector, U), ie && ge !== N.selector && (Q.selector = (0, R.applyImportantSelector)(Q.selector, ie)), Q.walkDecls((le) => {
              le.important = Y.important || q;
            });
            let Te = (0, o.default)().astSync(Q.selector);
            Te.each((le) => (0, P.movePseudos)(le)), Q.selector = Te.toString();
          }), M.nodes[0] && X.push([Y.sort, M.nodes[0]]);
        }
      }
      let H = C.offsets.sort(X).map((U) => U[1]);
      N.after(H);
    }
    for (let N of D) N.parent.nodes.length > 1 ? N.remove() : N.parent.remove();
    m(_, C, w);
  }
  function E(_) {
    return (C) => {
      let w = d(() => S(C, _));
      m(C, _, w);
    };
  }
})(pb);
var db = {}, fb = { exports: {} };
(function(a3) {
  (function() {
    function s(A, R, P) {
      if (!A) return null;
      s.caseSensitive || (A = A.toLowerCase());
      var t = s.threshold === null ? null : s.threshold * A.length, l = s.thresholdAbsolute, n;
      t !== null && l !== null ? n = Math.min(t, l) : t !== null ? n = t : l !== null ? n = l : n = null;
      var u, c, e, r, f, y = R.length;
      for (f = 0; f < y; f++) if (c = R[f], P && (c = c[P]), !!c && (s.caseSensitive ? e = c : e = c.toLowerCase(), r = b(A, e, n), (n === null || r < n) && (n = r, P && s.returnWinningObject ? u = R[f] : u = c, s.returnFirstMatch))) return u;
      return u || s.nullResultValue;
    }
    s.threshold = 0.4, s.thresholdAbsolute = 20, s.caseSensitive = false, s.nullResultValue = null, s.returnWinningObject = null, s.returnFirstMatch = false, a3.exports ? a3.exports = s : window.didYouMean = s;
    var o = Math.pow(2, 32) - 1;
    function b(A, R, P) {
      P = P || P === 0 ? P : o;
      var t = A.length, l = R.length;
      if (t === 0) return Math.min(P + 1, l);
      if (l === 0) return Math.min(P + 1, t);
      if (Math.abs(t - l) > P) return P + 1;
      var n = [], u, c, e, r, f;
      for (u = 0; u <= l; u++) n[u] = [u];
      for (c = 0; c <= t; c++) n[0][c] = c;
      for (u = 1; u <= l; u++) {
        for (e = o, r = 1, u > P && (r = u - P), f = l + 1, f > P + u && (f = P + u), c = 1; c <= t; c++) c < r || c > f ? n[u][c] = P + 1 : R.charAt(u - 1) === A.charAt(c - 1) ? n[u][c] = n[u - 1][c - 1] : n[u][c] = Math.min(n[u - 1][c - 1] + 1, Math.min(n[u][c - 1] + 1, n[u - 1][c] + 1)), n[u][c] < e && (e = n[u][c]);
        if (e > P) return P + 1;
      }
      return n[l][t];
    }
  })();
})(fb);
var ZI = fb.exports, sl = 40, il = 41, fa = 39, al = 34, ol = 92, Vs = 47, ll = 44, ul = 58, ha = 42, ek = 117, tk = 85, nk = 43, rk = /^[a-f0-9?-]+$/i, sk = function(a3) {
  for (var s = [], o = a3, b, A, R, P, t, l, n, u, c = 0, e = o.charCodeAt(c), r = o.length, f = [{ nodes: s }], y = 0, S, T = "", d = "", p = ""; c < r; ) if (e <= 32) {
    b = c;
    do
      b += 1, e = o.charCodeAt(b);
    while (e <= 32);
    P = o.slice(c, b), R = s[s.length - 1], e === il && y ? p = P : R && R.type === "div" ? (R.after = P, R.sourceEndIndex += P.length) : e === ll || e === ul || e === Vs && o.charCodeAt(b + 1) !== ha && (!S || S && S.type === "function" && false) ? d = P : s.push({ type: "space", sourceIndex: c, sourceEndIndex: b, value: P }), c = b;
  } else if (e === fa || e === al) {
    b = c, A = e === fa ? "'" : '"', P = { type: "string", sourceIndex: c, quote: A };
    do
      if (t = false, b = o.indexOf(A, b + 1), ~b) for (l = b; o.charCodeAt(l - 1) === ol; ) l -= 1, t = !t;
      else o += A, b = o.length - 1, P.unclosed = true;
    while (t);
    P.value = o.slice(c + 1, b), P.sourceEndIndex = P.unclosed ? b : b + 1, s.push(P), c = b + 1, e = o.charCodeAt(c);
  } else if (e === Vs && o.charCodeAt(c + 1) === ha) b = o.indexOf("*/", c), P = { type: "comment", sourceIndex: c, sourceEndIndex: b + 2 }, b === -1 && (P.unclosed = true, b = o.length, P.sourceEndIndex = b), P.value = o.slice(c + 2, b), s.push(P), c = b + 2, e = o.charCodeAt(c);
  else if ((e === Vs || e === ha) && S && S.type === "function") P = o[c], s.push({ type: "word", sourceIndex: c - d.length, sourceEndIndex: c + P.length, value: P }), c += 1, e = o.charCodeAt(c);
  else if (e === Vs || e === ll || e === ul) P = o[c], s.push({ type: "div", sourceIndex: c - d.length, sourceEndIndex: c + P.length, value: P, before: d, after: "" }), d = "", c += 1, e = o.charCodeAt(c);
  else if (sl === e) {
    b = c;
    do
      b += 1, e = o.charCodeAt(b);
    while (e <= 32);
    if (u = c, P = { type: "function", sourceIndex: c - T.length, value: T, before: o.slice(u + 1, b) }, c = b, T === "url" && e !== fa && e !== al) {
      b -= 1;
      do
        if (t = false, b = o.indexOf(")", b + 1), ~b) for (l = b; o.charCodeAt(l - 1) === ol; ) l -= 1, t = !t;
        else o += ")", b = o.length - 1, P.unclosed = true;
      while (t);
      n = b;
      do
        n -= 1, e = o.charCodeAt(n);
      while (e <= 32);
      u < n ? (c !== n + 1 ? P.nodes = [{ type: "word", sourceIndex: c, sourceEndIndex: n + 1, value: o.slice(c, n + 1) }] : P.nodes = [], P.unclosed && n + 1 !== b ? (P.after = "", P.nodes.push({ type: "space", sourceIndex: n + 1, sourceEndIndex: b, value: o.slice(n + 1, b) })) : (P.after = o.slice(n + 1, b), P.sourceEndIndex = b)) : (P.after = "", P.nodes = []), c = b + 1, P.sourceEndIndex = P.unclosed ? b : c, e = o.charCodeAt(c), s.push(P);
    } else y += 1, P.after = "", P.sourceEndIndex = c + 1, s.push(P), f.push(P), s = P.nodes = [], S = P;
    T = "";
  } else if (il === e && y) c += 1, e = o.charCodeAt(c), S.after = p, S.sourceEndIndex += p.length, p = "", y -= 1, f[f.length - 1].sourceEndIndex = c, f.pop(), S = f[y], s = S.nodes;
  else {
    b = c;
    do
      e === ol && (b += 1), b += 1, e = o.charCodeAt(b);
    while (b < r && !(e <= 32 || e === fa || e === al || e === ll || e === ul || e === Vs || e === sl || e === ha && S && S.type === "function" || e === Vs && S.type === "function" || e === il && y));
    P = o.slice(c, b), sl === e ? T = P : (ek === P.charCodeAt(0) || tk === P.charCodeAt(0)) && nk === P.charCodeAt(1) && rk.test(P.slice(2)) ? s.push({ type: "unicode-range", sourceIndex: c, sourceEndIndex: b, value: P }) : s.push({ type: "word", sourceIndex: c, sourceEndIndex: b, value: P }), c = b;
  }
  for (c = f.length - 1; c; c -= 1) f[c].unclosed = true, f[c].sourceEndIndex = o.length;
  return f[0].nodes;
}, ik = function a2(s, o, b) {
  var A, R, P, t;
  for (A = 0, R = s.length; A < R; A += 1) P = s[A], b || (t = o(P, A, s)), t !== false && P.type === "function" && Array.isArray(P.nodes) && a2(P.nodes, o, b), b && o(P, A, s);
};
function rf(a3, s) {
  var o = a3.type, b = a3.value, A, R;
  return s && (R = s(a3)) !== void 0 ? R : o === "word" || o === "space" ? b : o === "string" ? (A = a3.quote || "", A + b + (a3.unclosed ? "" : A)) : o === "comment" ? "/*" + b + (a3.unclosed ? "" : "*/") : o === "div" ? (a3.before || "") + b + (a3.after || "") : Array.isArray(a3.nodes) ? (A = hb(a3.nodes, s), o !== "function" ? A : b + "(" + (a3.before || "") + A + (a3.after || "") + (a3.unclosed ? "" : ")")) : b;
}
function hb(a3, s) {
  var o, b;
  if (Array.isArray(a3)) {
    for (o = "", b = a3.length - 1; ~b; b -= 1) o = rf(a3[b], s) + o;
    return o;
  }
  return rf(a3, s);
}
var ak = hb, cl, sf;
function ok() {
  if (sf) return cl;
  sf = 1;
  var a3 = 45, s = 43, o = 46, b = 101, A = 69;
  function R(P) {
    var t = P.charCodeAt(0), l;
    if (t === s || t === a3) {
      if (l = P.charCodeAt(1), l >= 48 && l <= 57) return true;
      var n = P.charCodeAt(2);
      return l === o && n >= 48 && n <= 57;
    }
    return t === o ? (l = P.charCodeAt(1), l >= 48 && l <= 57) : t >= 48 && t <= 57;
  }
  return cl = function(P) {
    var t = 0, l = P.length, n, u, c;
    if (l === 0 || !R(P)) return false;
    for (n = P.charCodeAt(t), (n === s || n === a3) && t++; t < l && (n = P.charCodeAt(t), !(n < 48 || n > 57)); ) t += 1;
    if (n = P.charCodeAt(t), u = P.charCodeAt(t + 1), n === o && u >= 48 && u <= 57) for (t += 2; t < l && (n = P.charCodeAt(t), !(n < 48 || n > 57)); ) t += 1;
    if (n = P.charCodeAt(t), u = P.charCodeAt(t + 1), c = P.charCodeAt(t + 2), (n === b || n === A) && (u >= 48 && u <= 57 || (u === s || u === a3) && c >= 48 && c <= 57)) for (t += u === s || u === a3 ? 3 : 2; t < l && (n = P.charCodeAt(t), !(n < 48 || n > 57)); ) t += 1;
    return { number: P.slice(0, t), unit: P.slice(t) };
  }, cl;
}
var lk = sk, mb = ik, yb = ak;
function bs(a3) {
  return this instanceof bs ? (this.nodes = lk(a3), this) : new bs(a3);
}
bs.prototype.toString = function() {
  return Array.isArray(this.nodes) ? yb(this.nodes) : "";
};
bs.prototype.walk = function(a3, s) {
  return mb(this.nodes, a3, s), this;
};
bs.unit = ok();
bs.walk = mb;
bs.stringify = yb;
var uk = bs;
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return C;
  } });
  const s = c(uh), o = c(ZI), b = c(ki), A = c(uk), R = eo, P = c(Za), t = Ha, l = xi, n = Pi, u = c(xr);
  function c(w) {
    return w && w.__esModule ? w : { default: w };
  }
  function e(w) {
    return typeof w == "object" && w !== null;
  }
  function r(w, I) {
    let D = (0, t.toPath)(I);
    do
      if (D.pop(), (0, s.default)(w, D) !== void 0) break;
    while (D.length);
    return D.length ? D : void 0;
  }
  function f(w) {
    return typeof w == "string" ? w : w.reduce((I, D, j) => D.includes(".") ? `${I}[${D}]` : j === 0 ? D : `${I}.${D}`, "");
  }
  function y(w) {
    return w.map((I) => `'${I}'`).join(", ");
  }
  function S(w) {
    return y(Object.keys(w));
  }
  function T(w, I, D, j = {}) {
    const L = Array.isArray(I) ? f(I) : I.replace(/^['"]+|['"]+$/g, ""), k = Array.isArray(I) ? I : (0, t.toPath)(L), N = (0, s.default)(w.theme, k, D);
    if (N === void 0) {
      let W = `'${L}' does not exist in your theme config.`;
      const X = k.slice(0, -1), H = (0, s.default)(w.theme, X);
      if (e(H)) {
        const U = Object.keys(H).filter((ee) => T(w, [...X, ee]).isValid), q = (0, o.default)(k[k.length - 1], U);
        q ? W += ` Did you mean '${f([...X, q])}'?` : U.length > 0 && (W += ` '${f(X)}' has the following valid keys: ${y(U)}`);
      } else {
        const U = r(w.theme, L);
        if (U) {
          const q = (0, s.default)(w.theme, U);
          e(q) ? W += ` '${f(U)}' has the following keys: ${S(q)}` : W += ` '${f(U)}' is not an object.`;
        } else W += ` Your theme has the following top-level keys: ${S(w.theme)}`;
      }
      return { isValid: false, error: W };
    }
    if (!(typeof N == "string" || typeof N == "number" || typeof N == "function" || N instanceof String || N instanceof Number || Array.isArray(N))) {
      let W = `'${L}' was found but does not resolve to a string.`;
      if (e(N)) {
        let X = Object.keys(N).filter((H) => T(w, [...k, H]).isValid);
        X.length && (W += ` Did you mean something like '${f([...k, X[0]])}'?`);
      }
      return { isValid: false, error: W };
    }
    const [F] = k;
    return { isValid: true, value: (0, b.default)(F)(N, j) };
  }
  function d(w, I, D) {
    I = I.map((L) => p(w, L, D));
    let j = [""];
    for (let L of I) L.type === "div" && L.value === "," ? j.push("") : j[j.length - 1] += A.default.stringify(L);
    return j;
  }
  function p(w, I, D) {
    if (I.type === "function" && D[I.value] !== void 0) {
      let j = d(w, I.nodes, D);
      I.type = "word", I.value = D[I.value](w, ...j);
    }
    return I;
  }
  function h(w, I, D) {
    return Object.keys(D).some((L) => I.includes(`${L}(`)) ? (0, A.default)(I).walk((L) => {
      p(w, L, D);
    }).toString() : I;
  }
  let m = { atrule: "params", decl: "value" };
  function* E(w) {
    w = w.replace(/^['"]+|['"]+$/g, "");
    let I = w.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), D;
    yield [w, void 0], I && (w = I[1], D = I[2], yield [w, D]);
  }
  function _(w, I, D) {
    const j = Array.from(E(I)).map(([k, N]) => Object.assign(T(w, k, D, { opacityValue: N }), { resolvedPath: k, alpha: N }));
    var L;
    return (L = j.find((k) => k.isValid)) !== null && L !== void 0 ? L : j[0];
  }
  function C(w) {
    let I = w.tailwindConfig, D = { theme: (j, L, ...k) => {
      let { isValid: N, value: F, error: W, alpha: X } = _(I, L, k.length ? k : void 0);
      if (!N) {
        var H;
        let ee = j.parent, re = (H = ee == null ? void 0 : ee.raws.tailwind) === null || H === void 0 ? void 0 : H.candidate;
        if (ee && re !== void 0) {
          w.markInvalidUtilityNode(ee), ee.remove(), u.default.warn("invalid-theme-key-in-class", [`The utility \`${re}\` contains an invalid theme value and was not generated.`]);
          return;
        }
        throw j.error(W);
      }
      let U = (0, n.parseColorFormat)(F);
      return (X !== void 0 || U !== void 0 && typeof U == "function") && (X === void 0 && (X = 1), F = (0, l.withAlphaValue)(U, X, U)), F;
    }, screen: (j, L) => {
      L = L.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
      let N = (0, R.normalizeScreens)(I.theme.screens).find(({ name: F }) => F === L);
      if (!N) throw j.error(`The '${L}' screen does not exist in your theme.`);
      return (0, P.default)(N);
    } };
    return (j) => {
      j.walk((L) => {
        let k = m[L.type];
        k !== void 0 && (L[k] = h(L, L[k], D));
      });
    };
  }
})(db);
var bb = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return A;
  } });
  const s = eo, o = b(Za);
  function b(R) {
    return R && R.__esModule ? R : { default: R };
  }
  function A({ tailwindConfig: { theme: R } }) {
    return function(P) {
      P.walkAtRules("screen", (t) => {
        let l = t.params, u = (0, s.normalizeScreens)(R.screens).find(({ name: c }) => c === l);
        if (!u) throw t.error(`No \`${l}\` screen found.`);
        t.name = "media", t.params = (0, o.default)(u);
      });
    };
  }
})(bb);
var gb = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true });
  function s(e, r) {
    for (var f in r) Object.defineProperty(e, f, { enumerable: true, get: r[f] });
  }
  s(a3, { elementSelectorParser: function() {
    return l;
  }, default: function() {
    return c;
  } });
  const o = R(Lr), b = R(as), A = is;
  function R(e) {
    return e && e.__esModule ? e : { default: e };
  }
  let P = { id(e) {
    return b.default.attribute({ attribute: "id", operator: "=", value: e.value, quoteMark: '"' });
  } };
  function t(e) {
    let r = e.filter((p) => p.type !== "pseudo" || p.nodes.length > 0 ? true : p.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(p.value)).reverse(), f = /* @__PURE__ */ new Set(["tag", "class", "id", "attribute"]), y = r.findIndex((p) => f.has(p.type));
    if (y === -1) return r.reverse().join("").trim();
    let S = r[y], T = P[S.type] ? P[S.type](S) : S;
    r = r.slice(0, y);
    let d = r.findIndex((p) => p.type === "combinator" && p.value === ">");
    return d !== -1 && (r.splice(0, d), r.unshift(b.default.universal())), [T, ...r.reverse()].join("").trim();
  }
  let l = (0, b.default)((e) => e.map((r) => {
    let f = r.split((y) => y.type === "combinator" && y.value === " ").pop();
    return t(f);
  })), n = /* @__PURE__ */ new Map();
  function u(e) {
    return n.has(e) || n.set(e, l.transformSync(e)), n.get(e);
  }
  function c({ tailwindConfig: e }) {
    return (r) => {
      let f = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Set();
      if (r.walkAtRules("defaults", (d) => {
        if (d.nodes && d.nodes.length > 0) {
          y.add(d);
          return;
        }
        let p = d.params;
        f.has(p) || f.set(p, /* @__PURE__ */ new Set()), f.get(p).add(d.parent), d.remove();
      }), (0, A.flagEnabled)(e, "optimizeUniversalDefaults")) for (let d of y) {
        let p = /* @__PURE__ */ new Map();
        var S;
        let h = (S = f.get(d.params)) !== null && S !== void 0 ? S : [];
        for (let m of h) for (let E of u(m.selector)) {
          let _ = E.includes(":-") || E.includes("::-") || E.includes(":has") ? E : "__DEFAULT__";
          var T;
          let C = (T = p.get(_)) !== null && T !== void 0 ? T : /* @__PURE__ */ new Set();
          p.set(_, C), C.add(E);
        }
        if (p.size === 0) {
          d.remove();
          continue;
        }
        for (let [, m] of p) {
          let E = o.default.rule({ source: d.source });
          E.selectors = [...m], E.append(d.nodes.map((_) => _.clone())), d.before(E);
        }
        d.remove();
      }
      else if (y.size) {
        let d = o.default.rule({ selectors: ["*", "::before", "::after"] });
        for (let h of y) d.append(h.nodes), d.parent || h.before(d), d.source || (d.source = h.source), h.remove();
        let p = d.clone({ selectors: ["::backdrop"] });
        d.after(p);
      }
    };
  }
})(gb);
var vb = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return b;
  } });
  let s = { atrule: ["name", "params"], rule: ["selector"] }, o = new Set(Object.keys(s));
  function b() {
    function A(R) {
      let P = null;
      R.each((t) => {
        if (!o.has(t.type)) {
          P = null;
          return;
        }
        if (P === null) {
          P = t;
          return;
        }
        let l = s[t.type];
        var n, u;
        t.type === "atrule" && t.name === "font-face" ? P = t : l.every((c) => ((n = t[c]) !== null && n !== void 0 ? n : "").replace(/\s+/g, " ") === ((u = P[c]) !== null && u !== void 0 ? u : "").replace(/\s+/g, " ")) ? (t.nodes && P.append(t.nodes), t.remove()) : P = t;
      }), R.each((t) => {
        t.type === "atrule" && A(t);
      });
    }
    return (R) => {
      A(R);
    };
  }
})(vb);
var Eb = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return s;
  } });
  function s() {
    return (A) => {
      A.walkRules((R) => {
        let P = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Set([]), l = /* @__PURE__ */ new Map();
        R.walkDecls((n) => {
          if (n.parent === R) {
            if (P.has(n.prop)) {
              if (P.get(n.prop).value === n.value) {
                t.add(P.get(n.prop)), P.set(n.prop, n);
                return;
              }
              l.has(n.prop) || l.set(n.prop, /* @__PURE__ */ new Set()), l.get(n.prop).add(P.get(n.prop)), l.get(n.prop).add(n);
            }
            P.set(n.prop, n);
          }
        });
        for (let n of t) n.remove();
        for (let n of l.values()) {
          let u = /* @__PURE__ */ new Map();
          for (let c of n) {
            let e = b(c.value);
            e !== null && (u.has(e) || u.set(e, /* @__PURE__ */ new Set()), u.get(e).add(c));
          }
          for (let c of u.values()) {
            let e = Array.from(c).slice(0, -1);
            for (let r of e) r.remove();
          }
        }
      });
    };
  }
  let o = Symbol("unitless-number");
  function b(A) {
    let R = /^-?\d*.?\d+([\w%]+)?$/g.exec(A);
    if (R) {
      var P;
      return (P = R[1]) !== null && P !== void 0 ? P : o;
    }
    return null;
  }
})(Eb);
var Sb = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return o;
  } });
  function s(b) {
    if (!b.walkAtRules) return;
    let A = /* @__PURE__ */ new Set();
    if (b.walkAtRules("apply", (R) => {
      A.add(R.parent);
    }), A.size !== 0) for (let R of A) {
      let P = [], t = [];
      for (let l of R.nodes) l.type === "atrule" && l.name === "apply" ? (t.length > 0 && (P.push(t), t = []), P.push([l])) : t.push(l);
      if (t.length > 0 && P.push(t), P.length !== 1) {
        for (let l of [...P].reverse()) {
          let n = R.clone({ nodes: [] });
          n.append(l), R.after(n);
        }
        R.remove();
      }
    }
  }
  function o() {
    return (b) => {
      s(b);
    };
  }
})(Sb);
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "default", { enumerable: true, get: function() {
    return r;
  } });
  const s = e(ab), o = e(ob), b = e(pb), A = e(db), R = e(bb), P = e(gb), t = e(vb), l = e(Eb), n = e(Sb), u = no(), c = is;
  function e(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function r(f) {
    return async function(y, S) {
      let { tailwindDirectives: T, applyDirectives: d } = (0, s.default)(y);
      (0, n.default)()(y, S);
      let p = f({ tailwindDirectives: T, applyDirectives: d, registerDependency(h) {
        S.messages.push({ plugin: "tailwindcss", parent: S.opts.from, ...h });
      }, createContext(h, m) {
        return (0, u.createContext)(h, m, y);
      } })(y, S);
      if (p.tailwindConfig.separator === "-") throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
      (0, c.issueFlagNotices)(p.tailwindConfig), await (0, o.default)(p)(y, S), (0, n.default)()(y, S), (0, b.default)(p)(y, S), (0, A.default)(p)(y, S), (0, R.default)(p)(y, S), (0, P.default)(p)(y, S), (0, t.default)(p)(y, S), (0, l.default)(p)(y, S);
    };
  }
})(ib);
var _b = {};
(function(a3) {
  Object.defineProperty(a3, "__esModule", { value: true }), Object.defineProperty(a3, "findAtConfigPath", { enumerable: true, get: function() {
    return A;
  } });
  const s = b(gt), o = b(gt);
  function b(R) {
    return R && R.__esModule ? R : { default: R };
  }
  function A(R, P) {
    let t = null, l = null;
    return R.walkAtRules("config", (n) => {
      var u, c, e;
      if (l = (e = (c = (u = n.source) === null || u === void 0 ? void 0 : u.input.file) !== null && c !== void 0 ? c : P.opts.from) !== null && e !== void 0 ? e : null, l === null) throw n.error("The `@config` directive cannot be used without setting `from` in your PostCSS config.");
      if (t) throw n.error("Only one `@config` directive is allowed per file.");
      let r = n.params.match(/(['"])(.*?)\1/);
      if (!r) throw n.error("A path is required when using the `@config` directive.");
      let f = r[2];
      if (o.default.isAbsolute(f)) throw n.error("The `@config` directive cannot be used with an absolute path.");
      if (t = o.default.resolve(o.default.dirname(l), f), !s.default.existsSync(t)) throw n.error(`The config file at "${f}" does not exist. Make sure the path is correct and the file exists.`);
      n.remove();
    }), t || null;
  }
})(_b);
var ck = Va.exports;
Object.defineProperty(ck, "__esModule", { value: true });
const pk = Tb(cf), af = Tb(ib), of = Os, dk = _b;
function Tb(a3) {
  return a3 && a3.__esModule ? a3 : { default: a3 };
}
Va.exports = function(s) {
  return { postcssPlugin: "tailwindcss", plugins: [of.env.DEBUG && function(o) {
    return console.log(`
`), console.time("JIT TOTAL"), o;
  }, async function(o, b) {
    var A;
    s = (A = (0, dk.findAtConfigPath)(o, b)) !== null && A !== void 0 ? A : s;
    let R = (0, pk.default)(s);
    if (o.type === "document") {
      let P = o.nodes.filter((t) => t.type === "root");
      for (const t of P) t.type === "root" && await (0, af.default)(R)(t, b);
      return;
    }
    await (0, af.default)(R)(o, b);
  }, of.env.DEBUG && function(o) {
    return console.timeEnd("JIT TOTAL"), console.log(`
`), o;
  }].filter(Boolean) };
};
Va.exports.postcss = true;
var fk = Va.exports, hk = fk;
const Lk = uf(hk);
export {
  Lk as default
};
